<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据结构 数据结构的基本概念 逻辑结构  线性结构：线性表、栈、队列、数组、串 非线性结构：集合、树、图  存储结构  顺序存储（随机存取） 链式存储（顺序存取） 索引存储（占用空间，增删数据花费较多时间） 散列存储（哈希存储，关键字与存储地址存在映射关系）">
<meta property="og:type" content="article">
<meta property="og:title" content="408知识点">
<meta property="og:url" content="http://example.com/2023/03/01/408%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="hxt&#39;s Blog">
<meta property="og:description" content="数据结构 数据结构的基本概念 逻辑结构  线性结构：线性表、栈、队列、数组、串 非线性结构：集合、树、图  存储结构  顺序存储（随机存取） 链式存储（顺序存取） 索引存储（占用空间，增删数据花费较多时间） 散列存储（哈希存储，关键字与存储地址存在映射关系）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/binary_tree.assets/balanced_binary_tree.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230811201257804.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230811201413092.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230811224431415.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813193820445.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813194154250.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813194523940.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813203217599.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814093118659.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814092857041.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309110916534.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814093458948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814092511362.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815093150181.png">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/190107/2-1Z10H11122456.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815100300128.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815100346847.png">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/190108/2-1Z10R04Hb26.gif">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/190108/2-1Z10R04A6457.gif">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/190108/2-1Z10R04635G8.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817195534099.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817195644524.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817201616229.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817202359994.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309120847285.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308201923357.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308201923421.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308211924185.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212001008.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308211946175.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308211947745.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212003408.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212004917.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212007638.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212009716.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212009153.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212015573.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212033124.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308222004550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308252005303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308252007095.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308262246924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308270934703.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230511172129518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230514164942777.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309021930775.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309021931146.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309021934507.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230510154015393.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230510163245020.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042019948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042023996.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042046081.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310130943382.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042112242.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310141418262.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042145366.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309051907893.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309031942505.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309051940907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311051646877.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309052002128.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230512114347333.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230512142347994.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309062056019.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309062137475.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230513142839273.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230513144145042.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309071924091.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308312012486.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309091929565.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515145822708.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515151717058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515153341208.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515151640198.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515153613748.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515174706714.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230516143405669.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309092110532.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101026521.png">
<meta property="og:image" content="https://pic4.zhimg.com/v2-1c6298c14a112569588275d006cade5b_r.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101029397.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101050081.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101117519.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101118871.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517195840794.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230516154612913.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517155200705.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517162832329.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517164334152.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230519131931196.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132025799.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132028593.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132039450.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132100215.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310101653167.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132102941.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132103209.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309141932790.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230522192316086.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309142003069.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309142032016.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309161608474.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230523150736610.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309161808077.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230524170957225.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309172037124.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230524173856180.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230525103043746.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309181922406.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230525114730902.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309202056078.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230528211123241.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230528211226194.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230528211318566.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309192337784.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309192341322.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309192343589.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150605157.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150650942.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150742932.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150832045.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529151022030.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529151533485.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309200941124.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309200920795.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309200919741.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309212014304.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309212018682.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309212023105.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531144036228.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309211940547.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531150457943.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531150113328.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531152726647.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531153611485.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531153942003.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531154224299.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531161012125.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601154211798.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601162746815.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601165543188.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601165651610.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309222126460.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602113649004.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311091712870.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602115601784.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602120211197.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231628621.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231638362.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231639004.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231636531.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602145706472.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602150503276.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602150250368.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309281731880.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604144828053.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604160117562.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309281949178.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309281950178.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604162136018.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291146033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604165520959.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604164855151.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605153021156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605153052622.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605152720388.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605153915360.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291624197.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291631696.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291643823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606134037983.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171442053.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171723246.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171552568.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171632573.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171829656.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606173520711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606183504183.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606184448921.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606184911168.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611133852311.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611141713247.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611144023065.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611151536617.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310121939069.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230614092453046.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230615110027586.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310052033527.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310052035565.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310052036139.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230616112047948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230616111923439.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310061915931.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310061917315.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230626141517691.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230619171415124.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618172821790.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618173841080.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618174541633.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310072000121.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230619185604937.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191113104555629-75420175.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230626151416856.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618190017537.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310081819554.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310081837416.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310081936430.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627165447895.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627171029546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627171525102.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310091956671.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310092004562.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627173110387.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627173215638.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627173523012.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628115019184.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628130640708.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628141533645.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628144406279.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628145215569.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628145457607.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628145642162.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310111801642.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310111906617.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310112105494.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310112035651.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310112036735.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230629114325955.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230630093634026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230630095755058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310102027447.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230705153551050.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230705153625307.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706105832514.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706111446419.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706112252992.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706112526664.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706112837499.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707110253397.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706144702982.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707112504500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707112731604.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707113221544.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707114521104.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707114348682.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707140902707.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707141253081.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707141557264.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202312071724428.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230708194709940.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230708193815454.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230708195108859.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310211654929.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310211654229.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230709195720343.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230709201929973.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230709203110929.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711202449104.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711191340072.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711191443782.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711191643573.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711200335898.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711200631740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711212412927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712191802009.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712194212005.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712195747087.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712202706738.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712203524516.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712204129188.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712204825974.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712210728986.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712211340422.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712211718685.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712212040697.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712212335796.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712212809756.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230713185455443.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230713195459338.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714191758962.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714191941091.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714193651078.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230713211356981.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714185356660.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230717165302231.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230717165831757.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230717165918458.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718185635822.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718190626255.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718192009043.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311041405620.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720192453492.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720192703002.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718200055620.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718200652484.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720194007085.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718201643349.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718204436969.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718205441917.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230719192532983.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230719193914186.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230719191534879.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720202324919.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-5c578bd8beb44dd6a2755ce989f9a2d5_r.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311181716356.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202312101507977.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230721201608405.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271646358.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271649358.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271904395.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271943864.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271944282.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310312047504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310312050404.png">
<meta property="article:published_time" content="2023-02-28T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-08T15:26:58.794Z">
<meta property="article:author" content="hxt">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="408">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png">

<link rel="canonical" href="http://example.com/2023/03/01/408%E7%9F%A5%E8%AF%86%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>408知识点 | hxt's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxt's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/408%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          408知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-01T00:00:00+08:00">2023-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-08 23:26:58" itemprop="dateModified" datetime="2026-02-08T23:26:58+08:00">2026-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/408/" itemprop="url" rel="index"><span itemprop="name">408</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" >
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>64k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>59 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构">数据结构</h1>
<h2 id="数据结构的基本概念">数据结构的基本概念</h2>
<h3 id="逻辑结构">逻辑结构</h3>
<ul>
<li>线性结构：线性表、栈、队列、数组、串</li>
<li>非线性结构：集合、树、图</li>
</ul>
<h3 id="存储结构">存储结构</h3>
<ul>
<li>顺序存储（随机存取）</li>
<li>链式存储（顺序存取）</li>
<li>索引存储（占用空间，增删数据花费较多时间）</li>
<li>散列存储（哈希存储，关键字与存储地址存在映射关系）</li>
</ul>
<span id="more"></span>
<h3 id="时间复杂度">时间复杂度</h3>
<p>问题规模是<strong>n</strong></p>
<p><span class="math inline">\(O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)\)</span></p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>与存储空间有关。</p>
<h2 id="线性表">线性表</h2>
<h3 id="顺序表">顺序表</h3>
<p>数组</p>
<p>随机访问，<strong>随机存取</strong>。</p>
<p>插入和删除需要移动大量元素。</p>
<p>按值查找（顺序查找）：最好O(1)，最坏O(n)</p>
<h3 id="链表">链表</h3>
<ul>
<li>单链表</li>
<li>双链表：前驱后继</li>
<li>循环链表：尾结点指向头结点，注意判空的条件
<ul>
<li><p>循环单链表</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head-&gt;next=head <span class="comment">//带头节点</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>循环双链表：头结点的prior指针指向表尾结点</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head-&gt;next=head&amp;&amp;head-&gt;prior=head <span class="comment">//带头节点，下面的也是带头节点</span></span><br><span class="line">head-&gt;next=head</span><br><span class="line">head-&gt;prior=head</span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li>静态链表：借助数组来描述线性表的链式存储结构，最后一个元素的next值为<strong>-1</strong>。</li>
</ul>
<h2 id="栈和队列">栈和队列</h2>
<p>对每个数据结构都可以从<strong>逻辑存储</strong>、<strong>存储结构</strong>和<strong>对数据的运算</strong>三个方面着手。</p>
<h3 id="栈">栈</h3>
<p>后进先出。</p>
<p>n个不同元素出栈，<strong>出栈元素的不同排列组合</strong>的个数为：<strong><span class="math inline">\(\frac{1}{n+1}C_{2n}^{n}\)</span></strong>
(卡特兰数).</p>
<ul>
<li><p><strong>顺序栈</strong>：连续的存储单元</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;   <span class="comment">//栈顶元素下标（栈顶指针）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>链栈</strong>：通常采用单链表</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>{</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> *<span class="title">next</span>;</span></span><br><span class="line">}*LinkList;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="队列">队列</h3>
<p>先进先出。</p>
<p>队头：出队</p>
<p>队尾：入队</p>
<ul>
<li><strong>循环队列</strong>（取余）：注意队满和队空的条件</li>
<li><strong>链队</strong>：队空条件——队头、队尾指针都指向
NULL；不存在队满的问题。</li>
<li><strong>双端队列</strong>：两端都可以进行入队和出队
<ul>
<li>输出受限的双端队列：一端允许插入和删除，另一端只允许插入（入队）；即删除（出队）操作只能在其中一端进行。</li>
<li>输入受限的双端队列：一端允许插入和删除，另一端只允许删除（出队）；即插入（入队）操作只能在其中一端进行。</li>
</ul></li>
</ul>
<h3 id="栈和队列的应用">栈和队列的应用</h3>
<ul>
<li><p>栈的应用：</p>
<ul>
<li><p>括号匹配</p></li>
<li><p><strong>借助栈将中缀表达式转换为后缀表达式</strong>：（栈只用来暂存<strong>操作符</strong>）</p>
<ol type="1">
<li><p>遍历到操作数，则直接输出；</p></li>
<li><p>若遍历到"(",则直接入栈；若为")",则依次输出栈中元素直到"("</p>
<p>注：括号压栈但不输出</p></li>
<li><p>遍历到其他操作符，先将该操作符与栈顶的操作符比较，当
栈顶优先级<strong>&gt;=</strong>当前运算符 ，则不断弹出栈中运算符直到
栈顶优先级<strong>&lt;</strong>当前运算符 ，然后再将当前运算符入栈。</p>
<p>若此时栈顶为"(",不遇到")"不将"("弹出</p></li>
<li><p>扫描完毕后，将栈中元素依次出栈</p></li>
</ol>
<p>https://www.cnblogs.com/wkfvawl/p/12864789.html</p></li>
<li><p><strong>后缀表达式求值</strong>：</p>
<ol type="1">
<li>扫描表达式</li>
<li>遇到操作数，直接将其入栈</li>
<li>遇到操作符，则弹出栈顶的两个操作数进行计算，再将计算结果压入栈顶</li>
</ol></li>
</ul></li>
<li><p>队列的应用</p>
<ul>
<li>层序遍历</li>
<li>打印机缓冲区</li>
<li>进程队列</li>
</ul></li>
</ul>
<h3 id="数组和特殊矩阵">数组和特殊矩阵</h3>
<ol type="1">
<li><p>数组</p>
<ul>
<li><p>行优先</p></li>
<li><p>列优先</p></li>
</ul></li>
<li><p>特殊矩阵</p>
<p>https://docs.qq.com/doc/DRW9qYWpsSUVPeXNN</p>
<ul>
<li>对称矩阵：使用一维数组存储上三角或下三角</li>
<li>三角矩阵：上三角区或下三角区所有元素的值为同一常量，<strong>比对称矩阵多存储一个常量</strong></li>
<li>三对角矩阵：所有非零元素集中在以主对角线为中心的3条对角线上，即<code>|i-j| = 1</code></li>
<li>稀疏矩阵：使用<strong>三元组</strong>（行标、列标、值）表示，可使用数组存储或十字链表法</li>
</ul>
<blockquote>
<p>若一个有向图的邻接矩阵仅有下三角区域非空，主对角线和上三角区都为空，则该有向图一定是有向无环图</p>
</blockquote></li>
</ol>
<h2 id="串">串</h2>
<p>主串：n</p>
<p>子串（模式串）：m</p>
<h3 id="朴素模式匹配暴力">朴素模式匹配（暴力）</h3>
<p>时间复杂度：O(nm)</p>
<h3 id="kmp算法">KMP算法</h3>
<p>时间复杂度：O(n+m)</p>
<p><strong>主串不回退</strong></p>
<p>注意字符串开始的编号是 <strong>1</strong> 还是 <strong>0</strong></p>
<ul>
<li><p>前缀：除最后一个字符之外的头部子串</p></li>
<li><p>后缀：除第一个字符之外的尾部子串</p></li>
<li><p>部分匹配值（PM）：最长相等前后缀长度</p></li>
<li><p>遇到不匹配的字符时：<strong>移动位数 = 已匹配的字符数 -
已匹配的部分匹配值</strong></p>
<p>模式串指针指向新的位置即<code>pos = next[pos-1]</code>，<strong>next[pos-1]</strong>就是<strong>已匹配的部分匹配值</strong></p></li>
<li><p>next 数组：即当前元素对应
该元素前面的子串的<strong>部分匹配值</strong></p></li>
<li><p>https://www.zhihu.com/question/21923021</p></li>
</ul>
<h2 id="树">树</h2>
<p><strong>结点数 = 分支数 + 1</strong></p>
<p><strong>分支数 = 所有结点的度数相加</strong></p>
<p><strong>具有 n 个结点的 m 叉树的最小高度为：<span class="math inline">\(log_m{(n(m-1)+1)}\)</span> 向上取整</strong></p>
<p><strong>最大度数称为树的度</strong></p>
<h3 id="二叉树">二叉树</h3>
<p>非空二叉树的<strong>叶结点数 = 度为2的结点数 + 1</strong></p>
<ul>
<li>「根结点 Root Node」：位于二叉树顶层的结点，没有父结点；</li>
<li>「叶结点 Leaf Node」：没有子结点的结点，其两个指针均指向 None
；</li>
<li>结点的「层 Level」：从顶至底递增，根结点所在层为 1 ；</li>
<li>结点的「度 Degree」：结点的子结点的数量。在二叉树中，度的范围是 0,
1, 2 ；</li>
<li>「边 Edge」：连接两个结点的线段，即结点指针；</li>
<li>二叉树的「高度」：从根结点到最远叶结点所经过的边的数量；</li>
<li>结点的「深度 Depth」
：从<strong>根结点到该结点</strong>所经过的边的数量；自顶向下</li>
<li>结点的「高度
Height」：从<strong>最远叶结点到该结点</strong>所经过的边的数量；自底向上</li>
</ul>
<figure>
<img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png" alt="二叉树的常用术语">
<figcaption aria-hidden="true">二叉树的常用术语</figcaption>
</figure>
<h4 id="满二叉树">满二叉树</h4>
<p><strong>含有 <span class="math inline">\(2^h-1\)</span>
个结点</strong></p>
<p>结点 i 的双亲为 i/2 (向下取整)</p>
<h4 id="完全二叉树">完全二叉树</h4>
<p><strong>叶结点</strong>只可能在层次<strong>最大的两层</strong>上出现。</p>
<p>双亲编号表示同满二叉树。</p>
<h4 id="二叉排序树">二叉排序树</h4>
<p>关键字大小：左子树 &lt; 根结点 &lt; 右子树</p>
<h4 id="平衡二叉树">平衡二叉树</h4>
<p>任意结点的左子树和右子树的<strong>高度之差的绝对值不超过 1</strong>
。</p>
<figure>
<img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/balanced_binary_tree.png" alt="平衡二叉树">
<figcaption aria-hidden="true">平衡二叉树</figcaption>
</figure>
<h4 id="二叉搜索树bst">二叉搜索树（BST）</h4>
<p>也称<strong>二叉排序树</strong></p>
<h3 id="二叉树的存储结构">二叉树的存储结构</h3>
<h4 id="顺序存储">顺序存储</h4>
<p>适合 满二叉树 和 完全二叉树</p>
<p>元素下标满足结点之间的关系</p>
<p>对于一般二叉树，可能需要添加空结点（浪费空间）。</p>
<h4 id="链式存储结构">链式存储结构</h4>
<p>至少包括三个域：数据域、左指针域、右指针域。</p>
<p><strong>在含有 n 个结点的二叉链表中，含有 n+1 个空链域。</strong></p>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<h4 id="先序">先序</h4>
<p>根 - 左 - 右</p>
<p>给定<strong>先序序列</strong>（n个元素），求所有可能的二叉树个数：卡特兰数
<span class="math inline">\(\frac{1}{n+1}C_{2n}^{n}\)</span></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visit(T);</span><br><span class="line">PreOrder(T-&gt;left);</span><br><span class="line">PreOrder(T-&gt;right);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="中序">中序</h4>
<p>左 - 根 - 右</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InOrder(T-&gt;left);</span><br><span class="line">visit(T);</span><br><span class="line">InOrder(T-&gt;right);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="后序">后序</h4>
<p>左 - 右 - 根</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PostOrder(left);</span><br><span class="line">PostOrder(right);</span><br><span class="line">visit(T);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="层序">层序</h4>
<p>借助<strong>队列</strong>实现，首先入队根结点，然后出队同时将其<strong>左子树</strong>和<strong>右子树</strong>入队，接着出队，同时将当前出队结点的左右子树入队，继续出队，重复之前的操作。</p>
<blockquote>
<p><strong>唯一</strong>地确定一棵二叉树：</p>
<ol type="1">
<li>先序和中序：先序确定根结点，中序确定左右子树</li>
<li>后序和中序：同上</li>
<li>层序和中序：层序遍历确定根结点</li>
</ol>
</blockquote>
<h4 id="非递归">非递归</h4>
<p>非递归实现先、中、后序遍历需要借助<strong>栈</strong>。（王道数据结构P135）</p>
<h3 id="线索二叉树">线索二叉树</h3>
<p>若无左子树，令<code>lchild</code>指向其<strong>前驱</strong>结点（置<code>ltag=1</code>）；若无右子树，令<code>rchild</code>指向其<strong>后驱</strong>结点。</p>
<p>实现过程：定义两个指针，一个（<code>p</code>）指向当前正在访问的结点，另一个（<code>pre</code>）指向刚刚访问过的结点。</p>
<p>记得<strong>处理最后一个结点</strong>（右孩子指向NULL）</p>
<p>线索二叉树是一种<strong>物理结构</strong>（二叉树是一种存储结构）</p>
<h4 id="中序-1">中序</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历线索化二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inthread</span><span class="params">(Node *p, Node *pre)</span> <span class="comment">//中序</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        Inthread(p-&gt;lchild, pre);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)<span class="comment">// 没有左孩子，连上</span></span><br><span class="line">        {</span><br><span class="line">            p -&gt; lchild = pre;</span><br><span class="line">            p -&gt; ltag = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="literal">NULL</span>){</span><br><span class="line">            pre -&gt; rchild = p;</span><br><span class="line">            pre -&gt; rtag = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        pre = p; </span><br><span class="line">        </span><br><span class="line">        Inthread(p-&gt;rchild, pre);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//先序和后序只需调换代码顺序，同时注意先序线索化需要判断tag值，不然可能会陷入死循环</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="先序-1">先序</h4>
<p>注意避免死循环（判断tag值）</p>
<p>先处理根节点再处理左子树，所以在处理根节点时左子树可能发生变化，所以要先判断tag</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230811201257804.png" alt="image-20230811201257804">
<figcaption aria-hidden="true">image-20230811201257804</figcaption>
</figure>
<h4 id="后序-1">后序</h4>
<p>找结点的后继时，需要知道结点的双亲，后序二叉线索树的遍历需要借助栈</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230811201413092.png" alt="image-20230811201413092">
<figcaption aria-hidden="true">image-20230811201413092</figcaption>
</figure>
<h4 id="线索二叉树的遍历">线索二叉树的遍历</h4>
<ul>
<li>先序遍历中，左右子树只能是根的后继，不是前驱</li>
<li>后序遍历(左右根)中，左右子树只能是根的前驱，不是后继</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230811224431415.png" alt="image-20230811224431415">
<figcaption aria-hidden="true">image-20230811224431415</figcaption>
</figure>
<h3 id="树森林">树、森林</h3>
<h4 id="树的存储结构">树的存储结构</h4>
<ul>
<li><p><strong>双亲表示法</strong>（顺序存储）：增设一个伪指针指向其双亲结点的位置（数组下标）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813193820445.png" alt="image-20230813193820445" style="zoom:50%;"></p>
<p>需要在树结构中<strong>频繁地查找某结点的父结点</strong>时，使用双亲表示法最合适。求结点的孩子时需遍历整个数组。<strong>注意区别树的顺序存储和二叉树的顺序存储</strong>。</p></li>
<li><p><strong>孩子表示法</strong>：使用顺序结构存储每个结点，将每个结点的孩子结点用单链表链接起来，则n个结点就有n个孩子链表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813194154250.png" alt="image-20230813194154250" style="zoom:67%;"></p>
<p>该结构查找孩子结点很方便，寻找双亲结点需要遍历n个结点指向的n个链表。</p></li>
<li><p><strong>孩子兄弟表示法</strong>（<strong>二叉树</strong>表示法）：每个结点设置两个指针，第一个指针指向该结点第一个<strong>孩子</strong>，第二个指针指向<strong>右兄弟</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813194523940.png" alt="image-20230813194523940" style="zoom:67%;"></p>
<p>寻找双亲结点比较麻烦，可以增设一个指向父结点的指针。</p>
<p><strong>无右孩子结点个数（右指针为空） = 非终端结点数（分支结点数） +
1</strong> (这里的分支是原分支)</p></li>
</ul>
<h4 id="树和森林的遍历">树和森林的遍历</h4>
<ul>
<li><p><strong>树</strong>的遍历：</p>
<p>（1）<strong>先根遍历</strong>（深度优先遍历）：遍历顺序与<strong>该树对应的二叉树</strong>的<strong>先序序列</strong>相同。</p>
<p>（2）<strong>后根遍历</strong>（深度优先遍历）：遍历顺序与<strong>该树对应的二叉树</strong>的<strong>中序序列</strong>相同。</p>
<p>（3）<strong>层序遍历</strong>（广度优先遍历）：借助队列完成，参考二叉树的层序遍历。</p></li>
<li><p><strong>森林</strong>的遍历：</p>
<p>（1）<strong>先序遍历</strong>：<strong>转换为二叉树</strong>，进行先序遍历；相当于依次对每个树进行先根遍历。</p>
<p>（2）<strong>中序遍历</strong>：同上；相当于依次对每个树进行后根遍历。</p></li>
</ul>
<h3 id="树与二叉树的应用">树与二叉树的应用</h3>
<h4 id="哈夫曼树">哈夫曼树</h4>
<ul>
<li><p><strong>哈夫曼树</strong></p>
<p><strong>WPL</strong>：带权路径长度（所有<strong>叶结点</strong>的带权路径长度<strong>之和</strong>）</p>
<p>WPL最小的树称为<strong>哈夫曼树</strong>（最优二叉树）</p>
<p>n 个结点（叶结点）构造的哈夫曼树共有 <strong>2n-1</strong>
个结点，不存在度为1的结点。</p>
<blockquote>
<p><strong>结点</strong>的带权路径长度：从一个结点到树的根节点之间的<strong>路径长度</strong>与该结点<strong>权值</strong>的<strong>乘积</strong>。</p>
<p><strong>树</strong>的带权路径长度：一棵树中所有<strong>叶结点</strong>的<strong>带权路径长度之和</strong></p>
</blockquote></li>
<li><p><strong>哈夫曼编码</strong>（P178）</p>
<p>可变长度编码</p>
<p>前缀码：没有一个编码是另一个编码的前缀</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230813203217599.png" alt="image-20230813203217599" style="zoom:80%;"></p></li>
</ul>
<h4 id="并查集">并查集</h4>
<p>通常使用树的<strong>双亲表示法</strong>作为并查集的存储结构。合并子集时直接将一个子集的根结点对应的数组元素指向另一个子集的根结点。</p>
<ul>
<li>并查集可用于实现克鲁斯卡尔算法</li>
<li>并查集可用于判断无向图的连通性</li>
</ul>
<p><strong>初始化</strong>：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814093118659.png" alt="image-20230814093118659">
<figcaption aria-hidden="true">image-20230814093118659</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814092857041.png" alt="image-20230814092857041">
<figcaption aria-hidden="true">image-20230814092857041</figcaption>
</figure>
<p><strong>Union优化</strong>：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309110916534.png" alt="image-20230911091555477">
<figcaption aria-hidden="true">image-20230911091555477</figcaption>
</figure>
<p><strong>Find优化</strong>：压缩路径</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814093458948.png" alt="image-20230814093458948">
<figcaption aria-hidden="true">image-20230814093458948</figcaption>
</figure>
<p><strong>总结</strong>：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230814092511362.png" alt="image-20230814092511362">
<figcaption aria-hidden="true">image-20230814092511362</figcaption>
</figure>
<h2 id="图">图</h2>
<h3 id="图的定义">图的定义</h3>
<p><strong>图的顶点集 <em>V</em> 一定非空</strong>，边集 <em>E</em>
可为空。</p>
<p><strong>无向图的所有顶点的度相加等于边的个数的两倍</strong>。</p>
<p>若无向图有<strong>n+1个顶点</strong>，要保证该图在<strong>任何情况</strong>下为<strong>连通</strong>的，至少需要
<strong>n(n-1)/2+1 条边</strong></p>
<ul>
<li>有向图：&lt;v,w&gt; 称为从 v 到 w 的弧（v-&gt;w）</li>
<li>无向图：(v,w)</li>
<li>简单图： 1. 不存在重复的边 2. 不存在顶点到自身的边
（可以有回路）</li>
<li><strong>简单路径是没有顶点重复的路径</strong></li>
<li><strong>完全图</strong>：<strong>每对不同的顶点之间都有一条边相连</strong>
<ol type="1">
<li>无向图---边的个数为 n(n-1)/2</li>
<li>有向图---边的个数为 n(n-1)</li>
</ol></li>
<li>子图：顶点子集与边子集构成子图，包含原图的所有顶点的子图称为<strong>生成子图</strong></li>
<li><strong>连通图（无向图）</strong>：任意两个顶点是连通的</li>
<li>连通分量：极大连通子图</li>
<li><strong>强连通（有向图）</strong>：任意一对顶点 v、w ，从 v 到 w、从
w 到 v 均有路径</li>
<li>强连通分量：极大强连通子图</li>
<li><strong>生成树</strong>（连通图）：包含图中<strong>所有顶点</strong>的一个<strong>极小连通图</strong>，例如<strong>n个结点的生成树有n-1条边</strong></li>
<li>生成森林（非连通图）：连通分量的生成树构成了生成森林</li>
<li>有向图的 <strong>入度 = 出度 = 边的个数</strong></li>
</ul>
<h3 id="图的存储">图的存储</h3>
<h4 id="邻接矩阵">邻接矩阵</h4>
<p><strong>一维数组</strong>保存<strong>顶点</strong>信息，<strong>二维数组</strong>保存<strong>边</strong>的信息</p>
<ul>
<li>无向图的邻接矩阵一定是一个对称矩阵（特殊矩阵可采用压缩存储），适用于稠密图</li>
<li>一行中非零（或非∞）元素个数为度或出度，一列中<strong>非</strong>
零/∞ 元素个数为度或入度</li>
<li>删除顶点操作：需要删除该顶点所在行和所在列，并移动数组（花销大）</li>
<li>图G的<strong>邻接矩阵A</strong>，A<sup>n</sup>的元素A<sup>n</sup>[i][j]等于由<strong>顶点i到顶点j</strong>的<strong>长度为n</strong>的<strong>路径数目</strong></li>
</ul>
<h4 id="邻接表">邻接表</h4>
<p>对图的每个顶点建立一个单链表（<strong>边表</strong>），指向单链表的顶点组成顶点表（数组，即图中V1、V2等在一个<strong>数组</strong>中），适用于稀疏图（减少存储空间）。不方便计算入度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815093150181.png" alt="image-20230815093150181" style="zoom:67%;"></p>
<h4 id="十字链表有向图">十字链表（有向图）</h4>
<figure>
<img src="http://data.biancheng.net/uploads/allimg/190107/2-1Z10H11122456.gif" alt="image-20230815092511362">
<figcaption aria-hidden="true">image-20230815092511362</figcaption>
</figure>
<p><strong>弧结点</strong>： <em>弧尾</em> 表示图中发出箭头的顶点，
<em>弧头</em> 表示箭头指向的顶点</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815100300128.png" alt="image-20230815100300128" style="zoom: 67%;"></p>
<ul>
<li>tailvex
用于存储以首元结点为<strong>弧尾</strong>的顶点位于数组中的位置下标；</li>
<li>headvex
用于存储以首元结点为<strong>弧头</strong>的顶点位于数组中的位置下标；</li>
<li>hlink 指针：用于链接下一个存储以首元结点为弧头的顶点的结点；</li>
<li>tlink 指针：用于链接下一个存储以首元结点为弧尾的顶点的结点；</li>
</ul>
<p><strong>顶点结点</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815100346847.png" alt="image-20230815100346847" style="zoom:67%;"></p>
<ul>
<li>firstin 指针用于连接以当前顶点为弧头的其他顶点构成的链表；</li>
<li>firstout 指针用于连接以当前顶点为弧尾的其他顶点构成的链表；</li>
</ul>
<h4 id="邻接多重表无向图">邻接多重表（无向图）</h4>
<figure>
<img src="http://data.biancheng.net/uploads/allimg/190108/2-1Z10R04Hb26.gif" alt="image-2023081501915362">
<figcaption aria-hidden="true">image-2023081501915362</figcaption>
</figure>
<p><strong>边结点</strong>：</p>
<figure>
<img src="http://data.biancheng.net/uploads/allimg/190108/2-1Z10R04A6457.gif" alt="image-2023081501910362">
<figcaption aria-hidden="true">image-2023081501910362</figcaption>
</figure>
<ul>
<li>ivex 和
jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；</li>
<li>ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的结点；</li>
<li>jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的结点；</li>
</ul>
<p><strong>顶点结点</strong>：</p>
<figure>
<img src="http://data.biancheng.net/uploads/allimg/190108/2-1Z10R04635G8.gif" alt="image-2023081501912362">
<figcaption aria-hidden="true">image-2023081501912362</figcaption>
</figure>
<ul>
<li>firstedge：指针域，用于指向同该顶点有直接关联的存储其他顶点的结点。</li>
</ul>
<p>邻接多重表与邻接表的区别：1.邻接表用两个<strong>结点</strong>表示同一条边
2.邻接多重表用一个<strong>结点</strong>表示</p>
<h3 id="图的遍历无权图">图的遍历（无权图）</h3>
<h4 id="广度优先搜索-bfs">广度优先搜索-BFS</h4>
<ul>
<li><p>类似于二叉树的<strong>层序遍历（辅助队列）</strong>，需要辅助数组<code>visited[]</code>记录顶点是否被访问过。</p></li>
<li><p><strong>空间复杂度</strong>：O(|V|) -- 队列</p></li>
<li><p><strong>时间复杂度</strong>：（1）邻接表--O(|V| + |E|)
(访问边表和顶点数组)</p>
<p>​ （2）邻接矩阵--O(|V|<sup>2</sup>)</p></li>
<li><p>可用于求解<strong>非带权图的单源最短路径</strong>。</p></li>
<li><p>广度优先生成树</p></li>
<li><p>BFS序列：邻接矩阵唯一，邻接表不唯一</p></li>
</ul>
<h4 id="深度优先搜索-dfs">深度优先搜索-DFS</h4>
<ul>
<li>类似于二叉树的<strong>先序遍历（递归）</strong>。</li>
<li><strong>空间复杂度</strong>：需要借助递归工作站，所以是 O(|V|)</li>
<li><strong>时间复杂度</strong>：（1）邻接表--O(|V| + |E|)
（2）邻接矩阵--O(|V|<sup>2</sup>)</li>
<li>深度优先生成树（连通图）、深度优先生成森林（非连通图）</li>
<li>DFS序列：邻接矩阵唯一，邻接表不唯一</li>
<li>判断<strong>有向图</strong>中是否存在<strong>回路</strong>（拓扑排序也可以）</li>
</ul>
<h3 id="图的应用">图的应用</h3>
<h4 id="最小生成树">最小生成树</h4>
<p>权值之和最小的生成树，树形可能不唯一，<strong>权值之和一定唯一</strong>。</p>
<p>最小生成树的边数 = 顶点数 - 1</p>
<p>以下两个算法都属于贪心算法</p>
<ul>
<li><p><strong>Prim算法</strong>（普里姆）</p>
<blockquote>
<p><strong>将顶点分为两类</strong>，一类是在查找的过程中已经包含在树中的（假设为
A 类），剩下的是另一类（假设为 B 类）。</p>
<p>对于给定的连通网，起始状态全部顶点都归为 B
类。在找最小生成树时，选定任意一个顶点作为起始点，并将之从 B 类移至 A
类；然后找出 B 类顶点 到 A
类中的顶点之间<strong>权值最小</strong>的顶点，将之从 B 类移至 A
类，如此重复，直到 B 类中没有顶点为止。分类后就避免了产生回路。</p>
<p><strong>时间复杂度：O(|V|<sup>2</sup>)</strong></p>
</blockquote></li>
<li><p><strong>Kruskal算法</strong>（克鲁斯卡尔）</p>
<blockquote>
<p>初始化：每个顶点构成一棵独立的树。</p>
<p>按照<strong>边的权值由小到大的顺序</strong>，不断选择当前未被选取过且<strong>不会形成回路</strong>的<strong>权值最小的边</strong>。</p>
<p>判断<strong>是否会产生回路</strong>的方法为：<strong>判断两个顶点是否属于不同连通分量</strong>。下面是具体实现：</p>
<p>在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。</p>
<p><strong>时间复杂度：O(|E|log|E|)</strong></p>
<p>采用<strong>堆</strong>存放边的集合，查询两点是否连通和连接两点可以使用<strong>并查集</strong></p>
<p>适用于<strong>边稀疏顶点较多</strong>的图</p>
</blockquote></li>
</ul>
<h4 id="最短路径带权图">最短路径（带权图）</h4>
<ul>
<li><p><strong>BFS</strong>（见图的遍历）</p></li>
<li><p><strong>Dijkstra算法</strong>（某个顶点到其余所有顶点的最短路径，<strong>不适用带负权值</strong>）</p>
<p>贪心思想</p>
<p>https://blog.csdn.net/xiaoxi_hahaha/article/details/110257368</p>
<p>https://www.youtube.com/watch?v=GazC3A4OQTE</p>
<blockquote>
<p>辅助数组：</p>
<p>dist[]--记录<strong>源点</strong>到其他顶点的最短路径长度，S集合每增加一个顶点，可能就需要修改数组的值</p>
<p>path[]--表示从源点到顶点之间的最短路径的前驱结点，方便回溯最短路径</p>
<p>（1）设置一个集合 S 记录已求得最短路径的顶点</p>
<p>（2）每次在集合 <code>V - S</code> (未被选择过的顶点)中选择一点
<em>i</em> ，i满足的要求：dist[i] 为数组中最小的元素</p>
<p>（3）将 i 添加到 S 中，并更新 dist 数组</p>
<p>（4）重复上述操作直到所有的顶点包含在 S 中</p>
<p><strong>时间复杂度：O(|V|<sup>2</sup>)</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prim更新的是未标记集合到已标记集合之间的距离</span><br><span class="line"></span><br><span class="line">Dijkstra更新的是源点到未标记集合之间的距离</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>Floyd算法</strong>（任意两顶点之间的最短路径，动态规划）</p>
<p>http://data.biancheng.net/view/47.html</p>
<blockquote>
<p><strong>可用于负权值带权图，但不能解决带有负权回路的图</strong></p>
<p>分为不同轮次，每次设置不同的中间顶点判断路径</p>
<p>将不同的点作为中间点找到最小路径</p>
<p><strong>时间复杂度：O(|V|<sup>3</sup>)</strong></p>
<p>A[i][j] 用于存放 i、j 两点之间的最短路径长度</p>
<p>path[i][j] 用于存放 i、j 两点之间经过的中间顶点k</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++) {<span class="comment">//注意循环顺序，中间顶点在最外层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v=<span class="number">0</span>; v&lt;n; v++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> w=<span class="number">0</span>; w&lt;n; w++) {</span><br><span class="line">                <span class="keyword">if</span> (A[v][w] &gt; A[v][k] + A[k][w]) {</span><br><span class="line">                    <span class="comment">//如果当前路径长度大于以 k 为中间点的路径长度，则更新 A[][]</span></span><br><span class="line">                    A[v][w]=A[v][k] + A[k][w];</span><br><span class="line">                    path[v][w]=k;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="有向无环图dag图">有向无环图（DAG图）</h4>
<p>可用于描述表达式，可简化重复的部分，节省空间</p>
<p>简化前</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817195534099.png" alt="image-20230817195534099" style="zoom:67%;"></p>
<p>简化后（每个操作数只出现一次）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817195644524.png" alt="image-20230817195644524" style="zoom:80%;"></p>
<h4 id="拓扑排序">拓扑排序</h4>
<ul>
<li><p><strong>AOV网</strong>：<strong>有向无环图</strong>，有向边表示活动的先后关系</p></li>
<li><p>满足拓扑排序的图属于<strong>有向无环图</strong>，无权值</p></li>
<li><p>每个顶点存在先后关系</p></li>
<li><p>每个AOV网有一个或多个<strong>拓扑排序</strong></p></li>
<li><p>若<strong>不存在</strong>==无前驱的顶点==，则说明该有向图必然存在环</p></li>
<li><p><strong>时间复杂度</strong>：邻接表--O(|V|+|E|)
邻接矩阵--O(|V|<sup>2</sup>)</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817201616229.png" alt="image-20230817201616229">
<figcaption aria-hidden="true">image-20230817201616229</figcaption>
</figure>
<blockquote>
<p>代码步骤：将所有<strong>入度为0</strong>的顶点<strong>进栈</strong>，输出栈中顶点后，将其指向的顶点的<strong>入度减1</strong></p>
</blockquote>
<p><strong>逆拓扑排序</strong></p>
<p>使用邻接矩阵更方便（删除指向当前顶点的边）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230817202359994.png" alt="image-20230817202359994">
<figcaption aria-hidden="true">image-20230817202359994</figcaption>
</figure>
<p><strong>DFS算法</strong>实现逆拓扑排序：深度优先会一直递归到没有出度的顶点，在顶点退栈前输出</p>
<h4 id="关键路径">关键路径</h4>
<p><strong>AOE网</strong></p>
<ul>
<li><p>带权<strong>有向无环图</strong></p></li>
<li><p><strong>顶点</strong>表示<strong>事件</strong>，<strong>有向边</strong>表示<strong>活动</strong>，权值表示完成该活动的开销</p></li>
<li><p>仅有一个入度为0的顶点，仅有一个出度为0的顶点</p></li>
<li><p><strong>关键路径</strong>：路径长度最大</p></li>
<li><p><strong>关键活动</strong>：关键路径上的活动（有向边）满足的条件----
<code>l - e = 0</code></p></li>
<li><p><strong>事件v最早</strong>发生时间
<strong>ve</strong>：从前往后推（最大值）</p></li>
<li><p><strong>事件v最迟</strong>发生时间
<strong>vl</strong>：从后往前推（最小值）</p></li>
<li><p><strong>活动a最早</strong>开始时间
<strong>e</strong>：<code>e = ve</code> e等于这条弧的起点的ve</p></li>
<li><p><strong>活动a最迟</strong>开始时间
<strong>l</strong>：<code>l = vl - weight(权值)</code>，从后往前推</p></li>
</ul>
<h2 id="查找">查找</h2>
<p><strong>平均查找长度 ASL</strong></p>
<p>动态查找表：二叉排序树、散列查找</p>
<p>静态查找表：顺序查找、折半查找、散列查找</p>
<h3 id="线性结构">线性结构</h3>
<h4 id="顺序查找">顺序查找</h4>
<ol type="1">
<li>一般线性表</li>
</ol>
<ul>
<li><p>适用于顺序表和链表</p></li>
<li><p>ASL<sub>成功</sub> = (n+1)/2</p></li>
<li><p>ASL<sub>失败</sub> = n+1</p></li>
</ul>
<ol start="2" type="1">
<li>有序表</li>
</ol>
<ul>
<li>若未查到且下一个元素大于key，可直接退出（查找失败）</li>
<li>ASL<sub>失败</sub> = n/2 + n/(n+1)</li>
</ul>
<h4 id="折半查找二分查找">折半查找（二分查找）</h4>
<p><strong>仅适用于有序的顺序表</strong>，仅适合<strong>顺序存储</strong>，不适合链式存储结构</p>
<ul>
<li>每次与中间元素(n/2 可向<strong>上/下</strong>取整)进行比较</li>
<li><strong>判定树</strong>：<strong>平衡二叉树</strong></li>
<li>若能查找成功，则比较次数最多不会超过<strong>树高</strong></li>
<li>时间复杂度：O(log<sub>2</sub>n)</li>
<li>ASL = log<sub>2</sub>(n+1)-1</li>
</ul>
<h4 id="分块查找索引顺序查找">分块查找（索引顺序查找）</h4>
<ul>
<li><p><strong>块内可无序</strong>，<strong>块间有序</strong></p></li>
<li><p>建立<strong>索引表</strong>，索引表的每个元素包括各块的最大关键字和各块第一个元素的位置</p></li>
<li><p>先在索引表中<strong>确定块的位置</strong>（上述两种查找均可），然后在<strong>块内顺序查找</strong></p></li>
<li><p>ASL = L<sub>I</sub> + L<sub>S</sub>
(L<sub>I</sub>时索引查找，L<sub>S</sub>是块内查找)</p>
<p>将长度为 n 的查找表均匀分为 b 块，每块有 s
个记录，<strong>若均使用顺序查找</strong>，则：</p>
<p><span class="math display">\[
ASL = \frac{b+1}{2} + \frac{s+1}{2} = \frac{bs+s^2+2s}{2s} =
\frac{n+s^2+2s}{2s}
\]</span> 则当 ==<span class="math inline">\(s = \sqrt{n}\)</span>==
时，平均查找长度最小---<span class="math inline">\(\sqrt{n}+1\)</span></p></li>
</ul>
<h3 id="树形结构">树形结构</h3>
<h4 id="二叉排序树bst">二叉排序树（BST）</h4>
<ul>
<li><p>左子树 &lt; 根结点 &lt; 右子树</p></li>
<li><p><strong>中序遍历可以得到有序序列</strong></p></li>
<li><p>从根结点开始比较，若关键字小于根结点则进入左子树，否则进入右子树</p></li>
<li><p>可使用递归，但执行效率低（空间复杂度高）；<strong>非递归使用循环</strong></p></li>
<li><p>结点的<strong>插入</strong>：插入的结点一定是<strong>叶子结点</strong>，可使用<strong>递归</strong>实现；若存在相同的关键字，插入失败</p></li>
<li><p>结点 z 的<strong>删除</strong>：</p>
<p>（1）叶结点：直接删除</p>
<p>（2）只有一棵子树：让子树成为 z 的父结点的子树</p>
<p>（3）有左右两个子树：令<strong>右子树最左下结点/直接后继（或左子树最右下结点/直接前驱）</strong>代替
z，然后删除直接后继/直接前驱结点</p>
<p>注意：删除一个结点可能会影响多个结点，因此可能要操作多次</p></li>
<li><p><strong>ASL</strong>：成功 = 比较次数(根节点也算一次)/结点个数 ；
失败 = 失败比较次数/<strong>失败结点个数</strong></p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309120847285.png" alt="image-20230912084739404" style="zoom:80%;"></p>
<h4 id="平衡二叉树avl树">平衡二叉树（AVL树）</h4>
<p><strong>一定是二叉排序树</strong></p>
<ul>
<li><p>左右子树高度差绝对值不超过1</p></li>
<li><p>结点的<strong>插入</strong>：插入步骤与二叉排序树相同，插入后若导致<strong>不平衡</strong>则需要调整结点位置</p>
<blockquote>
<p>调整的对象是——<strong>最小不平衡子树</strong></p>
<ol type="1">
<li><strong>LL</strong>平衡旋转（右单旋转）：在左孩子的左子树插入结点，需要旋转<strong>左孩子结点</strong></li>
<li><strong>RR</strong>平衡旋转（左单旋转）：在右孩子的右子树插入结点，需要旋转<strong>右孩子结点</strong></li>
<li><strong>LR</strong>平衡旋转（先左后右）：在左孩子的右子树插入结点，旋转<strong>左孩子</strong>的<strong>右子树的根结点</strong></li>
<li><strong>RL</strong>平衡旋转（先右后左）：在右孩子的左子树插入结点，旋转<strong>右孩子</strong>的<strong>左子树的根结点</strong></li>
</ol>
</blockquote></li>
<li><p>结点的<strong>删除</strong>：删除步骤同二叉排序树，删除后需要调整结点位置</p>
<blockquote>
<p>调整方法同插入结点，可能会回溯到根结点（树高减1）</p>
</blockquote></li>
<li><p><strong>ASL</strong>同二叉排序树</p></li>
<li><p>==<strong>n<sub>h</sub> = n<sub>h-1</sub> + n<sub>h-2</sub> +
1</strong>== （n<sub>0</sub>=0,n<sub>1</sub>=1,n<sub>2</sub>=2;
n<sub>h</sub>表示深度为h的平衡树中含有的最少结点数）</p></li>
<li><p>适用于以查为主，很少进行插入/删除的场景</p></li>
</ul>
<h4 id="红黑树rbt">红黑树（RBT）</h4>
<ul>
<li><p>是<strong>二叉排序树</strong></p></li>
<li><p>适用于频繁插入、删除的场景，实用性更强</p></li>
<li><p>左子树结点值≤ 根结点值≤ 右子树结点值 （左根右）</p></li>
<li><p>红黑性质：“左根右，根叶黑，不红红，黑路同”</p>
<blockquote>
<ol type="1">
<li><p><strong>根</strong>节点是<strong>黑</strong>的</p></li>
<li><p><strong>不存在</strong>两个相邻的红结点</p></li>
<li><p>从每个结点(不包括该结点)到任意一个叶结点(包括叶结点)的路径上的<strong>黑结点个数</strong>相同（<strong>黑高</strong>）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308201923357.png" alt="image-20230820183328913">
<figcaption aria-hidden="true">image-20230820183328913</figcaption>
</figure></li>
<li><p><strong>叶</strong>结点（外部结点）都是<strong>黑</strong>的（NULL）</p></li>
</ol>
</blockquote></li>
<li><p>结论：</p>
<ol type="1">
<li><p>从根到叶结点的最长路径<strong>不大于</strong>最短路径的<strong>2倍</strong>（最长路径：红黑结点相间）</p></li>
<li><p>n个内部结点(非叶结点)的红黑树的高度（不计入叶结点） <strong>h
&lt;= 2log<sub>2</sub>(n+1)</strong></p>
<p>黑高 &gt;= h/2</p></li>
</ol></li>
<li><p><strong>插入</strong>结点：https://www.cnblogs.com/crazymakercircle/p/16320430.html#autoid-h3-6-1-0</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308201923421.png" alt="image-20230428193424258">
<figcaption aria-hidden="true">image-20230428193424258</figcaption>
</figure>
<ul>
<li>删除:
<ol type="1">
<li>时间复杂度：O(log<sub>2</sub>n)</li>
<li>处理方法同二叉排序树，删除后需要调整红黑树结点的颜色和位置</li>
</ol></li>
</ul>
<h4 id="b树">B树</h4>
<p>m阶B树</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308211924185.png" alt="image-20230821192426665">
<figcaption aria-hidden="true">image-20230821192426665</figcaption>
</figure>
<ul>
<li>所有结点的平衡因子为0的<em>m路平衡查找树</em></li>
<li>每个结点最多有m棵子树，即最多 <strong>m-1 个关键字</strong></li>
<li>根结点至少有<strong>两个子树</strong></li>
<li>分支结点（非根）至少有 <strong>⌈m/2⌉</strong> 棵子树，即至少含有
<strong>⌈m/2⌉-1</strong> 个关键字</li>
<li>所有叶结点都在同一层次上（不携带信息）？<strong>真题里叶结点是内部结点</strong></li>
<li>关键字个数 = 子树个数 - 1</li>
<li>计算B树高度不算入叶子结点(<strong>n为关键字个数</strong>)：<strong>log<sub>m</sub>(n+1)
&lt;= h &lt;= log<sub>⌈m/2⌉</sub>[(n+1)/2] + 1</strong></li>
<li><strong>n个关键字的B树必有 n+1
个叶子节点</strong>（查找失败的结点）</li>
<li>只支持<strong>随机查找</strong>（https://ask.csdn.net/questions/7498622）</li>
<li>应用于数据库和文件系统</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212001008.png" alt="image-20230821200146110">
<figcaption aria-hidden="true">image-20230821200146110</figcaption>
</figure>
<p><strong>插入</strong></p>
<ul>
<li><p>用“查找”确定插入位置</p></li>
<li><p>关键字超过上限，向上移动</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308211946175.png" alt="image-20230821194623697">
<figcaption aria-hidden="true">image-20230821194623697</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308211947745.png" alt="image-20230821194706476">
<figcaption aria-hidden="true">image-20230821194706476</figcaption>
</figure></li>
</ul>
<p><strong>删除</strong></p>
<ul>
<li><p>若删除的关键字在<strong>非终端</strong>结点，则使用直接前驱/后继代替被删除的关键字（类似于二叉排序树）</p></li>
<li><p>若删除的关键字在<strong>终端</strong>结点：</p>
<ol type="1">
<li><p>删除后关键字个数高于下限（⌈m/2⌉-1）：直接删除</p></li>
<li><p>删除后关键字个数<strong>低于下限</strong>：</p>
<ul>
<li><p><strong>兄弟够借</strong>：需要移动兄弟结点和父结点中的关键字（保证核心要求）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212003408.png" alt="image-20230821200349342">
<figcaption aria-hidden="true">image-20230821200349342</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212004917.png" alt="image-20230821200416246">
<figcaption aria-hidden="true">image-20230821200416246</figcaption>
</figure></li>
<li><p><strong>兄弟不够借</strong>：合并兄弟结点，移动父结点关键字，<strong>向上递归</strong>；下图：删除关键字<code>49</code></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212007638.png" alt="image-20230821200746707">
<figcaption aria-hidden="true">image-20230821200746707</figcaption>
</figure>
<p>合并终端结点后，父结点又需要进行调整</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212009716.png" alt="image-20230821200859400">
<figcaption aria-hidden="true">image-20230821200859400</figcaption>
</figure>
<p>合并完成：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212009153.png" alt="image-20230821200951415">
<figcaption aria-hidden="true">image-20230821200951415</figcaption>
</figure></li>
</ul></li>
</ol></li>
</ul>
<h4 id="b树-1">B+树</h4>
<p>m阶B+树（类比分块查找）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212015573.png" alt="image-20230821201549775">
<figcaption aria-hidden="true">image-20230821201549775</figcaption>
</figure>
<ul>
<li><strong>结点的子树个数与该结点关键字个数相同</strong></li>
<li><strong>叶结点包含所有关键字及指向相应记录的指针，有序排列</strong></li>
<li>注意上图中的“记录”不是叶子节点</li>
<li><strong>根结点</strong>（不是叶结点的根结点）<strong>至少有两棵树</strong>，其他分支结点至少有⌈m/2⌉个子树</li>
<li>所有分支结点中仅包含它的各个<strong>子结点</strong>中的<strong>关键字的最大值</strong>及其指向其子结点的指针</li>
<li>既支持<strong>随机查找</strong>也支持<strong>顺序查找</strong></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308212033124.png" alt="image-20230821203320627">
<figcaption aria-hidden="true">image-20230821203320627</figcaption>
</figure>
<h4 id="散列表哈希表">散列表（哈希表）</h4>
<ul>
<li><p>散列函数：将关键字<strong>映射成该关键字对应的地址</strong>的函数（直接映射关系）</p></li>
<li><p>散列函数构造方法：</p>
<ol type="1">
<li><strong>直接定址法</strong>：线性函数 --
<code>H(key) = a × key + b</code></li>
<li><strong>除留余数法</strong>：最简单最常用--<code>H(key) = key % p</code>（p为最接近/等于散列表长度的<strong>质数</strong>）</li>
<li><strong>数字分析法</strong>：选取数码分布较为均匀的若干位作为散列地址（例如手机号后四位）</li>
<li><strong>平方取中法</strong>：取关键字的平方值的中间几位数字作为散列地址</li>
</ol></li>
<li><p>处理冲突的方法：</p>
<ol type="1">
<li><p><strong>拉链法</strong>（链接法）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308222004550.png" alt="image-20230822200426453">
<figcaption aria-hidden="true">image-20230822200426453</figcaption>
</figure></li>
<li><p><strong>开放定址法</strong></p>
<p>H<sub>i</sub> = ( H(key) + d<sub>i</sub> ) % m</p>
<p><strong>不能随便物理删除表中元素，若要删除元素，可使用删除标记进行逻辑删除</strong>（2023真题）</p>
<ul>
<li><strong>线性探测法</strong>：发生冲突时，顺序查看表中的<strong>下一个单元</strong>，缺点--大量元素堆积，降低了查找效率</li>
<li>平方探测法：又称二次探测法，散列表长度必须为可以表示为（4j+3）的质数，正负平方交替</li>
<li>伪随机序列法：d<sub>i</sub> 是伪随机数序列</li>
<li>双散列法：使用两个散列函数</li>
</ul></li>
</ol></li>
<li><p>装填因子 = 表中记录数/散列表长度</p></li>
<li><p>平均查找长度：</p>
<p><strong>ASL<sub>成功</sub></strong> = 查找次数/关键字个数</p>
<p><strong>ASL<sub>失败</sub></strong> = 查找失败次数/p
（查找失败次数是从哈希函数<strong>计算出的位置</strong>[等概率]到<strong>第一个空地址</strong>(包括)；一共需要计算<strong>p个位置</strong>的查找失败次数，p为哈希函数所能计算出的地址个数，比如
key%7 的范围是 0~6，所以p为7，不要多算）</p>
<p>例：https://www.cnblogs.com/47Gamer/p/13160610.html</p></li>
<li><p><strong>堆积</strong>对存储效率、散列函数和装填因子不会有影响，会影响到平均查找长度</p></li>
</ul>
<h2 id="排序">排序</h2>
<ul>
<li><p><strong>稳定性</strong>：关键字相同的元素在排序后<strong>相对位置不变</strong></p></li>
<li><p>分为<strong>内部排序</strong>（一次性放入内存）和<strong>外部排序</strong>（无法同时放入内存）</p></li>
<li><p><strong>基于比较的排序</strong>：至少需要比较
<strong>⌈log<sub>2</sub>(n!)⌉</strong>
(n!为所有可能的序列，将比较过程转化为二叉树，则二叉树的高度就是最少比较次数)</p></li>
<li><p>时间复杂度：https://cloud.tencent.com/developer/article/1899388</p>
<p>https://blog.csdn.net/pange1991/article/details/85460755</p></li>
<li><p>长度分别为<strong>m</strong>和<strong>n</strong>的有序数组，每次比较处理一个元素，合并的最多比较次数为<strong>(m+n-1)</strong></p></li>
</ul>
<h3 id="插入排序">插入排序</h3>
<ol type="1">
<li><p><strong>直接插入排序</strong></p>
<ul>
<li>边比较边移动元素，然后将目标元素插入<strong>有序序列</strong>的确定位置</li>
<li><strong>有序序列从后往前比较</strong>，边比较边向后移动元素（顺序存储，非有序部分从前往后遍历）</li>
<li>链式存储可从前往后查找指定位置</li>
<li>排序趟数与序列的原始状态无关</li>
<li>比较次数和移动次数与序列初始状态有关</li>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li><strong>稳定</strong></li>
</ul></li>
<li><p><strong>折半插入排序</strong></p>
<ul>
<li>在确定元素插入的位置时，对<strong>有序子表</strong>使用<strong>折半查找</strong></li>
<li>比较完确定位置后再移动元素</li>
<li>比较次数改进了(仅取决于序列元素个数)，但<strong>移动次数未改变</strong></li>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li><strong>稳定</strong></li>
</ul></li>
</ol>
<h3 id="希尔排序">希尔排序</h3>
<p>又称<em>缩小增量排序</em></p>
<ul>
<li><strong>分组</strong>（相隔固定的增量）</li>
<li>增量不断减小直至1</li>
<li>时间复杂度：O(n<sup>1.3</sup>) ，最坏情况O(n<sup>2</sup>)</li>
<li>仅适用于<strong>顺序表</strong></li>
<li>分组后的子序列使用<strong>直接插入排序</strong></li>
<li><strong>不稳定</strong></li>
</ul>
<h3 id="冒泡排序">冒泡排序</h3>
<p>属于交换排序</p>
<p>两两比较，移动元素至序列的一端</p>
<ul>
<li>每趟排序都会将一个元素放在其最终位置</li>
<li>可设置一个标志判断此趟排序是否发生交换，若未发生，直接退出</li>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>最好情况下序列有序，只需比较不需移动，O(n)</li>
<li><strong>稳定</strong></li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p>属于交换排序</p>
<p>分治思想</p>
<ul>
<li>两端有low和high指针，一趟排序结束后分为两个子序列</li>
<li>每一趟排序都会将一个元素放在其最终的位置上</li>
<li><strong>时间复杂度</strong>：<strong>最好/平均情况</strong>--<strong>O(nlog<sub>2</sub>n)</strong>；<strong>最坏情况</strong>--基本有序和基本逆序，<strong>O(n<sup>2</sup>)</strong></li>
<li><strong>递归</strong>：先划分为两个子表，然后分别对两个子表进行递归排序</li>
<li>空间复杂度（递归调用的最大深度）：平均情况--O(log<sub>2</sub>n)，最坏情况--O(n)</li>
<li>平均性能最优的内部排序算法</li>
<li><strong>划分操作的时间复杂度为 O(n)</strong></li>
<li><strong>不稳定</strong></li>
</ul>
<blockquote>
<p>快速排序的一次划分算法从两头交替搜索，直到low和high重合，因此其时间复杂度是<strong>O(n)</strong>，树高为
<strong>log<sub>2</sub>n</strong>，所以总的时间复杂度为 O(nlogn)</p>
<p>每次<strong>划分</strong>后，两边分区是<strong>同时进行递归</strong>处理的</p>
<p><strong>递归次数与处理先后无关</strong></p>
<p><strong>栈</strong>的深度与处理先后有关：https://www.cnblogs.com/hwx0000/p/12733660.htm</p>
</blockquote>
<p>P324-T17
https://www.nowcoder.com/questionTerminal/0e322ea03d0d4b318403c7119a18e5a1</p>
<h3 id="简单选择排序">简单选择排序</h3>
<p>属于选择排序</p>
<ul>
<li>选取 [i, n-1] 区间内最小/最大的元素与i处的元素交换次序</li>
<li>排序趟数与序列的原始状态无关</li>
<li>比较次数也与序列初始状态无关</li>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li><strong>不稳定</strong></li>
</ul>
<h3 id="堆排序">堆排序</h3>
<p>属于选择排序</p>
<p>「堆
Heap」是一种满足特定条件的<strong>完全二叉树</strong>，可分为两种类型：</p>
<ul>
<li><p>「大顶堆 Max Heap」，任意结点的值 ≥ 其子结点的值</p></li>
<li><p>「小顶堆 Min Heap」，任意结点的值 ≤ 其子结点的值</p></li>
<li><p>分支结点 i &lt;= <strong>⌊n/2⌋</strong></p></li>
<li><p><strong>堆排序过程</strong>：https://www.hello-algo.com/chapter_heap/heap/#4</p>
<ol type="1">
<li><p>首先无序序列构建<strong>初始堆</strong>，从
i=<strong>⌊n/2⌋</strong>
(即最后一个分支结点)开始，比较其子结点与i的值，调整位置，然后<code>i--</code>依次向前对分支结点进行调整直到根节点（对于<strong>单个子树是向下调整</strong>，<strong>总体的趋势是向上调整</strong>）。[<strong>建堆</strong>时间复杂度O(n)]。建堆完成并不表示排好序了</p>
<blockquote>
<p>建堆共有两种方法——筛选法、插入法。上述方法就是筛选法，直接在原有的序列上进行操作；而插入法是从0开始建堆，每次将元素插入堆底[O(nlgn)]。</p>
<p>维护堆的性质（处理单个元素）：时间复杂度为 O(lgn)</p>
</blockquote></li>
<li><p>然后进行<strong>排序</strong>，将堆顶元素与堆底元素<strong>交换</strong>。完成交换后（此时堆顶元素位于数组末尾），堆的长度减1，此时堆的结构被破坏，需要再次<strong>调整</strong>（从堆顶元素开始）</p></li>
<li><p>重复上述过程</p></li>
<li><p>最后得到的序列就是有序序列了（<strong>升序建大根堆，降序建小根堆</strong>）</p>
<blockquote>
<p>因为在排序阶段，堆顶和堆底<strong>交换了位置</strong>，即堆顶元素（最值）放在了数组最后一个下标处，所以升序建大根堆</p>
</blockquote></li>
</ol></li>
<li><p>时间复杂度：<strong>O(nlog<sub>2</sub>n)</strong></p></li>
<li><p>插入：将新元素插入到堆的末端，然后向上进行调整</p></li>
<li><p><strong>不稳定</strong></p></li>
<li><p>注意删除后（多比较一次：两个子元素比较）和插入后重建堆的比较次数</p></li>
</ul>
<h3 id="归并排序2路">归并排序（2路）</h3>
<p><strong>比较次数</strong>的数量级与序列初始状态无关。</p>
<ul>
<li>每一趟都是两个<strong>有序表</strong>（单个元素也算有序表）合并</li>
<li>递归：先从中间划分两个子序列，对左侧子序列递归排序，对右侧子序列递归排序，归并</li>
<li>空间复杂度：O(n)</li>
<li>时间复杂度：<strong>O(nlog<sub>2</sub>n)</strong></li>
<li>k路归并排序的排序趟数：<strong>log<sub>k</sub>n</strong>
向上取整</li>
<li><strong>稳定</strong></li>
<li>https://www.runoob.com/w3cnote/merge-sort.html</li>
</ul>
<p>注：两个长度分别为m和n的有序数组，每次比较处理一个元素，<strong>最多比较次数</strong>为<strong>(m+n-1)</strong></p>
<h3 id="基数排序">基数排序</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308252005303.png" alt="image-20230825200523692">
<figcaption aria-hidden="true">image-20230825200523692</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308252007095.png" alt="image-20230825200727052">
<figcaption aria-hidden="true">image-20230825200727052</figcaption>
</figure>
<p>基数排序的元素移动次数与关键字的初始排列顺序无关。</p>
<p>排序趟数与序列的原始状态无关。</p>
<ul>
<li>空间复杂度：O(r) （r为基数，上图中r=10）</li>
<li>时间复杂度：O(d(n+r)) （d为关键字可分成d元组，n为关键字个数）</li>
<li>擅长解决的问题：
<ol type="1">
<li>数据元素的关键字可以方便地拆分为d组，且<strong>d</strong>较小</li>
<li>每组关键字取值范围不大（<strong>r</strong>较小）</li>
<li>数据元素个数<strong>n</strong>较大</li>
</ol></li>
<li><strong>稳定</strong>（基你太稳）</li>
</ul>
<blockquote>
<p><strong>基数</strong>排序、<strong>冒泡</strong>排序、直接<strong>插入</strong>排序、折半插入排序、<strong>归并</strong>排序是<strong>稳定的排序算法</strong></p>
</blockquote>
<h3 id="外部排序">外部排序</h3>
<p>http://data.biancheng.net/view/76.html</p>
<p>https://www.cnblogs.com/haimishasha/p/10898715.html</p>
<p>在实际归并的过程中，由于内存容量的限制不能满足同时将 2
个归并段全部完整的读入内存进行归并，只能不断地取 2
个归并段中的每一小部分进行归并，通过不断地读数据和向外存写数据，直至 2
个归并段完成归并变为 1 个大的有序文件。</p>
<ul>
<li><p>主要考虑访问磁盘的次数，即<strong>I/O次数</strong></p></li>
<li><p>缓冲区大小与磁盘块大小一致（输入缓冲区1，输入缓冲区2，输出缓冲区）</p></li>
<li><p>当其中一个缓冲区取空时，需要从对应的归并段中读入下一块数据，然后才能继续进行归并</p></li>
<li><p>外部排序时间开销 = 内部排序算法(生成初始归并段) +
<strong>读写外存的时间</strong> + 内部归并的时间</p></li>
<li><p>优化：采用多路归并，减少归并趟数（h-1），从而减少磁盘I/O的次数</p>
<p>代价：（1）增加缓冲区大小（2）关键字的比较次数增多</p></li>
</ul>
<h4 id="败者树">败者树</h4>
<p><strong>减少比较次数</strong></p>
<p>可视为完全二叉树</p>
<p>每个结点存储<strong>失败</strong>关键字所在的归并段序号，假设 r
为归并段数量，k为k路归并，<strong>总</strong>的比较次数为：<strong>（n -
1）⌈log<sub>2</sub>r⌉</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308262246924.png" alt="image-20230826224623238">
<figcaption aria-hidden="true">image-20230826224623238</figcaption>
</figure>
<h4 id="置换选择排序">置换选择排序</h4>
<ul>
<li><p>初始归并段输出文件 FO （位于磁盘中）</p></li>
<li><p>内存工作区 WA （假设大小为w）</p></li>
<li><p>初始待排文件 FI</p></li>
<li><p>算法步骤：</p>
<p>（1）从FI输入w个记录到WA中(存在输入缓冲区，从磁盘中读入多个记录，然后将记录输入到WA中)</p>
<p>（2）从WA中选出最小关键字(用<strong>败者树</strong>来实现)，并<strong>记为
MINIMAX</strong></p>
<p>（3）将MINIMAX输出到 FO
中(存在输出缓冲区，输出缓冲区满则以块为单位写入磁盘)</p>
<p>（4）当WA中所有关键字的值 &lt;
MINIMAX时，<strong>截断</strong>归并段，记录新的MINIMAX并输出到新的归并段</p>
<p>（5）重复上述操作</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308270934703.png" alt="image-20230827093432664">
<figcaption aria-hidden="true">image-20230827093432664</figcaption>
</figure></li>
</ul>
<p>归并段长度不一定相等。</p>
<h4 id="最佳归并树">最佳归并树</h4>
<p>利用哈夫曼树的思想，构造<strong>严格k叉树</strong>（即树中只有度为 k
或 0 的结点），若初始归并段不足以构成一棵严格 k 叉树，需添加长度为 0
的“虚段”（权为0的叶子）。</p>
<ul>
<li><p>WPL = 读磁盘的次数 = 写磁盘的次数</p></li>
<li><p>磁盘I/O次数 = WPL * 2</p></li>
<li><p>n = n<sub>k</sub> + n<sub>0</sub> ; kn<sub>k</sub> = n-1
(<strong>分叉数等于非根结点数</strong>，即每个非根结点都有一个入度)</p></li>
<li><p>计算虚段个数满足的要求：<strong>（n<sub>0</sub> - 1）%（k - 1）=
0</strong></p></li>
</ul>
<p>（注：n<sub>0</sub>是度为0的结点，k为k叉树）</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%">
<col style="width: 10%">
<col style="width: 16%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 10%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>排序法</th>
<th>平均时间</th>
<th>最坏情况</th>
<th>最好情况</th>
<th>稳定度</th>
<th>额外空间</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>稳定</td>
<td>O(1)</td>
<td>n小时较好</td>
</tr>
<tr class="even">
<td>选择</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td></td>
<td>不稳定</td>
<td>O(1)</td>
<td>n小时较好</td>
</tr>
<tr class="odd">
<td>插入</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td></td>
<td>稳定</td>
<td>O(1)</td>
<td>大部分已排序时较好</td>
</tr>
<tr class="even">
<td>基数</td>
<td>O(logRB)</td>
<td>O(logRB)</td>
<td></td>
<td>稳定</td>
<td>O(n)</td>
<td>B是真数(0-9)，R是基数(个十百)</td>
</tr>
<tr class="odd">
<td>Shell</td>
<td>O(nlogn)</td>
<td>O(n<sup>s</sup>) 1&lt;s&lt;2</td>
<td></td>
<td>不稳定</td>
<td>O(1)</td>
<td>s是所选分组</td>
</tr>
<tr class="even">
<td>快速</td>
<td>O(nlogn)</td>
<td>O(n2)</td>
<td></td>
<td>不稳定</td>
<td>O(nlogn)</td>
<td>n大时较好</td>
</tr>
<tr class="odd">
<td>归并</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td></td>
<td>稳定</td>
<td>O(1)</td>
<td>n大时较好</td>
</tr>
<tr class="even">
<td>堆</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td></td>
<td>不稳定</td>
<td>O(1)</td>
<td>n大时较好</td>
</tr>
</tbody>
</table>
<h1 id="计算机组成原理">计算机组成原理</h1>
<h2 id="计算机系统概述">计算机系统概述</h2>
<h3 id="计算机硬件">计算机硬件</h3>
<h4 id="冯诺依曼结构">冯诺依曼结构</h4>
<p>“<strong>存储程序</strong>”的概念</p>
<p>五大部件：</p>
<ul>
<li><p><strong>输入设备</strong></p></li>
<li><p><strong>输出设备</strong></p></li>
<li><p><strong>存储器</strong>：</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储体 + MDR + MAR + 地址译码器（主存）</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>运算器</strong>(中心)：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU[核心] + ACC + MQ + X + IX[变址寄存器] + BR[基址寄存器] + PSW[程序状态寄存器]</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>控制器</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CU[控制单元] + PC[程序计数器，存放地址] + IR[指令寄存器]</span><br></pre></td></tr></tbody></table></figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230511172129518.png" alt="image-20230511172129518">
<figcaption aria-hidden="true">image-20230511172129518</figcaption>
</figure></li>
</ul>
<blockquote>
<p><strong>程序员可见的寄存器</strong>：通用寄存器、PC（jmp）、PSW（cmp）、基址寄存器</p>
<p><strong>不可见（透明）</strong>：MAR、MDR、IR</p>
</blockquote>
<p>CPU与主存之间存在地址、控制、数据三组总线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230514164942777.png" alt="image-20230514164942777" style="zoom: 80%;"></p>
<h4 id="现代计算机结构">现代计算机结构</h4>
<ul>
<li>机器字长等于CPU内部用于整数运算的运算器位数和<strong>通用寄存器</strong>位数。</li>
<li>以<strong>存储器</strong>为中心</li>
<li><strong>CPU = 运算器 + 控制器</strong></li>
<li>现代计算机中MAR和MDR存在于CPU里</li>
<li>系列机的指令系统<strong>向后/下兼容</strong>（兼容旧版本）</li>
</ul>
<h4 id="计算机软件">计算机软件</h4>
<p>按功能分类：</p>
<ul>
<li>系统软件：操作系统、数据库管理系统</li>
<li>应用软件</li>
</ul>
<p>三个级别的语言：</p>
<ul>
<li>机器语言：二进制代码</li>
<li>汇编语言：助记符</li>
<li>高级语言</li>
</ul>
<p><strong>翻译程序</strong>：</p>
<ul>
<li>汇编程序：汇编语言 -&gt; 机器语言</li>
<li><strong>编译程序</strong>：<strong>高级语言 -&gt;
汇编语言或机器语言</strong></li>
<li>解释程序：将语句按执行顺序逐条翻译成机器指令并立即执行</li>
</ul>
<p><strong>软硬件关系</strong>：</p>
<ul>
<li>软件和硬件在功能上是等价的（软硬件逻辑功能的等价性）</li>
</ul>
<h3 id="计算机系统的工作原理">计算机系统的工作原理</h3>
<ol type="1">
<li>“存储程序”的工作方式：
<ul>
<li>程序执行前，将指令和数据送入主存</li>
<li>一旦程序启动则无需人员干预</li>
<li>先将指令地址放入PC中；然后取指令——根据PC内容从主存中取指令；接着对指令进行译码，计算下条指令的地址送至PC；取操作数并执行；将结果送回存储器</li>
</ul></li>
<li>高级语言程序 -&gt; 机器程序
<ul>
<li>预处理阶段：处理头文件</li>
<li>编译阶段：编译器将高级语言 -&gt; 汇编语言程序</li>
<li>汇编阶段：汇编语言程序 -&gt;
机器语言程序（<strong>目标文件</strong>，二进制文件）</li>
<li>链接阶段：将多个目标文件与标准库函数合并为一个可执行文件</li>
</ul></li>
<li>程序执行过程
<ul>
<li>用户程序不能直接访问底层硬件，需要操作系统的内核来完成</li>
</ul></li>
<li>指令执行过程(取数指令)
<ul>
<li>取指令：PC -&gt; MAR -&gt; M -&gt; MDR -&gt; IP</li>
<li>分析指令：OP(IR) -&gt; CU</li>
<li>执行指令：Ad(IR) -&gt; MAR -&gt; M -&gt; MDR -&gt;ACC</li>
</ul></li>
</ol>
<h3 id="性能指标">性能指标</h3>
<ol type="1">
<li><strong>字长</strong>：计算机进行一次整数运算所能处理的二进制数据的位数，一般等于内部寄存器的大小</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">机器字长：一次定点整数运算的位数（内部寄存器大小）</span><br><span class="line"></span><br><span class="line">存储字长：一个存储单元所存储的二进制数的长度</span><br><span class="line"></span><br><span class="line">指令字长：是存储字长的整数倍，假如为存储字长的n倍，则取指周期为机器周期n倍 </span><br></pre></td></tr></tbody></table></figure>
<ol start="2" type="1">
<li><p><strong>数据通路带宽</strong>：数据总线一次所能并行传输的位数（数据字长）（这里是指外部数据总线）</p></li>
<li><p><strong>主存容量</strong>：单位——字节，或字数×字长。MAR的位数 =
存储单元个数；MDR位数 = 存储单元字长</p></li>
<li><p>运算速度：</p>
<ul>
<li><strong>吞吐量</strong>：单位时间内处理请求的数量，取决于主存的存取周期</li>
<li><strong>响应时间</strong>：从请求到获得结果的等待时间</li>
</ul></li>
<li><p>CPU<strong>时钟周期</strong>：最小的时间单位，主频的倒数</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指令周期：取出一条指令并执行这条指令的时间</span><br><span class="line"></span><br><span class="line">机器周期：为了便于管理，常把一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个时钟周期组成 。</span><br><span class="line"></span><br><span class="line">时钟周期：每一个基本操作都是由若干CPU最基本的动作组成，完成一个动作至少需要一个时钟周期</span><br></pre></td></tr></tbody></table></figure>
<p><strong>指令周期由若干个机器周期组成，而机器周期又包含若干个时钟周期</strong></p></li>
<li><p><strong>主频</strong>：主频越高，完成一个执行步骤所用的时间越短，执行速度越快（单位：Hz）</p></li>
<li><p><strong>CPI</strong>：执行<strong>一条</strong>指令所需的<strong>时钟周期数</strong>，也可表示平均时钟周期数（<strong>时钟频率不影响CPI</strong>）</p>
<p>CPU<strong>执行时间</strong> = 时钟周期数/主频 （时钟周期数 =
指令数×CPI）</p></li>
<li><p><strong>MIPS</strong>：<strong>每秒</strong>执行多少百万条<strong>指令</strong>；MIPS
= 指令条数/(执行时间*10<sup>6</sup>) =
主频/(CPI*10<sup>6</sup>)</p></li>
<li><p>MFLOPS(10<sup>6</sup>)、GFLOPS、TFLOPS、PFLOPS(10<sup>15</sup>)、EFLOPS、ZFLOPS：每秒执行浮点运算次数</p></li>
</ol>
<blockquote>
<p>注：描述存储容量时（K、M、G、T），通常使用<strong>2的幂次</strong>；描述速率、频率时（k、M、G、T），通常使用<strong>10的幂次</strong></p>
</blockquote>
<h2 id="数据的表示与运算">数据的表示与运算</h2>
<p>定点数的乘除有难度</p>
<h3 id="数制和编码">数制和编码</h3>
<h4 id="十进制转任意进制">十进制转任意进制</h4>
<p>整数部分——除基取余法（逆序），小数部分——乘基取整法（乘积为1.0时结束或满足精度要求）</p>
<h4 id="无符号整数">无符号整数</h4>
<ol type="1">
<li>有符号数和无符号数之间的转换规则：位模式不变，但解释这些位的方式改变</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HK411K7TX/?p=8&amp;share_source=copy_web&amp;vd_source=35780f510c31cf111e4e8d765815365f">【CSAPP-深入理解计算机系统】2-2.整数的表示(下)</a></p>
<ol start="2" type="1">
<li>有符号数转无符号数：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309021930775.png" alt="image-20230902193043778" style="zoom: 50%;"></p>
<ol start="3" type="1">
<li>无符号数转有符号数：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309021931146.png" alt="image-20230902193121962" style="zoom: 50%;"></p>
<ol start="4" type="1">
<li><strong>无符号整数的减法运算</strong>：</li>
</ol>
<ul>
<li>被减数不变</li>
<li>减数<strong>全部位</strong>按位取反，<strong>末位加1</strong>，减法变加法</li>
</ul>
<h4 id="原码">原码</h4>
<ul>
<li>原码转补码：从右往左找到第一个 <strong>1</strong> ，这个
<strong>1</strong> 左边的所有<strong>数值位</strong>按位取反。</li>
<li>最高位是符号位，其余各位表示数的绝对值；</li>
<li>正零和负零，不方便进行加减运算</li>
</ul>
<h4 id="补码">补码</h4>
<ul>
<li><p>补码转原码：从右往左找到第一个 <strong>1</strong> ，这个
<strong>1</strong> 左边的所有<strong>数值位</strong>按位取反。</p></li>
<li><p>补码二进制与有符号数之间的转换（<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ba4y1E7qy?t=205.6">负权重</a>）：</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309021934507.png" alt="image-20230902193414399">
<figcaption aria-hidden="true">image-20230902193414399</figcaption>
</figure>
<ul>
<li>零的补码唯一（0.）</li>
<li>用来表示浮点数的阶码，只能表示整数</li>
<li>符号位参与运算（https://www.bilibili.com/video/BV1ps4y1d73V?t=1274.2&amp;p=11）</li>
<li>减法：[A]<sub>补</sub> - [B]<sub>补</sub> = [A]<sub>补</sub> +
[-B]<sub>补</sub></li>
<li>[B]<sub>补</sub>
&lt;--按位取反，末位加1（包括<strong>符号位</strong>）--&gt;
[-B]<sub>补</sub></li>
<li>模4补码仅需1个符号位</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230510154015393.png" alt="image-20230510154015393">
<figcaption aria-hidden="true">image-20230510154015393</figcaption>
</figure>
<h4 id="反码">反码</h4>
<ul>
<li>零的表示方法不唯一（正负零）</li>
<li><strong>负数的反码</strong>除了符号位外，其他位与原码相反（见下表）</li>
</ul>
<h4 id="移码">移码</h4>
<ul>
<li>[x]<sub>移</sub> = x + 2<sup>n</sup> (偏置值，机器字长为n+1)</li>
<li>零的表示唯一</li>
<li>移码和补码符号位相反</li>
<li>全0表示最小值：-2<sup>n</sup> ; 全1表示最大值：2<sup>n</sup>-1</li>
</ul>
<h4 id="定点整数和定点小数">定点整数和定点小数</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230510163245020.png" alt="image-20230510163245020">
<figcaption aria-hidden="true">image-20230510163245020</figcaption>
</figure>
<h3 id="基本运算部件">基本运算部件</h3>
<h4 id="一位全加器">一位全加器</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042019948.png" alt="image-20230904201918499">
<figcaption aria-hidden="true">image-20230904201918499</figcaption>
</figure>
<ul>
<li>本位和：S<sub>i</sub> = A<sub>i</sub> ⊕ B<sub>i</sub> ⊕
C<sub>i-1</sub> （A、B、C有奇数个1，则S=1）</li>
<li>进位：C<sub>i</sub> = A<sub>i</sub>B<sub>i</sub> +
(A<sub>i</sub>⊕B<sub>i</sub>)C<sub>i-1</sub></li>
</ul>
<h4 id="串行进位的并行加法器">串行进位的并行加法器</h4>
<p>并行输入，进位信息是串行产生的</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042023996.png" alt="image-20230904202311147" style="zoom: 80%;"></p>
<ul>
<li>逐位相加</li>
<li>进位信号逐级形成</li>
<li>位数越多延迟时间越长</li>
</ul>
<h4 id="并行进位加法器">并行进位加法器</h4>
<ul>
<li>进位产生函数（本位两个数相加是否应该进位）：G<sub>i</sub> =
A<sub>i</sub>B<sub>i</sub> (均为1时，G<sub>i</sub>置1)</li>
<li>进位传递函数（根据前面的进位 C<sub>i-1</sub>
以及本位和判断是否应该进位）：P<sub>i</sub> = A<sub>i</sub> ⊕
B<sub>i</sub></li>
<li>进位表达式：C<sub>i</sub> = G<sub>i</sub> +
P<sub>i</sub>C<sub>i-1</sub> (C<sub>i-1</sub>可继续展开)</li>
<li>该电路称为先行进位（超前进位）部件，简称CLA部件</li>
<li>16位加法器可用4组4位先行进位部件组成，提高运算速度，可细分为下面两种：</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042046081.png" alt="image-20230904204610659">
<figcaption aria-hidden="true">image-20230904204610659</figcaption>
</figure>
<h4 id="带标志位的加法器">带标志位的加法器</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310130943382.png" alt="image-20231013094347590">
<figcaption aria-hidden="true">image-20231013094347590</figcaption>
</figure>
<p>注：<strong>Cin</strong>与<strong>sub</strong>相连，因此内容相同</p>
<h4 id="算术逻辑单元alu">算术逻辑单元（ALU）</h4>
<ul>
<li>核心：带标志加法器（通过标志位表示溢出、进位、符号等）</li>
<li>支持<strong>算术运算</strong>、<strong>逻辑运算</strong></li>
<li>低位进位输入位 <strong>Cin = sub</strong>，当sub=1时，表示减法</li>
</ul>
<h3 id="定点数的移位运算">定点数的移位运算（?）</h3>
<ol type="1">
<li><p>算术移位（有符号数）</p>
<ul>
<li><strong>正数</strong>：空位补0</li>
<li><strong>负数</strong>：<strong>算术左移和逻辑左移是一样的</strong>，符号位跟着一起移动（袁书）
<ul>
<li>反码：空位补1</li>
<li>补码：左移补0，右移补1</li>
</ul></li>
</ul></li>
<li><p>逻辑移位（无符号数）</p>
<ul>
<li>空位补0</li>
</ul></li>
<li><p>循环移位</p>
<ul>
<li>带进位标志位CF</li>
<li>不带进位标志位CF：循环左移将最高位进入最低位和标志寄存器</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042112242.png" alt="image-20230904211220007">
<figcaption aria-hidden="true">image-20230904211220007</figcaption>
</figure></li>
</ol>
<blockquote>
<p>左移都相同，区别在右移</p>
<p><strong>有符号数</strong>——算术右移（补码通过最高位判断补0还是1）</p>
<p><strong>无符号数</strong>——逻辑右移</p>
</blockquote>
<h3 id="定点数的加减运算">定点数的加减运算</h3>
<h4 id="加减运算">加减运算</h4>
<ul>
<li>补码加减法：[A+B]<sub>补</sub> = [A]<sub>补</sub>+[B]<sub>补</sub>
； [A-B]<sub>补</sub> = [A]<sub>补</sub>+[-B]<sub>补</sub></li>
<li>符号位参加运算</li>
</ul>
<h4 id="补码加减运算电路">补码加减运算电路</h4>
<ul>
<li>也可实现无符号数的加减运算</li>
<li>减法：减数全部位按位取反，末位加1，减法变加法
<ol type="1">
<li>减法，<strong>sub</strong>位<strong>置1</strong></li>
<li>多路选择器选择<strong>1</strong>通路将减数按位取反（取反后的加1在第4步）</li>
<li>Cin连接着sub，因此也置为<strong>1</strong></li>
<li>减法变加法，将两数相加并加上进位（Cin）</li>
</ol></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310141418262.png" alt="image-20231014141811360">
<figcaption aria-hidden="true">image-20231014141811360</figcaption>
</figure>
<h4 id="标志位">标志位</h4>
<ul>
<li><strong>零标志 ZF</strong>=1 表示结果为 0</li>
<li><strong>溢出标志 OF</strong>=1
表示<strong>有符号</strong>整数运算溢出</li>
<li><strong>符号标志 SF</strong>
表示<strong>有符号</strong>整数运算结果的符号</li>
<li><strong>进/借位标志 CF</strong>
表示<strong>无符号</strong>整数运算的进/借位</li>
</ul>
<h4 id="溢出判别">溢出判别</h4>
<ul>
<li>上溢：正 + 正 = 负</li>
<li>下溢：负 + 负 = 正</li>
</ul>
<ol type="1">
<li><p>一位符号位</p>
<p>需要用到结果的符号</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309042145366.png" alt="image-202309042145366">
<figcaption aria-hidden="true">image-202309042145366</figcaption>
</figure></li>
<li><p>采用一位符号位，根据数据位的进位情况判断</p>
<p>若<strong>符号位的进位</strong>和<strong>最高数位的进位</strong>相同，则没有溢出；反之溢出（硬件实现方式）</p></li>
<li><p><strong>双符号位</strong>（模4补码）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309051907893.png" alt="image-20230905190652811">
<figcaption aria-hidden="true">image-20230905190652811</figcaption>
</figure></li>
</ol>
<p>https://www.bilibili.com/video/BV13Z4y1V734?t=200.9</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309031942505.png" alt="image-20230903194214482">
<figcaption aria-hidden="true">image-20230903194214482</figcaption>
</figure>
<p>符号位的进位和最高数位的进位相同时，则没溢出；否则发生溢出。</p>
<h3 id="定点数的乘除运算">定点数的乘除运算</h3>
<h4 id="乘法运算">乘法运算</h4>
<ol type="1">
<li><p><strong>原码一位乘法</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309051940907.png" alt="image-20230905194034219">
<figcaption aria-hidden="true">image-20230905194034219</figcaption>
</figure>
<ul>
<li><p>双符号位</p></li>
<li><p>逻辑右移</p></li>
<li><p>符号位和数值位分开计算</p></li>
<li><p>符号位进行异或运算</p></li>
<li><p>数值位有n位，就重复n次</p></li>
<li><p>数值位（绝对值）：</p>
<p>用乘数的每一位乘以被乘数，与前面的计算结果进行累加，然后右移一位，重复上述操作</p></li>
</ul></li>
<li><p><strong>补码一位乘法</strong>（Booth算法）</p>
<p>[X]<sub>补</sub> =
x<sub>S</sub>.x<sub>1</sub>x<sub>2</sub>···x<sub>n</sub> ，
[Y]<sub>补</sub> =
y<sub>S</sub>.y<sub>1</sub>y<sub>2</sub>···y<sub>n</sub></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311051646877.png" alt="image-20231105164602645">
<figcaption aria-hidden="true">image-20231105164602645</figcaption>
</figure>
<p>https://www.bilibili.com/video/BV1ps4y1d73V?t=323.1&amp;p=23</p>
<ul>
<li>双符号位</li>
<li><strong>乘数符号位参与运算</strong>（因此比原码一位乘法<strong>多一次</strong>加法操作，移位操作相同）</li>
<li>在乘数末尾增设辅助位 y<sub>n+1</sub></li>
<li>算术右移（根据符号补0或1）</li>
</ul></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309052002128.png" alt="image-20230905200254756" style="zoom:67%;"></p>
<h4 id="除法运算">除法运算</h4>
<ol type="1">
<li><p>原码除法：恢复余数法</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230512114347333.png" alt="image-20230512114347333">
<figcaption aria-hidden="true">image-20230512114347333</figcaption>
</figure>
<ul>
<li><p>符号单独处理（异或）</p></li>
<li><p>先默认商1，若被除数减除数的值（余数）小于0，则将1改为商0</p></li>
<li><p>逻辑左移，低位补0</p></li>
<li><p>左移n次，上商n+1次（n为数值位数）</p></li>
</ul></li>
<li><p>原码除法：不恢复余数法（加减交替）</p>
<ul>
<li>若余数的值小于0，商0，让余数<strong>左移1位，再加上除数</strong></li>
<li>若余数的值大于0，商1</li>
<li>最终的余数的正负性与商相同</li>
</ul></li>
<li><p>补码除法：加减交替法</p>
<ul>
<li>符号位参与运算</li>
<li>双符号位</li>
<li>被除数与除数<strong>同号</strong>，则 被除数-除数
；<strong>异号</strong>，则 被除数+除数</li>
<li>余数和除数同号，商1，余数左移1位，并减去除数；异号，商0，余数左移一位，并加上除数</li>
<li>商的末位恒置为1</li>
</ul>
<blockquote>
<p><strong>同号相除时，够减商1，不够减商0；</strong></p>
<p><strong>异号相除时，够减商0，不够减商1。</strong></p>
</blockquote></li>
</ol>
<h3 id="浮点数的表示与运算">浮点数的表示与运算</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230512142347994.png" alt="image-20230512142347994">
<figcaption aria-hidden="true">image-20230512142347994</figcaption>
</figure>
<ul>
<li><p>浮点数：N = M × R<sup>E</sup>
(M为尾数-定点小数，R为基数，E为阶码-定点整数)</p></li>
<li><p>规格化：使得尾数的最高位是有效值</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309062056019.png" alt="image-20230906205648644">
<figcaption aria-hidden="true">image-20230906205648644</figcaption>
</figure></li>
</ul>
<h4 id="ieee754">IEEE754</h4>
<ul>
<li>阶码的偏置值为：<strong>2<sup>n-1</sup>-1</strong>
(n为阶码位数)</li>
<li>尾数用原码表示，隐藏最高位1，23位尾数实际表示了24位有效数字，表示
1.M</li>
<li>移码：全0、全1用作特殊用途</li>
<li>短浮点数真值：(-1)<sup>S</sup>×1.M×2<sup>E-127</sup></li>
<li>移码计算技巧：先对真值和偏置值进行十进制加法，再将结果转化为<strong>无符号</strong>二进制，就是阶码</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309062137475.png" alt="image-20230906213741063" style="zoom: 50%;"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230513142839273.png" alt="image-20230513142839273" style="zoom: 50%;"></p>
<p>短浮点数阶码为8位，真值正常范围：<strong>-126 ~
127</strong>（阶码全1和全0用作特殊用途）。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230513144145042.png" alt="image-20230513144145042">
<figcaption aria-hidden="true">image-20230513144145042</figcaption>
</figure>
<p>相同长度，相同格式，基数大的浮点数表示范围更大精度更低</p>
<blockquote>
<p>基数可以看作，阶码真值每变化1，尾数小数点需要移动的位数。比如阶码真值增加1，对于基为2的，就需要移动一位，对于基为4的，就需要移动两位。</p>
<p>而同样规格划分的浮点数，能表示的不同状态个数是一定的，表示的范围大，就说明数据的离散程度更大，说明数据的精度更小
https://www.zhihu.com/question/341002108</p>
</blockquote>
<h4 id="浮点数的加减运算">浮点数的加减运算</h4>
<ul>
<li>对阶：小阶向大阶对齐</li>
<li>尾数加减</li>
<li>规格化</li>
<li>舍入：（1）0舍1入发 （2）恒置1法</li>
<li>判溢出：阶码溢出才是真溢出
<ol type="1">
<li>（正/负）上溢：抛出异常</li>
<li>（正/负）下溢：按0处理</li>
</ol>
<blockquote>
<p><strong>1.对阶时，统一保留大的阶数，并不会造成阶码的上溢或者下溢。</strong></p>
<p><strong>2.右规和尾数舍入的过程会造成阶码的增加，因而有可能会引起阶码上溢。</strong></p>
<p><strong>3.左规的过程会造成阶码的减少，因而有可能会引起阶码下溢。</strong></p>
<p><strong>4.尾数溢出时，阶码不一定会溢出，结果也不一定能溢出。</strong></p>
</blockquote></li>
</ul>
<h4 id="c语言中类型转换">C语言中类型转换</h4>
<p>https://blog.csdn.net/albertsh/article/details/92385277</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309071924091.png" alt="image-20230907192424212">
<figcaption aria-hidden="true">image-20230907192424212</figcaption>
</figure>
<h2 id="存储系统">存储系统</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202308312012486.png" alt="image-20230831201200997">
<figcaption aria-hidden="true">image-20230831201200997</figcaption>
</figure>
<h3 id="存储器的基本组成">存储器的基本组成</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309091929565.png" alt="image-20230909192853208">
<figcaption aria-hidden="true">image-20230909192853208</figcaption>
</figure>
<ul>
<li><strong>CD-ROM</strong>是只读型光盘存储器，不属于只读存储器ROM</li>
</ul>
<h3 id="主存储器">主存储器</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515145822708.png" alt="image-20230515145822708">
<figcaption aria-hidden="true">image-20230515145822708</figcaption>
</figure>
<h4 id="dram和sram">DRAM和SRAM</h4>
<h5 id="dram主存">DRAM（主存）</h5>
<ul>
<li><p><strong>破坏性读出</strong>，需重写，读写速度更慢</p></li>
<li><p><strong>地址线复用技术</strong>：地址线减半，<strong>行</strong>选通线+<strong>列</strong>选通线</p></li>
<li><p>栅极电容，电荷只能维持 1~2ms（刷新周期）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515151717058.png" alt="image-20230515151717058" style="zoom: 33%;"></p></li>
<li><p>刷新方式：以“行”为单位</p>
<ol type="1">
<li>集中刷新：存在<strong>死区</strong></li>
<li>分散刷新：加长了系统的存取周期</li>
<li>异步刷新：刷新周期数除以行数，减少了刷新次数</li>
</ol></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515153341208.png" alt="image-20230515153341208">
<figcaption aria-hidden="true">image-20230515153341208</figcaption>
</figure>
<h5 id="sramcache">SRAM（Cache）</h5>
<ul>
<li><strong>非破坏性读出</strong>，无需重写，读写速度更快</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515151640198.png" alt="image-20230515151640198" style="zoom:50%;"></p>
<p>写入0：给BL加低电平，给BLX加高电平</p>
<h5 id="sram和dram的比较">SRAM和DRAM的比较</h5>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515153613748.png" alt="image-20230515153613748">
<figcaption aria-hidden="true">image-20230515153613748</figcaption>
</figure>
<h4 id="存储芯片">存储芯片</h4>
<ul>
<li>存储体：存储单元的集合。相同行、列上的数据会同时读出或写入</li>
<li>地址译码器</li>
<li>I/O控制电路：连通存储元的电路，用以控制被选中单元的读出或写入，放大信息的作用</li>
<li><strong>片选</strong>控制信号：选择存储字所在的芯片</li>
<li>读/写控制信号：读/写操作</li>
</ul>
<h4 id="rom">ROM</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230515174706714.png" alt="image-20230515174706714">
<figcaption aria-hidden="true">image-20230515174706714</figcaption>
</figure>
<h4 id="多模块存储器">多模块存储器</h4>
<p>存储体的<strong>存取周期 = 存取时间(总线传输时间?) +
恢复时间</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230516143405669.png" alt="image-20230516143405669">
<figcaption aria-hidden="true">image-20230516143405669</figcaption>
</figure>
<h5 id="单体多字存储器">单体多字存储器</h5>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309092110532.png" alt="image-20230909211003479">
<figcaption aria-hidden="true">image-20230909211003479</figcaption>
</figure>
<ul>
<li>只有一个存储器</li>
<li>一次并行读出m个字</li>
<li>地址必须顺序排列并处于同一存储单元</li>
<li>若存储内容不在同一行，则会读取多余单元，不灵活</li>
</ul>
<h5 id="多体并行存储器">多体并行存储器</h5>
<ol type="1">
<li><p>高位交叉编址</p>
<ul>
<li>高位地址表示体号，低位地址为体内地址</li>
<li>将低位的体内地址送到由高位地址确定的模块内进行译码</li>
<li>总是现在一个模块内访问（连续主存块）</li>
<li>不能并行访问</li>
<li>不满足程序的局部性</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101026521.png" alt="image-20230910102557348"></p></li>
<li><p><strong>低位交叉编址</strong></p>
<ul>
<li><p><strong>低位地址为体号</strong>，高位地址为体内地址</p></li>
<li><p>将高的体内地址送到由低位地址确定的模块内进行译码</p></li>
<li><p>模块号 = 单元地址 % m （m为模块数量） 交叉编址</p></li>
<li><p>程序连续存放在相邻的模块中（交叉存储器）</p></li>
<li><p><strong>存取周期</strong>为
T（包括存取时间和恢复时间），<strong>存取时间</strong>为 r
，模块数m&gt;=T/r</p></li>
<li><p>宏观上忽视了恢复时间</p></li>
<li><p>满足程序的局部性</p></li>
<li><p><strong>存取周期（数据准备时间）</strong>结束后才能开始<strong>传输数据</strong></p>
<figure>
<img src="https://pic4.zhimg.com/v2-1c6298c14a112569588275d006cade5b_r.jpg" alt="imgcycle">
<figcaption aria-hidden="true">imgcycle</figcaption>
</figure></li>
</ul></li>
</ol>
<ul>
<li>可<strong>轮流启动</strong>，也可以<strong>同时启动</strong>（根据题干判断）</li>
</ul>
<blockquote>
<p>局部性指的是你刚刚访问了它，那么大概率很快要继续访问它。高位是在一个存储模块里连续存放，这就造成你要一直访问同一个存储模块，最坏的话存一次就要等完整的一个存取周期才能继续访问下一次，这显然太慢了。而低位的话就算一直重复访问一段连续的地址，因为是交叉存放的，显然比高位等待的时间要少的多。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101029397.png" alt="image-20230910102933246" style="zoom: 50%;"></p>
<blockquote>
<p><strong>三通道内存</strong>将内存总线位宽扩大到了64-bit×3=192-bit</p>
</blockquote>
<h3 id="主存与cpu的连接">主存与CPU的连接</h3>
<h4 id="连接原理">连接原理</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101050081.png" alt="image-20230910105000908" style="zoom:80%;"></p>
<ul>
<li>数据总线</li>
<li>地址总线</li>
<li>控制总线：读/写</li>
</ul>
<h4 id="主存容量扩展">主存容量扩展</h4>
<ol type="1">
<li><p>位扩展（相当于芯片并联）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101117519.png" alt="image-20230910111733836">
<figcaption aria-hidden="true">image-20230910111733836</figcaption>
</figure>
<ul>
<li>将多个存储芯片的地址端、片选端和读/写端并联</li>
<li>数据总线(CPU)与不同芯片的数据端相连（相当于<strong>增加数据位数</strong>）</li>
<li>地址总线位数不变</li>
<li>片选线<strong>一次选中所有芯片</strong></li>
<li>例：用8片 8K×1位的RAM芯片组成 8K×8位的存储器</li>
</ul></li>
<li><p>字扩展（相当于芯片串联）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309101118871.png" alt="image-20230910111842698">
<figcaption aria-hidden="true">image-20230910111842698</figcaption>
</figure>
<ul>
<li>将芯片的数据线、地址线、控制线并联</li>
<li>数据总线(CPU)位数不变</li>
<li>地址总线与不同芯片相连（相当于<strong>增加地址总数</strong>）</li>
<li>译码片选法（用译码器<strong>一次选择一个芯片</strong>）</li>
<li>例：用4片 16K×8位的RAM芯片组成 64K×8位的存储器</li>
</ul></li>
<li><p>字位同时扩展</p>
<ul>
<li>既增加字，又增加位</li>
<li>例：用8片 16K×4位的RAM芯片组成
64K×8位的存储器，即每两片构成一组，共四组 16K×8位的存储器 &gt;
地址分配和片选： &gt; &gt; 1. 线选法 &gt; -
一次只允许一位有效（每次选一个芯片，0/1表示是否有效） &gt; -
地址资源浪费 &gt; 2. 译码片选法 &gt; - 用几位二进制位表示某一个芯片 &gt;
- 3位能选择8个芯片</li>
</ul></li>
</ol>
<h3 id="外部存储器">外部存储器</h3>
<h4 id="磁盘存储器">磁盘存储器</h4>
<ul>
<li>不能同一时刻又读又写</li>
<li><strong>格式化</strong>后的容量比<strong>非格式化</strong>容量要小</li>
<li><strong>平均存取时间</strong> = 平均寻道时间(题干) +
查询扇区时间(半圈) + 传输时间(转一个扇区的时间)+ (延迟)</li>
<li><strong>磁盘阵列</strong>
<ul>
<li>RAID0：条带化</li>
</ul>
<blockquote>
<p>就是将一块<strong>连续</strong>的数据分成很多小部分并把他们分别存储到<strong>不同</strong>的磁盘上去。</p>
<p>这就能使多个进程同时访问数据的多个不同部分而不会造成<strong>磁盘冲突</strong>。</p>
<p>在对这种数据进行<strong>顺序</strong>访问的时候可以获得最大程度上的
I/O 并行能力，从而获得非常好的性能</p>
</blockquote>
<ul>
<li>RAID1：镜像（备份）</li>
<li>RAID2：海明码</li>
<li>RAID3/4：位/块交叉奇偶校验</li>
<li>RAID5：无独立校验的奇偶校验</li>
</ul></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517195840794.png" alt="image-20230517195840794">
<figcaption aria-hidden="true">image-20230517195840794</figcaption>
</figure>
<h4 id="ssd">SSD</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230516154612913.png" alt="image-20230516154612913">
<figcaption aria-hidden="true">image-20230516154612913</figcaption>
</figure>
<ul>
<li>U盘采用Flash技术，属于ROM</li>
</ul>
<h3 id="cache">Cache</h3>
<h4 id="局部性原理">局部性原理</h4>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
<p>利用局部性原理，将正在使用的部分数据存放在Cache中，提高程序运行速度</p>
<h4 id="工作原理">工作原理</h4>
<ul>
<li>Cache由<strong>SRAM</strong>构成</li>
<li>Cache与主存都被划分为相等的块</li>
<li>若访存地址<strong>命中</strong>，则直接将该地址转换成Cache地址，对Cache进行读操作（不涉及主存）</li>
<li>若访存地址<strong>未命中</strong>，则需要<strong>访问主存</strong>，<strong>并</strong>将该主存<strong>块</strong>中的数据<strong>调入Cache</strong>中</li>
<li>若Cache已满，则需要根据替换算法交换主存块和Cache块</li>
<li><strong>命中率</strong> = 总命中次数/（总命中次数+访存次数）</li>
</ul>
<blockquote>
<p><strong>块：</strong>
块是一个固定大小的信息包，是cache和主存之间交换数据的最小单位</p>
<p><strong>行：</strong>
行是cache的一个容器，存储块以及其他信息（例如有效位和标记位）</p>
</blockquote>
<h4 id="映射方式">映射方式</h4>
<p>==学的不好，错题较多==</p>
<ul>
<li>一个<strong>有效位</strong>（在Cache行中）</li>
<li>以下提到的主存地址都是<strong>物理地址</strong>（虚拟地址-&gt;TLB/页表-&gt;物理地址，然后用物理地址访存）</li>
<li>当未命中时，访存并将该数据存入Cache，同时将数据送CPU</li>
<li><strong>Cache行的位数</strong> = 有效位 + 标记 + <strong>数据位
</strong>（不需要块内地址，直接通过主存地址获取块内地址，若使用回写法，则需要加一个脏位）</li>
<li>上式中的<strong>标记 = 主存地址位数-Cache行号-块内地址</strong></li>
</ul>
<ol type="1">
<li>直接映射
<ul>
<li>空间利用率低</li>
<li>冲突概率高</li>
<li><strong>Cache行号</strong> = 主存<strong>块号</strong> % Cache总行数
（主存地址先分块再取模）</li>
<li>内存<strong>地址结构</strong> ：标记 + Cache行号 + 块内地址</li>
<li>CPU根据访存地址(内存地址)找到对应的Cache行，分别比较<strong>有效位</strong>和<strong>标志位</strong></li>
</ul></li>
<li><strong>全相联映射</strong>
<ul>
<li>空间利用率高</li>
<li>命中率高</li>
<li>主存的每一块可以装入Cache的<strong>任何位置</strong></li>
<li>需要与<strong>所有Cache行</strong>的标记进行比较，缺点是比较速度慢</li>
<li>内存<strong>地址结构</strong>：标记(主存块号) + 块内地址</li>
</ul></li>
<li>组相联映射
<ul>
<li>每个主存块可以装入固定组中的任意一行（将Cache分为若干个大小相同的组）</li>
<li>组间采用直接映射，组内采用全相联映射</li>
<li>若<strong>每组</strong>有<strong>r</strong>个Cache行，则称之为<strong>r路</strong>组相联</li>
<li><strong>Cache组号</strong> = 主存块号 %
Cache<strong>组数</strong>（Q=行数/r，先计算Cache组数，再继续计算）</li>
<li>内存<strong>地址结构</strong>：标记 + 组号 + 块内地址</li>
<li><strong>每组多少行</strong>就有多少个<strong>比较器</strong>，比较<strong>标记</strong>（王道计组P121-T23）</li>
</ul></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517155200705.png" alt="image-20230517155200705">
<figcaption aria-hidden="true">image-20230517155200705</figcaption>
</figure>
<h4 id="替换算法详见操作系统">替换算法（详见操作系统）</h4>
<ul>
<li><strong>直接映射不考虑替换算法</strong>，直接替换主存块中的内容</li>
<li>近期最少使用（LRU）是看未被访问的时间</li>
<li>最不经常使用（LFU）是看频率</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517162832329.png" alt="image-20230517162832329">
<figcaption aria-hidden="true">image-20230517162832329</figcaption>
</figure>
<h4 id="写策略">写策略</h4>
<ol type="1">
<li>写命中（被修改的单元在Cache中）
<ul>
<li><strong>全写法</strong>(直写法):把数据<strong>同时写入Cache和主存</strong>;使用<strong>写缓存</strong>(Cache和主存之间的FIFO队列）</li>
<li><strong>回写法</strong>：只写入Cache，当该块被换出时才写回主存；设置<strong>脏位</strong>，0不写回主存，1写回主存</li>
</ul></li>
<li>写不命中（要修改的单元不在Cache中）
<ul>
<li><strong>写分配法</strong>：加载主存块到Cache中，然后更新该Cache块</li>
<li><strong>非写分配法</strong>：只写入主存，不进行调块</li>
</ul></li>
</ol>
<blockquote>
<p>非写分配法通常和全写法合用，写分配法和回写法合用</p>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230517164334152.png" alt="image-20230517164334152">
<figcaption aria-hidden="true">image-20230517164334152</figcaption>
</figure>
<h3 id="虚拟存储器">虚拟存储器</h3>
<ul>
<li><strong>主存+辅存</strong></li>
<li>替换算法（类比Cache和主存）</li>
<li>全相联映射</li>
<li>回写法</li>
<li>每个进程都可以使用同样的虚拟内存地址而不冲突</li>
</ul>
<h4 id="页式虚拟存储器">页式虚拟存储器</h4>
<ul>
<li><strong>虚拟地址</strong>被分为：<strong>虚页号</strong> +
页内地址</li>
<li>虚拟空间和主存空间分划分为大小相同的页</li>
<li>找到物理地址后：查看该内存块是否在Cache中，步骤见Cache一节</li>
</ul>
<ol type="1">
<li><p><strong>页表</strong>（慢表）</p>
<ul>
<li>虚页号与实页号的对照表（存放在内存中）</li>
<li>根据<strong>虚拟地址的高位</strong>(虚拟页号)找到对应的页表项（虚拟页号相当于序号？）</li>
<li>页表项包含：<strong>有效位</strong>(0/1表示是否调入主存)、<strong>脏位</strong>(修改位)、<strong>引用位</strong>(替换策略)、<strong>物理页号</strong></li>
<li>页表项中虚页号可省略</li>
</ul>
<blockquote>
<p>通过虚拟页号<strong>判断程序段是否在同一页</strong></p>
</blockquote></li>
<li><p><strong>快表（TLB）</strong></p>
<ul>
<li>由高速缓冲器（Cache）组成（相联存储器）</li>
<li>首先查找快表，若未命中，则查找页表</li>
<li>TLB项 = 标记字段(全相联/组相联映射) + 实页号</li>
</ul>
<blockquote>
<p><strong>标记字段在全相联映射下就是虚页号</strong></p>
</blockquote></li>
</ol>
<h4 id="段式虚拟存储器">段式虚拟存储器</h4>
<ul>
<li><p><strong>虚拟地址</strong> = 虚段号 + 段内地址</p></li>
<li><p>各个段的长度因程序而异</p></li>
<li><p>段表项：段号(可省略) + 段首址 + 段长 + 装入位(同有效位)</p></li>
</ul>
<h4 id="段页式虚拟存储器">段页式虚拟存储器</h4>
<ul>
<li>先分段后分页</li>
<li>段长是页长的整数倍</li>
</ul>
<h2 id="指令系统">指令系统</h2>
<h3 id="指令系统-1">指令系统</h3>
<h4 id="指令的基本格式">指令的基本格式</h4>
<ul>
<li>指令系统是指令集体系结构（ISA）的核心</li>
<li>基本格式：操作码 + 地址码</li>
<li>分为 定长指令字结构、变长指令字结构</li>
</ul>
<ol type="1">
<li><strong>零地址指令</strong>
<ul>
<li>不需要操作数的指令：空操作，关中断</li>
<li>操作数再堆栈中</li>
</ul></li>
<li><strong>一地址指令</strong>（OP + A）
<ul>
<li>只有目的操作数的<strong>单操作数指令</strong>：3次访存——取指-&gt;读A-&gt;写A(写回原地址，A是指令地址)</li>
<li>隐含目的地址的<strong>双操作数指令</strong>：隐含的第二个操作数由ACC提供，结果也存入ACC中（2次访存，ACC不属于主存）</li>
</ul></li>
<li><strong>二地址指令</strong>（OP + A<sub>1</sub> + A<sub>2</sub>）
<ul>
<li>4次访存：取指-&gt;读A<sub>1</sub>-&gt;读A<sub>2</sub>-&gt;写A<sub>1</sub>
（A<sub>1</sub>为目的地址）</li>
</ul></li>
<li><strong>三地址指令</strong>（OP + A<sub>1</sub> + A<sub>2</sub> +
A<sub>3</sub>）
<ul>
<li>4次访存：取指-&gt;读A<sub>1</sub>-&gt;读A<sub>2</sub>-&gt;写A<sub>3</sub>
（A<sub>3</sub>存放运算结果）</li>
</ul></li>
<li><strong>四地址指令</strong>（OP + A<sub>1</sub> + A<sub>2</sub> +
A<sub>3</sub> + A<sub>4</sub>）
<ul>
<li>4次访存：同上，A<sub>4</sub>存放下一条指令的地址（PC会修改为A<sub>4</sub>）</li>
</ul></li>
</ol>
<h4 id="操作码是否可变">操作码是否可变</h4>
<ol type="1">
<li>定长操作码：简化硬件设计，提高指令译码和识别速度</li>
<li>扩展操作码（变长操作码）：全1一般用于<strong>扩展操作码</strong></li>
</ol>
<h4 id="指令的操作类型">指令的操作类型</h4>
<ol type="1">
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位逻辑</li>
<li>转移操作</li>
<li>输入输出操作</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230519131931196.png" alt="image-20230519131931196">
<figcaption aria-hidden="true">image-20230519131931196</figcaption>
</figure>
<h3 id="寻址">寻址</h3>
<h4 id="寻址方式">寻址方式</h4>
<ol type="1">
<li><strong>指令寻址</strong>
<ul>
<li>顺序寻址（PC+1）</li>
<li>跳跃寻址</li>
</ul></li>
<li><strong>数据寻址</strong>（重点）
<ul>
<li>如何在指令中表示操作数地址，以及如何计算出操作数地址</li>
<li>格式：<strong>操作码 + 寻址特征(4位) + 形式地址A</strong></li>
</ul></li>
</ol>
<h4 id="数据寻址方式">数据寻址方式</h4>
<ol type="1">
<li>隐含寻址
<ul>
<li>累加器(ACC)对于单地址指令格式来说是隐含寻址</li>
<li>有利于缩短指令长度</li>
</ul></li>
<li>立即(数)寻址
<ul>
<li>地址字段不是地址而是<strong>操作数本身</strong></li>
<li>寻址特征为'#'</li>
<li>不需要访问主存，指令执行时间短</li>
<li>立即数的范围被A的位数限制</li>
</ul></li>
<li>直接寻址
<ul>
<li>形式地址A就是操作数的真实地址 EA</li>
<li><strong>执行</strong>阶段只访存一次</li>
<li>A的位数限制了操作数的寻址范围</li>
</ul></li>
<li>间接寻址
<ul>
<li>形式地址A存放的是一个主存地址A1，该主存单元存放的是真实地址
(A-&gt;A1-&gt;EA)</li>
<li>扩大了寻址范围</li>
<li>执行阶段需要多次访存，访问速度慢</li>
<li>扩大寻址范围一般是指<strong>寄存器间接寻址</strong></li>
</ul></li>
<li>寄存器寻址
<ul>
<li>形式地址A给出操作数所在寄存器的编号</li>
<li>执行阶段不访存（取指阶段访存一次）</li>
<li>执行速度快，但是寄存器数量有限</li>
</ul></li>
<li>寄存器间接寻址
<ul>
<li>寄存器R<sub>i</sub>给出的不是操作数，而是操作数所在主存的地址</li>
<li>R<sub>i</sub> -&gt; EA (形式地址A就是R<sub>i</sub>)</li>
<li>执行阶段需要访存</li>
</ul></li>
<li><strong>相对寻址</strong>
<ul>
<li>EA = (PC) + A （这里的PC是<strong>下一条指令的地址</strong>）</li>
<li>广泛应用于<strong>转移指令</strong></li>
</ul></li>
<li>基址寻址
<ul>
<li>EA = (BR) + A （BR为基址寄存器，A相当于偏移量）</li>
<li><strong>面向操作系统</strong></li>
</ul></li>
<li>变址寻址
<ul>
<li>EA = (IX) + A （IX是变址寄存器）</li>
<li><strong>面向用户</strong></li>
<li>A不变（基地址），IX为偏移量</li>
<li>适合用于循环程序</li>
</ul></li>
<li>堆栈寻址
<ul>
<li>后进先出（LIFO）</li>
<li>地址由堆栈指针<code>SP</code>(寄存器)给出</li>
<li>硬堆栈：使用寄存器作为堆栈</li>
<li>软堆栈：使用主存中的区域作为堆栈</li>
<li>一般用于无操作数指令（操作数地址由SP隐含给出）</li>
</ul></li>
</ol>
<h3 id="程序的机器级表示">程序的机器级表示</h3>
<h4 id="过程函数调用">过程(函数)调用</h4>
<ul>
<li>一个栈由若干个栈帧构成（栈底为高地址）</li>
<li>EBP指向当前栈帧底，ESP指向当前栈帧顶</li>
<li>ESP+4 对应pop， ESP-4 对应push</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132025799.png" alt="image-20230913202538974">
<figcaption aria-hidden="true">image-20230913202538974</figcaption>
</figure>
<ul>
<li><p><code>add</code>函数运行结束，需退回<code>caller</code>函数</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132028593.png" alt="image-20230913202839868">
<figcaption aria-hidden="true">image-20230913202839868</figcaption>
</figure></li>
<li><p>在<code>caller</code>函数中<strong>调用</strong><code>add</code>函数的过程：</p>
<ol type="1">
<li>在执行 <strong>call</strong> 指令时，<strong>IP</strong>
指向下一条指令地址</li>
<li><strong>call</strong>指令会将当前<strong>IP</strong>的值(下一条指令的地址)保存到栈中</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132039450.png" alt="image-20230913203934093">
<figcaption aria-hidden="true">image-20230913203934093</figcaption>
</figure>
<p><strong>保存</strong>上一层函数的<strong>栈帧基址</strong>，然后将<code>esp</code>中的地址赋给<code>ebp</code>，也就是将<code>ebp</code>移到<code>esp</code></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132100215.png" alt="image-20230913210002367">
<figcaption aria-hidden="true">image-20230913210002367</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310101653167.png" alt="image-20231010165241241">
<figcaption aria-hidden="true">image-20231010165241241</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132102941.png" alt="image-20230913210227154">
<figcaption aria-hidden="true">image-20230913210227154</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309132103209.png" alt="image-20230913210336520">
<figcaption aria-hidden="true">image-20230913210336520</figcaption>
</figure></li>
<li><p>含参数的函数调用</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309141932790.png" alt="image-20230914193208069">
<figcaption aria-hidden="true">image-20230914193208069</figcaption>
</figure></li>
<li><p>栈帧结构（栈顶在下，栈底在上）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230522192316086.png" alt="image-20230522192316086">
<figcaption aria-hidden="true">image-20230522192316086</figcaption>
</figure></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309142003069.png" alt="image-20230914200326048">
<figcaption aria-hidden="true">image-20230914200326048</figcaption>
</figure>
<h4 id="选择语句">选择语句</h4>
<ul>
<li>通过标志位进行条件跳转</li>
</ul>
<h4 id="循环语句">循环语句</h4>
<ul>
<li>使用条件跳转指令判断循环条件的结束</li>
</ul>
<h3 id="cisc和risc">CISC和RISC</h3>
<h4 id="cisc">CISC</h4>
<ul>
<li>复杂指令系统计算机</li>
<li>指令系统复杂，指令数目多</li>
<li>指令长度不固定</li>
<li>访存指令不受限制</li>
<li>控制器大多使用<strong>微程序控制</strong></li>
<li>难以优化编译</li>
</ul>
<h4 id="risc">RISC</h4>
<ul>
<li>简单指令组合成复杂指令</li>
<li>功耗低，适用于手机、平板</li>
<li><strong>指令长度固定</strong></li>
<li>只有<code>Load</code>(取数)、<code>Store</code>(存数)指令访存</li>
<li>通用寄存器的数目较多</li>
<li>采用<strong>流水线</strong>技术</li>
<li><strong>硬布线控制</strong>为主</li>
<li>重视编译优化</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309142032016.png" alt="image-20230914203240531">
<figcaption aria-hidden="true">image-20230914203240531</figcaption>
</figure>
<h2 id="中央处理器">中央处理器</h2>
<h3 id="cpu的功能和基本结构">CPU的功能和基本结构</h3>
<h4 id="功能">功能</h4>
<ul>
<li>指令控制：程序的顺序控制</li>
<li>操作控制：控制操作信号</li>
<li>时间控制</li>
<li>数据加工：<strong>算术运算</strong>和<strong>逻辑运算</strong></li>
<li>中断处理</li>
</ul>
<h4 id="基本结构">基本结构</h4>
<ol type="1">
<li><strong>运算器</strong>（对数据进行加工处理）
<ul>
<li>算术逻辑单元（ALU）：算术和逻辑运算</li>
<li>暂存寄存器：暂存从主存读取的数据</li>
<li>累加寄存器（ACC）：暂存ALU的运算结果，可作为加法运算的输入端</li>
<li>通用寄存器：AX、BX、CX、DX、SP等</li>
<li>程序状态字寄存器（PSW）：OF、CF、SF、ZF</li>
<li>移位器：进行移位操作</li>
<li>计数器：控制乘除运算的操作步数</li>
</ul></li>
<li><strong>控制器</strong>（基本功能是执行指令）
<ul>
<li>程序计数器（PC）：CPU根据PC去主存取指令</li>
<li>指令寄存器（IR）：存放正在执行的那条指令</li>
<li>指令译码器：仅对操作码进行译码，向控制器提供操作信号</li>
<li>存储器地址寄存器（MAR）：用于存放要访问的主存单元的地址</li>
<li>存储器数据寄存器（MDR）：用于存放读出/写入的信息</li>
<li>时序系统：产生时序信号</li>
<li>微操作信号发生器</li>
</ul>
<blockquote>
<p>IR、MAR、MDR对用户透明</p>
</blockquote></li>
</ol>
<h3 id="指令执行过程">指令执行过程</h3>
<h4 id="指令周期">指令周期</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309161608474.png" alt="image-20230916160824308">
<figcaption aria-hidden="true">image-20230916160824308</figcaption>
</figure>
<ul>
<li>指令周期：取出指令并执行指令的时间
(取指操作<strong>自动</strong>进行)</li>
<li><strong>指令周期</strong>由若干<strong>机器周期</strong>(CPU周期)构成，机器周期由若干<strong>时钟周期</strong>构成(节拍/T周期[主频的倒数])</li>
<li>定长的机器周期包含的时钟周期相等，不定长则不等</li>
<li>无条件转移指令不需访存</li>
<li>4个标志触发器：FE(取指)、IND(间址)、EX(执行)、INT(中断)；
（‘1’表示有效）</li>
<li>CPU在<strong>每条指令结束前</strong>，发送<strong>中断查询信号</strong></li>
<li>完整的指令周期包括：<strong>取指周期、间址周期(可无)、执行周期、中断周期(可无)</strong>，如下图所示</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230523150736610.png" alt="image-20230523150736610" style="zoom: 67%;"></p>
<h4 id="指令周期的数据流">指令周期的数据流</h4>
<ol type="1">
<li><p>取指周期</p>
<ul>
<li>PC-&gt;MAR-&gt;地址总线-&gt;主存 （在主存中找到指令）</li>
<li>CU(读命令)-&gt;控制总线-&gt;主存 (CU发出读操作)</li>
<li>主存-&gt;数据总线-&gt;MDR-&gt;IR （将指令存放在IR中）</li>
<li>CU控制PC+1</li>
</ul>
<blockquote>
<p><strong>取值周期为机器周期的2倍；若指令字长等于存储字长，则取值周期等于机器周期</strong></p>
</blockquote></li>
<li><p>间址周期</p>
<p>此时指令已保存在IR中(或MDR中)</p>
<ul>
<li>Ad(IR)/MDR-&gt;MAR-&gt;地址总线-&gt;主存
（通过指令中的地址码部分在主存中找到EA）</li>
<li>CU(读命令)-&gt;控制总线-&gt;主存 （CU发出读命令，读取EA）</li>
<li>主存-&gt;数据总线-&gt;MDR （将EA存入MDR中）</li>
</ul></li>
<li><p>执行周期</p>
<ul>
<li><strong>取操作数</strong></li>
<li>根据IR中的操作码部分通过ALU进行运算操作</li>
</ul></li>
<li><p>中断周期</p>
<p>这里的中断是指暂停当前任务去执行其他任务</p>
<ul>
<li>CU控制 SP-1 (压栈)，SP-&gt;MAR-&gt;地址总线-&gt;主存
（找到SP指向的主存）</li>
<li>CU(写命令)-&gt;控制总线-&gt;主存
（CU发出写命令，对该主存位置进行写操作）</li>
<li>PC-&gt;MDR-&gt;数据总线-&gt;主存 （将PC值写入栈中）</li>
<li>CU(中断服务程序的入口地址)-&gt;PC （之后就开始执行中断程序了）</li>
</ul></li>
</ol>
<h4 id="指令执行方案">指令执行方案</h4>
<ol type="1">
<li><p>单指令周期</p>
<ul>
<li>串行执行</li>
<li>指令周期取决于执行时间最长的指令</li>
<li><strong>指令执行过程中控制信号不变</strong></li>
<li><strong>每条指令的CPI为1</strong></li>
<li>若采用单总线数据通路，传操作数到ALU时，分成两步来传送，那就需要两个时钟周期。加完还得写回寄存器里，又是一个时钟周期。所以加法指令<strong>不是单总线一个时钟周期内能完成的</strong></li>
</ul>
<blockquote>
<p>https://www.zhihu.com/question/65712275</p>
</blockquote></li>
<li><p>多指令周期</p>
<ul>
<li>串行执行</li>
<li>不同类型的指令周期不同</li>
<li>需要复杂的硬件设计</li>
</ul></li>
<li><p>流水线方案</p>
<ul>
<li>并行执行</li>
<li>各指令处在不同的执行步骤中</li>
</ul></li>
</ol>
<h3 id="数据通路的功能和结构">数据通路的功能和结构</h3>
<h4 id="功能-1">功能</h4>
<ul>
<li><strong>由控制器控制</strong>，不包括控制部件</li>
<li>实现<strong>CPU内部</strong>的运算器与寄存器以及寄存器之间的数据交换</li>
</ul>
<h4 id="基本结构-1">基本结构</h4>
<ol type="1">
<li>CPU内部单总线方式
<ul>
<li>存在较多冲突</li>
<li>运算时需要暂存器（ALU需要两个操作数）</li>
<li>一个时钟内只允许传一个数据</li>
</ul></li>
<li>CPU内部多总线方式
<ul>
<li>执行效率提高</li>
</ul></li>
<li>专用数据通路方式
<ul>
<li>性能高</li>
<li>硬件量大</li>
<li>避免使用共享的总线</li>
</ul></li>
</ol>
<h4 id="数据传送">数据传送</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309161808077.png" alt="image-20230916180854972" style="zoom:80%;"></p>
<ol type="1">
<li>寄存器之间（以PC寄存器为例）
<ul>
<li>(PC)-&gt;Bus-&gt;MAR</li>
</ul></li>
<li>主存与CPU之间（以取指令为例）
<ul>
<li>(PC)-&gt;Bus-&gt;MAR</li>
<li>1-&gt;R （CU发出读命令）</li>
<li>MEM(MAR)-&gt;MDR （操作数从存储器-&gt;MDR）</li>
<li>(MDR)-&gt;Bus-&gt;IR （MDRout和IRin有效，现行指令-&gt;IR）</li>
</ul></li>
<li>执行算术或逻辑运算
<ul>
<li>ALU的两个输入端同时有效，所以需要使用暂存器Y（暂存器与ALU之间有专用数据通路），另一个操作数经内部总线直接送入ALU中</li>
<li>计算结果暂存在Z中</li>
</ul></li>
</ol>
<h3 id="控制器">控制器</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230524170957225.png" alt="image-20230524170957225">
<figcaption aria-hidden="true">image-20230524170957225</figcaption>
</figure>
<h4 id="硬布线控制器">硬布线控制器</h4>
<ul>
<li>一般用于<strong>RISC</strong></li>
<li>由复杂的组合逻辑门电路和一些触发器构成，也称组合逻辑控制器</li>
<li><strong>存储字长等于指令字长时，取指周期 = 机器周期</strong></li>
</ul>
<h5 id="输入信号来源">输入信号来源</h5>
<ol type="1">
<li>指令译码器译码</li>
<li>机器周期信号（四个触发器的信号）和节拍信号</li>
<li>执行单元的反馈信息（标志）</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309172037124.png" alt="image-20230917203712242">
<figcaption aria-hidden="true">image-20230917203712242</figcaption>
</figure>
<h5 id="控制方式">控制方式</h5>
<ol type="1">
<li>同步控制方式——系统有一个<strong>统一的时钟</strong>，采用有相同时间间隔和相同数目的节拍作为机器周期</li>
<li>异步控制方式——不存在基准时标信号</li>
<li>联合控制方式——介于同步和异步之间</li>
</ol>
<h5 id="设计步骤">设计步骤</h5>
<ol type="1">
<li>分析每个阶段的微操作序列（取指、间址、执行、中断）</li>
<li>选择CPU控制方式（机器周期是否定长，一个机器周期几个节拍）</li>
<li>安排微操作时序（如何在若干节拍内完成整个机器周期的所有微操作）</li>
<li>电路设计（用电路实现逻辑表达式）</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230524173856180.png" alt="image-20230524173856180">
<figcaption aria-hidden="true">image-20230524173856180</figcaption>
</figure>
<h4 id="微程序控制器">微程序控制器</h4>
<ul>
<li>一般用于CISC</li>
<li>机器<strong>指令 = 微程序</strong> &gt; 微指令 &gt;=
微操作（微命令是微操作的控制信号，微操作是微命令的执行）</li>
<li><strong>微指令格式</strong>：<strong>操作控制字段</strong>(用于产生控制信号)
+ <strong>顺序控制字段</strong>(下一条要执行的微指令地址)</li>
<li>可共享<strong>微程序段</strong>（例如取值周期对应的微程序段）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230525103043746.png" alt="image-20230525103043746">
<figcaption aria-hidden="true">image-20230525103043746</figcaption>
</figure>
<h5 id="微程序控制器的组成">微程序控制器的组成</h5>
<ul>
<li><strong>控制存储器</strong>(CM或<strong>CS</strong>)：存放各指令对应的微程序，<strong>按微指令的地址访问</strong></li>
<li>微指令寄存器(CMDR)：<strong>存放</strong>从CM中取出的<strong>微指令</strong></li>
<li>微地址寄存器(CMAR)：接收微地址形成部件送来的微地址</li>
<li>微地址形成部件：用于产生初始和后序的微地址（不同机器指令对应不同的微指令）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309181922406.png" alt="image-20230918192155244">
<figcaption aria-hidden="true">image-20230918192155244</figcaption>
</figure>
<h5 id="工作原理-1">工作原理</h5>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230525114730902.png" alt="image-20230525114730902">
<figcaption aria-hidden="true">image-20230525114730902</figcaption>
</figure>
<h5 id="编码方式">编码方式</h5>
<p>基本格式：操作控制 + 下地址</p>
<p>下面是微指令<strong>控制字段</strong>的编码方式</p>
<ol type="1">
<li>直接编码
<ul>
<li>操作控制字段每一位0/1对应一个微命令</li>
<li>缺点：微指令过长</li>
</ul></li>
<li><strong>字段直接编码</strong>
<ul>
<li><strong>互斥</strong>性微命令在<strong>同一字段 </strong>
（互斥性：不可并行执行）</li>
<li><strong>相容</strong>性微命令在<strong>不同字段 </strong>
（相容性：可并行执行）</li>
<li>每个字段独立编码</li>
<li><strong>每种编码对应一个微命令</strong></li>
<li>每一段需要<strong>留出一个状态</strong>表示是否发出微命令</li>
</ul></li>
<li>字段间接编码
<ul>
<li>需要别的微命令解释（两层译码?）</li>
<li>隐式编码</li>
<li>削弱了并行控制能力，缩短了微指令字长</li>
</ul></li>
</ol>
<h5 id="地址形成方式">地址形成方式</h5>
<ul>
<li>直接由下地址指出（又称断定方式）</li>
<li>根据机器指令操作码形成：微指令地址由操作码经微地址形成部件形成</li>
<li>增量计数器法：(CMAR) + 1 -&gt; CMAR （可类比PC）</li>
<li>根据标志进行分支转移</li>
<li>通过测试网络形成</li>
<li>由硬件产生</li>
</ul>
<h5 id="微指令的格式">微指令的格式</h5>
<ol type="1">
<li>水平型微指令
<ul>
<li>定义并执行几种<strong>并行</strong>的基本操作</li>
<li>优点：微程序短(行长则列短)，执行速度快</li>
<li>缺点：微指令长，编写微程序麻烦</li>
</ul></li>
<li>垂直型微指令
<ul>
<li>只能定义并执行<strong>一种</strong>基本操作</li>
<li>优点：微指令短、简单、规整，便于编写微程序</li>
<li>缺点：微程序长(行短则列长)，执行速度慢，效率低</li>
</ul></li>
<li>混合型微指令：综合</li>
</ol>
<h5 id="设计步骤-1">设计步骤</h5>
<ul>
<li>分析微操作序列及节拍安排</li>
<li>确定微指令格式</li>
<li>编写微指令码点</li>
</ul>
<h5 id="其他">其他</h5>
<ul>
<li>动态微程序设计：EPROM（可编程可擦除只读存储器）</li>
<li>毫微程序设计：在控制存储器中有二级控制存储器</li>
</ul>
<h3 id="异常和中断机制">异常和中断机制</h3>
<h4 id="异常内中断">异常（内中断）</h4>
<p><strong>CPU内部</strong>产生</p>
<ol type="1">
<li>故障（Fault）
<ul>
<li>非法操作码（终止进程）</li>
<li>缺段、<strong>缺页</strong>（可回到中断处继续执行）</li>
<li>除数为‘0’（终止进程）</li>
</ul>
<blockquote>
<p>Cache缺失由CPU硬件实现，不需要使用异常处理程序</p>
</blockquote></li>
<li>自陷（Trap）
<ul>
<li>人为设置（断点调试）</li>
<li>进行相应的处理后，返回到自陷指令的下一条指令执行</li>
<li>若<strong>自陷指令</strong>是<strong>转移指令</strong>，不返回，而是到转移目标指令执行</li>
</ul></li>
<li>终止（Abort）
<ul>
<li>硬件故障</li>
<li><strong>终止</strong>异常和<strong>外中断</strong>属于硬件中断</li>
</ul></li>
</ol>
<h4 id="中断">中断</h4>
<ul>
<li><p>来自CPU外部，与CPU执行指令无关的事件引起</p></li>
<li><p>CPU<strong>每执行完一条指令</strong>就检查<strong>中断请求信号线</strong></p></li>
</ul>
<ol type="1">
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ol>
<blockquote>
<p>子程序调用(函数调用)只需保存程序断点，中断处理需要保存断点(PC)和PSW</p>
</blockquote>
<h4 id="响应过程">响应过程 *</h4>
<ol type="1">
<li>关中断：在保存断点和程序状态时，不能被新的中断打断，因此要禁止相应新的中断</li>
<li>保存断点和程序状态：保存在栈中</li>
<li>识别异常和中断并转到相应的处理程序：
<ul>
<li>软件识别：异常、中断</li>
<li>硬件识别：向量中断，处理程序的<strong>首地址</strong>称为<strong>中断向量</strong>，中断类型号与中断向量一一对应</li>
</ul></li>
</ol>
<h3 id="指令流水线">指令流水线</h3>
<p>RISC</p>
<h4 id="指令流水线的基本概念">指令流水线的基本概念</h4>
<p>一般分为下面5个阶段（功能段/流水段）：</p>
<ul>
<li>取指（IF）：从指令存储器或<strong>Cache</strong>中取命令</li>
<li>译码（ID）：对指令进行译码，同时从<strong>寄存器</strong>(不能直接从内存)中取操作数（RISC的特点）</li>
<li>执行（EX）</li>
<li>访存（MEM）</li>
<li>写回（WB）：写回寄存器堆</li>
</ul>
<blockquote>
<p>流水线每个功能段部件后都要有一个流水/缓冲寄存器(或称锁存器)，保存本段的执行结果，提供给下一个流水段使用。（方便统一每个阶段的耗时开销——以最长耗时阶段为准）</p>
</blockquote>
<h4 id="影响流水线的因素">影响流水线的因素</h4>
<p><strong>流水线冒险</strong>：流水线无法正确执行后续指令而引起流水线阻塞或停顿。</p>
<ol type="1">
<li><p>结构冒险（资源冲突）</p>
<ul>
<li><p>多条指令在同一时刻争用同一资源</p></li>
<li><p>解决方案：</p>
<ol type="1">
<li><p>使后一个相关的指令暂停一个时钟周期</p></li>
<li><p>单独设置指令存储器和数据存数器（现代计算机采用<strong>数据Cache和指令Cache分离</strong>的方式避免冲突）</p></li>
</ol></li>
</ul></li>
<li><p>数据冒险（数据冲突）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309202056078.png" alt="image-20230920205612480">
<figcaption aria-hidden="true">image-20230920205612480</figcaption>
</figure>
<ul>
<li><p>下条指令会用到当前指令计算的结果</p></li>
<li><p>解决方案：</p>
<ol type="1">
<li><p>将遇到数据相关的指令暂停若干时钟周期，主要有两种方法：硬件阻塞、软件插入“NOP”指令</p></li>
<li><p>设置专用通路，将前一条指令的计算结果直接作为当前指令的输入数据（<strong>数据旁路技术</strong>）</p></li>
<li><p>编译优化：调整指令顺序</p></li>
</ol></li>
</ul></li>
<li><p>控制冒险（控制冲突）</p>
<ul>
<li><p>转移、调用（call）等指令导致PC值改变</p></li>
<li><p>解决方案：</p>
<ol type="1">
<li><p>分支预测：分为静态预测(默认是y或n)和动态预测</p></li>
<li><p>预取两个方向的目标指令</p></li>
<li><p>提前形成条件码</p></li>
<li><p>提高猜准率</p></li>
</ol></li>
</ul></li>
</ol>
<h4 id="流水线性能指标">流水线性能指标</h4>
<ol type="1">
<li><p>吞吐率</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230528211123241.png" alt="image-20230528211123241">
<figcaption aria-hidden="true">image-20230528211123241</figcaption>
</figure></li>
<li><p>加速比</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230528211226194.png" alt="image-20230528211226194">
<figcaption aria-hidden="true">image-20230528211226194</figcaption>
</figure></li>
<li><p>效率</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230528211318566.png" alt="image-20230528211318566">
<figcaption aria-hidden="true">image-20230528211318566</figcaption>
</figure></li>
</ol>
<h4 id="流水线的分类">流水线的分类</h4>
<ol type="1">
<li>按级别分类：
<ul>
<li>部件功能级</li>
<li>处理机级(本节介绍的流水线)</li>
<li>处理机间级</li>
</ul></li>
<li>按可完成的功能分类：
<ul>
<li>单功能流水线</li>
<li>多功能流水线</li>
</ul></li>
<li>按连接方式：
<ul>
<li>静态流水线</li>
<li>动态流水线</li>
</ul></li>
<li>是否有反馈信号：
<ul>
<li>线性流水线（无反馈）</li>
<li>非线性流水线（存在反馈电路）</li>
</ul></li>
</ol>
<h4 id="流水线的多发技术">流水线的多发技术</h4>
<ol type="1">
<li><p><strong>超标量流水线</strong>技术</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309192337784.png" alt="image-20230919233748030" style="zoom: 80%;"></p></li>
<li><p><strong>超流水线</strong>技术</p>
<p>图中的“时钟周期”其实应该是机器周期，这里默认机器周期等于时钟周期</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309192341322.png" alt="image-20230919234110925">
<figcaption aria-hidden="true">image-20230919234110925</figcaption>
</figure></li>
<li><p><strong>超长指令字</strong>技术</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309192343589.png" alt="image-20230919234258657">
<figcaption aria-hidden="true">image-20230919234258657</figcaption>
</figure></li>
</ol>
<h4 id="五段式流水线相关指令">五段式流水线相关指令</h4>
<ol type="1">
<li><p>运算类指令</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150605157.png" alt="image-20230529150605157">
<figcaption aria-hidden="true">image-20230529150605157</figcaption>
</figure></li>
<li><p>LOAD指令</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150650942.png" alt="image-20230529150650942">
<figcaption aria-hidden="true">image-20230529150650942</figcaption>
</figure></li>
<li><p>STORE指令</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150742932.png" alt="image-20230529150742932">
<figcaption aria-hidden="true">image-20230529150742932</figcaption>
</figure></li>
<li><p>条件转移类指令</p>
<p>这里<code>(PC)+指令字长</code>是下一条指令的地址，再加上偏移量得到跳转的地址</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529150832045.png" alt="image-20230529150832045">
<figcaption aria-hidden="true">image-20230529150832045</figcaption>
</figure></li>
<li><p>无条件转移指令</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529151022030.png" alt="image-20230529151022030">
<figcaption aria-hidden="true">image-20230529151022030</figcaption>
</figure></li>
</ol>
<p>例题：https://www.bilibili.com/video/BV1ps4y1d73V?t=1618.0&amp;p=72</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230529151533485.png" alt="image-20230529151533485">
<figcaption aria-hidden="true">image-20230529151533485</figcaption>
</figure>
<h3 id="多处理器">多处理器</h3>
<h4 id="基本概念">基本概念</h4>
<ol type="1">
<li><p>SISD</p>
<ul>
<li>一个处理器，一个存储器；各指令程序只能并发，不能并行</li>
<li>前面所学的均是SISD</li>
<li>可采用流水线技术</li>
<li><strong>不是</strong>数据级并行技术</li>
</ul></li>
<li><p>SIMD</p>
<ul>
<li>一个指令流对多个数据流进行处理</li>
<li><strong>数据级并行</strong></li>
<li>各<strong>指令序列只能并发</strong></li>
<li>一个指令控制部件(CU) + 多个处理单元(ALU)</li>
<li>例：for循环</li>
<li><strong>向量处理器</strong></li>
</ul></li>
<li><p>MISD</p>
<ul>
<li>多条指令并行执行，处理同一数据</li>
<li>实际<strong>不存在</strong>这样的计算机</li>
</ul></li>
<li><p>MIMD(现代计算机)</p>
<ul>
<li><p>各指令序列并行执行，处理多个不同的数据</p></li>
<li><p><strong>线程级并行</strong>，甚至是线程级以上并行</p></li>
<li><p>分类：</p>
<ol type="1">
<li>多处理器系统(同共享内存多处理器)</li>
</ol>
<p>共享最低级Cache和主存（通过LOAD/STORE指令访存）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309200941124.png" alt="image-20230920094121842">
<figcaption aria-hidden="true">image-20230920094121842</figcaption>
</figure>
<ol start="2" type="1">
<li>多计算机系统</li>
</ol>
<p>​
计算机与计算机之间，只能通过<strong>消息传递</strong>互相传送数据</p>
<p>​ 由多台计算机组成，独立的地址空间</p></li>
</ul></li>
<li><p>向量处理器</p>
<ul>
<li>指令处理对象是“向量”</li>
<li>擅长计算向量型数据</li>
<li>支持多端口同时读取的多模块交叉存储器</li>
</ul></li>
</ol>
<h4 id="硬件多线程">硬件多线程</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309200920795.png" alt="image-20230920092004264">
<figcaption aria-hidden="true">image-20230920092004264</figcaption>
</figure>
<h4 id="多核处理器和共享内存多处理器">多核处理器和共享内存多处理器</h4>
<ul>
<li><p>共享内存多处理器<strong>SMP</strong>：共享同一个物理地址</p></li>
<li><p>图中观点不正确，多核不是多处理器（多处理器系统是一个拥有多个 CPU
的系统，每个 CPU 中也可能有多个核）</p></li>
<li><p>多处理器共享内存，多核共享Cache</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309200919741.png" alt="image-20230920091857534">
<figcaption aria-hidden="true">image-20230920091857534</figcaption>
</figure>
<h2 id="总线">总线</h2>
<p><strong>数据通路</strong>表示的是数据流经的路径。</p>
<p><strong>数据总线</strong>是承载的媒介。</p>
<h3 id="总线概述">总线概述</h3>
<h4 id="总线基本概念">总线基本概念</h4>
<ul>
<li><p>总线特点：<strong>分时、共享</strong></p></li>
<li><p>同一时刻只能有一个部件发送数据，但是可以有多个部件接收数据</p></li>
<li><p>总线设备：主设备(对总线有控制权)、从设备(被主设备访问的设备)</p></li>
<li><p>总线特性：</p>
<ol type="1">
<li><p>机械特性：尺寸、形状</p></li>
<li><p>电气特性：传输方向和电平范围</p></li>
<li><p>功能特性：每根传输线的功能</p></li>
<li><p>时间特性：信号和时序的关系</p></li>
</ol></li>
</ul>
<h4 id="总线的分类">总线的分类</h4>
<p>按功能分类：</p>
<ol type="1">
<li>片内总线：CPU内部</li>
<li><strong>系统总线</strong>：
<ul>
<li>数据总线：双向，位数与机器字长、存储字长有关</li>
<li>地址总线：单向，与主存地址空间有关</li>
<li>控制总线</li>
</ul></li>
<li>通信总线：不同计算机系统之间或计算机系统和其他系统之间</li>
</ol>
<h4 id="系统总线结构">系统总线结构</h4>
<ol type="1">
<li><p><strong>单总线</strong>：不是只有一根信号线，而是包括数据总线、地址总线、控制总线</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309212014304.png" alt="image-20230921201445519" style="zoom:67%;"></p></li>
<li><p><strong>双总线</strong>：主存总线(支持<strong>突/猝发传送</strong>)
+ I/O总线</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309212018682.png" alt="image-20230921201823160" style="zoom:67%;"></p></li>
<li><p><strong>三总线</strong>：主存总线 + I/O总线 +
DMA总线(直接内存访问)</p>
<ul>
<li>DMA总线用于在<strong>内存和高速外设</strong>之间直接传送数据</li>
<li>同一时刻只能有一根总线工作</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309212023105.png" alt="image-20230921202221925" style="zoom:67%;"></p></li>
</ol>
<p><strong>桥接</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531144036228.png" alt="image-20230531144036228">
<figcaption aria-hidden="true">image-20230531144036228</figcaption>
</figure>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309211940547.png" alt="image-20230921193956497" style="zoom: 67%;"></p>
<h3 id="总线的性能指标">总线的性能指标</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531150457943.png" alt="image-20230531150457943">
<figcaption aria-hidden="true">image-20230531150457943</figcaption>
</figure>
<p>例题：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531150113328.png" alt="image-20230531150113328">
<figcaption aria-hidden="true">image-20230531150113328</figcaption>
</figure>
<h3 id="总线操作和定时">总线操作和定时</h3>
<ol type="1">
<li><p>同步定时</p>
<ul>
<li>主从设备属于强制性同步，可靠性差</li>
<li>一个总线周期内进行一次数据传送</li>
<li>适用于总线长度较短</li>
<li><strong>统一的时钟信号</strong></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531152726647.png" alt="image-20230531152726647">
<figcaption aria-hidden="true">image-20230531152726647</figcaption>
</figure></li>
<li><p>异步定时</p>
<p>总线周期可变；通过<strong>“握手”</strong>信号实现定时控制</p>
<ul>
<li>不互锁：经过一段时间后自动撤销“请求”、“回答”信号</li>
<li>半互锁：主设备<strong>接收到从设备的“回答”信号后</strong>撤销“请求”信号</li>
<li>全互锁：接收到“回答”信号后-&gt;“请求”信号撤销-&gt;“回答”信号撤销</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531153611485.png" alt="image-20230531153611485">
<figcaption aria-hidden="true">image-20230531153611485</figcaption>
</figure></li>
<li><p>半同步通信</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531153942003.png" alt="image-20230531153942003"></p></li>
<li><p>分离式通信</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531154224299.png" alt="image-20230531154224299"></p></li>
</ol>
<h3 id="总线标准">总线标准</h3>
<ul>
<li><strong>USB</strong>：串行总线</li>
<li><strong>PCI-E</strong>：串行总线，全双工</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230531161012125.png" alt="image-20230531161012125">
<figcaption aria-hidden="true">image-20230531161012125</figcaption>
</figure>
<h2 id="io系统">I/O系统</h2>
<h3 id="io控制方式">I/O控制方式</h3>
<ul>
<li><strong>程序查询</strong>方式：CPU忙等</li>
<li><strong>程序中断</strong>方式：在I/O准备阶段，CPU可以处理其他事情</li>
<li><strong>DMA方式</strong>：主存与I/O设备(高速设备)之间有一条<strong>直接数据通路</strong>（整<strong>块</strong>数据读写）</li>
<li><strong>通道方式</strong>：通道执行通道程序，完成I/O操作</li>
</ul>
<h3 id="io接口">I/O接口</h3>
<p>又称I/O控制器、设备控制器；<strong>实现主机和外设之间的信息交换</strong></p>
<ol type="1">
<li><p>功能</p>
<ul>
<li>地址译码和设备选择</li>
<li>实现主机与外设的通信联络</li>
<li>数据缓冲（设置数据缓冲寄存器）</li>
<li>信号格式转换（电平转换、并/串）</li>
<li>传送控制命令和状态信息（状态/控制寄存器）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601154211798.png" alt="image-20230601154211798">
<figcaption aria-hidden="true">image-20230601154211798</figcaption>
</figure>
<blockquote>
<p>端口是指寄存器，而接口是由若干端口和控制逻辑组成</p>
</blockquote></li>
<li><p>编址方式（这里是对端口编址，而不是接口）</p>
<ul>
<li>统一编址：灵活，编址空间大；占用内存，慢</li>
<li>独立编址：程序编制清晰，便于理解；复杂</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601162746815.png" alt="image-20230601162746815">
<figcaption aria-hidden="true">image-20230601162746815</figcaption>
</figure>
<blockquote>
<p>在统一编址下，存储单元和I/O设备是靠<strong>不同的地址码</strong>来区别的；</p>
<p>在独立编址下，靠<strong>不同的指令</strong>来区别的</p>
</blockquote></li>
</ol>
<h3 id="io方式">I/O方式</h3>
<h4 id="程序查询方式">程序查询方式</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601165543188.png" alt="image-20230601165543188">
<figcaption aria-hidden="true">image-20230601165543188</figcaption>
</figure>
<p>例题：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230601165651610.png" alt="image-20230601165651610">
<figcaption aria-hidden="true">image-20230601165651610</figcaption>
</figure>
<h4 id="程序中断方式">程序中断方式</h4>
<p>工作流程如下</p>
<ol type="1">
<li><p><strong>中断请求</strong></p>
<ul>
<li>中断请求标记触发器置为“1”，表示中断源有请求</li>
<li>INTR线发出可屏蔽中断，<strong>NMI</strong>线发出<strong>不可屏蔽中断</strong>(时钟中断，电源掉电等)</li>
</ul>
<blockquote>
<p><strong>不可中断屏蔽</strong>可在<strong>关中断</strong>被响应（<strong>异常</strong>——内中断是<strong>不可中断屏蔽</strong>）</p>
</blockquote></li>
<li><p><strong>中断判优</strong></p>
<ul>
<li>判优通过<strong>硬件排队器</strong>实现</li>
<li>高速设备优先于低速设备，输入设备优先于输出设备，实时设备优先于普通设备</li>
</ul></li>
<li><p><strong>中断响应</strong>过程：</p>
<p>执行<strong>中断隐指令</strong>（==硬件自动完成==）：保存<strong>PSW和PC</strong>的内容</p>
<ul>
<li><strong>关中断</strong>：==PSW==(标志寄存器)中的 <strong>IF</strong>
置为0</li>
<li><strong>保存断点</strong>(硬件实现)：中断——保存下一条指令地址（==PC==），异常——保存当前指令地址</li>
<li><strong>引出中断服务程序</strong>：识别中断源（有下面两种方法）</li>
</ul>
<ol type="1">
<li><strong>硬件向量法(向量中断)</strong>：</li>
</ol></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309222126460.png" alt="image-20230922212626689" style="zoom:80%;"></p>
<p>​
①通过识别中断源获取<strong>中断类型号</strong>(向量地址)，一个中断类型号对应一个中断向量</p>
<p>​
②根据<strong>中断类型号</strong>(向量地址)查表找到对应的<strong>中断向量</strong>即中断服务程序对应的<strong>入口地址</strong></p>
<p>​ (2) 软件查询法：设置异常状态寄存器</p>
<ol start="4" type="1">
<li><p><strong>中断处理过程</strong></p>
<p>执行<strong>中断服务程序</strong>：（注意顺序）</p>
<ul>
<li>保存现场和屏蔽字：现场——保存用户可见的工作寄存器(<strong>通用寄存器</strong>)的内容到栈中</li>
<li>开中断：允许更高级的中断响应，实现<strong>中断嵌套</strong>(多重中断)</li>
<li>执行中断服务程序</li>
<li>关中断：保证恢复现场和屏蔽字时不被打断 (屏蔽字"1"表示屏蔽)</li>
<li>恢复现场</li>
<li>开中断</li>
<li>中断返回</li>
</ul></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602113649004.png" alt="image-20230602113649004">
<figcaption aria-hidden="true">image-20230602113649004</figcaption>
</figure>
<p><strong>中断屏蔽字中至少有一个“1”（用于屏蔽自身中断）</strong>：P289-例7.1</p>
<blockquote>
<p>一个中断需要屏蔽<strong>自身</strong>和<strong>优先级比其低</strong>的中断</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311091712870.png" alt="image-20231109171237830">
<figcaption aria-hidden="true">image-20231109171237830</figcaption>
</figure>
</blockquote>
<p>补充：</p>
<p>中断隐指令引出中断服务程序</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602115601784.png" alt="image-20230602115601784">
<figcaption aria-hidden="true">image-20230602115601784</figcaption>
</figure>
<p>中断处理过程</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602120211197.png" alt="image-20230602120211197">
<figcaption aria-hidden="true">image-20230602120211197</figcaption>
</figure>
<h4 id="dma方式">DMA方式</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231628621.png" alt="image-20230923162845730">
<figcaption aria-hidden="true">image-20230923162845730</figcaption>
</figure>
<ul>
<li>完全由<strong>硬件</strong>进行</li>
<li>以数据块为单位（传送完一个数据块发出中断请求）</li>
<li>CPU与外设并行工作</li>
<li>需要向CPU申请系统总线控制权</li>
</ul>
<h5 id="dma方式的过程">DMA方式的过程</h5>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231638362.png" alt="image-20230923163853547" style="zoom:67%;"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231639004.png" alt="image-20230923163928181" style="zoom:67%;"></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309231636531.png" alt="image-20230923163638811">
<figcaption aria-hidden="true">image-20230923163638811</figcaption>
</figure>
<ul>
<li><p>传送过程中，<strong>数据缓冲区</strong>每充满一次（一个字）就发出一次==DMA请求==（请求总线的使用权）</p>
<p>注：<strong>若题目中提到DMA和CPU访存不冲突，则不考虑DMA请求</strong></p></li>
<li><p>当传送完一个<strong>数据块</strong>时，发出==DMA中断请求==，即上述第5步</p></li>
</ul>
<h5 id="dma控制器组成">DMA控制器组成</h5>
<ul>
<li>主存地址计数器：存放要交换数据的主存地址</li>
<li>传送长度计数器：记录传送数据的长度，计数溢出则传送完毕（递增）</li>
<li>数据缓冲寄存器：暂存每次传送的数据</li>
<li>DMA请求触发器：控制信号</li>
<li>控制/状态逻辑：指定传送方向</li>
<li>中断机构：一个数据块传送完毕后触发中断机构，向CPU提出中断请求</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602145706472.png" alt="image-20230602145706472">
<figcaption aria-hidden="true">image-20230602145706472</figcaption>
</figure>
<p>上述结构中DMA使用主存需要受<strong>CPU</strong>控制，而==三总线==结构访存时可能会发生冲突，因为DMA传送不需要向CPU申请总线使用权</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602150503276.png" alt="image-20230602150503276">
<figcaption aria-hidden="true">image-20230602150503276</figcaption>
</figure>
<p>下面是解决方案</p>
<p><strong>DMA传送方式</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230602150250368.png" alt="image-20230602150250368">
<figcaption aria-hidden="true">image-20230602150250368</figcaption>
</figure>
<h1 id="操作系统">操作系统</h1>
<h2 id="计算机系统概述-1">计算机系统概述</h2>
<h3 id="操作系统基本概念">操作系统基本概念</h3>
<h4 id="操作系统的特征">操作系统的特征</h4>
<ol type="1">
<li>并发：宏观上并行，微观上串行</li>
<li>共享
<ul>
<li>互斥共享方式：一次只允许一个进程访问临界资源</li>
<li>同时访问方式：宏观上“同时”</li>
</ul></li>
<li>虚拟：虚拟处理器（时分）、虚拟存储器（空分）</li>
<li>异步：进程以不可预知的速度向前推进</li>
</ol>
<blockquote>
<p><strong>并发</strong>和<strong>共享</strong>是两个<strong>最基本</strong>的特征</p>
</blockquote>
<h4 id="接口">接口</h4>
<ol type="1">
<li><strong>命令接口</strong>：用户可直接使用
<ul>
<li>联机命令接口：交互式命令接口，输入一条命令就执行一条（终端）</li>
<li>脱机命令接口：批处理命令接口，一次输入一堆命令（脚本）</li>
</ul></li>
<li><strong>程序接口</strong>：由<strong>系统调用</strong>组成，用户通过<strong>程序</strong>间接使用</li>
</ol>
<blockquote>
<p><strong>库函数</strong>是对系统调用的再次封装，库函数是将函数封装入库，供用户使用的一种方式
注意：有些库函数涉及系统调用，而<strong>有些库函数不涉及系统调用</strong></p>
</blockquote>
<h3 id="操作系统发展历程">操作系统发展历程</h3>
<h4 id="手工操作阶段">手工操作阶段</h4>
<ul>
<li>用户独占全机，资源利用率低</li>
<li>所有工作需要人工干预</li>
</ul>
<h4 id="批处理阶段">批处理阶段</h4>
<p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾</p>
<ol type="1">
<li><p>单道批处理系统</p>
<ul>
<li>自动性：磁带上的程序能自动逐个运行</li>
<li>顺序性：先调入内存的作业先完成</li>
<li>单道性：内存中<strong>仅有一道程序</strong>运行</li>
</ul>
<p>缺点：高速CPU需要等待低速的I/O设备完成</p></li>
<li><p>多道批处理系统</p>
<ul>
<li>多道：内存中<strong>同时存放多道</strong>相互独立的程序</li>
<li>宏观上并行：同时进入内存的程序都处于运行过程</li>
<li>微观上串行：多道程序轮流占有CPU，<strong>交替执行</strong></li>
</ul>
<p>缺点：用户响应时间长，不提供人机交互</p>
<p>优点：资源利用率高</p></li>
</ol>
<h4 id="分时操作系统">分时操作系统</h4>
<p>按<strong>时间片</strong>轮流将处理器分配给各作业</p>
<ul>
<li>同时性</li>
<li>交互性</li>
<li>独立性</li>
<li>及时性</li>
</ul>
<h4 id="实时操作系统">实时操作系统</h4>
<p>为了在时间限制内完成某些紧急任务而不需要时间片排队</p>
<ol type="1">
<li><p>硬实时系统</p>
<p>某个动作必须在规定时刻完成：例如飞机自动控制系统</p></li>
<li><p>软实时系统</p>
<p>偶尔违反时间规定不会造成大的损害：飞机订票系统</p></li>
</ol>
<h3 id="操作系统运行环境">操作系统运行环境</h3>
<h4 id="运行模式">运行模式</h4>
<ol type="1">
<li>内核态
<ul>
<li>特权指令</li>
<li>内核程序</li>
</ul>
<blockquote>
<p>广义指令即系统调用命令</p>
<p><strong>I/O指令、置终端屏蔽指令、清内存、建存储保护、设置时钟指令</strong></p>
<p>中断、异常</p>
<p>进程调度</p>
</blockquote></li>
<li>用户态
<ul>
<li>非特权指令</li>
<li>应用程序</li>
</ul></li>
</ol>
<blockquote>
<p>用户态进入核心态通过<strong>硬件</strong>实现</p>
</blockquote>
<h4 id="异常和中断">异常和中断</h4>
<p><a href="#异常和中断机制">详见计组</a></p>
<h4 id="系统调用">系统调用</h4>
<ol type="1">
<li><p>分类：</p>
<ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程控制</li>
<li>进程通信</li>
<li>内存管理</li>
</ul></li>
<li><p>流程：</p>
<ul>
<li>用户执行<strong>陷入指令</strong>(异常)</li>
<li>将CPU使用权主动交给内核程序（用户态-&gt;核心态）</li>
<li>内核程序对系统调用进行处理</li>
<li>处理完成内核程序将CPU使用权归还给用户程序（用户态-&gt;核心态）</li>
</ul>
<blockquote>
<p><strong>陷入指令</strong>又称<strong>访管指令</strong>或<strong>trap指令</strong>，该指令是在用户态使用的，不是特权指令；分为<strong>有条件陷入</strong>和<strong>无条件陷入</strong></p>
</blockquote></li>
</ol>
<h3 id="操作系统结构">操作系统结构</h3>
<ol type="1">
<li><p>分层</p>
<ul>
<li>高层只能调用相邻低层的功能和服务</li>
<li>优点：(1) 便于调试和验证；(2) 易扩充和维护</li>
<li>缺点：(1) 定义各层较难；(2) 效率较差</li>
</ul></li>
<li><p>模块化</p>
<ul>
<li>按功能划分为若干具有独立性的模块</li>
<li>内聚性越高独立性越好，耦合性越低独立性越好</li>
<li>优点：(1) 易于维护；(2) 加速了开发过程；(3) 适应性强</li>
<li>缺点：(1) 难以满足实际需要；(2) 难以调试和验证</li>
</ul></li>
<li><p>宏内核</p>
<ul>
<li>将系统的主要功能模块运行在核心态</li>
<li>优点：提供高性能服务</li>
<li>缺点：不可靠，某个模块出错，可能导致整个系统崩溃</li>
</ul></li>
<li><p>微内核</p>
<ul>
<li>内核中最基本的功能保留在内核，其他功能移到用户态运行</li>
<li>优点：功能少易于维护；某模块出错不会导致整个系统崩溃</li>
<li>缺点：性能低，需要频繁切换状态；用户态下的各功能只能通过内核的“信息传递”间接通信</li>
</ul></li>
<li><p>外核</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309281731880.png" alt="image-20230928173131077">
<figcaption aria-hidden="true">image-20230928173131077</figcaption>
</figure></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604144828053.png" alt="image-20230604144828053"></p>
<h3 id="操作系统引导">操作系统引导</h3>
<ul>
<li>CPU读取ROM中的<strong>BIOS</strong>程序，<strong>先初始化中断向量表</strong>，然后BIOS程序进行“<strong>硬件自检</strong>”（会用到中断），如无故障则显示CPU、内存等信息</li>
<li>硬件自检完成后，BIOS读取Boot
Sequence（启动顺序），将控制权交给优先级最高的存储设备</li>
<li>CPU将该存储设备上的<strong>主引导记录(MBR)</strong>读入内存（一个磁盘只有一个MBR，位于磁盘第一扇区）</li>
<li>主引导记录告诉CPU去哪个<strong>主分区</strong>（C盘、D盘等）找操作系统</li>
<li>活动分区的第一个扇区中读入<strong>分区引导记录</strong>(PBR)（PBR是各个分区自己的引导记录，位于各个分区开始处第一个扇区）</li>
<li>通过分区引导记录找到<strong>根目录</strong>下的<strong>启动管理器</strong>，加载操作系统，完成开机</li>
</ul>
<blockquote>
<p>https://www.ruanyifeng.com/blog/2013/02/booting.html</p>
<p>一个硬盘最多只能有一个活动分区，即将包含此次启动信息的主分区标记为<strong>活动分区</strong></p>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604160117562.png" alt="image-20230604160117562">
<figcaption aria-hidden="true">image-20230604160117562</figcaption>
</figure>
<h3 id="虚拟机">虚拟机</h3>
<ol type="1">
<li><p>第一类 VMM</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309281949178.png" alt="image-20230928194935037" style="zoom:67%;"></p></li>
<li><p>第二类 VMM</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309281950178.png" alt="image-20230928195009747" style="zoom:67%;"></p></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604162136018.png" alt="image-20230604162136018">
<figcaption aria-hidden="true">image-20230604162136018</figcaption>
</figure>
<h2 id="进程与线程">进程与线程</h2>
<h3 id="进程">进程</h3>
<h4 id="进程的概念和特征">进程的概念和特征</h4>
<ol type="1">
<li>概念：是系统进行资源分配和调度的一个独立单位</li>
<li>特征：
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul></li>
</ol>
<h4 id="进程状态转换">进程状态转换</h4>
<ol type="1">
<li><p>状态</p>
<ul>
<li><strong>运行态</strong>：单处理中，每个时刻只有一个进程处于运行态</li>
<li><strong>就绪态</strong>：已获得处理机外的一切资源；就绪队列</li>
<li><strong>阻塞态</strong>（等待态）：即使处理机空闲也不能运行该进程；阻塞队列</li>
<li>创建态：申请空白PCB并写入相关信息，分配必要资源插入就绪队列</li>
<li>终止态：先将进程置为终止态，然后处理资源释放和回收</li>
</ul>
<blockquote>
<p>前三种为基本状态</p>
</blockquote></li>
<li><p>状态转换</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291146033.png" alt="image-20230929114622834">
<figcaption aria-hidden="true">image-20230929114622834</figcaption>
</figure></li>
</ol>
<blockquote>
<p>被唤醒是指<strong>阻塞态-&gt;就绪态</strong></p>
</blockquote>
<h4 id="进程的组成">进程的组成</h4>
<ol type="1">
<li><p><strong>进程控制块 PCB</strong>（核心）</p>
<ul>
<li>PCB是进程存在的唯一标志</li>
<li>常驻内存</li>
</ul>
<ol type="1">
<li><p>进程描述信息：进程标识符(PID)、用户标识符(UID)</p></li>
<li><p>进程控制和管理信息：状态、优先级、代码入口、外存地址、时间</p></li>
<li><p>资源分配清单：代码段/数据段/堆栈段指针、文件描述符</p></li>
<li><p>处理机相关信息：寄存器值和状态字</p></li>
</ol></li>
<li><p>程序段：多个进程可运行同一个程序</p></li>
<li><p>数据段：原始数据或中间结果</p></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604165520959.png" alt="image-20230604165520959"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230604164855151.png" alt="image-20230604164855151"></p>
<h4 id="进程控制">进程控制</h4>
<p>进程控制的程序段称为<strong>原语</strong>（不允许中断）</p>
<ol type="1">
<li><p>进程创建</p>
<ul>
<li>为进程分配一个进程标识号</li>
<li>为进程分配资源</li>
<li>初始化PCB</li>
<li>插入就绪队列</li>
</ul></li>
<li><p>进程终止</p>
<ul>
<li>获取该进程当前的状态</li>
<li>终止该进程的执行，将处理机资源分配给其他进程</li>
<li>终止子孙进程</li>
<li>将该进程拥有的所有资源归还给操作系统或其父进程</li>
<li>将其PCB从队列中删除</li>
</ul></li>
<li><p>进程阻塞和唤醒</p>
<ol type="1">
<li><strong>阻塞原语 Block</strong></li>
</ol>
<ul>
<li>找到将要被阻塞的进程，获取其PCB</li>
<li>保护现场，转为阻塞态，停止运行</li>
<li>将PCB插入等待队列（阻塞队列）</li>
</ul>
<ol start="2" type="1">
<li><strong>唤醒原语 Wakeup</strong></li>
</ol>
<ul>
<li>找到对应的PCB</li>
<li>从等待队列中移出，置为就绪队列</li>
<li>将PCB插入就绪队列，等待调度</li>
</ul>
<blockquote>
<p>成对使用</p>
</blockquote></li>
</ol>
<h4 id="进程通信">进程通信</h4>
<ol type="1">
<li><p>共享存储</p>
<ul>
<li>需要同步互斥工具（P、V操作）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605153021156.png" alt="image-20230605153021156">
<figcaption aria-hidden="true">image-20230605153021156</figcaption>
</figure></li>
<li><p>消息传递</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605153052622.png" alt="image-20230605153052622">
<figcaption aria-hidden="true">image-20230605153052622</figcaption>
</figure></li>
<li><p>管道通信</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605152720388.png" alt="image-20230605152720388">
<figcaption aria-hidden="true">image-20230605152720388</figcaption>
</figure></li>
</ol>
<h3 id="线程">线程</h3>
<p><strong>内核级线程是处理机分配的单位</strong></p>
<h4 id="概念和特征">概念和特征</h4>
<ul>
<li>独立调度的<strong>基本单位</strong></li>
<li>线程<strong>不拥有系统资源</strong>，进程是系统中拥有资源的基本单位</li>
<li>与同属一个进程的其他线程共享进程的资源</li>
<li>三种基本状态：就绪、阻塞、运行</li>
<li>线程切换代价远小于进程切换</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230605153915360.png" alt="image-20230605153915360">
<figcaption aria-hidden="true">image-20230605153915360</figcaption>
</figure>
<h4 id="线程的组织和控制">线程的组织和控制</h4>
<ul>
<li>线程控制块 <strong>TCB</strong></li>
<li>线程的创建：线程创建函数</li>
<li>线程的终止：被终止后不会立即释放资源</li>
</ul>
<h4 id="线程的实现两类">线程的实现（两类）</h4>
<ol type="1">
<li><p>用户级线程</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291624197.png" alt="image-20230929162456332" style="zoom:67%;"></p>
<ul>
<li>线程管理工作由应用程序负责（包括线程切换）</li>
<li>通过线程库实现多线程程序</li>
<li>操作系统内核意识不到线程的存在</li>
<li>优点：线程切换不需要在内核状态下实现，开销小，效率高</li>
<li>缺点：一个线程被阻塞，整个进程就会被阻塞；并发度不高；不能发挥多处理机的优势</li>
</ul></li>
<li><p>内核级线程</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291631696.png" alt="image-20230929163149208" style="zoom: 33%;"></p>
<ul>
<li>线程的管理工作由内核负责</li>
<li><strong>线程的切换</strong>需要在<strong>内核态</strong>中完成</li>
<li>操作系统为每个线程建立对应的PCB</li>
<li>优点：一个线程被阻塞，不影响其他线程运行，并发能力强，可在多核处理机上运行</li>
<li>缺点：线程管理成本高，开销大</li>
</ul></li>
</ol>
<h4 id="多线程模型">多线程模型</h4>
<p>注：这里的多对一模型默认一个进程对应一个内核级线程</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202309291643823.png" alt="image-20230929164317033">
<figcaption aria-hidden="true">image-20230929164317033</figcaption>
</figure>
<h3 id="处理机调度">处理机调度</h3>
<h4 id="调度的概念">调度的概念</h4>
<p>高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606134037983.png" alt="image-20230606134037983">
<figcaption aria-hidden="true">image-20230606134037983</figcaption>
</figure>
<h4 id="性能指标-1">性能指标</h4>
<ol type="1">
<li>CPU利用率：有效工作时间/(有效工作时间+空闲等待时间)</li>
<li>系统吞吐率：单位时间内CPU完成作业的数量</li>
<li><strong>周转时间</strong>
<ul>
<li>周转时间 = 作业<strong>完成</strong>时间 -
作业<strong>提交</strong>时间</li>
<li>平均周转时间 = n个周转时间之和/n</li>
<li>带权周转时间 = 作业周转时间/作业实际运行时间</li>
</ul></li>
<li>等待时间：等待处理机的时间（不计算I/O时间）</li>
<li>响应时间：系统首次产生响应时间 - 提交时间</li>
</ol>
<h4 id="调度算法">调度算法</h4>
<h5 id="先来先服务fcfs">先来先服务（FCFS）</h5>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171442053.png" alt="image-20230606171442053">
<figcaption aria-hidden="true">image-20230606171442053</figcaption>
</figure>
<h5 id="短作业优先sjf">短作业优先（SJF）</h5>
<p><strong>平均等待时间和平均周转时间最短</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171723246.png" alt="image-20230606171723246">
<figcaption aria-hidden="true">image-20230606171723246</figcaption>
</figure>
<ul>
<li><p>非抢占式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171552568.png" alt="image-20230606171552568">
<figcaption aria-hidden="true">image-20230606171552568</figcaption>
</figure></li>
<li><p>抢占式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171632573.png" alt="image-20230606171632573">
<figcaption aria-hidden="true">image-20230606171632573</figcaption>
</figure></li>
</ul>
<h5 id="高响应比优先">高响应比优先</h5>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606171829656.png" alt="image-20230606171829656">
<figcaption aria-hidden="true">image-20230606171829656</figcaption>
</figure>
<h5 id="时间片轮转">时间片轮转</h5>
<ul>
<li>时间片过大可转化为<strong>先来先服务</strong>（时间片长度大于运行时间）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606173520711.png" alt="image-20230606173520711">
<figcaption aria-hidden="true">image-20230606173520711</figcaption>
</figure>
<h5 id="优先级调度算法">优先级调度算法</h5>
<p>优先级分为：静态优先级、动态优先级</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606183504183.png" alt="image-20230606183504183">
<figcaption aria-hidden="true">image-20230606183504183</figcaption>
</figure>
<h5 id="多级反馈队列调度算法">多级反馈队列调度算法</h5>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606184448921.png" alt="image-20230606184448921">
<figcaption aria-hidden="true">image-20230606184448921</figcaption>
</figure>
<h5 id="多级队列调度算法">多级队列调度算法</h5>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230606184911168.png" alt="image-20230606184911168">
<figcaption aria-hidden="true">image-20230606184911168</figcaption>
</figure>
<blockquote>
<p>可能产生饥饿的算法：SJF、优先级调度算法、多级反馈队列调度算法</p>
</blockquote>
<h3 id="同步与互斥">同步与互斥</h3>
<h4 id="基本概念-1">基本概念</h4>
<ol type="1">
<li><p>临界资源</p>
<ul>
<li><p>一次仅允许一个进程使用</p></li>
<li><p>访问临界资源的代码被称为<strong>临界区</strong></p></li>
<li><p>访问过程：</p>
<ol type="1">
<li><p>进入区：检查是否能进入临界区，若能，则上锁</p></li>
<li><p>临界区：访问临界资源的代码段</p></li>
<li><p>退出区：清除相关标志，解锁</p></li>
<li><p>剩余区：代码的剩余部分</p></li>
</ol></li>
</ul></li>
<li><p>同步</p>
<ul>
<li>直接制约关系，源于互相合作</li>
<li>协调不同进程的工作次序</li>
</ul></li>
<li><p>互斥</p>
<ul>
<li><p>间接制约关系</p></li>
<li><p><strong>准则</strong>：</p>
<ol type="1">
<li><p>空闲让进</p></li>
<li><p>忙则等待</p></li>
<li><p>有限等待：防止饥饿</p></li>
<li><p>让权等待：防止进程忙等待</p></li>
</ol></li>
</ul></li>
</ol>
<h4 id="实现临界区互斥的基本方法">实现临界区互斥的基本方法</h4>
<ol type="1">
<li><p>软件</p>
<ul>
<li><strong>单标志法</strong>（违背空闲让进）：必须交替进入，如果一个不进，另一个就进不了</li>
<li><strong>双标志法先检查</strong>（违背忙则等待）：先检查(while)后上锁，可能<strong>同时进入</strong>临界区（flag[]）</li>
<li><strong>双标志法后检查</strong>（违背空闲让进和有限等待）：先上锁（flag[]）后检查(while)，同时想进临界区，同时检测对方状态，互相谦让，<strong>都无法进入临界区</strong>，导致“饥饿”</li>
<li><strong>Peterson's
Algorithm</strong>（违背让权等待）：虽然进不了临界区，但是占用CPU资源（循环），在谦让的同时看对方是否想进临界区，若不想则不用谦让（flag[]
+ turn）</li>
</ul>
<blockquote>
<p>检查和上锁应该一气呵成</p>
<p>这里的上锁就是将 标志位
置为<strong>true</strong>，检查则是判断是否满足循环条件</p>
</blockquote></li>
<li><p>硬件</p>
<ul>
<li><p>中断屏蔽法（不适用于多处理机）：开关中断操作需要处于内核态</p></li>
<li><p>硬指令法（<strong>违背让权等待</strong>）：</p>
<p>（1）TestAndSet指令(<strong>TSL</strong>)：通过<strong>lock</strong>值判断是否能够进入临界区。若当前<strong>lock</strong>值（用<strong>old</strong>变量暂存）为<strong>true</strong>，则陷入死循环，无法进入临界区；若为<strong>false</strong>，则可跳出循环，同时将当前<strong>lock</strong>置为<strong>true</strong>防止其他进程进入临界区</p>
<p>（2）<strong>Swap指令</strong>：交换<strong>lock</strong>值和局部变量<strong>key</strong>的值，通过<strong>key</strong>的值(循环条件)判断是否进入临界区，与第一个原理类似（都是使用一个局部变量暂存当前的<strong>lock</strong>值）</p></li>
</ul>
<blockquote>
<p><strong>TSL指令本身就是原子操作</strong></p>
</blockquote></li>
</ol>
<h4 id="互斥锁">互斥锁</h4>
<ul>
<li>缺点：忙等待（违反让权等待）</li>
<li>需要连续循环忙等的互斥锁称为<strong>自旋锁</strong>（TSL指令、Swap指令和单标志法）</li>
<li>常用于多处理器</li>
</ul>
<h4 id="信号量">信号量</h4>
<p>PV原语访问信号量</p>
<ol type="1">
<li>类型</li>
</ol>
<ul>
<li><p>整形信号量（不满足让权等待）：整型量<strong>S</strong>表示资源数目，S&lt;=0则不断查询（忙等）</p></li>
<li><p>记录型信号量（满足让权等待）：</p>
<p>（1）整型量<strong>value</strong> + 进程链表<strong>L</strong></p>
<p>（2）资源不足(value&lt;0)则进程插入等待队列<strong>L</strong>（block）；使用wakeup唤醒<strong>L</strong>中的进程</p>
<p>（3）负值表示阻塞队列中进程个数</p></li>
</ul>
<ol start="2" type="1">
<li><p>实现</p>
<ul>
<li><p>同步：解决执行顺序问题——<strong>先V后P</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>;  <span class="comment">//初始化信号量，P2会被阻塞直到P1释放资源</span></span><br><span class="line"></span><br><span class="line">P1(){           <span class="comment">//进程P1</span></span><br><span class="line">    x;          <span class="comment">//x语句必须在V操作前执行</span></span><br><span class="line">    V(S);       <span class="comment">//释放资源</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line">P2(){           <span class="comment">//进程P2</span></span><br><span class="line">    ...</span><br><span class="line">    P(S);       <span class="comment">//申请资源</span></span><br><span class="line">    y;          <span class="comment">//y语句要在P操作之后执行</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>互斥：一次只允许一个进程进入临界区，将临界区置于<strong>P</strong>、<strong>V</strong>之间</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">1</span>;</span><br><span class="line">P1(){</span><br><span class="line">    ...</span><br><span class="line">    P(S);  <span class="comment">//加锁</span></span><br><span class="line">    临界区</span><br><span class="line">    V(S);  <span class="comment">//解锁</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line">P2(){</span><br><span class="line">    ...</span><br><span class="line">    P(S);</span><br><span class="line">    临界区</span><br><span class="line">    V(S);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>前驱关系：找出每一对前驱关系（执行顺序），给每对进程设置一个初始值为0的信号量</p></li>
</ul></li>
</ol>
<h4 id="管程">管程</h4>
<ul>
<li>一次<strong>仅允许一个进程</strong>在管程内执行</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611133852311.png" alt="image-20230611133852311">
<figcaption aria-hidden="true">image-20230611133852311</figcaption>
</figure>
<h4 id="经典同步问题">经典同步问题*</h4>
<ol type="1">
<li>生产者-消费者
<ul>
<li>互斥同步关系</li>
<li>信号量：mutex（互斥）、full（同步）、empty（同步）</li>
<li>互斥的P操作一定要在同步的P操作之后（防止死锁）</li>
</ul></li>
<li>多生产者-多消费者
<ul>
<li>多对同步关系</li>
</ul></li>
<li>读者-写者*
<ul>
<li>允许多个读进程同时访问文件</li>
<li>只允许一个写进程在文件中写信息</li>
<li>任意一个写进程在完成前不允许其他读/写进程工作</li>
<li>写进程执行前应让已有的读/写进程退出</li>
<li><strong>信号量</strong>：count(记录当前读者数量)、mutex(互斥访问count)、rw(读写互斥)</li>
<li>当对<strong>count</strong>进行操作时，需要分别设置一对<strong>PV</strong>操作夹紧<code>cout++</code>或<code>count--</code></li>
<li><strong>写进程优先</strong>：增加信号量<strong>w</strong>，写进程请求访问时，读进程不再增加</li>
</ul></li>
<li>哲学家进餐
<ul>
<li>可能发生死锁</li>
<li>解决方案：
<ul>
<li>减少同时就餐的人数：破坏循环等待条件</li>
<li>当左右两边都有筷子时才允许拿筷子（一次只允许一个人拿筷子）：破坏请求与保持</li>
<li>奇数号哲学家拿左边的筷子，偶数号拿右边的筷子：破坏循环等待条件</li>
</ul></li>
</ul></li>
<li>吸烟者*
<ul>
<li>供应者与三个吸烟者是同步关系（三个信号量表示三种不同资源，先V后P）</li>
<li>三个吸烟者是互斥关系（一个信号量，轮流抽烟）</li>
</ul></li>
</ol>
<h3 id="死锁">死锁</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611141713247.png" alt="image-20230611141713247">
<figcaption aria-hidden="true">image-20230611141713247</figcaption>
</figure>
<h4 id="死锁产生的必要条件">死锁产生的必要条件</h4>
<p>只要其中一个条件不满足，死锁就不会发生：</p>
<ol type="1">
<li><strong>互斥条件</strong>：一段时间内某资源只能有一个进程使用</li>
<li><strong>不剥夺条件</strong>：只能是主动释放，别的进程拿不走</li>
<li><strong>请求并保持条件</strong>：进程已经保持了一个资源，但又提出新的资源请求，对自己的资源保持不放</li>
<li><strong>循环等待条件</strong>（循环等待未必导致死锁，但死锁一定循环等待）：循环等待链</li>
</ol>
<h4 id="死锁的处理策略">死锁的处理策略</h4>
<ol type="1">
<li><p>死锁预防：破坏四个必要条件</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611144023065.png" alt="image-20230611144023065">
<figcaption aria-hidden="true">image-20230611144023065</figcaption>
</figure></li>
<li><p>死锁避免：防止系统进入不安全状态</p>
<ul>
<li><p>安全状态：以某种顺序执行进程，这些进程组成的序列称为安全序列</p></li>
<li><p><strong>银行家算法</strong>：可用资源数、最大需求数(某一进程某一类资源)、已分配资源数、还需资源数</p>
<blockquote>
<p><strong>不会限制申请资源的顺序，但是会限制分配资源的顺序</strong></p>
<p><strong>不能</strong>用于<strong>判断系统是否处于死锁状态</strong></p>
</blockquote></li>
</ul></li>
<li><p>死锁检测与解除</p>
<ul>
<li><strong>分配资源时不采取任何措施</strong></li>
<li>资源分配图：
<ul>
<li><strong>圆圈表示进程</strong>，<strong>框</strong>中的圆圈表示一类<strong>资源</strong></li>
<li>框-&gt;圆圈：分配边；圆圈-&gt;框：请求边</li>
<li>若能消去所有边，则称该图可完全简化</li>
</ul></li>
<li><strong>死锁定理</strong>：死锁的条件是当且仅当该资源分配图不可完全简化</li>
<li>死锁解除：
<ul>
<li>资源剥夺法：<strong>挂起</strong>某些死锁进程并<strong>抢夺其资源</strong>，同时需要防止饥饿</li>
<li>撤销进程法：<strong>强制撤销</strong>部分死锁进程并<strong>抢夺其资源</strong>（撤销原则：优先级、代价高低）</li>
<li>进程回退法：进程<strong>回退</strong>时<strong>自愿释放资源</strong></li>
</ul></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230611151536617.png" alt="image-20230611151536617">
<figcaption aria-hidden="true">image-20230611151536617</figcaption>
</figure></li>
</ol>
<h2 id="内存管理">内存管理</h2>
<h3 id="内存管理基本概念">内存管理基本概念</h3>
<h4 id="程序的链接与装入">程序的链接与装入</h4>
<ol type="1">
<li><strong>链接</strong></li>
</ol>
<ul>
<li>静态链接：程序运行前，将各目标模块及其所需库函数链接成一个完整的装配模块</li>
<li>装入时动态链接（装入内存）：边装入边链接</li>
<li>运行时动态链接：加快装入过程，节省内存空间</li>
</ul>
<blockquote>
<p>链接：在链接阶段，编译器将生成的目标代码与程序所需的库函数和其他目标文件进行链接，<strong>形成</strong>最终的可执行文件和该文件的==逻辑地址==（虚拟地址）。</p>
<p>装载：在装载阶段，操作系统将可执行文件从磁盘加载到物理内存中，并将程序的逻辑地址（虚拟地址）转换为<strong>物理地址</strong>。这个过程由地址变换机构（如页表或段表）完成。</p>
</blockquote>
<ol start="2" type="1">
<li><strong>装入</strong></li>
</ol>
<ul>
<li>绝对装入：只适用于单道程序环境</li>
<li>可重定位装入（<strong>静态重定位</strong>）：一次分配所需的全部内存空间(连续空间)，装入时地址就转换成了物理地址</li>
<li>动态运行时装入（<strong>动态重定位</strong>）：程序执行时才进行地址转换，需要重定位寄存器；<strong>可分配不连续的空间</strong>；便于程序段的共享</li>
</ul>
<blockquote>
<p><strong>逻辑</strong>地址<strong>转变</strong>为<strong>物理</strong>地址：<strong>重定位</strong></p>
</blockquote>
<h4 id="进程的内存映像进程映像">进程的内存映像（进程映像）</h4>
<p>从低地址往高地址依次如下：</p>
<ul>
<li>代码段：只读，被多个进程共享</li>
<li>数据段：包括全局变量和静态变量</li>
<li>进程控制块：PCB</li>
<li>堆：向高地址增长</li>
<li>栈：从高地址往低地址增长</li>
<li>内核空间被所有进程共享</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310121939069.png" alt="image-20231012193932301" style="zoom:80%;"></p>
<h4 id="内存保护">内存保护</h4>
<p>确保每个进程有独立的内存空间，两种方法：</p>
<ul>
<li>设置一对<strong>上、下限寄存器</strong>，存放上下限地址，判断有无越界</li>
<li>采用<strong>重定位寄存器</strong>(基地址寄存器)和<strong>界地址寄存器</strong>(限长寄存器)：
<ul>
<li>界地址寄存器：最大逻辑地址（判断是否越界）</li>
<li>重定位寄存器：最小物理地址（若没越界则加上重定位寄存器的值转换成物理地址）</li>
</ul></li>
</ul>
<blockquote>
<p>一个系统设置一个重定位寄存器</p>
</blockquote>
<h4 id="内存共享">内存共享</h4>
<p><strong>可重入代码</strong>（纯代码）是一种允许<strong>多个</strong>进程<strong>同时访问</strong>但<strong>不允许修改</strong>的代码</p>
<h3 id="连续分配管理方式">连续分配管理方式</h3>
<h4 id="单一连续分配">单一连续分配</h4>
<p>用户区内存仅有一道用户程序（无外部碎片，有内部碎片）</p>
<h4 id="固定分区分配">固定分区分配</h4>
<ul>
<li><p>有内部碎片</p></li>
<li><p>分区大小相等</p></li>
<li><p>分区大小不等</p></li>
</ul>
<h4 id="动态分区分配">动态分区分配</h4>
<p>又称可变分区分配：有<strong>外部碎片</strong>——使用紧凑技术</p>
<ul>
<li><strong>首次</strong>适应算法：按<strong>地址</strong>递增查找（通常最快、最好，增加了开销）</li>
<li><strong>邻近</strong>适应算法：从上次结束的位置开始继续查找</li>
<li><strong>最佳</strong>适应算法：按<strong>容量</strong>递增(<strong>从小到大</strong>)次序查找（性能差,<strong>最容易</strong>、产生<strong>最多</strong>的外部碎片）</li>
<li><strong>最坏</strong>适应算法：按<strong>容量</strong>递减(<strong>从大到小</strong>)次序查找（性能差）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230614092453046.png" alt="image-20230614092453046">
<figcaption aria-hidden="true">image-20230614092453046</figcaption>
</figure>
<blockquote>
<p>操作系统实现<strong>分区</strong>存储管理的代价最小（不需要设置额外的数据结构）</p>
</blockquote>
<h3 id="非连续分配管理">非连续分配管理</h3>
<h4 id="基本分页存储管理">基本分页存储管理</h4>
<ol type="1">
<li>基本概念
<ul>
<li>逻辑地址结构：页号 + 页内地址</li>
<li>页表（慢表）：存放在内存中（页号可省略）</li>
<li>分页管理的地址空间是<strong>一维</strong>的（给出地址就能算出）</li>
<li>页表项：页号(可省略) + <strong>物理内存的块号</strong></li>
</ul></li>
<li><strong>基本地址变换机构</strong>
<ul>
<li>页表寄存器<strong>PTR</strong>：用于存放页表在内存中的起始地址<strong>F</strong>和页表长度<strong>M</strong></li>
<li>过程：进程<strong>未执行时</strong>，<strong>F</strong>和<strong>M</strong>存放在<strong>PCB</strong>中，进程<strong>被调用时</strong>则将<strong>F</strong>和<strong>M</strong>装入<strong>PTR</strong>中</li>
<li><strong>页号P &lt;
页表长度M</strong>（页号从0开始），否则产生越界中断</li>
<li>地址转换过程由硬件自动完成</li>
</ul>
<blockquote>
<p><strong>越界检查</strong>在<strong>查询页表之前</strong></p>
</blockquote></li>
<li>具有快表的地址变换机构
<ul>
<li>快表——高速缓冲存储器：相联存储器（TLB）（注：这里可以联系Cache全相联映射）</li>
<li><strong>过程</strong>：
<ol type="1">
<li>CPU给出逻辑地址后，硬件转换地址后将页号送入TLB，将此页号与TLB中页号进行比较；</li>
<li>若未找到匹配的页号，则需要访问主存中的页表，读出页表项后同时将该页表项存入TLB</li>
</ol></li>
<li>注：快表和慢表可同时查找（具体按题目来）</li>
</ul></li>
<li>两级页表
<ul>
<li>页表需要占用连续空间，因此采用二级页表压缩页表，提高内存空间利用率</li>
<li>顶级页表最多只能有一个页面</li>
</ul></li>
</ol>
<h4 id="基本分段存储管理">基本分段存储管理</h4>
<ol type="1">
<li>分段
<ul>
<li>按照程序逻辑划分</li>
<li>段内连续，段间不要求连续</li>
<li>地址空间是<strong>二维</strong>的（需要显式给出<strong>段号</strong>和<strong>段内偏移</strong>才能计算出）</li>
</ul></li>
<li>段表
<ul>
<li>段表项：段号(可省略) + <strong>段长</strong> +
本段在内存中的<strong>始址</strong></li>
</ul></li>
<li>地址变换机构
<ul>
<li>设置段表寄存器（同分页管理）</li>
</ul></li>
<li>段的保护和共享
<ul>
<li>可重入代码为只读（不属于临界资源）</li>
<li>分段管理需要判断<strong>段号是否越界以及偏移量是否越界</strong>（分页管理只需判断页号是否越界）</li>
</ul></li>
</ol>
<h4 id="基本段页式存储管理">基本段页式存储管理</h4>
<ul>
<li>先分段再分页（段内分页）</li>
<li>逻辑地址结构：段号 + 页号 + 页内偏移量</li>
<li>段表项结构：段号(可省略) + 页表长度 + 页表起始地址</li>
</ul>
<blockquote>
<p>段表寄存器和页表寄存器作用：</p>
<ul>
<li>寻址</li>
<li>判断是否越界</li>
</ul>
</blockquote>
<h3 id="虚拟内存管理">虚拟内存管理</h3>
<p>虚拟存储器大小由地址结构决定（地址寄存器位数）</p>
<h4 id="基本概念-2">基本概念</h4>
<ol type="1">
<li>局部性原理
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul></li>
<li>虚拟存储器特征
<ul>
<li>仅将当前要运行的少数页面或段先装入内存，其余部分留在外存</li>
<li>特征：
<ul>
<li>多次性</li>
<li>对换性</li>
<li>虚拟性</li>
</ul></li>
</ul></li>
<li>虚拟内存技术的实现
<ul>
<li>三种方式：
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul></li>
<li>硬件支持：
<ul>
<li>一定容量的内存和外存</li>
<li>页表机制</li>
<li>中断机构（缺页则触发中断）</li>
<li>地址变换机构</li>
</ul></li>
</ul></li>
</ol>
<h4 id="请求分页管理">请求分页管理</h4>
<p>在基本分页系统基础上增加<strong>请求调页</strong>功能和<strong>页面置换</strong>功能。</p>
<ol type="1">
<li>页表机制
<ul>
<li>页表项：<strong>|</strong>页号<strong>|</strong>物理块号<strong>|</strong>状态位P<strong>|</strong>访问字段A<strong>|</strong>修改位M<strong>|</strong>外存地址<strong>|</strong></li>
<li>字段说明：
<ul>
<li>状态位P：有无调入主存（有效位？）</li>
<li>访问字段A：访问次数或未访问的时间 (置换算法)</li>
<li>修改位M：是否修改</li>
<li>外存地址</li>
</ul></li>
</ul></li>
<li>缺页中断机构（内中断/故障）
<ul>
<li>在指令执行期间（不是指令执行完）</li>
<li>一条指令执行期间，可能产生多次中断</li>
</ul></li>
<li>地址变换机构
<ul>
<li>在换出页面时判断该页是否被修改过（是否需要写回外存）</li>
<li>访问页面时注意修改访问位</li>
</ul></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230615110027586.png" alt="image-20230615110027586">
<figcaption aria-hidden="true">image-20230615110027586</figcaption>
</figure>
<blockquote>
<p>请求分页与基本分页的区别：前者不需要将作业一次性装入内存，后者需要</p>
</blockquote>
<h4 id="页框分配">页框分配</h4>
<ol type="1">
<li><p>驻留集</p>
<ul>
<li>给一个进程分配的<strong>物理页框的集合</strong>就是这个进程的驻留集</li>
<li>过多：驻留在主存的进程就越少</li>
<li>过少：缺页率提高</li>
</ul></li>
<li><p>内存分配策略</p>
<ul>
<li>固定分配局部置换：每个进程分配一定数目的物理块，只从本进程的页面中进行置换</li>
<li>可变分配全局置换：每个进程的空间大小可变，从<strong>空闲物理块</strong>或其他进程的页面进行置换</li>
<li>可变分配局部置换：只从当前进程的页面中置换</li>
</ul>
<blockquote>
<p>局部置换：缺页时，只能从自己的页面中进行置换</p>
<p>全局置换：缺页时，可对系统的空闲物理块或其他进程持有的物理块进行置换</p>
<p>注：<strong>没有</strong>固定分配全局置换</p>
</blockquote></li>
<li><p>物理块分配（固定分配策略）</p>
<ul>
<li>平均分配算法</li>
<li>按比例分配算法</li>
<li>优先权分配算法</li>
</ul></li>
<li><p>调入页面的时机</p>
<ul>
<li>预调页策略（运行前）：根据局部性原理，以预测为基础；用于进程的首次调入，由程序员指定调入的部分</li>
<li>请求调页策略（运行期间）：要访问的页面不在内存，则提出请求（大多采用此策略）</li>
</ul></li>
<li><p>从何处调入</p>
<p>对换区连续分配；文件区离散分配</p>
<ul>
<li><p>系统拥有足够的对换区空间</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310052033527.png" alt="image-20231005203318622" style="zoom:50%;"></p></li>
<li><p>系统缺少足够的对换区空间</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310052035565.png" alt="image-20231005203500809" style="zoom:50%;"></p></li>
<li><p>Unix 方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310052036139.png" alt="image-20231005203558530" style="zoom:50%;"></p></li>
</ul></li>
</ol>
<h4 id="页面置换算法">页面置换算法</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230616112047948.png" alt="image-20230616112047948">
<figcaption aria-hidden="true">image-20230616112047948</figcaption>
</figure>
<ul>
<li><p>最佳置换算法（OPT）：无法实现</p></li>
<li><p>先进先出页面置换算法（FIFO）：<strong>Belady异常</strong>（独有）——分配的物理块数增加缺页率不减反增</p></li>
<li><p>最近最久未使用置换算法（LRU）：<strong>==LRU位==记录未被使用的次数</strong>（被使用时则清0），选择最大的置换出去</p></li>
<li><p>时钟置换算法（CLOCK）</p>
<p>（1）简单的CLOCK置换算法（<strong>访问位</strong>）：（注意区分<strong>访问</strong>和<strong>扫描</strong>的区别）</p>
<ul>
<li><p>==访问==：初次调入主存和<strong>访问</strong>时访问位置1</p></li>
<li><p>==扫描==：当需要进行<strong>替换</strong>时替换指针从队首进行<strong>扫描</strong>（指针转动）</p>
<p><strong>遇0</strong>则进行<strong>替换</strong>并将访问位<strong>置1</strong>并<strong>后移</strong>指针；<strong>遇1置0</strong>。</p></li>
</ul>
<p>（2）改进型CLOCK置换算法（<strong>访问位</strong>、<strong>修改位</strong>）：四种组合</p>
<ul>
<li>替换顺序：<strong>最多</strong>进行<strong>四轮</strong>扫描
<ul>
<li>第一轮：查找 (0,0)</li>
<li>第二轮：查找 (0,1)</li>
<li>第三轮：查找 (0,0) ——因为（1,0）经过第二轮会被置为（0,0）</li>
<li>第四轮：查找 (0,1) ——因为（1,1）经过第三轮会被置为（0,1）</li>
</ul></li>
</ul>
<blockquote>
<p>页面置换算法原则：尽可能保留访问过的页面，淘汰<strong>未访问</strong>的页面</p>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230616111923439.png" alt="image-20230616111923439">
<figcaption aria-hidden="true">image-20230616111923439</figcaption>
</figure></li>
</ul>
<blockquote>
<p>LFU和LRU区别：看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sddai/p/9739900.html">评论区</a></p>
<p><strong>页缓冲队列</strong>：被淘汰的页面的集合，暂时不写回磁盘，<strong>影响页面置换，不影响缺页率</strong></p>
</blockquote>
<h4 id="抖动与工作集">抖动与工作集</h4>
<ol type="1">
<li>抖动
<ul>
<li>频繁进行页面调度</li>
<li>根本原因：系统中同时运行的进程太多，分配给每个进程的物理块太少</li>
<li>解决方案：增加内存；减少进程数量；改变算法</li>
</ul></li>
<li>工作集（2016真题 P209-T38）
<ul>
<li>在某段时间内，进程要访问（<strong>访问过的？</strong>）的页面集合</li>
<li>工作集大小<strong>不大于</strong>驻留集的大小</li>
<li>工作集窗口大小 &gt; 工作集大小</li>
</ul></li>
</ol>
<h3 id="内存映射文件-mmap">内存映射文件 MMAP</h3>
<h4 id="传统文件访问方式">传统文件访问方式</h4>
<ul>
<li>open系统调用——打开文件</li>
<li>seek系统调用——将读写指针移动到目标位置</li>
<li>read系统调用——从指针处读入若干数据（从磁盘读入内存）</li>
<li>write系统调用——写回磁盘</li>
</ul>
<h4 id="mmap">MMAP</h4>
<ul>
<li><p>open系统调用——打开文件</p></li>
<li><p>mmap系统调用——将文件映射到虚拟地址空间</p></li>
<li><p>以访问内存的方式访问文件数据（无需read、write系统调用）</p></li>
<li><p>进程关闭文件后，由操作系统自动将修改的数据写回磁盘</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310061915931.png" alt="image-20231006191456852">
<figcaption aria-hidden="true">image-20231006191456852</figcaption>
</figure></li>
<li><p>便于实现共享内存</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310061917315.png" alt="image-20231006191658361" style="zoom:80%;"></p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230626141517691.png" alt="image-20230626141517691">
<figcaption aria-hidden="true">image-20230626141517691</figcaption>
</figure>
<h2 id="文件管理">文件管理</h2>
<h3 id="文件系统">文件系统</h3>
<p>Unix中输入/输出设备是特殊文件</p>
<h4 id="基本概念-3">基本概念</h4>
<ol type="1">
<li>文件结构（自底而上）：</li>
</ol>
<ul>
<li>数据项：最低级</li>
<li>记录：一组相关的数据项的集合</li>
<li>文件：有结构；无结构（字符流）</li>
</ul>
<ol start="2" type="1">
<li>磁盘块/物理块/块</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230619171415124.png" alt="image-20230619171415124">
<figcaption aria-hidden="true">image-20230619171415124</figcaption>
</figure>
<h4 id="文件控制块和索引结点">文件控制块和索引结点</h4>
<ol type="1">
<li><strong>文件控制块（FCB）</strong>
<ul>
<li>基本信息：文件名、文件位置、逻辑结构、物理结构等</li>
<li>存取控制信息：不同用户的存取权限</li>
<li>使用信息：创建时间，修改时间</li>
<li>一个FCB就是一个文件目录项</li>
</ul>
<blockquote>
<p>最重要、最基本是文件名和文件存放的物理地址</p>
</blockquote></li>
<li><strong>索引结点（inode）</strong>
<ul>
<li>文件描述信息单独形成索引结点</li>
<li>文件目录的目录项结构：<strong>文件名</strong> <strong>+</strong>
指向该文件对应<strong>inode</strong>的<strong>指针</strong></li>
<li><strong>磁盘索引结点</strong>：
<ul>
<li>文件类型</li>
<li>存取权限</li>
<li>文件<strong>物理地址</strong>（盘块编号）</li>
<li>文件长度</li>
<li>文件链接计数：系统中指向该文件名的指针</li>
<li>文件存取时间</li>
</ul></li>
</ul>
<blockquote>
<p><strong>目录项</strong>：也就是
<em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</p>
<p><strong>目录</strong>：是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p>
<p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。</p>
</blockquote></li>
</ol>
<h4 id="文件的操作">文件的操作</h4>
<ul>
<li>创建文件——create</li>
<li>写文件——write</li>
<li>读文件——read</li>
<li>重新定位文件</li>
<li>删除文件——delete</li>
<li>关闭文件——close</li>
</ul>
<h4 id="文件的逻辑结构">文件的逻辑结构</h4>
<ol type="1">
<li><p>无结构文件（流式文件）</p>
<p>由一系列二进制流和字符流组成，例如文本文档</p></li>
<li><p>有结构文件（记录式文件）：可分为<strong>定长记录</strong>和<strong>可变长记录</strong></p>
<ul>
<li><p><strong>顺序文件</strong>：采用<strong>顺序存储</strong>或<strong>链式存储</strong></p>
<p>按记录顺序分类：</p>
<p>（1）<strong>串结构</strong>（按存入时间的先后排序）</p>
<p>（2）<strong>顺序结构</strong>（按关键字排序，可用<strong>折半查找</strong>）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618172821790.png" alt="image-20230618172821790">
<figcaption aria-hidden="true">image-20230618172821790</figcaption>
</figure></li>
<li><p><strong>索引文件</strong>：方便查找可变长记录文件</p>
<ul>
<li>索引表的表项物理上连续存放</li>
<li>索引表本身是<strong>定长记录的顺序文件</strong></li>
<li>索引表项包括相应<strong>记录的长度</strong>和<strong>逻辑起始地址(指针)</strong></li>
</ul></li>
</ul></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618173841080.png" alt="image-20230618173841080">
<figcaption aria-hidden="true">image-20230618173841080</figcaption>
</figure>
<ul>
<li><p><strong>索引顺序文件</strong></p>
<ul>
<li><p>将记录分成若干组，一组对应一个索引表项</p></li>
<li><p>表项包括：记录的<strong>关键字值</strong>和指向该记录的<strong>指针</strong>(起始地址)</p></li>
<li><p><strong>计算查找次数</strong>：</p>
<p>N 条记录分为 √N 组，则索引表中有 √N 条表项，需要查找<strong>√N/2 +
√N/2 = √N</strong> 次</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618174541633.png" alt="image-20230618174541633">
<figcaption aria-hidden="true">image-20230618174541633</figcaption>
</figure></li>
<li><p><strong>散列文件</strong></p>
<ul>
<li>根据记录的键值通过<strong>散列函数</strong>计算出物理地址</li>
</ul></li>
</ul>
<h4 id="文件的物理结构">文件的物理结构</h4>
<ol type="1">
<li><p><strong>连续分配</strong>：磁盘上占有连续的块</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>顺序读/写速度最快</li>
<li>顺序访问：需要从起始块号开始访问</li>
<li>直接访问（<strong>随机访问</strong>）：直接访问目标块</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li><strong>不方便拓展</strong></li>
<li>产生磁盘碎片(可用紧凑技术解决)</li>
</ul></li>
</ul></li>
<li><p><strong>链接分配</strong>：离散</p>
<ul>
<li><p><strong>隐式链接</strong>（默认）</p>
<ul>
<li>缺点：只支持<strong>顺序访问</strong>，不支持随机访问</li>
<li>优点：<strong>方便拓展</strong>文件；不会产生碎片；外存利用率高</li>
</ul></li>
<li><p><strong>显式链接</strong>（<strong>FAT</strong>）</p>
<ul>
<li><p>将用于链接各文件物理块的<strong>指针</strong>显式地存放在<strong>文件分配表(FAT)</strong>中</p></li>
<li><p>目录中<strong>只需记录起始块号</strong></p></li>
<li><p>一个磁盘设置一张FAT表</p></li>
<li><p>FAT<strong>常驻内存</strong></p></li>
<li><p>支持<strong>随机访问</strong>（只需在<strong>内存中查表</strong>找到对应的物理块号)</p>
<p>(不需要按顺序访问磁盘找对应的块）</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310072000121.png" alt="image-20231007195959297"></p></li>
</ul></li>
<li><p><strong>索引分配</strong>：离散</p>
<ul>
<li>索引块：存放索引表的磁盘块</li>
<li>数据块：存放文件数据的磁盘块</li>
<li>目录项中需要记录索引块</li>
<li>优点：<strong>适合随机访问</strong>、<strong>易于文件扩展</strong></li>
</ul></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230619185604937.png" alt="image-20230619185604937">
<figcaption aria-hidden="true">image-20230619185604937</figcaption>
</figure>
<p>索引表太大一个索引块装不下，以下是解决方案：</p>
<ul>
<li><p>链接方案：将多个索引块链接起来——效率低</p></li>
<li><p>多层索引：多级索引</p>
<figure>
<img src="https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191113104555629-75420175.png" alt="img2018">
<figcaption aria-hidden="true">img2018</figcaption>
</figure></li>
<li><p><strong>混合索引</strong>：多种分配方式混合（直接索引、一级索引、二级索引）——存放在<strong>索引结点</strong>中</p></li>
</ul>
<h4 id="逻辑结构vs物理结构">逻辑结构VS物理结构</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230626151416856.png" alt="image-20230626151416856">
<figcaption aria-hidden="true">image-20230626151416856</figcaption>
</figure>
<h3 id="目录">目录</h3>
<p>FCB（文件控制块）的有序集合</p>
<h4 id="单级目录结构">单级目录结构</h4>
<ul>
<li>不允许文件重名</li>
<li>不适用于多用户操作系统</li>
</ul>
<h4 id="两级目录结构">两级目录结构</h4>
<ol type="1">
<li>主文件目录：记录用户名及其用户文件目录的位置</li>
<li>用户文件目录</li>
</ol>
<p>缺点：不能对文件进行分类</p>
<h4 id="多级目录结构树形目录结构">多级目录结构（树形目录结构）</h4>
<ol type="1">
<li>绝对路径：从根目录出发</li>
<li>相对路径：从当前目录出发，磁盘IO次数减少</li>
</ol>
<p>缺点：不便于实现文件共享</p>
<h4 id="无环图目录结构">无环图目录结构</h4>
<ul>
<li>在树形目录结构上增加了指向同一结点的有向边，形成有向无环图</li>
<li>不同文件名可指向同一文件</li>
<li>每个共享结点设置一个<strong>共享计数器</strong></li>
<li>用户进行删除时，共享计数器减1，并删去当前用户目录表项，不直接删结点</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230618190017537.png" alt="image-20230618190017537">
<figcaption aria-hidden="true">image-20230618190017537</figcaption>
</figure>
<h3 id="外存空闲空间管理">外存空闲空间管理</h3>
<h4 id="存储空间的划分">存储空间的划分</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310081819554.png" alt="image-20231008181854968">
<figcaption aria-hidden="true">image-20231008181854968</figcaption>
</figure>
<h4 id="管理方法">管理方法</h4>
<ol type="1">
<li><p><strong>空闲表法</strong></p>
<ul>
<li>适用于<strong>连续分配</strong></li>
<li>与内存管理的<strong>动态分区分配</strong>类似，可使用相同的算法（最佳适应、首次适应等）</li>
<li>回收时，注意表项的合并问题：四种情况（前后是否有空闲区）</li>
</ul></li>
<li><p><strong>空闲链表法</strong></p>
<ul>
<li>空闲盘块链：从链头摘下盘块进行分配，回收的盘块挂到链尾</li>
<li>空闲盘区链：采用最佳适应等算法找到合适的盘区进行分配</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310081837416.png" alt="image-20231008183703447">
<figcaption aria-hidden="true">image-20231008183703447</figcaption>
</figure></li>
<li><p><strong>位示图法</strong></p>
<ul>
<li>字号和位号的组合对应一个盘块号</li>
<li>“0”表示空闲</li>
<li>注意还是序号是0还是1</li>
</ul></li>
<li><p><strong>成组链接法</strong>（Unix系统）</p>
<ul>
<li>超级块存放空闲块号</li>
<li>每组第一个盘块存放盘块信息：前两块分别存放下一组块数和指向下一组的指针</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310081936430.png" alt="image-20231008193612340">
<figcaption aria-hidden="true">image-20231008193612340</figcaption>
</figure></li>
</ol>
<blockquote>
<p>文件分配表(<strong>FAT</strong>)也可以对空闲磁盘块进行管理（负数表项表示空闲）</p>
</blockquote>
<h3 id="文件的操作-1">文件的操作</h3>
<h4 id="打开文件open系统调用">打开文件（open系统调用）</h4>
<ul>
<li><p>不是直接将数据放入内存</p></li>
<li><p>找到对应的目录文件</p></li>
<li><p>在目录中找到对应的目录项</p></li>
<li><p>将目录项复制到<strong>内存</strong>中的<strong>系统打开文件表</strong>中，并在进程打开文件表中增加表项(指向系统打开文件表)，将对应表项的编号fd（文件描述符）返回给用户</p></li>
</ul>
<blockquote>
<p>注意系统的打开文件表和每个进程的打开文件表（P232中间）</p>
<p>打开文件表包含的文件信息：</p>
<ul>
<li><strong>读写指针</strong>：对文件的读写操作进行到的位置</li>
<li>访问权限：读/写</li>
</ul>
</blockquote>
<h4 id="关闭文件">关闭文件</h4>
<ul>
<li>打开计数器减1，若为0则删除打开文件表中对应的表项</li>
<li>回收内存空间等资源</li>
</ul>
<h4 id="读文件">读文件</h4>
<ul>
<li>指明文件在打开文件表中的索引号</li>
<li>指明读入多少数据</li>
<li>指明读入的数据放在内存的什么位置（外存-&gt;内存）</li>
</ul>
<h4 id="写文件">写文件</h4>
<ul>
<li>同读文件</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627165447895.png" alt="image-20230627165447895">
<figcaption aria-hidden="true">image-20230627165447895</figcaption>
</figure>
<h3 id="文件共享">文件共享</h3>
<h4 id="硬链接">硬链接</h4>
<ul>
<li>基于索引结点</li>
<li>不同用户的目录项指向同一个索引结点</li>
<li><strong>链接计数count</strong></li>
</ul>
<h4 id="软链接">软链接</h4>
<ul>
<li>创建Link型(快捷方式)文件——记录文件存放路径</li>
<li>共享文件被删除，Link型文件<strong>依然存在</strong>，但是会查找失败</li>
<li>软链接索引结点中的<strong>引用计数值</strong>应该<strong>恒为1</strong></li>
</ul>
<blockquote>
<p>建立符号链接时，引用计数<strong>不是复制原文件</strong>而是<strong>必为1</strong></p>
</blockquote>
<h3 id="文件保护">文件保护</h3>
<h4 id="口令保护">口令保护</h4>
<ul>
<li>将用户提供的口令与<strong>FCB或索引结点</strong>中的口令进行对比</li>
<li>优点：开销小</li>
<li>缺点：口令存放系统内部，不够安全</li>
</ul>
<h4 id="加密保护">加密保护</h4>
<ul>
<li>用密码对文件进行加密，用户提供密码解密</li>
<li>优点：保密性强</li>
<li>缺点：花费时间</li>
</ul>
<h4 id="访问控制">访问控制</h4>
<ul>
<li><p>增加<strong>访问控制列表</strong></p></li>
<li><p>对访问者进行分组</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627171029546.png" alt="image-20230627171029546">
<figcaption aria-hidden="true">image-20230627171029546</figcaption>
</figure>
<h3 id="文件系统结构">文件系统结构</h3>
<h4 id="王道视频参考国内教材">王道视频（参考国内教材）</h4>
<ul>
<li>用户接口：提供功能接口，处理用户的系统调用请求</li>
<li>文件目录系统：根据文件路径找到FCB或索引结点</li>
<li>存取控制块：权限验证</li>
<li>逻辑文件系统与文件信息缓冲区：查找记录号（索引表项）对应的逻辑地址</li>
<li>物理文件系统：逻辑地址-&gt;物理地址</li>
<li>辅助分配模块：分配回收空间</li>
<li>设备管理模块：与硬件交互</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627171525102.png" alt="image-20230627171525102">
<figcaption aria-hidden="true">image-20230627171525102</figcaption>
</figure>
<h4 id="王道书参考国外教材">王道书（参考国外教材）</h4>
<p>从下到上</p>
<ul>
<li>I/O控制：设备驱动程序和中断处理程序，与硬件交互</li>
<li>基本文件系统：发送通用命令读/写物理块；管理内存缓冲区</li>
<li>文件组织模块：逻辑地址-&gt;物理地址</li>
<li>逻辑文件系统：管理元数据信息，管理FCB</li>
</ul>
<h3 id="文件系统布局">文件系统布局</h3>
<h4 id="文件系统在磁盘中的结构">文件系统在磁盘中的结构</h4>
<p><strong>一个磁盘可能分为多个分区，==每个分区有一个独立的文件系统==</strong></p>
<ul>
<li>主引导记录（MBR）</li>
<li>引导块</li>
<li>超级块：<strong>文件系统的信息</strong>，块的信息，管理空闲块</li>
<li>空闲块信息（位示图）</li>
<li>i结点（索引结点）</li>
<li>根目录</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310091956671.png" alt="image-20231009195611086">
<figcaption aria-hidden="true">image-20231009195611086</figcaption>
</figure>
<h4 id="文件系统在内存中的结构">文件系统在内存中的结构</h4>
<ul>
<li>目录缓存</li>
<li>系统打开文件表</li>
<li>进程打开文件表：包含指向系统打开文件表项的索引；返回文件描述符fd</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310092004562.png" alt="image-20231009200456313">
<figcaption aria-hidden="true">image-20231009200456313</figcaption>
</figure>
<h3 id="虚拟文件系统-vfs">虚拟文件系统 VFS</h3>
<ul>
<li><p>四种<strong>对象类型</strong>：超级块对象、索引结点对象、目录项对象、文件对象</p></li>
<li><p>向<strong>上层</strong>用户进程提供<strong>统一接口</strong></p></li>
<li><p>要求<strong>下层</strong>的文件系统实现某些规定的函数功能</p></li>
<li><p>不同文件系统的文件数据结构不同，VFS通过新建<strong>vnode</strong>用<strong>统一</strong>的数据结构保存不同文件系统信息</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627173110387.png" alt="image-20230627173110387">
<figcaption aria-hidden="true">image-20230627173110387</figcaption>
</figure>
<ul>
<li><p><strong>函数功能指针</strong>指向对应文件系统提供的函数功能。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627173215638.png" alt="image-20230627173215638">
<figcaption aria-hidden="true">image-20230627173215638</figcaption>
</figure></li>
</ul>
<h3 id="文件系统挂载安装装载">文件系统挂载/安装/装载</h3>
<ul>
<li>函数地址列表：具体函数实现的代码的地址（open、read等操作）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230627173523012.png" alt="image-20230627173523012">
<figcaption aria-hidden="true">image-20230627173523012</figcaption>
</figure>
<h2 id="io管理">I/O管理</h2>
<h3 id="io设备的概念和分类">I/O设备的概念和分类</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628115019184.png" alt="image-20230628115019184">
<figcaption aria-hidden="true">image-20230628115019184</figcaption>
</figure>
<h3 id="io控制器设备控制器">I/O控制器（设备控制器）</h3>
<h4 id="io接口-1">I/O接口</h4>
<ol type="1">
<li>设备控制器与CPU的接口：数据线、地址线、控制线</li>
<li>设备控制器与设备的接口：数据、控制、状态三种信号</li>
<li>I/O逻辑：对I/O命令进行译码</li>
</ol>
<h4 id="io端口">I/O端口</h4>
<p>可被CPU访问的<strong>寄存器</strong></p>
<ul>
<li>数据寄存器</li>
<li>状态寄存器</li>
<li>控制寄存器</li>
</ul>
<blockquote>
<ol type="1">
<li>独立编址</li>
<li>统一编址</li>
</ol>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628130640708.png" alt="image-20230628130640708">
<figcaption aria-hidden="true">image-20230628130640708</figcaption>
</figure>
<h3 id="io控制方式-1">I/O控制方式</h3>
<h4 id="程序直接控制方式轮询">程序直接控制方式（轮询）</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628141533645.png" alt="image-20230628141533645">
<figcaption aria-hidden="true">image-20230628141533645</figcaption>
</figure>
<h4 id="中断驱动方式">中断驱动方式</h4>
<p>详见计组</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628144406279.png" alt="image-20230628144406279">
<figcaption aria-hidden="true">image-20230628144406279</figcaption>
</figure>
<h4 id="dma方式-1">DMA方式</h4>
<p>Direct Memory Access直接存储器存取：详见计组</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628145215569.png" alt="image-20230628145215569">
<figcaption aria-hidden="true">image-20230628145215569</figcaption>
</figure>
<h4 id="通道控制方式">通道控制方式</h4>
<ul>
<li>完成<strong>一组数据块</strong>的操作后发出中断信号</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628145457607.png" alt="image-20230628145457607">
<figcaption aria-hidden="true">image-20230628145457607</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230628145642162.png" alt="image-20230628145642162">
<figcaption aria-hidden="true">image-20230628145642162</figcaption>
</figure>
<blockquote>
<p>I/O <strong>通道</strong>接收要 CPU
发送来的这些信息之后，就可以从内存中找到并执行这个通道程序，即发送启动命令和一条条
I/O 命令<strong>给设备控制器</strong>；当对 I/O
设备的操作完成之后，通道向 CPU 发出中断信号，告诉 CPU
相应的操作已经完成。</p>
</blockquote>
<h3 id="io软件层次结构">I/O软件层次结构</h3>
<h4 id="用户层io软件">用户层I/O软件</h4>
<ul>
<li>库函数</li>
<li>实现用户交互</li>
</ul>
<h4 id="设备独立性软件">设备独立性软件</h4>
<ul>
<li>设备无关性</li>
<li>逻辑设备名映射成物理设备名（LUT——逻辑设备表）</li>
<li>向上提供同一的调用接口（例如<strong>系统调用</strong>）</li>
<li>设备的回收与分配</li>
<li><strong>将系统调用翻译成设备操作指令</strong></li>
</ul>
<h4 id="设备驱动程序">设备驱动程序</h4>
<ul>
<li>不同I/O设备的硬件特性不同，需要提供对应的驱动程序</li>
<li>I/O进程与设备控制器之间的通信程序</li>
<li>与硬件直接相关</li>
<li><strong>执行操作系统发出的I/O命令</strong></li>
</ul>
<h4 id="中断处理程序">中断处理程序</h4>
<ul>
<li>与硬件相连</li>
<li>保存中断进程的CPU环境</li>
<li>进程的上下文切换</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310111801642.png" alt="image-20231011180123879">
<figcaption aria-hidden="true">image-20231011180123879</figcaption>
</figure>
<h3 id="应用程序io接口">应用程序I/O接口</h3>
<h4 id="字符设备接口">字符设备接口</h4>
<ul>
<li>不可寻址</li>
<li>以字符为单位</li>
<li>传输速率低</li>
<li>get/put 系统调用</li>
</ul>
<h4 id="块设备接口">块设备接口</h4>
<ul>
<li>可寻址</li>
<li>以数据块为单位</li>
<li>read/write 系统调用</li>
</ul>
<h4 id="网络设备接口">网络设备接口</h4>
<ul>
<li>网络套接字接口</li>
<li>与其他计算机进行通信</li>
<li>socket 系统调用（指明协议：TCP/UDP）</li>
</ul>
<h4 id="阻塞非阻塞-io">阻塞/非阻塞 I/O</h4>
<ol type="1">
<li>阻塞I/O：
<ul>
<li>用户进行相关操作时，进程会被阻塞</li>
<li>I/O操作完成后唤醒进程</li>
</ul></li>
<li>非阻塞I/O
<ul>
<li>用户调用I/O操作时，不阻塞进程</li>
<li>通常以轮询的方式查询I/O操作是否完成</li>
</ul></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310111906617.png" alt="image-20231011190412534">
<figcaption aria-hidden="true">image-20231011190412534</figcaption>
</figure>
<h3 id="设备独立性软件-1">设备独立性软件</h3>
<h4 id="spooling技术">SPOOLing技术</h4>
<ul>
<li>用户层软件实现</li>
<li>用软件的方式模拟脱机技术</li>
<li><strong>输入/输出井</strong>用于模拟<strong>磁盘</strong></li>
<li><strong>输入缓冲区</strong>暂存输入设备送来的数据，然后再送入输入井（输入设备-&gt;缓冲区-&gt;输入井）</li>
<li><strong>输出缓冲区</strong>暂存输出井送来的数据，然后再送入输出设备（输出井-&gt;缓冲区-&gt;输出设备）</li>
</ul>
<blockquote>
<ol type="1">
<li><strong>输入进程</strong>（外围控制机）：数据流动
<ul>
<li>输入设备-&gt;输入缓冲区-&gt;输入井</li>
<li>CPU需要输入数据时，输入井-&gt;内存</li>
</ul></li>
<li><strong>输出进程</strong>（外围控制机）：数据流动
<ul>
<li>用户要求输出的数据：内存-&gt;输出井</li>
<li>输出设备空闲时，输出井-&gt;输出缓冲区-&gt;输出设备</li>
</ul></li>
</ol>
<p>可参考：https://www.cnblogs.com/liyaaixuexi/p/17352046.html</p>
</blockquote>
<h4 id="设备的分配与回收">设备的分配与回收</h4>
<h5 id="分类">分类</h5>
<ul>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备（SPOOLing技术）</li>
</ul>
<h5 id="策略">策略</h5>
<ul>
<li>原则：避免死锁</li>
<li>方式：
<ul>
<li>静态分配：破坏了“请求与保持”条件从而避免了死锁</li>
<li>动态分配：可能造成死锁</li>
</ul></li>
</ul>
<h5 id="安全性">安全性</h5>
<ul>
<li>安全分配方式：阻塞，破坏“请求与保持”条件；CPU和设备串行工作</li>
<li>不安全分配方式：一个进程可以同时操作多个设备，可能造成死锁</li>
</ul>
<h5 id="设备分配的数据结构">设备分配的数据结构</h5>
<ol type="1">
<li><strong>设备控制表</strong>（DCT）
<ul>
<li>一个设备一张DCT</li>
<li>记录设备情况</li>
</ul></li>
<li><strong>控制器控制表</strong>（COCT）
<ul>
<li>每个设备控制器一张COCT</li>
</ul></li>
<li><strong>通道控制表</strong>（CHCT）
<ul>
<li>每个通道对应一张CHCT</li>
</ul></li>
<li><strong>系统设备表</strong>（SDT）
<ul>
<li>整个系统只有一张SDT</li>
<li>每个物理设备占一个表项</li>
</ul></li>
</ol>
<blockquote>
<p>设备分配步骤：</p>
<ul>
<li>进程根据物理设备名查找SDT（每个物理设备占一个表项）</li>
<li>根据SDT找到DCT，若<strong>设备</strong>忙碌则将PCB挂到<strong>设备等待队列</strong>中；不忙碌则分配给进程</li>
<li>根据DCT找到COCT，若<strong>控制器</strong>忙碌则将PCB挂到<strong>控制器等待队列</strong>中；不忙碌则分配给进程</li>
<li>根据COCT找到CHCT，若<strong>通道</strong>忙碌则将PCB挂到<strong>通道等待队列</strong>中；不忙碌则分配给进程</li>
</ul>
<p>注：只有<strong>设备</strong>、<strong>控制器</strong>、<strong>通道</strong>三者都分配成功，才算设备分配成功，进行接下来的操作</p>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310112105494.png" alt="image-20231011210554198">
<figcaption aria-hidden="true">image-20231011210554198</figcaption>
</figure>
<h5 id="设备分配的改进">设备分配的改进</h5>
<ul>
<li>使用LUT(逻辑设备表)实现，记录对应的物理设备信息，给进程分配空闲的设备</li>
<li>一个用户一张LUT 或 整个系统只设置一张LUT(适用于单用户系统)</li>
</ul>
<h4 id="缓冲区">缓冲区</h4>
<h5 id="单缓冲">单缓冲</h5>
<ul>
<li><p>一个缓冲区</p></li>
<li><p>填满缓冲区时间<strong>T</strong>，填满工作区时间<strong>M</strong>，CPU处理时间<strong>C</strong></p></li>
<li><p>CPU处理的同时输入数据到缓冲区</p></li>
<li><p>处理每块数据用时：<strong>max(C, T) + M </strong>
（画图理解）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310112035651.png" alt="image-20231011203536202" style="zoom:50%;"></p></li>
</ul>
<h5 id="双缓冲区">双缓冲区</h5>
<ul>
<li><p>缓冲区1，缓冲区2</p></li>
<li><p>缓冲区1填满后开始装填缓冲区2，同时CPU处理缓冲区1传送的数据</p></li>
<li><p>处理每块数据用时：<strong>max(C+M, T)</strong></p>
<p>T &lt; C+M 的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310112036735.png" alt="image-20231011203634527" style="zoom:50%;"></p></li>
</ul>
<h5 id="循环缓冲">循环缓冲</h5>
<ul>
<li>多个大小相同的缓冲区通过指针相连，构成环形</li>
<li><strong>in</strong>指针指向第一个空缓冲区，<strong>out</strong>指针指向第一个满缓冲区</li>
</ul>
<h5 id="缓冲池三种队列">缓冲池（三种队列）</h5>
<ul>
<li>空缓冲区队列</li>
<li>输入缓冲区队列（装满输入数据的缓冲区）</li>
<li>输出缓冲区队列（装满输出数据的缓冲区）</li>
</ul>
<h4 id="设备驱动程序接口">设备驱动程序接口</h4>
<ul>
<li>向上层提供统一接口</li>
<li>驱动程序表格包含函数指针，可实现间接调用</li>
</ul>
<h2 id="磁盘">磁盘</h2>
<p>磁盘的组成：</p>
<ul>
<li>每个圆环是一个<strong>磁道</strong></li>
<li>一条磁道分为多个<strong>扇区</strong></li>
<li>不同盘面的相同磁道组成<strong>柱面</strong></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230629114325955.png" alt="image-20230629114325955">
<figcaption aria-hidden="true">image-20230629114325955</figcaption>
</figure>
<ul>
<li>定位：<strong>三元组（柱面号，盘面号，扇区号）</strong></li>
</ul>
<blockquote>
<p><strong>设备驱动程序</strong>计算数据所在磁盘的柱面号，盘面号，扇区号</p>
</blockquote>
<h3 id="磁盘管理">磁盘管理</h3>
<h4 id="初始化">初始化</h4>
<p>注意顺序，先分区后逻辑格式化</p>
<ol type="1">
<li>低级格式化(物理格式化)：磁道划分为<strong>扇区</strong>（头部 +
数据区域 + 尾部）</li>
<li>磁盘<strong>分区</strong>：有一个或多个柱面组成的分区（例：C盘、D盘）</li>
<li><strong>逻辑格式化</strong>：<strong>创建文件系统</strong>，将初始的文件系统数据结构存储到磁盘中</li>
</ol>
<h4 id="引导块">引导块</h4>
<ul>
<li>ROM中保留很小的自举装入程序</li>
<li>完整功能的引导程序保存在磁盘启动块中</li>
</ul>
<h4 id="坏块">坏块</h4>
<ul>
<li>简单磁盘：逻辑格式化时，将坏块在FAT中标明</li>
<li>复杂磁盘：：低级格式化将一些块作为备用</li>
</ul>
<h3 id="磁盘调度">磁盘调度</h3>
<h4 id="一次读写操作时间">一次读写操作时间</h4>
<ul>
<li>寻找时间：移动磁头花费的时间 + 启动磁臂时间</li>
<li>旋转延迟时间：定位到某一扇区花费的时间（平均时间：旋转半圈花费的时间）</li>
<li>传输时间：读出或写入的时间（与旋转速度有关）</li>
</ul>
<blockquote>
<p>总时间是上述时间之和</p>
</blockquote>
<h4 id="调度算法-1">调度算法</h4>
<p>指标：移动磁头花费的时间</p>
<ul>
<li>先来先服务：公平</li>
<li>最短寻找时间优先：处理距离最近的磁道，可能导致饥饿</li>
<li>SCAN算法(电梯调度)：磁头单向移动到最外/内侧后才能向内/外侧移动</li>
<li>C-SCAN算法(循环扫描)：磁头单向移动到一端后返回到另一端（中途不服务请求）</li>
<li><strong>LOOK算法</strong>：类似SCAN算法，只需移动到<strong>最远端的请求</strong>即可返回(不需要到端点)</li>
<li><strong>C-LOOK算法</strong>：类似C-SCAN算法，移动到<strong>最远端的请求</strong>即可返回（中途不服务）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230630093634026.png" alt="image-20230630093634026">
<figcaption aria-hidden="true">image-20230630093634026</figcaption>
</figure>
<h4 id="减少延迟">减少延迟</h4>
<p>磁盘在读取完一个扇区后需要处理时间，导致错过相邻扇区的读取，导致<strong>延迟</strong></p>
<p>下面是减少延迟的方法：</p>
<p>注：错位命名是指不同盘面对应位置的扇区编号错位</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230630095755058.png" alt="image-20230630095755058">
<figcaption aria-hidden="true">image-20230630095755058</figcaption>
</figure>
<h3 id="固态硬盘ssd">固态硬盘SSD</h3>
<ul>
<li>基于<strong>闪存</strong>技术——EEPROM（U盘）</li>
<li>读快、写慢</li>
<li>读写单位——页；擦除单位——块（一块包含多页）</li>
<li>要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的(擦除过的)块中，再写入新的页（先擦再写）</li>
<li>磨损均衡（<strong>静态</strong>磨损均衡比动态磨损均衡更优秀）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310102027447.png" alt="image-20231010202658862">
<figcaption aria-hidden="true">image-20231010202658862</figcaption>
</figure>
<h1 id="计算机网络">计算机网络</h1>
<h2 id="概述">概述</h2>
<h3 id="计算机网络的组成">计算机网络的组成</h3>
<ol type="1">
<li>从组成部分上看：<strong>硬件</strong>、<strong>软件</strong>、<strong>协议</strong>。
<ul>
<li><strong>硬件</strong>组成部分：主机（端系统）、通信链路（双绞线、光纤）、交换设备（路由器、交换机）、通信处理机（网卡）。</li>
<li><strong>软件</strong>主要包括各种实现资源共享的软件和方便用户使用的各种工具软件。</li>
<li><strong>协议</strong>是计算机网络的核心。</li>
</ul></li>
<li>从工作方式上看：<strong>边缘部分</strong>（主机）、<strong>核心部分</strong>（路由器）。</li>
<li>从功能上看：<strong>通信子网</strong>(传输介质、通信设备、网络协议；<strong>网络层及以下</strong>)、<strong>资源子网</strong>(设备及其软件的集合)。</li>
</ol>
<h3 id="计算机网络的功能">计算机网络的功能</h3>
<ol type="1">
<li>数据通信</li>
<li>资源共享</li>
<li>分布式处理</li>
<li>提高可靠性</li>
<li>负载均衡</li>
</ol>
<h3 id="分类-1">分类</h3>
<ol type="1">
<li>按分布范围分类
<ul>
<li>广域网（WAN）</li>
<li>城域网（MAN）</li>
<li>局域网（LAN）</li>
<li>个人区域网（PAN）</li>
</ul></li>
<li>按传输技术分类
<ul>
<li>广播式网络（LAN）</li>
<li>点对点网络（WAN）</li>
</ul></li>
<li>按拓扑结构分类
<ul>
<li>总线型</li>
<li>星形</li>
<li>环形</li>
<li>网状</li>
</ul></li>
<li>按使用者分类
<ul>
<li>公用网</li>
<li>专用网</li>
</ul></li>
<li>按交换技术分类
<ul>
<li>电路交换</li>
<li>报文交换（整个报文存储-转发）</li>
<li>分组交换（每个分组[报文的一部分]进行存储转发）</li>
</ul></li>
<li>按传输介质分类
<ul>
<li>有线</li>
<li>无线</li>
</ul></li>
</ol>
<h3 id="性能指标-2">性能指标</h3>
<p>带宽、时延（发送/传输、传播、处理、排队）、时延带宽积、往返时间（RTT）、吞吐量、速率、信道利用率</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230705153551050.png" alt="image-20230705153551050">
<figcaption aria-hidden="true">image-20230705153551050</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230705153625307.png" alt="image-20230705153625307">
<figcaption aria-hidden="true">image-20230705153625307</figcaption>
</figure>
<h2 id="体系结构">体系结构</h2>
<h3 id="osi参考模型">OSI参考模型</h3>
<p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h3 id="tcpip">TCP/IP</h3>
<p>四层</p>
<p><strong>网络接口层</strong></p>
<ul>
<li>物理层（比特）</li>
<li>数据链路层(帧):成帧、差错控制、流量控制(协调发送/接收速率[相邻结点之间])、介质访问控制</li>
</ul>
<p><strong>网际层</strong></p>
<ul>
<li>网络层（分组/IP数据报）：路由选择、差错控制、流量控制[整个网络]、拥塞控制</li>
</ul>
<p><strong>传输层</strong></p>
<ul>
<li>传输层（报文段/用户数据报）：端到端(进程),差错控制、流量控制[端到端]、可靠/不可靠传输</li>
</ul>
<p><strong>应用层</strong></p>
<ul>
<li>会话层：会话管理，实现数据同步</li>
<li>表示层：信息格式的处理（数据压缩、加密、解密）</li>
<li>应用层：最复杂的一层；FTP、SMTP、HTTP</li>
</ul>
<blockquote>
<p><strong>OSI</strong>在<strong>网络层</strong>支持<strong>无连接和面向连接</strong>的通信，<strong>传输层</strong>仅有<strong>面向连接</strong>的通信。</p>
<p><strong>TCP/IP</strong>在<strong>传输层</strong>支持<strong>无连接和面向连接</strong>的通信，<strong>网际层</strong>仅有<strong>无连接</strong>的通信。</p>
</blockquote>
<h3 id="层协议模型">5层协议模型</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706105832514.png" alt="image-20230706105832514">
<figcaption aria-hidden="true">image-20230706105832514</figcaption>
</figure>
<h3 id="体系结构中的专用术语">体系结构中的专用术语</h3>
<h4 id="实体">实体</h4>
<p>任何可发送或接收信息的硬件或软件进程。</p>
<p><strong>对等实体</strong>：收发双方相同层次中的实体。</p>
<h4 id="协议">协议</h4>
<p>控制两个<strong>对等实体</strong>进行逻辑通信的规则的集合。（水平）</p>
<p><strong>三要素</strong>：</p>
<ul>
<li>语法：定义所交换信息的格式。</li>
<li>语义：定义收发双方所要完成的操作。</li>
<li>时序：定义收发双方的时序关系。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706111446419.png" alt="image-20230706111446419">
<figcaption aria-hidden="true">image-20230706111446419</figcaption>
</figure>
<h4 id="服务">服务</h4>
<p>下层对上层提供服务。（垂直）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706112252992.png" alt="image-20230706112252992">
<figcaption aria-hidden="true">image-20230706112252992</figcaption>
</figure>
<p><strong>服务访问点</strong>、<strong>服务原语</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706112526664.png" alt="image-20230706112526664">
<figcaption aria-hidden="true">image-20230706112526664</figcaption>
</figure>
<p>相关术语：</p>
<p><strong>协议数据单元PDU</strong>、<strong>服务数据单元SDU</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706112837499.png" alt="image-20230706112837499">
<figcaption aria-hidden="true">image-20230706112837499</figcaption>
</figure>
<h2 id="物理层">物理层</h2>
<h3 id="基本概念-4">基本概念</h3>
<ol type="1">
<li><p>数据</p>
<ul>
<li>数字数据（数字信号）：离散数值</li>
<li>模拟数据（模拟信号）：连续变化</li>
</ul></li>
<li><p>传输方式</p>
<ul>
<li>并行</li>
<li>串行</li>
</ul></li>
<li><p>码元：一个固定时长的信号波形（数字脉冲）</p></li>
<li><p>通信交互方式</p>
<ul>
<li>单向通信</li>
<li>半双工通信</li>
<li>全双工通信</li>
</ul></li>
<li><p>数据传输速率</p>
<ul>
<li>码元传输速率：<strong>波特率</strong>，单位时间系统传输的<strong>码元个数</strong>，单位是Baud</li>
<li>信息传输速率：<strong>比特率</strong> =
波特率×比特数（log<sub>2</sub>V，V是码元的数目）</li>
</ul></li>
<li><p>按信号分类</p>
<ul>
<li><p><strong>基带信号</strong></p>
<ul>
<li><strong>信源发出的原始信号</strong></li>
<li>基带传输</li>
<li><strong>数字信道</strong>(数字信号[计网]，也可以是模拟信号)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707110253397.png" alt="image-20230707110253397" style="zoom: 50%;"></p></li>
<li><p>宽带信号</p>
<ul>
<li>频分复用</li>
<li>宽带传输</li>
<li><strong>模拟信道</strong>(模拟信号)</li>
</ul></li>
</ul></li>
</ol>
<h3 id="传输媒体">传输媒体</h3>
<ol type="1">
<li>导引型传输媒体
<ul>
<li>同轴电缆：外导体屏蔽层，良好的抗干扰能力</li>
<li>双绞线：绞合提高抗干扰能力；传输速率高、传输距离远、价格贵</li>
<li>光纤：多模光纤——近距离；单模光纤——远距离</li>
<li>电力线</li>
</ul></li>
<li>非导引型传输媒体
<ul>
<li>无线电波：长距离</li>
<li>微波：方向性，频率较高</li>
<li>红外线：方向性</li>
<li>卫星通信：传播时延长</li>
</ul></li>
</ol>
<h3 id="物理层接口特性">物理层接口特性</h3>
<ul>
<li>机械特性：接线器的形状和尺寸、引脚数等</li>
<li>电气特性：电压范围</li>
<li>功能特性：某一电平代表的意义</li>
<li>过程特性：事件的出现顺序</li>
</ul>
<h3 id="传输方式">传输方式</h3>
<ol type="1">
<li><p>串行传输、并行传输</p></li>
<li><p>同步传输、异步传输</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230706144702982.png" alt="image-20230706144702982">
<figcaption aria-hidden="true">image-20230706144702982</figcaption>
</figure></li>
<li><p>单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）</p></li>
</ol>
<h3 id="编码与调制">编码与调制</h3>
<h4 id="编码">编码</h4>
<ol type="1">
<li><p>数字数据<strong>编码</strong>成<strong>数字信号</strong></p>
<ul>
<li><p><strong>不归零编码</strong>——NRZ（存在同步问题）</p>
<p>需要<strong>额外</strong>一根传输线来传输时钟信号。</p></li>
<li><p><strong>归零编码</strong>——RZ（自同步，编码效率低）</p>
<p>接收方在信号归零后进行采样。每个时钟周期的<strong>中间归零</strong>，自同步</p></li>
<li><p><strong>反向非归零编码</strong>——NRZI（USB2.0）</p>
<p>信号<strong>翻转</strong>代表0，不变代表1；能够传输时钟信号，有前两种编码的优点</p></li>
<li><p><strong>曼彻斯特编码</strong>（传统以太网，10Mb/s）</p>
<p>码元中间时刻的跳变既表示时钟，又表示数据。</p>
<p>==<strong>以太网</strong>采用的是<strong>曼彻斯特编码</strong>，一个码元由半个比特组成，或一个比特对应两个码元==</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707112504500.png" alt="image-20230707112504500">
<figcaption aria-hidden="true">image-20230707112504500</figcaption>
</figure></li>
<li><p><strong>差分曼彻斯特编码</strong>（比曼彻斯特编码变化少，更适合较高的传输速率）</p>
<p>（1）跳变仅表示时钟</p>
<p>（2）<strong>码元开始处</strong>电平是否发生变化表示数据（比特0或1）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707112731604.png" alt="image-20230707112731604">
<figcaption aria-hidden="true">image-20230707112731604</figcaption>
</figure></li>
</ul></li>
<li><p>模拟数据<strong>编码</strong>成<strong>数字信号</strong></p>
<ul>
<li>脉冲调制(PCM)</li>
<li>采样定理(奈氏定理)：<strong>采样频率</strong> &gt;=
2*原始频率f<sub>max</sub></li>
</ul></li>
</ol>
<h4 id="调制">调制</h4>
<ol type="1">
<li>数字数据<strong>调制</strong>成<strong>模拟信号</strong>
<ul>
<li>幅移键控(ASK)：通过改变载波信号的<strong>振幅</strong>来表示数字0/1</li>
<li>频移键控(FSK)：通过改变载波信号的<strong>频率</strong>来表示数字0/1</li>
<li>相移键控(PSK)：通过改变载波信号的<strong>相位</strong>来表示数字0/1</li>
<li>正交振幅调制(QAM)：在<strong>频率</strong>相同的前提下，将<strong>ASK</strong>和<strong>PSK</strong>结合起来--m个相位，每个相位有n种振幅(码元信息量为<strong>log<sub>2</sub>mn</strong>)</li>
</ul></li>
<li>模拟数据<strong>调制</strong>成<strong>模拟信号</strong>
<ul>
<li>频分复用(FDM)</li>
</ul></li>
</ol>
<p>基本调制方法</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707113221544.png" alt="image-20230707113221544">
<figcaption aria-hidden="true">image-20230707113221544</figcaption>
</figure>
<p>混合调制</p>
<ul>
<li><p>正交振幅调制QMA（相位和振幅混合调制）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707114521104.png" alt="image-20230707114521104" style="zoom: 67%;"></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707114348682.png" alt="image-20230707114348682">
<figcaption aria-hidden="true">image-20230707114348682</figcaption>
</figure></li>
</ul>
<h3 id="奈氏准则">奈氏准则</h3>
<p>为了避免<strong>码间串扰</strong>，码元传输速率是有上限的。（调制速度——码元传输速度）</p>
<ul>
<li>没有噪声</li>
<li>理想低通（2W）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707140902707.png" alt="image-20230707140902707">
<figcaption aria-hidden="true">image-20230707140902707</figcaption>
</figure>
<h3 id="香农公式">香农公式</h3>
<p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707141253081.png" alt="image-20230707141253081">
<figcaption aria-hidden="true">image-20230707141253081</figcaption>
</figure>
<ul>
<li><p>==注==：若题目给出<strong>比值</strong>，则比值即为
S/N；若给出xxx<strong>dB</strong>，则说明 xxxdB =
10×log<sub>10</sub>(S/N)</p></li>
<li><p>总结：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230707141557264.png" alt="image-20230707141557264">
<figcaption aria-hidden="true">image-20230707141557264</figcaption>
</figure></li>
</ul>
<h3 id="数据交换方式">数据交换方式</h3>
<h4 id="电路交换">电路交换</h4>
<ul>
<li>先建立一条专用(双方独占)的物理通信路径</li>
<li>通信结束后才释放</li>
<li>优点：时延小，全双工，无冲突，实时性强</li>
<li>缺点：信道利用率低，灵活性差，难以规格化</li>
</ul>
<h4 id="报文交换">报文交换</h4>
<ul>
<li>存储转发</li>
<li>优点：无需建立连接，提高线路可靠性(一条坏了换一条)，提高线路利用率</li>
<li>缺点：转发时延大，文件大则需要路由器有较大的缓存空</li>
</ul>
<h4 id="分组交换">分组交换</h4>
<ul>
<li>存储转发</li>
<li>分组</li>
<li>优点：无建立时延，传输时延小，路线利用率高，简化了存储管理，加速传输，出错概率减小</li>
<li>缺点：存储转发有时延，传输额外的信息，可能失序、丢失或重复分组</li>
</ul>
<blockquote>
<p>分组交换进一步分为<strong>面向连接的虚电路方式</strong>和<strong>无连接的数据报方式</strong>：</p>
<ol type="1">
<li><p>数据报</p>
<ul>
<li>尽最大努力交付，<strong>不保证</strong>可靠性</li>
<li>每个分组转发的路径可能不同，所以不一定按序到达</li>
</ul></li>
<li><p>虚电路（数据报与电路交换方式结合）</p>
<p>三个阶段：虚电路建立(<strong>路由选择</strong>)、数据传输、虚电路释放</p>
<ul>
<li>发送前，<strong>建立逻辑上相连的虚电路</strong>（不是专用的）</li>
<li>建立时为每个虚电路分配一个<strong>虚电路号</strong></li>
<li>双向传输</li>
<li>致命弱点：某个节点或链路出现故障则相关虚电路遭到破坏</li>
<li>保证每个分组正确且有序到达</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202312071724428.png" alt="image-20231207172350608">
<figcaption aria-hidden="true">image-20231207172350608</figcaption>
</figure></li>
</ol>
<p>网络中的传输是否有确认与网络层提供的两种服务无关</p>
</blockquote>
<h3 id="物理层设备">物理层设备</h3>
<ol type="1">
<li>中继器（数字信号）
<ul>
<li><strong>再生</strong>衰减信号</li>
<li>放大转发</li>
<li>串联的中继器个数<strong>不超过4个</strong></li>
</ul></li>
<li>集线器
<ul>
<li>一个输入，广播到多个输出</li>
<li>不能分割冲突域</li>
</ul></li>
</ol>
<h2 id="数据链路层">数据链路层</h2>
<p><strong>点对点链路</strong>（广域网，PPP协议）、<strong>广播式链路</strong>（局域网，介质访问控制）</p>
<h3 id="三个重要问题">三个重要问题</h3>
<p>组帧、差错控制、可靠传输</p>
<h4 id="封装成帧">封装成帧</h4>
<p><strong>既要加首部，也要加尾部</strong></p>
<ol type="1">
<li>字符计数法
<ul>
<li>帧头使用一个<strong>计数字段</strong>标明帧内字符数（包括自身占用）</li>
</ul></li>
<li>字符填充的首尾定界符法
<ul>
<li>控制字符<strong>SOH</strong>：首部开始</li>
<li>控制字段<strong>EOT</strong>：帧的结束</li>
<li>转义字符<strong>ESC</strong>：转义与控制字符相同的帧内容</li>
</ul></li>
<li>零比特填充的首尾标志法
<ul>
<li>使用<code>01111110</code>表示帧的开始和结束</li>
<li>信息位：每遇到<strong>5个</strong>“1”就自动在后面添加<strong>1个</strong>“0”</li>
</ul></li>
<li>违规编码法
<ul>
<li>只适用于冗余编码</li>
</ul></li>
</ol>
<h4 id="差错控制">差错控制</h4>
<ol type="1">
<li><strong>检错编码</strong></li>
</ol>
<ul>
<li><p>奇偶校验码</p>
<p>在附加一个校验位后，信息位中的“<strong>1</strong>”的个数为<strong>奇数</strong>(奇校验)/<strong>偶数</strong>(偶校验)</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230708194709940.png" alt="image-20230708194709940">
<figcaption aria-hidden="true">image-20230708194709940</figcaption>
</figure></li>
<li><p>循环冗余码<strong>CRC</strong></p>
<ol type="1">
<li><p><strong>多项式</strong>(<strong>k位</strong>，0 ~ k-1
次方)作为<strong>除数</strong>：<strong>110110</strong>表示的多项式为<strong>X<sup>5</sup>+X<sup>4</sup>+X<sup>2</sup>+X</strong></p></li>
<li><p>要检验的信息位后 加上
多项式阶数(k-1)个<strong>0</strong></p></li>
<li><p><strong>组合后的二进制数</strong>除以<strong>多项式</strong>得到的<strong>余数</strong>就是<strong>帧检验序列FSC</strong></p>
<p>注：余数<strong>位数</strong>与多项式阶数相同(即
k-1)；要传送的<strong>数据位</strong>即为<strong>信息位+FSC</strong></p></li>
<li><p>检验是否出错：将接收到的二进制数除以多项式，看余数是否为0</p></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230708193815454.png" alt="image-20230708193815454">
<figcaption aria-hidden="true">image-20230708193815454</figcaption>
</figure></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230708195108859.png" alt="image-20230708195108859">
<figcaption aria-hidden="true">image-20230708195108859</figcaption>
</figure>
<ol start="2" type="1">
<li><strong>纠错编码</strong></li>
</ol>
<ul>
<li><p><strong>海明码</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WK411N7kz/?share_source=copy_web&amp;vd_source=35780f510c31cf111e4e8d765815365f">【官方双语】汉明码Pa■t1，如何克服噪■</a></p>
<ul>
<li><p>海明码位数：n+k &lt;= 2<sup>k</sup>-1
(n为有效信息位数，k为校验位数)</p></li>
<li><p>校验位（若加上0号校验位，可对进行两位检错，即0号校验位可对整个数据位进行偶校验）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310211654929.png" alt="image-20231021165450464" style="zoom:80%;"></p></li>
<li><p>分组进行偶校验</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310211654229.png" alt="image-20231021165403282">
<figcaption aria-hidden="true">image-20231021165403282</figcaption>
</figure></li>
</ul></li>
<li><p><strong>海明距离</strong></p>
<p>两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。</p>
<ol type="1">
<li>海明距离为<strong>d+1</strong>的编码能<strong>检测</strong>出<strong>d</strong>位<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61334144/article/details/130824468">差错</a></li>
<li>海明距离为<strong>2d+1</strong>的编码能<strong>纠正d</strong>位差错</li>
</ol></li>
</ul>
<h4 id="流量控制">流量控制</h4>
<p><strong>滑动窗口机制</strong></p>
<ul>
<li>发送窗口W<sub>T</sub>：
<ul>
<li>窗口大小表示最多还可以发送多少个数据帧；</li>
<li>发送窗口内所有帧都收到确认帧后才会移动</li>
</ul></li>
<li>接收窗口W<sub>R</sub>：只有收到的数据帧序号落在窗口内才允许接收</li>
</ul>
<p><strong>不同ARQ协议的窗口大小</strong>：</p>
<ul>
<li>停止-等待协议：W<sub>T</sub>=1，W<sub>R</sub>=1</li>
<li>后退N帧协议：W<sub>T</sub>&gt;1，W<sub>R</sub>=1</li>
<li>选择重传协议：W<sub>T</sub>&gt;1，W<sub>R</sub>&gt;1</li>
</ul>
<h4 id="可靠传输">可靠传输</h4>
<blockquote>
<p>（不局限于数据链路层，其他层也可选择实现可靠传输）</p>
<p><strong>有线</strong>链路误码率较低，<strong>不要求</strong>数据链路层向上提供可靠传输服务；</p>
<p><strong>无线</strong>链路易受干扰，误码率较高，因此<strong>要求</strong>数据链路层向上层提供可靠传输服务;</p>
<p>自动重传协议（ARQ），下面的三种都是ARQ协议</p>
<p>通过<strong>确认</strong>和<strong>超时重传</strong>两种机制实现</p>
</blockquote>
<ul>
<li><p><strong>停止-等待协议</strong>（SW-ARQ）</p>
<p>发送方每发送一帧都要等待接收方的<strong>应答</strong>信号才能发送下一帧，传输效率低</p>
<p>发送窗口和接收窗口大小均为<strong>1</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230709195720343.png" alt="image-20230709195720343">
<figcaption aria-hidden="true">image-20230709195720343</figcaption>
</figure>
<p>注意给数据分组和ACK分组<strong>编号</strong>，“确认迟到”中第三个Data0是新的数据</p></li>
<li><p><strong>回退N帧协议</strong>（GBN-ARQ）</p>
<ul>
<li>接收方对接收的最后一个数据帧进行确认（<strong>累积确认</strong>）</li>
<li>发送窗口大小：<strong>1&lt;Ｗ<sub>T</sub>&lt;=2<sup>n</sup>-1</strong>
(n为数据帧的编号)</li>
<li>接收窗口大小：<strong>1</strong></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230709201929973.png" alt="image-20230709201929973">
<figcaption aria-hidden="true">image-20230709201929973</figcaption>
</figure></li>
<li><p><strong>选择重传协议</strong>（SR-ARQ）</p>
<ul>
<li>接收方不再采用累计确认，而需要对每个正确接收到的数据分组进行<strong>逐一确认</strong></li>
<li><strong>1 &lt; W<sub>T</sub> = W<sub>R</sub> &lt;
2<sup>n-1</sup></strong></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230709203110929.png" alt="image-20230709203110929">
<figcaption aria-hidden="true">image-20230709203110929</figcaption>
</figure></li>
</ul>
<blockquote>
<p>==信道利用率==：有效发送数据时间/发送周期(发送数据到接收第一个确认帧)</p>
<p>最大利用：在发送周期内(<strong>传输时延</strong>[发送方和接收方]+**传播时延*2**)尽可能多的发送数据</p>
</blockquote>
<h3 id="介质访问控制mac">介质访问控制（MAC）</h3>
<ul>
<li>数据链路的子层</li>
<li>用来决定广播信道中<strong>信道分配</strong>的协议</li>
<li>防止同一信道不同结点之间的通信相互干扰</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711202449104.png" alt="image-20230711202449104">
<figcaption aria-hidden="true">image-20230711202449104</figcaption>
</figure>
<h4 id="静态划分信道">静态划分信道</h4>
<p><strong>信道划分MAC</strong>：</p>
<ul>
<li><p>频分复用FDM</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711191340072.png" alt="image-20230711191340072">
<figcaption aria-hidden="true">image-20230711191340072</figcaption>
</figure></li>
<li><p>时分复用TDM</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711191443782.png" alt="image-20230711191443782">
<figcaption aria-hidden="true">image-20230711191443782</figcaption>
</figure>
<ul>
<li>改进：<strong>统计时分多路复用（STDM）</strong>--按需动态分配时隙</li>
</ul>
<blockquote>
<p><strong>单个信号的位速率（每个用户的最高速率）小于介质的位速率</strong></p>
</blockquote></li>
<li><p>波分复用WDM：光的频分复用</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711191643573.png" alt="image-20230711191643573">
<figcaption aria-hidden="true">image-20230711191643573</figcaption>
</figure></li>
<li><p>码分复用CDM</p>
<p>这里不区分复用（CDM）和多址（CDMA）</p>
<ul>
<li>既共享信道频率又共享时间</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711200335898.png" alt="image-20230711200335898">
<figcaption aria-hidden="true">image-20230711200335898</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711200631740.png" alt="image-20230711200631740">
<figcaption aria-hidden="true">image-20230711200631740</figcaption>
</figure></li>
</ul>
<h4 id="动态接入控制">动态接入控制</h4>
<h5 id="随机访问介质访问控制">随机访问介质访问控制</h5>
<p>占用信道全部速率</p>
<ol type="1">
<li>ALOHA</li>
</ol>
<p>https://www.bilibili.com/video/BV1JV411t7ow?t=843.9&amp;p=42</p>
<p>（1）时隙ALOHA：将时间划分为多个等长的时隙,只在<strong>时隙开始时发送帧</strong>；发生冲突则以p概率重发</p>
<p>（2）纯ALOHA：超时，<strong>随机时间重传</strong>；吞吐量低</p>
<ol start="2" type="1">
<li>CSMA 协议</li>
</ol>
<p>载波监听多路访问</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230711212412927.png" alt="image-20230711212412927">
<figcaption aria-hidden="true">image-20230711212412927</figcaption>
</figure>
<ol start="3" type="1">
<li>==CSMA/CD 协议==</li>
</ol>
<ul>
<li><p>应用于<strong>有线局域网</strong>，适用于总线型或半双工网络</p></li>
<li><p><strong>先听后发，边听边发，冲突停发，随机重发</strong></p></li>
<li><p>往返时间：争用期——<code>2τ</code>
（τ为单程传播时延），争用期内未检测到碰撞则此次发送未冲突</p></li>
<li><p><strong>最小帧长</strong>：发送完毕不再监听，所以需要最小帧长；小于最小帧长则为无效帧</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712191802009.png" alt="image-20230712191802009">
<figcaption aria-hidden="true">image-20230712191802009</figcaption>
</figure>
<ul>
<li><p><strong>截断二进制指数退避算法</strong>：解决发生冲突后何时发送的问题</p>
<p>退避时间为：<strong>2rτ</strong>，r=2<sup>k</sup>-1，k=min{重传次数，10}</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712194212005.png" alt="image-20230712194212005">
<figcaption aria-hidden="true">image-20230712194212005</figcaption>
</figure>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712195747087.png" alt="image-20230712195747087" style="zoom:67%;"></p>
<ol start="3" type="1">
<li>==CSMA/CA 协议==（802.11标准）</li>
</ol>
<ul>
<li><p>应用于<strong>无线局域网</strong></p></li>
<li><p>先监听后发送</p></li>
<li><p>收到<strong>确认帧</strong>才继续发送下一帧</p></li>
<li><p><strong>帧间间隔</strong>：</p>
<ol type="1">
<li>SIFS（短IFS）：分隔属于一次会话的帧（ACK、CTS、分片后的数据帧）</li>
</ol>
<ul>
<li><strong>第一帧</strong>在等待一个<strong>DIFS</strong>时间后即可发送数据帧（不使用退避算法）</li>
<li>其余帧<strong>等待DIFS后</strong>再<strong>等到退避计时器</strong>倒计时到0，发送</li>
</ul>
<ol start="2" type="1">
<li><p>PIFS（点协调IFS）：在PCF操作中使用</p></li>
<li><p><strong>DIFS</strong>（分布式协调IFS）：<strong>最长</strong>的IFS，异步帧竞争访问</p></li>
</ol></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712202706738.png" alt="image-20230712202706738">
<figcaption aria-hidden="true">image-20230712202706738</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712203524516.png" alt="image-20230712203524516">
<figcaption aria-hidden="true">image-20230712203524516</figcaption>
</figure>
<ul>
<li><p><strong>问</strong>：源站为什么在检测到信道空闲后还要再等待一段时间<code>DIFS</code>？</p>
<p><strong>答</strong>：考虑到可能有其他的站有高优先级的帧要发送。</p></li>
<li><p><strong>问</strong>：目的站为什么正确接收数据帧后还要等待一段时间<code>SIFS</code>才能发送
ACK帧？</p>
<p><strong>答</strong>：<code>SIFS</code>是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。</p></li>
<li><p><strong>问</strong>：为什么信道由忙转为空闲且经过<code>DIFS</code>时间后，还要退避一段随机时间才能使用信道？</p>
<p><strong>答</strong>：防止多个站点同时发送数据而发生碰撞。</p></li>
</ul>
<ol start="2" type="1">
<li><p>退避算法</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712204129188.png" alt="image-20230712204129188">
<figcaption aria-hidden="true">image-20230712204129188</figcaption>
</figure></li>
<li><p><strong>隐蔽站</strong></p>
<ul>
<li>发送请求<strong>RTS</strong>：<strong>源站</strong>对信道进行预约（广播发送RTS）</li>
<li>允许发送<strong>CTS</strong>：<strong>目的站</strong>广播CTS抑制其他站点发送</li>
</ul></li>
</ol>
<blockquote>
<p><strong>区别</strong>：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712204825974.png" alt="image-20230712204825974">
<figcaption aria-hidden="true">image-20230712204825974</figcaption>
</figure>
</blockquote>
<h5 id="轮询访问令牌传递协议">轮询访问：令牌传递协议</h5>
<p>注意<strong>令牌持有时间</strong>。</p>
<ul>
<li>发送完一帧就释放令牌</li>
<li>发送方站点持有令牌后，将数据附加在令牌上进行传递直到再次回到自身</li>
<li>然后重新产生一个令牌并传递给下一个站点</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712210728986.png" alt="image-20230712210728986">
<figcaption aria-hidden="true">image-20230712210728986</figcaption>
</figure>
<h3 id="局域网">局域网</h3>
<h4 id="基本概念和体系结构">基本概念和体系结构</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712211340422.png" alt="image-20230712211340422">
<figcaption aria-hidden="true">image-20230712211340422</figcaption>
</figure>
<ul>
<li><p>局域网<strong>拓扑结构</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712211718685.png" alt="image-20230712211718685">
<figcaption aria-hidden="true">image-20230712211718685</figcaption>
</figure></li>
<li><p>局域网<strong>传输介质</strong></p>
<ul>
<li>有线局域网：双绞线、同轴电缆、光纤</li>
<li>无线局域网：电磁波</li>
</ul></li>
<li><p>局域网<strong>介质访问控制方式</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712212040697.png" alt="image-20230712212040697">
<figcaption aria-hidden="true">image-20230712212040697</figcaption>
</figure></li>
<li><p>局域网的分类</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712212335796.png" alt="image-20230712212335796">
<figcaption aria-hidden="true">image-20230712212335796</figcaption>
</figure></li>
<li><p>MAC子层和LLC子层</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230712212809756.png" alt="image-20230712212809756">
<figcaption aria-hidden="true">image-20230712212809756</figcaption>
</figure></li>
</ul>
<h4 id="以太网ieee-802.3">以太网（IEEE 802.3）</h4>
<p>在以太网中，如果一个结点要发送数据，那么它将以“广播”方式把数据通过作为公共传翻介质的总线发送出去，连在总线上的<strong>所有结点（包括发送结点）</strong>都能“收听”到发送结点发送的数据信号。</p>
<ul>
<li>曼彻斯特编码</li>
<li>尽最大努力交付</li>
<li>逻辑上为总线型结构</li>
<li><strong>无连接、不可靠</strong>（12年真题）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230713185455443.png" alt="image-20230713185455443">
<figcaption aria-hidden="true">image-20230713185455443</figcaption>
</figure>
<ol type="1">
<li><p>传输介质</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">10BASE5</th>
<th style="text-align: center;">10BASE2</th>
<th style="text-align: center;">10BASE-T</th>
<th style="text-align: center;">10BASE-FL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">传输媒体</td>
<td style="text-align: center;">同轴电缆</td>
<td style="text-align: center;">同轴电缆</td>
<td style="text-align: center;">非屏蔽双绞线</td>
<td style="text-align: center;">光纤</td>
</tr>
<tr class="even">
<td style="text-align: center;">拓扑结构</td>
<td style="text-align: center;">总线型</td>
<td style="text-align: center;">总线型</td>
<td style="text-align: center;">星形</td>
<td style="text-align: center;">点对点</td>
</tr>
<tr class="odd">
<td style="text-align: center;">最大段长</td>
<td style="text-align: center;">500m</td>
<td style="text-align: center;">185m</td>
<td style="text-align: center;">100m</td>
<td style="text-align: center;">2000m</td>
</tr>
<tr class="even">
<td style="text-align: center;">最多结点数</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p>注：10BASE-T在逻辑上是总线型</p>
<blockquote>
<p>"BASE"后面的数字表示最长长度（例如“5”表示500m），“<strong>T</strong>”表示<strong>双绞线</strong>，“<strong>F</strong>”表示光纤</p>
</blockquote></li>
<li><p>网卡</p>
<ul>
<li><p>串并转换</p></li>
<li><p>帧的组装和拆封</p></li>
<li><p>网卡与局域网的通信——<strong>串行</strong></p></li>
<li><p>网卡与计算机的通信通过I/O总线——<strong>并行</strong></p></li>
<li><p><strong>MAC地址</strong>：唯一，6字节，高24位表示厂商</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230713195459338.png" alt="image-20230713195459338"></p></li>
</ul></li>
<li><p><strong>MAC帧</strong>（DIX Ethernet V2 标准）</p>
<ul>
<li><p><strong>前导码</strong>-<strong>8B</strong>：前7字节是前同步码，后1字节是帧开始定界符</p>
<blockquote>
<p>前导码是在物理层添加的（但是物理层<strong>不添加</strong>首部），因此不是MAC帧的一部分</p>
</blockquote></li>
<li><p>目的地址-6B</p></li>
<li><p>源地址-6B</p></li>
<li><p>类型-2B：标明协议</p></li>
<li><p>数据：<strong>46</strong>B~<strong>1500</strong>B（即<strong>IP数据报</strong>）</p></li>
<li><p>校验码(FCS)-4B：校验MAC帧（不校验前导码）</p></li>
</ul>
<p>注：IEEE802.3标准与V2标准的帧格式不同之处用<strong>长度域</strong>替代了<strong>类型</strong></p>
<blockquote>
<p>首部+尾部(FCS)共<strong>18B</strong>（6+6+2 +
4，不算前导码），整个MAC帧的大小范围是 <strong>64~1518</strong>B</p>
</blockquote></li>
<li><p>高速以太网</p>
<ul>
<li>100BASE-T以太网：100Mb/s；支持半/全双工；半双工时使用<strong>CSMA/CD</strong></li>
<li>吉比特/千兆以太网：1Gb/s； 支持半/全双工；同上</li>
<li>10吉比特以太网：10Gb/s;
只支持<strong>全双工</strong>，所以无争用问题</li>
</ul></li>
</ol>
<h4 id="无线局域网ieee802.11">无线局域网（IEEE802.11）</h4>
<ol type="1">
<li><p>有固定基础设施无线局域网</p>
<ul>
<li>基本服务集BSS：包括一个<strong>接入点AP</strong>和若干移动站</li>
<li>连接另一个BSS构成扩展的服务集ESS；不同BSS的站点通信需要通过AP</li>
</ul></li>
<li><p>无固定基础设施移动自组织网络</p>
<ul>
<li>由平等状态的移动站组成</li>
</ul></li>
<li><p>MAC帧</p>
<p>分为数据帧、控制帧、管理帧，下面讨论数据帧</p>
<ul>
<li><p>首部-30B：<strong>接收地址</strong>、<strong>发送地址</strong>、<strong>源/目的地址</strong></p>
<blockquote>
<p>将<strong>AP地址、目的地址、源地址</strong>分别填入上述字段</p>
</blockquote></li>
<li><p>帧主体：不超过2312B</p></li>
<li><p>帧检验序列FCS是尾部-4B</p></li>
</ul></li>
</ol>
<h4 id="vlan">VLAN</h4>
<p>主机与交换机之间只交换普通的以太网帧，<strong>IEEE
802.1Q</strong>帧由交换机来处理（插入标签）。</p>
<ul>
<li>将较大的局域网划分为较小的逻辑上的局域网</li>
<li>隔离冲突域</li>
<li>隔离广播域</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714191758962.png" alt="image-20230714191758962">
<figcaption aria-hidden="true">image-20230714191758962</figcaption>
</figure>
<ul>
<li>端口类型</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714191941091.png" alt="image-20230714191941091"></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714193651078.png" alt="image-20230714193651078">
<figcaption aria-hidden="true">image-20230714193651078</figcaption>
</figure>
<h3 id="广域网">广域网</h3>
<h4 id="ppp协议">PPP协议</h4>
<ul>
<li>只支持全双工链路</li>
<li>面向字节，默认使用字符填充法，也支持比特填充法</li>
<li>应用在两个直接相连节点的链路上</li>
<li>串行线路</li>
<li>通信两端可使用<strong>不同的网络层协议</strong></li>
<li>不可靠</li>
<li>点对点</li>
<li>提供<strong>差错检验但不纠错</strong></li>
<li>首部-5B，尾部-3B</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230713211356981.png" alt="image-20230713211356981">
<figcaption aria-hidden="true">image-20230713211356981</figcaption>
</figure>
<h4 id="hdlc协议考纲删除">HDLC协议（考纲删除）</h4>
<p>可靠传输。</p>
<h3 id="数据链路层设备">数据链路层设备</h3>
<h4 id="以太网交换机">以太网交换机</h4>
<ul>
<li><p>全双工</p></li>
<li><p>用户通信时独占带宽（n个端口的交换机总容量为 n×10Mb/s）</p></li>
<li><p>帧的转发表通过<strong>自学习</strong>算法自动建立，自学习过程见下图</p></li>
<li><p>利用交换机实现VLAN</p></li>
<li><p>实质上是一个多端口的网桥</p></li>
<li><p>交换模式</p>
<ol type="1">
<li><p>直通式交换机：<strong>只检查帧的目的地址</strong>(<strong>6B</strong>)，速度快，不安全</p></li>
<li><p>存储转发式交换机：确认无误再转发，可靠性高，延迟大</p></li>
</ol></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230714185356660.png" alt="image-20230714185356660">
<figcaption aria-hidden="true">image-20230714185356660</figcaption>
</figure>
<ul>
<li>对于集线器，所有连接到集线器的设备共享同一个冲突域。</li>
<li>对于交换机，每个端口单独形成一个冲突域，因此交换机的冲突域数等于端口数。</li>
</ul>
<blockquote>
<p><strong>数据链路层</strong>的设备<strong>不能隔离广播域</strong></p>
<p>局域网内通信靠交换机，局域网间通信靠路由器</p>
</blockquote>
<h2 id="网络层">网络层</h2>
<h3 id="网络层的功能">网络层的功能</h3>
<ul>
<li>功能一：路由选择(控制平面) 与 分组转发(数据平面)</li>
<li>功能二：异构网络互联：<strong>数据链路层和物理层不同</strong></li>
<li>功能三：拥塞控制</li>
</ul>
<blockquote>
<ol type="1">
<li>面向连接的虚电路服务</li>
<li>无连接的数据报服务</li>
</ol>
<p>上述两个服务只能实现一种，不能同时实现</p>
</blockquote>
<h4 id="sdn">SDN</h4>
<p>在SDN路由器中，<strong>路由选择处理器</strong>负责与<strong>远程控制器</strong>通信，目的是接收远程控制器计算的转发表项。</p>
<ul>
<li><strong>南向接口</strong>（SDN控制器和网络设备之间的接口）：通过<strong>Openflow</strong>协议将<strong>流表下发</strong>给路由器</li>
<li>北向接口（网络OS提供给网络应用的API）</li>
</ul>
<p>注：控制器在 SDN 中相当于网络操作系统。</p>
<h4 id="拥塞控制">拥塞控制</h4>
<ul>
<li>全局性的问题（注意与流量控制的区别——流量控制抑制发送端发送速率）</li>
<li><strong>拥塞控制</strong>的两种方法：
<ul>
<li>开环控制：静态</li>
<li>闭环控制：动态</li>
</ul></li>
<li>传输层的拥塞控制是重点</li>
</ul>
<h3 id="路由算法">路由算法</h3>
<ul>
<li>静态路由算法：手工配置，不能及时适应网络变化</li>
<li>动态路由算法：自适应路由算法
<ol type="1">
<li><strong>距离-向量</strong>路由算法（分散性）：RIP；结点将其整个路由表转发给相邻结点</li>
<li><strong>链路状态</strong>路由算法（全局性）：OSPF；给所有路由器发送(部分)信息（洪泛法）</li>
</ol></li>
<li>层次路由：
<ol type="1">
<li>自治系统内：<strong>内部网关协议IGP</strong>——具体协议有<strong>RIP、OSPF</strong></li>
<li>自治系统之间：<strong>外部网关协议EGP</strong>——具体协议有<strong>BGP</strong></li>
</ol></li>
</ul>
<h3 id="ipv4">IPv4</h3>
<h4 id="ipv4分组格式">IPv4分组格式</h4>
<p><strong>首部</strong> + <strong>数据部分</strong></p>
<ul>
<li>版本-4位：广泛应用的版本号是4（IPv4）</li>
<li>首部长度-4位：以<strong>4B</strong>为单位，最大可表示60B(15×4B)；一般为<strong>20B</strong></li>
<li>服务类型-8位</li>
<li>总长度-16位：单位<strong>1B</strong>，<strong>首部+数据长度</strong>（不大于1500B——<strong>以太网帧</strong>的最大<strong>数据帧</strong>[MTU]）</li>
<li>标识-16位：同一数据报的分片使用同一标识</li>
<li>标志-3位：<strong>MF=1</strong>表示后面还有分片(More
Fragment)，<strong>DF=0</strong>表示允许分片(Don’t Fragment)</li>
<li>片偏移-13位：每个分片的<strong>数据部分</strong>以<strong>8B</strong>为单位，除了最后一个分片，其他分片都是<strong>8B的整数倍</strong></li>
<li>生存时间(TTL)-8位：可通过<strong>路由器</strong>的最大值，减为0时丢弃</li>
<li>协议-8位：<strong>6</strong>表示<strong>TCP</strong>，<strong>17</strong>表示<strong>UDP</strong></li>
<li>首部校验和-16位：<strong>只检验首部</strong></li>
<li>源地址字段-4B：发送方IP地址</li>
<li>目的地址字段-4B：接收方IP地址</li>
</ul>
<blockquote>
<p><strong>分片</strong>可以在源主机或传输路径上的任何一台<strong>路由器</strong>上进行，而<strong>重组</strong>只能在<strong>目的主机</strong>上进行</p>
<p><strong>TTL</strong>
的减少<strong>只在路由器处理</strong>时发生，而不是在数据包到达最终目的地的主机时。当数据包到达最终目的地时，TTL
的值不会减少</p>
</blockquote>
<h4 id="ipv4地址">IPv4地址</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230717165302231.png" alt="image-20230717165302231">
<figcaption aria-hidden="true">image-20230717165302231</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230717165831757.png" alt="image-20230717165831757">
<figcaption aria-hidden="true">image-20230717165831757</figcaption>
</figure>
<blockquote>
<p><strong>0.0.0.0</strong>表示<strong>在本网络上的本主机</strong></p>
</blockquote>
<h4 id="nat">NAT</h4>
<p>将专用网络地址转换为公用地址，因此整个专用网只需一个全球IP即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230717165918458.png" alt="image-20230717165918458"></p>
<ul>
<li>隐藏了内部网络结构，多个私有IP映射到一个全球IP上</li>
<li><strong>NAT转换表</strong>：{本地IP地址 : 端口} 映射为 {全球IP地址 :
端口}</li>
</ul>
<blockquote>
<p><strong>私有地址</strong>与互联网通信时，需要<strong>NAT路由器</strong>进行IP地址转换</p>
</blockquote>
<h4 id="子网划分">子网划分</h4>
<p>从主机号借用若干比特作为子网号，两级IP变成了三级IP</p>
<p>变长划分：</p>
<blockquote>
<p>现将一个IP网络划分为3个子网，若其中一个子网是192.168.9.128/26，则下列网络中，不可能是另外两个子网之一的是
  A.192.168.9.0/25   B.192.168.9.0/26   C.192.168.9.192/26
  D.192.168.9.192/27</p>
<p>答案：B</p>
<p>需包含所有IP地址</p>
</blockquote>
<ul>
<li><strong>子网掩码</strong>：‘1’对应IP地址中的网络号和子网号，‘0’对应主机号。</li>
</ul>
<blockquote>
<p><strong>最小子网划分：使用变长子网的划分方法，保证子网的IP数尽可能小</strong></p>
</blockquote>
<h4 id="cidr">CIDR</h4>
<ul>
<li><p>使用“网络前缀”的概念代替子网概念。例如：128.14.32.5/20（相当于没有子网号？）</p></li>
<li><p>路由聚合(构成超网)</p></li>
<li><p>可以在地址块内划分子网</p></li>
<li><p>最长前缀匹配</p></li>
<li><p>是一种归并网络的技术，作用是把小的网络汇聚成大的超网。</p></li>
</ul>
<h3 id="arpdhcpicmp">ARP、DHCP、ICMP</h3>
<h4 id="arp网络层">ARP（网络层）</h4>
<ul>
<li>IP地址到MAC地址的映射</li>
<li><strong>同一局域网内</strong></li>
<li><strong>ARP请求分组</strong>是<strong>广播</strong>发送(目的MAC地址为全1)；<strong>ARP响应分组</strong>是<strong>单播</strong>即源地址到目的地址</li>
<li>若不在同一局域网内则ARP找到<strong>网关</strong>的MAC地址，剩下的工作由该路由器完成</li>
</ul>
<blockquote>
<p>目的MAC地址为广播地址FF-FF-FF-FF-FF-FF</p>
<ul>
<li><p><strong>ARP 不属于网络层，因为它不使用 IP
头，而是直接封装在以太网帧（L2）中。</strong></p></li>
<li><p><strong>ARP 之所以涉及 IP 地址，是因为它的目的是解析 IP 到
MAC，但它的传输方式是 L2 级别的广播或单播。</strong></p></li>
<li><p><strong>如果 ARP 运行在网络层，那就会陷入“找 MAC 地址必须先知道
MAC 地址”的矛盾。</strong></p></li>
</ul>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 12%">
<col style="width: 67%">
</colgroup>
<thead>
<tr class="header">
<th><strong>普通 ARP</strong></th>
<th>❌ 不能跨网</th>
<th>只能在局域网（LAN）内解析 MAC，ARP 广播不会被路由器转发</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>默认网关方式</strong></td>
<td>✅ 间接跨网</td>
<td>通过 ARP 解析网关 MAC，让网关转发 IP 数据</td>
</tr>
<tr class="even">
<td><strong>Proxy ARP</strong></td>
<td>✅ 代理跨网</td>
<td>代理设备响应 ARP 请求，伪装 MAC 地址，实际上仍然是转发</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="dhcp应用层-udp">DHCP（应用层-UDP）</h4>
<ul>
<li><p>C/S模式</p></li>
<li><p>需要IP地址的主机在启动时进行广播</p></li>
<li><p>过程：</p>
<ol type="1">
<li><p><strong>客户机</strong>广播“<strong>DHCP发现</strong>”消息（源地址——<strong>0.0.0.0</strong>；目的地址——<strong>255.255.255.255</strong>）</p></li>
<li><p><strong>服务器</strong>收到消息后，广播“<strong>DHCP提供</strong>”消息，包括了提供给客户机的IP地址（源地址——服务器IP地址；目的地址——255.255.255.255）</p></li>
<li><p><strong>客户机</strong>收到消息后，若接受该IP，则广播“<strong>DHCP请求</strong>”（源地址——0.0.0.0；目的地址——255.255.255.255）</p></li>
<li><p><strong>服务器</strong>广播“<strong>DHCP确认</strong>”消息，将IP分配给客户机（源地址——服务器IP地址；目的地址——255.255.255.255）</p></li>
</ol></li>
<li><p>DHCP服务器提供的IP是临时IP（租用期）</p></li>
</ul>
<h4 id="icmp网络层">ICMP（网络层）</h4>
<p>ICMP报文作为<strong>IP层数据报</strong>的数据</p>
<ol type="1">
<li><p><strong>ICMP差错报告报文</strong>：向源主机报告差错和异常情况</p>
<ul>
<li>终点不可达</li>
<li><strong>源点抑制</strong>：路由器或主机<strong>因拥塞控制而丢弃数据</strong></li>
<li>时间超过(应用:Traceroute)：TTL=0，丢弃该数据报并发送时间超过报文</li>
<li>参数问题：数据报首部字段不正确</li>
<li>改变路由(重定向)：路由器发送改变路由报文（告诉主机有更好的路径）</li>
</ul>
<blockquote>
<p><strong>不应发送</strong>的情况：</p>
<ul>
<li>对ICMP差错报告报文</li>
<li>对第一个分片的后续数据报片</li>
<li>对具有组播地址的数据报</li>
<li>对具有特殊地址的数据报</li>
</ul>
</blockquote></li>
<li><p><strong>ICMP询问报文</strong>：前两种最常用</p>
<ul>
<li>回送请求和回答报文：PING(应用层)</li>
<li>时间戳请求和回答报文</li>
<li>地址掩码请求和回答报文</li>
<li>路由器询问和通告报文</li>
</ul></li>
</ol>
<h3 id="ipv6">IPv6</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718185635822.png" alt="image-20230718185635822">
<figcaption aria-hidden="true">image-20230718185635822</figcaption>
</figure>
<ul>
<li><strong>只能在源点分片</strong>，传输过程中的路由器不能分片</li>
<li><strong>首部长度不可变</strong></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718190626255.png" alt="image-20230718190626255">
<figcaption aria-hidden="true">image-20230718190626255</figcaption>
</figure>
<ul>
<li><p>单播：一对一通信，可作为源地址和目的地址</p></li>
<li><p>多播：一对多通信，可作为目的地址</p></li>
<li><p>任播：一对多中的一个通信，可作为目的地址</p></li>
</ul>
<p>IPv4 向 IPv6 过渡：</p>
<ul>
<li><strong>双协议栈</strong>：既支持IPv4，又支持IPv6</li>
<li><strong>隧道技术</strong>：使IPv6数据报在IPv4中传输</li>
</ul>
<h3 id="路由协议">路由协议</h3>
<p>AS：自治系统</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718192009043.png" alt="image-20230718192009043">
<figcaption aria-hidden="true">image-20230718192009043</figcaption>
</figure>
<h4 id="rip">RIP</h4>
<p><strong>应用层</strong>协议（<strong>UDP</strong>），基于<strong>距离向量</strong>的路由选择协议。使用<strong>跳数</strong>衡量到达目的网络的距离。</p>
<ol type="1">
<li><p>RIP特点</p>
<ul>
<li>仅与<strong>相邻路由器</strong>交换信息</li>
<li>交换当前路由器所知道的<strong>全部信息</strong></li>
<li><strong>16跳</strong>则表示<strong>不可达</strong>（所以最多15跳）</li>
<li>两个使用RIP协议的路由器之间每30秒广播一次路由信息</li>
</ul></li>
<li><p>距离向量算法</p>
<p>收到来自C的路由表，包含目的网络N，<strong>先</strong>将收到了路由表进行改造：<strong>跳数+1；下一跳改为C</strong></p>
<ul>
<li>原路由表<strong>没有N</strong>，则添加</li>
<li>原路由表<strong>有N</strong>，且下一跳是C，则更新（取新）</li>
<li>原路由表<strong>有N</strong>，下一跳不为C，取小（若相等则添加？负载均衡？）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311041405620.png" alt="image-20231104140513348">
<figcaption aria-hidden="true">image-20231104140513348</figcaption>
</figure></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720192453492.png" alt="image-20230720192453492">
<figcaption aria-hidden="true">image-20230720192453492</figcaption>
</figure>
<ul>
<li>好消息传得快，坏消息传得慢（慢收敛）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720192703002.png" alt="image-20230720192703002">
<figcaption aria-hidden="true">image-20230720192703002</figcaption>
</figure>
<h4 id="ospf">OSPF</h4>
<p><strong>网络层协议</strong>，使用<strong>IP</strong>数据报传送；全称：开放最短路径优先协议</p>
<ul>
<li>向本自治区内<strong>所有路由器</strong>发送信息，<strong>洪泛</strong>法</li>
<li>发送的信息是与本路由器<strong>相邻</strong>的路由器的链路状态（只包含<strong>部分信息</strong>）</li>
<li>链路状态改变时才发送信息</li>
<li>使用<strong>Dijkstra算法</strong>，路由表只存储下一跳</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718200055620.png" alt="image-20230718200055620">
<figcaption aria-hidden="true">image-20230718200055620</figcaption>
</figure>
<p><strong>工作原理：</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718200652484.png" alt="image-20230718200652484">
<figcaption aria-hidden="true">image-20230718200652484</figcaption>
</figure>
<p>特点：收敛速度快</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720194007085.png" alt="image-20230720194007085">
<figcaption aria-hidden="true">image-20230720194007085</figcaption>
</figure>
<h4 id="bgp">BGP</h4>
<ul>
<li><p>边界网关协议（应用层-<strong>TCP</strong>）</p></li>
<li><p>是一种<strong>外部</strong>网关协议</p></li>
<li><p><strong>路径向量</strong>路由选择协议</p></li>
<li><p>每个自治区一个BGP代言人</p></li>
<li><p>先建立TCP连接，然后交换路由表（刚开始交换整个BGP路由表，后面只更新有变化的部分）</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718201643349.png" alt="image-20230718201643349">
<figcaption aria-hidden="true">image-20230718201643349</figcaption>
</figure>
<blockquote>
<p>BGP-4的四种报文：</p>
<ul>
<li>打开</li>
<li>更新</li>
<li>保活</li>
<li>通知</li>
</ul>
</blockquote>
<h3 id="ip组播">IP组播</h3>
<ul>
<li><p>只用于<strong>UDP</strong>（因为TCP是一对一发送）</p></li>
<li><p>使用IGMP协议加入组播组</p></li>
<li><p>使用D类地址（不是所有D类地址都行）</p></li>
<li><p>分为局域网组播和因特网组播</p></li>
<li><p>传送路径分岔时会复制分组继续转发</p></li>
</ul>
<h4 id="硬件组播">硬件组播</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718204436969.png" alt="image-20230718204436969">
<figcaption aria-hidden="true">image-20230718204436969</figcaption>
</figure>
<h4 id="igmp和组播路由算法">IGMP和组播路由算法</h4>
<ul>
<li>第一阶段：主机向组播组发送IGMP报文声明加入该组，本地组播路由器收到后，将组成员关系转发给因特网上其他组播路由器</li>
<li>第二阶段：本地组播路由器要周期性探询这些主机是否还是组的成员</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230718205441917.png" alt="image-20230718205441917"></p>
<h3 id="移动ip">移动IP</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230719192532983.png" alt="image-20230719192532983">
<figcaption aria-hidden="true">image-20230719192532983</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230719193914186.png" alt="image-20230719193914186">
<figcaption aria-hidden="true">image-20230719193914186</figcaption>
</figure>
<h3 id="网络层设备">网络层设备</h3>
<h4 id="路由器的组成和功能">路由器的组成和功能</h4>
<ul>
<li>从模型上看，路由器实现了下三层：物理层、数据链路层、网络层</li>
<li>从结构上看，路由器分为<strong>路由选择</strong>和<strong>分组转发</strong>：
<ol type="1">
<li>路由选择：核心构件是路由选择处理机，任务是构造路由表</li>
<li>分组转发：三部分组成——交换结构、输入端口、输出端口</li>
</ol></li>
</ul>
<p>流程：</p>
<ul>
<li>普通待转发的数据分组——&gt;查表（转发表）转发</li>
<li>路由间交换路由信息的路由报文——&gt;路由选择处理机（更新路由表）</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230719191534879.png" alt="image-20230719191534879">
<figcaption aria-hidden="true">image-20230719191534879</figcaption>
</figure>
<h4 id="路由表和路由选择">路由表和路由选择</h4>
<ul>
<li>转发表是由路由表得来的</li>
<li>路由表的四个表项：目的网络IP地址、子网掩码、下一跳IP地址、接口</li>
<li>转发表可用软件实现，也可用硬件实现（路由表总是用软件实现）</li>
</ul>
<blockquote>
<p>默认路由：0.0.0.0；子网掩码：0.0.0.0</p>
</blockquote>
<h2 id="传输层">传输层</h2>
<h3 id="传输层功能及特点">传输层功能及特点</h3>
<ul>
<li><strong>进程</strong>之间的逻辑通信，<strong>端到端</strong></li>
<li><strong>差错检验</strong>——首部 和
数据（网络层只检查IP数据报首部）</li>
<li>服务访问点是<strong>端口</strong>（网络层——IP地址，数据链路层——MAC地址）</li>
<li>支持<strong>无连接</strong>服务和<strong>面向连接</strong>服务</li>
</ul>
<h3 id="端口">端口</h3>
<h4 id="服务器端端口">服务器端端口</h4>
<ol type="1">
<li><strong>熟知端口号</strong>：0~1023</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">应用程序</th>
<th style="text-align: center;">FTP</th>
<th style="text-align: center;">TELNET</th>
<th style="text-align: center;">SMTP</th>
<th style="text-align: center;">DNS</th>
<th style="text-align: center;">TFTP</th>
<th style="text-align: center;">HTTP</th>
<th style="text-align: center;">SNMP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">熟知端口号</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">25</td>
<td style="text-align: center;">53</td>
<td style="text-align: center;">69</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">161</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>登记端口号：1024~49151</li>
</ol>
<h4 id="客户端端口">客户端端口</h4>
<ul>
<li>又称短暂端口号(临时端口)：49152~65535</li>
</ul>
<h3 id="套接字">套接字</h3>
<ul>
<li>端口号拼接到IP地址构成Socket</li>
<li>socket = &lt;IP地址 : 端口号&gt;</li>
<li>唯一标识网络上的一台主机及其一个应用(进程)</li>
<li>应用层与传输层之间的接口</li>
</ul>
<h3 id="udp">UDP</h3>
<h4 id="udp特点">UDP特点</h4>
<ul>
<li>无连接不可靠</li>
<li>首部开销小（<strong>8B</strong>）</li>
<li>面向数据报</li>
<li><strong>没有拥塞控制</strong></li>
<li>支持一对一、一对多、多对一、多对多</li>
<li>不分片</li>
<li>用于一次性传输较少数据的应用，如<strong>DNS</strong>、<strong>SNMP</strong></li>
</ul>
<h4 id="udp首部">UDP首部</h4>
<p>UDP数据报格式：首部 + 数据</p>
<ul>
<li>首部-<strong>8B</strong></li>
<li>由四个字段组成：每个<strong>2B</strong>
<ul>
<li><strong>源端口号</strong>(若不需要则置为全0)</li>
<li><strong>目的端口号</strong></li>
<li><strong>UDP长度</strong>(首部+数据)：最小为8B（只有首部）</li>
<li><strong>校验和</strong>（若源主机不想计算校验和，则置为全0）</li>
</ul></li>
<li>若接收方发现目的<strong>端口号不正确</strong>，则丢弃该报文，并发送“<strong>端口不可达</strong>”ICMP差错报文</li>
</ul>
<h4 id="udp校验">UDP校验</h4>
<ul>
<li>计算校验和时，需要添加12B的伪首部</li>
<li>伪首部不向上/下传递</li>
<li>步骤如下：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230720202324919.png" alt="image-20230720202324919" style="zoom:50%;"></p>
<p>​ 全为1表示 原码+反码 的结果全为1，则未发生错误</p>
<blockquote>
<p>这里的<strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/LINZEYU666/article/details/121463392">二进制反码求和</a></strong>是：当16位数据求和发生溢出时(最高位产生进位)，不是将该进位舍去，而是则将该进位(第17位)加到后16位上</p>
</blockquote>
<h3 id="tcp">TCP</h3>
<h4 id="tcp特点">TCP特点</h4>
<ul>
<li>面向连接（逻辑连接）</li>
<li>面向<strong>字节流</strong></li>
<li>可靠，保证数据 无差错、不丢失、不重复、有序</li>
<li>全双工通信</li>
<li>两端都有发送缓存和接收缓存</li>
<li>TCP为了避免被发送方分片，它主动把数据分成小段再交给网络层。最大的分段大小称为<code>MSS</code></li>
</ul>
<figure>
<img src="https://pic2.zhimg.com/v2-5c578bd8beb44dd6a2755ce989f9a2d5_r.jpg" alt="MSS_MTU">
<figcaption aria-hidden="true">MSS_MTU</figcaption>
</figure>
<blockquote>
<p>TCP 内核缓冲区是 <strong>操作系统内核</strong> 维护的一块用于
<strong>存储 TCP 连接中发送和接收的数据</strong>
的缓冲区。它主要包括两个部分：</p>
<ol type="1">
<li><strong>发送缓冲区（Send Buffer）</strong>：存储
<strong>应用程序</strong> 通过 <code>send()</code> /
<code>write()</code> 发送但尚未被对方接收的数据。</li>
<li><strong>接收缓冲区（Receive Buffer）</strong>：存储
<strong>内核从网卡接收</strong> 但尚未被应用层 <code>recv()</code> /
<code>read()</code> 读取的数据。</li>
</ol>
<p>这两个缓冲区是 <strong>TCP
可靠传输、流量控制、拥塞控制的核心机制</strong>，用于临时存放数据，确保
TCP 连接的稳定性和高效性。</p>
</blockquote>
<h4 id="tcp首部">TCP首部</h4>
<p>首部的<strong>前20B固定</strong>（最大60B）</p>
<ul>
<li>源端口-2B + 目的端口-2B</li>
<li>序号-4B：当前数据部分第一个字节的序号</li>
<li><strong>确认号</strong>-4B：下一个报文段的第一个数据字节的序号（前面所有序号的字节均已接收）</li>
<li>数据偏移-4bit：首部长度（以32位为单位，最大值15表示60B）</li>
<li>保留-6bit</li>
<li>标志位-6bit：
<ul>
<li>紧急位URG：URG=1时，紧急指针字段有效（高优先级）</li>
<li><strong>确认位ACK</strong>：ACK=1时，确认号字段有效，连接建立后一直为1</li>
<li>推送位PSH：PSH=1时，尽快交付，不需要等待缓存区满</li>
<li>复位位RST：RST=1时，出现严重差错</li>
<li><strong>同步位SYN</strong>：SYN=1时，表明是连接请求/接受报文</li>
<li><strong>终止位FIN</strong>：FIN=1时，要求释放连接</li>
</ul></li>
<li>窗口-2B：允许对方发送的数据量（<strong>字节数</strong>）</li>
<li>校验和-2B：计算同UDP（需要伪首部）</li>
<li>紧急指针-2B</li>
<li>选项-长度可变</li>
<li>填充：保持整个首部长度是4B的整数倍</li>
</ul>
<h4 id="tcp连接管理">TCP连接管理</h4>
<p><strong>三报文握手</strong></p>
<ul>
<li>客户端：SYN=1，seq=x</li>
<li>服务端：SYN=1，ACK=1，ack=x+1，seq=y</li>
<li>客户端：ACK=1(之后都是1)，ack=y+1，seq=x+1 (SYN 不再需要置为 1)</li>
</ul>
<blockquote>
<p>规定：</p>
<ol type="1">
<li>同步位<strong>SYN被设置为1(即上述前两步)</strong>的报文段<strong>不能携带数据</strong>，但要<strong>消耗掉一个序号</strong>。</li>
<li><strong>普通</strong>确认报文段如果不携带数据，则不消耗序号。</li>
</ol>
</blockquote>
<p>采用三报文握手而不是两报文握手：防止已失效的连接请求报文段又传送到了TCP服务器，而浪费服务器资源。下面是详细解释：</p>
<blockquote>
<p>服务器将无法确定客户端是否已经收到了它的响应。这意味着，如果客户端发送了一个连接请求，但是在服务器响应之前就断开了连接，那么服务器将无法确定客户端是否已经断开连接。这可能会导致服务器继续等待客户端的响应，浪费资源</p>
</blockquote>
<p><strong>四报文挥手</strong></p>
<p>任何一端都可终止连接，下面以客户端为例</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202311181716356.png" alt="image-20231118171338296">
<figcaption aria-hidden="true">image-20231118171338296</figcaption>
</figure>
<ul>
<li>客户端：FIN=1，seq=u；进入FIN-WAIT-1状态(终止等待1)，不能再发送数据</li>
<li>服务端：ACK=1，ack=u+1，seq=v；进入CLOSE-WAIT状态(等待关闭，<strong>这一步可省去</strong>，见下图)</li>
<li>服务器：FIN=1，ack=u+1，seq=w；进入LAST-ACK状态（最后确认）</li>
<li>客户端：ACK=1，ack=w+1，seq=u+1；<strong>等待 2MSL
时间</strong>，进入CLOSED状态(连接关闭)</li>
</ul>
<blockquote>
<p>规定：</p>
<ol type="1">
<li>终止位<strong>FIN被设置为1</strong>的报文段即使<strong>不携带数据</strong>，也要<strong>消耗掉一个序号</strong>。</li>
<li>发送过FIN=1的一端就不能再发送数据了（所以上述第二步服务器还可发送数据）</li>
</ol>
</blockquote>
<p><strong>若第二次挥手省去</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202312101507977.png" alt="image-20231210150733013">
<figcaption aria-hidden="true">image-20231210150733013</figcaption>
</figure>
<h4 id="tcp可靠传输">TCP可靠传输</h4>
<ol type="1">
<li><p>序号</p>
<ul>
<li>保证有序</li>
</ul></li>
<li><p>确认</p>
<ul>
<li>发送方未收到确认的报文段存储在缓存区中</li>
<li>接收方采用GBN和SR的结合，虽然使用累计确认，但是<strong>只重传一个报文段</strong>(与后退N帧区别)</li>
</ul>
<blockquote>
<p>《自顶向下》：许多TCP实现会将正确接收但失序的报文段缓存起来，进一步假设对分组<em>n&lt;N</em>的确认报文丢失，但是其余<em>N-1</em>个确认报文在分别超时前到达发送端，这时又会发生的情况。在该例中，<strong>GBN</strong>不仅会重传分组<em>n</em>，还会重传所有后继的分组<em>n+1</em>,<em>n+2</em>,…<em>N</em>。
在另一方面，<strong>TCP将重传至多一个报文段</strong>，即报文段<em>n</em>。此外，如果对报文段<em>n+1</em>的确认报文在报文段n超时之前到达，TCP甚至不会重传报文段n</p>
</blockquote></li>
<li><p>重传</p>
<ol type="1">
<li>超时</li>
</ol>
<ul>
<li>超时重传时间(RTO)应略大于一个加权平均往返时间RTT<sub>s</sub></li>
</ul>
<ol start="2" type="1">
<li>冗余ACK</li>
</ol>
<ul>
<li>接收方收到比期待序号大的报文段时，就发送一个冗余ACK</li>
<li>发送方收到<strong>3</strong>个冗余ACK时，则<strong>快速重传</strong></li>
</ul></li>
</ol>
<h4 id="tcp流量控制">TCP流量控制</h4>
<p>点对点，接收端到发送端</p>
<ul>
<li><p>发送窗口大小 =
<strong>min</strong>{接收窗口rwnd，拥塞窗口cwnd}</p>
<p>（接收窗口由接收方控制，拥塞窗口由发送方规定）</p></li>
<li><p>传输层的窗口可以<strong>动态变化</strong></p></li>
<li><p>数据链路层的窗口大小不能动态变化</p></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230721201608405.png" alt="image-20230721201608405">
<figcaption aria-hidden="true">image-20230721201608405</figcaption>
</figure>
<h4 id="tcp拥塞控制">TCP拥塞控制</h4>
<p>全局性</p>
<ol type="1">
<li><p>慢开始和拥塞避免：cwnd到达阈值后改用拥塞避免算法</p>
<ul>
<li><p>慢开始算法</p>
<p>令 cwnd = 1，每次(每个RTT)乘2，直到ssthresh</p></li>
<li><p>拥塞避免（慢开始到达阈值后）</p>
<p>每次加 1</p></li>
</ul>
<blockquote>
<p>拥塞处理：</p>
<ul>
<li>开始时，cwnd=1，每次乘2</li>
<li>到达ssthresh后，每次加 1</li>
<li>发送拥塞时，将ssthresh设为<strong>发生拥塞时cwnd的值</strong>的<strong>一半</strong></li>
<li>将cwnd重新设为1，执行慢开始算法（这一步不消耗时间，与拥塞发生同时进行）</li>
</ul>
</blockquote></li>
<li><p>快重传和快恢复：是对上述两个算法的改进</p>
<ul>
<li><p>快重传</p>
<p>三个冗余ACK</p></li>
<li><p>快恢复</p>
<p>收到三个冗余ACK后，将ssthresh设为当前cwnd的一半，但同时发送方认为没有发生严重拥塞，于是将<strong>新的cwnd的值设为阈值</strong>(也就是当前cwnd/2，不从1开始)，同时开始执行<strong>拥塞避免</strong>算法</p></li>
</ul>
<blockquote>
<p>总结：</p>
<ul>
<li>TCP建立连接或出现超时，则使用慢开始和拥塞避免</li>
<li>当发送方收到3个冗余ACK，则使用快重传和快恢复</li>
</ul>
</blockquote></li>
</ol>
<h2 id="应用层">应用层</h2>
<h3 id="网络应用模型">网络应用模型</h3>
<h4 id="cs模型">C/S模型</h4>
<ul>
<li>客户请求服务</li>
<li>服务器提供服务</li>
<li>地位不平等</li>
<li>客户机之间不能直接通信</li>
<li>可拓展性不好</li>
</ul>
<h4 id="p2p模型">P2P模型</h4>
<ul>
<li>任意一对计算机称为<em>对等方</em></li>
<li>直接互相通信</li>
<li>每个结点即作为客户机请求资源，又作为服务器提供服务</li>
<li>资源利用率高</li>
<li>可拓展性好</li>
<li>健壮性强</li>
</ul>
<blockquote>
<p>缺点：</p>
<ul>
<li>占用较多内存</li>
<li>对硬盘造成伤害</li>
<li>造成网络拥塞</li>
</ul>
</blockquote>
<h3 id="dns">DNS</h3>
<p>用于域名与IP的转换；<strong>UDP</strong>，端口号53；C/S模型</p>
<h4 id="域名空间">域名空间</h4>
<p>域名规范：</p>
<ul>
<li>英文不区分大小写</li>
<li>符号只能使用连字符<code>-</code></li>
<li>每个标号不超过63个字符，总长度不超过255个字符</li>
<li>从<strong>右</strong>到<strong>左</strong>域名级别依次降低</li>
</ul>
<p>顶级域名：</p>
<ul>
<li>国家顶级域名：cn、us、uk</li>
<li>通用顶级域名：com、net、org</li>
<li>基础结构域名：只有一个——<code>arpa</code>，用于反向域名解析</li>
</ul>
<h4 id="域名服务器">域名服务器</h4>
<p>联机分布式；使用高速缓存</p>
<ul>
<li>本地域名服务器：主机发送DNS查询，<strong>第一个</strong>到达的域名服务器</li>
<li>根域名服务器：无法解析，<strong>首先</strong>访问该服务器；13个，告诉下一步该查询的顶级域名服务器</li>
<li>顶级域名服务器：TLD服务器提供了权威DNS服务器的IP地址</li>
<li>授权(权威)域名服务器：总能找到目标</li>
</ul>
<h4 id="域名解析过程">域名解析过程</h4>
<p>第一步：主机向本地域名服务器发送DNS请求报文(UDP数据报)</p>
<p>两种方式解析域名：</p>
<ol type="1">
<li><p>递归查询（靠别人）：实际中几乎不使用</p>
<ul>
<li>本地域名只向根域名查询一次</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271646358.png" alt="image-20231027164559914">
<figcaption aria-hidden="true">image-20231027164559914</figcaption>
</figure></li>
<li><p>递归和迭代相结合</p>
<ul>
<li><p>这里的递归是指主机和本地域名服务器之间（主机只发送一次请求）</p></li>
<li><p><strong>迭代</strong>（靠自己）：本地域名服务器和跟服务器之间（本地域名服务器发送多次请求）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271649358.png" alt="image-20231027164945510">
<figcaption aria-hidden="true">image-20231027164945510</figcaption>
</figure></li>
</ul></li>
</ol>
<h3 id="ftp文件传输协议">FTP（文件传输协议）</h3>
<h4 id="特点">特点</h4>
<ul>
<li><strong>TCP</strong></li>
<li>C/S模型</li>
<li><strong>21号</strong>端口：<strong>控制</strong>连接</li>
<li><strong>20号</strong>端口：<strong>数据</strong>连接</li>
<li>用户权限管理</li>
</ul>
<h4 id="控制连接">控制连接</h4>
<ul>
<li>服务器监听21号端口</li>
<li>等待客户连接</li>
<li><strong>整个会话期间一直保持打开状态</strong></li>
<li>控制信息格式：7位ASCII</li>
</ul>
<h4 id="数据连接">数据连接</h4>
<ul>
<li><strong>传送完毕就关闭连接</strong></li>
<li>主动模式PORT：
<ul>
<li>服务器打开20号端口并(<strong>主动</strong>)连接客户打开的随机端口</li>
</ul></li>
<li>被动模式PASV：
<ul>
<li>服务器打开随机端口被客户连接(<strong>被动</strong>)</li>
</ul></li>
</ul>
<h3 id="电子邮件">电子邮件</h3>
<h4 id="电子邮件系统组成结构">电子邮件系统组成结构</h4>
<ol type="1">
<li>用户代理
<ul>
<li>用户与邮件系统的接口</li>
<li>客户端软件</li>
</ul></li>
<li>邮件服务器
<ul>
<li>接收/发送邮件</li>
<li>C/S模型</li>
</ul></li>
<li>协议
<ul>
<li>发送协议——SMTP：推</li>
<li>读取协议——POP3：拉</li>
</ul></li>
</ol>
<h4 id="邮件格式和mime">邮件格式和MIME</h4>
<ol type="1">
<li><p>邮件格式</p>
<ul>
<li>From：由邮件系统自动填入</li>
<li>To：一个或多个收件人的邮件地址</li>
<li>Subject：邮件主题</li>
</ul>
<blockquote>
<p>邮件地址格式：邮箱名@邮箱所在主机的域名</p>
</blockquote></li>
<li><p>MIME：多用途网际邮件扩充</p>
<ul>
<li>SMTP只能传送一定长度的ASCII码</li>
<li>MIME增加了邮件的结构，能够传送非ASCII码</li>
<li>多了5个新的首部字段</li>
</ul></li>
</ol>
<h4 id="smtp">SMTP</h4>
<p>使用<strong>TCP</strong>连接；端口号25</p>
<p>用<strong>A</strong>表示发送方邮件服务器，<strong>B</strong>表示接收方邮件服务器</p>
<ol type="1">
<li><p>连接建立</p>
<ul>
<li>A使用25号端口与B建立TCP连接</li>
<li>B发送<em>220 Service ready</em>(服务就绪)</li>
<li>A向B发送<em>HELLO命令</em></li>
</ul></li>
<li><p>邮件传送</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271904395.png" alt="image-20231027190401433">
<figcaption aria-hidden="true">image-20231027190401433</figcaption>
</figure></li>
<li><p>连接释放</p>
<p>A发送<em>QUIT命令</em>，B返回221，则表示同意释放TCP连接</p></li>
</ol>
<h4 id="pop3">POP3</h4>
<p><strong>TCP</strong>；端口号110</p>
<p>两种工作方式：</p>
<ul>
<li>下载并保留：用户从邮件服务器上读取邮件后，邮件服务器依旧保留该邮件</li>
<li>下载并删除：用户读取邮件后，邮件服务器就删除该邮件</li>
</ul>
<blockquote>
<p><strong>IMAP</strong>(因特网报文存取协议)：用户可使用创建文件夹等联机命令；可以只读取报文的部分内容</p>
<p>基于万维网的电子邮件：Hotmail，Gmail等，浏览器使用<strong>HTTP</strong>与邮件服务器之间实现接收/发送</p>
</blockquote>
<h3 id="www万维网">WWW(万维网)</h3>
<h4 id="概念和组成">概念和组成</h4>
<p>内核部分由三个标准构成：</p>
<ul>
<li><p>URL统一资源定位符：唯一标识万维网上的资源，形式如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">协议</span>&gt;</span>://<span class="tag">&lt;<span class="name">主机</span>&gt;</span>:<span class="tag">&lt;<span class="name">端口</span>&gt;</span>/<span class="tag">&lt;<span class="name">路径</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>HTTP超文本传输协议：应用层协议，使用TCP</p></li>
<li><p>HTML超文本标记语言：标记语言</p></li>
</ul>
<h4 id="http">HTTP</h4>
<ol type="1">
<li><p>特点</p>
<ul>
<li>本身是<strong>无连接</strong>的，由<strong>TCP</strong>保证可靠传输</li>
<li><strong>一个RTT</strong>用于TCP连接(因为第三次握手捎带了用户请求)</li>
<li>无状态（实际应用中使用<strong>Cookie</strong>记录来跟踪用户活动）</li>
<li>支持<strong>非持久连接</strong>：每个元素对象都要<strong>独立建立TCP连接</strong></li>
<li>支持<strong>持久连接</strong>(HTTP/<strong>1.1</strong>)：
<ul>
<li>非流水线：收到前一个响应才能继续发送下一个请求（每个元素一个RTT延迟）</li>
<li>流水线：连续发送请求（所有元素一个RTT延迟）</li>
</ul></li>
</ul></li>
<li><p>过程</p>
<ul>
<li>浏览器解析URL</li>
<li>浏览器发送DNS请求</li>
<li>DNS解析出域名对应的IP</li>
<li>建立TCP连接（端口号：80）</li>
<li>数据传输</li>
<li>释放连接</li>
<li>浏览器将Web页显示给用户</li>
</ul></li>
<li><p>报文结构</p>
<ul>
<li><p>请求报文：Web请求是在TCP三报文握手的第三个数据载荷中的</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271943864.png" alt="image-20231027194326950">
<figcaption aria-hidden="true">image-20231027194326950</figcaption>
</figure></li>
<li><p>响应报文</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310271944282.png" alt="image-20231027194412985">
<figcaption aria-hidden="true">image-20231027194412985</figcaption>
</figure></li>
</ul>
<blockquote>
<p>注意<strong>首部行</strong>与<strong>实体主体</strong>之间有一个<strong>空行</strong>(回车换行)</p>
<p><code>Connection:close</code>：表示<strong>非持续连接</strong>，如下图所示</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310312047504.png" alt="image-20231031204318944">
<figcaption aria-hidden="true">image-20231031204318944</figcaption>
</figure>
<p><strong>真题</strong>：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202310312050404.png" alt="image-20231031205011530">
<figcaption aria-hidden="true">image-20231031205011530</figcaption>
</figure>
</blockquote></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
              <a href="/tags/408/" rel="tag"># 408</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"># 计算机组成原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/27/RSA%E7%AE%97%E6%B3%95/" rel="prev" title="RSA算法">
      <i class="fa fa-chevron-left"></i> RSA算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/14/%E4%BF%AE%E6%94%B9PowerShell%E4%B8%BB%E9%A2%98/" rel="next" title="修改PowerShell的主题">
      修改PowerShell的主题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">数据结构的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">栈和队列的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="nav-text">数组和特殊矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%9A%B4%E5%8A%9B"><span class="nav-text">朴素模式匹配（暴力）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">满二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">完全二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-text">二叉排序树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91bst"><span class="nav-text">二叉搜索树（BST）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">顺序存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E5%BA%8F"><span class="nav-text">先序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F"><span class="nav-text">中序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F"><span class="nav-text">后序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F"><span class="nav-text">层序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-text">非递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F-1"><span class="nav-text">中序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E5%BA%8F-1"><span class="nav-text">先序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F-1"><span class="nav-text">后序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">线索二叉树的遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E6%A3%AE%E6%9E%97"><span class="nav-text">树、森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">树和森林的遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">树与二叉树的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-text">哈夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">并查集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">图的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">图的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-text">十字链表（有向图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-text">邻接多重表（无向图）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E6%97%A0%E6%9D%83%E5%9B%BE"><span class="nav-text">图的遍历（无权图）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-bfs"><span class="nav-text">广度优先搜索-BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs"><span class="nav-text">深度优先搜索-DFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">图的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%B8%A6%E6%9D%83%E5%9B%BE"><span class="nav-text">最短路径（带权图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BEdag%E5%9B%BE"><span class="nav-text">有向无环图（DAG图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">关键路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-text">线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">折半查找（二分查找）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">分块查找（索引顺序查找）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-text">树形结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91bst"><span class="nav-text">二叉排序树（BST）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avl%E6%A0%91"><span class="nav-text">平衡二叉树（AVL树）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91rbt"><span class="nav-text">红黑树（RBT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b%E6%A0%91"><span class="nav-text">B树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b%E6%A0%91-1"><span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">散列表（哈希表）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2%E8%B7%AF"><span class="nav-text">归并排序（2路）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-text">外部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91"><span class="nav-text">败者树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">置换选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="nav-text">最佳归并树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="nav-text">计算机组成原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-text">计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6"><span class="nav-text">计算机硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84"><span class="nav-text">冯诺依曼结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84"><span class="nav-text">现代计算机结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6"><span class="nav-text">计算机软件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">计算机系统的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">性能指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="nav-text">数据的表示与运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%88%B6%E5%92%8C%E7%BC%96%E7%A0%81"><span class="nav-text">数制和编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6"><span class="nav-text">十进制转任意进制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0"><span class="nav-text">无符号整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81"><span class="nav-text">原码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81"><span class="nav-text">补码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E7%A0%81"><span class="nav-text">反码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E7%A0%81"><span class="nav-text">移码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E5%92%8C%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0"><span class="nav-text">定点整数和定点小数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6"><span class="nav-text">基本运算部件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8"><span class="nav-text">一位全加器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="nav-text">串行进位的并行加法器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="nav-text">并行进位加法器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="nav-text">带标志位的加法器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83alu"><span class="nav-text">算术逻辑单元（ALU）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">定点数的移位运算（?）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="nav-text">定点数的加减运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="nav-text">加减运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF"><span class="nav-text">补码加减运算电路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-text">标志位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E5%88%A4%E5%88%AB"><span class="nav-text">溢出判别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97"><span class="nav-text">定点数的乘除运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-text">乘法运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-text">除法运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="nav-text">浮点数的表示与运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ieee754"><span class="nav-text">IEEE754</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="nav-text">浮点数的加减运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">C语言中类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-text">存储器的基本组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">主存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dram%E5%92%8Csram"><span class="nav-text">DRAM和SRAM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dram%E4%B8%BB%E5%AD%98"><span class="nav-text">DRAM（主存）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sramcache"><span class="nav-text">SRAM（Cache）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sram%E5%92%8Cdram%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">SRAM和DRAM的比较</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87"><span class="nav-text">存储芯片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rom"><span class="nav-text">ROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">多模块存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">单体多字存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">多体并行存储器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E4%B8%8Ecpu%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-text">主存与CPU的连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="nav-text">连接原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95"><span class="nav-text">主存容量扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">外部存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">磁盘存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ssd"><span class="nav-text">SSD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache"><span class="nav-text">Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="nav-text">映射方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">替换算法（详见操作系统）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-text">写策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">页式虚拟存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">段式虚拟存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">段页式虚拟存储器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-text">指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-1"><span class="nav-text">指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="nav-text">指令的基本格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81%E6%98%AF%E5%90%A6%E5%8F%AF%E5%8F%98"><span class="nav-text">操作码是否可变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="nav-text">指令的操作类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80"><span class="nav-text">寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">数据寻址方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="nav-text">程序的机器级表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">过程(函数)调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="nav-text">选择语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text">循环语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cisc%E5%92%8Crisc"><span class="nav-text">CISC和RISC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cisc"><span class="nav-text">CISC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#risc"><span class="nav-text">RISC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">中央处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">CPU的功能和基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-text">功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">基本结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">指令执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="nav-text">指令周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-text">指令周期的数据流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="nav-text">指令执行方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%93%E6%9E%84"><span class="nav-text">数据通路的功能和结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="nav-text">功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-1"><span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-text">数据传送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">硬布线控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7%E6%9D%A5%E6%BA%90"><span class="nav-text">输入信号来源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">控制方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="nav-text">设计步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">微程序控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">微程序控制器的组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-text">编码方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E6%96%B9%E5%BC%8F"><span class="nav-text">地址形成方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">微指令的格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4-1"><span class="nav-text">设计步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-text">异常和中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%86%85%E4%B8%AD%E6%96%AD"><span class="nav-text">异常（内中断）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-text">中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="nav-text">响应过程 *</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-text">指令流水线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">指令流水线的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-text">影响流水线的因素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">流水线性能指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">流水线的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF"><span class="nav-text">流水线的多发技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E6%AE%B5%E5%BC%8F%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-text">五段式流水线相关指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">多处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">硬件多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">多核处理器和共享内存多处理器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-text">总线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0"><span class="nav-text">总线概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">总线基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">总线的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="nav-text">系统总线结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">总线的性能指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E5%AE%9A%E6%97%B6"><span class="nav-text">总线操作和定时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86"><span class="nav-text">总线标准</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E7%B3%BB%E7%BB%9F"><span class="nav-text">I&#x2F;O系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">I&#x2F;O控制方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%8E%A5%E5%8F%A3"><span class="nav-text">I&#x2F;O接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%96%B9%E5%BC%8F"><span class="nav-text">I&#x2F;O方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-text">程序查询方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="nav-text">程序中断方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E6%96%B9%E5%BC%8F"><span class="nav-text">DMA方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dma%E6%96%B9%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">DMA方式的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dma%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90"><span class="nav-text">DMA控制器组成</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-1"><span class="nav-text">计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">操作系统基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-text">操作系统的特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-text">操作系统发展历程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5"><span class="nav-text">手工操作阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="nav-text">批处理阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">分时操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">实时操作系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-text">操作系统运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-text">运行模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="nav-text">异常和中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-text">操作系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="nav-text">操作系统引导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">虚拟机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81"><span class="nav-text">进程的概念和特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-text">进程状态转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">进程的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">进程通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81"><span class="nav-text">概念和特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="nav-text">线程的组织和控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%A4%E7%B1%BB"><span class="nav-text">线程的实现（两类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">多线程模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-text">处理机调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">调度的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-1"><span class="nav-text">性能指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1fcfs"><span class="nav-text">先来先服务（FCFS）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88sjf"><span class="nav-text">短作业优先（SJF）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="nav-text">高响应比优先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC"><span class="nav-text">时间片轮转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">多级队列调度算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-text">同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-text">实现临界区互斥的基本方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-text">管程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">经典同步问题*</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">死锁产生的必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-text">死锁的处理策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">内存管理基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5"><span class="nav-text">程序的链接与装入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F"><span class="nav-text">进程的内存映像（进程映像）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">内存保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB"><span class="nav-text">内存共享</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">连续分配管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-text">单一连续分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-text">固定分区分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-text">动态分区分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-text">非连续分配管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">基本分页存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">基本分段存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">基本段页式存储管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">虚拟内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="nav-text">请求分页管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D"><span class="nav-text">页框分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">页面置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="nav-text">抖动与工作集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6-mmap"><span class="nav-text">内存映射文件 MMAP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-text">传统文件访问方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap"><span class="nav-text">MMAP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-text">文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="nav-text">文件控制块和索引结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">文件的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">文件的逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">文件的物理结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84vs%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑结构VS物理结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">单级目录结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">两级目录结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">多级目录结构（树形目录结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">无环图目录结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E5%AD%98%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">外存空闲空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-text">存储空间的划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">管理方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C-1"><span class="nav-text">文件的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">打开文件（open系统调用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="nav-text">关闭文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-text">写文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-text">文件共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="nav-text">硬链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="nav-text">软链接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-text">文件保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="nav-text">口令保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"><span class="nav-text">加密保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">访问控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-text">文件系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%8B%E9%81%93%E8%A7%86%E9%A2%91%E5%8F%82%E8%80%83%E5%9B%BD%E5%86%85%E6%95%99%E6%9D%90"><span class="nav-text">王道视频（参考国内教材）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%8B%E9%81%93%E4%B9%A6%E5%8F%82%E8%80%83%E5%9B%BD%E5%A4%96%E6%95%99%E6%9D%90"><span class="nav-text">王道书（参考国外教材）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="nav-text">文件系统布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">文件系统在磁盘中的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">文件系统在内存中的结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-vfs"><span class="nav-text">虚拟文件系统 VFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E5%AE%89%E8%A3%85%E8%A3%85%E8%BD%BD"><span class="nav-text">文件系统挂载&#x2F;安装&#x2F;装载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E7%AE%A1%E7%90%86"><span class="nav-text">I&#x2F;O管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="nav-text">I&#x2F;O设备的概念和分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">I&#x2F;O控制器（设备控制器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#io%E6%8E%A5%E5%8F%A3-1"><span class="nav-text">I&#x2F;O接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#io%E7%AB%AF%E5%8F%A3"><span class="nav-text">I&#x2F;O端口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F-1"><span class="nav-text">I&#x2F;O控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E8%BD%AE%E8%AF%A2"><span class="nav-text">程序直接控制方式（轮询）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">中断驱动方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E6%96%B9%E5%BC%8F-1"><span class="nav-text">DMA方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">通道控制方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">I&#x2F;O软件层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82io%E8%BD%AF%E4%BB%B6"><span class="nav-text">用户层I&#x2F;O软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="nav-text">设备独立性软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">设备驱动程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">中断处理程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8Fio%E6%8E%A5%E5%8F%A3"><span class="nav-text">应用程序I&#x2F;O接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3"><span class="nav-text">字符设备接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3"><span class="nav-text">块设备接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3"><span class="nav-text">网络设备接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E-io"><span class="nav-text">阻塞&#x2F;非阻塞 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6-1"><span class="nav-text">设备独立性软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spooling%E6%8A%80%E6%9C%AF"><span class="nav-text">SPOOLing技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-text">设备的分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-text">分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-text">策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">设备分配的数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-text">设备分配的改进</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="nav-text">单缓冲</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">双缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2"><span class="nav-text">循环缓冲</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E4%B8%89%E7%A7%8D%E9%98%9F%E5%88%97"><span class="nav-text">缓冲池（三种队列）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">设备驱动程序接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98"><span class="nav-text">磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="nav-text">磁盘管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="nav-text">引导块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%8F%E5%9D%97"><span class="nav-text">坏块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-text">磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4"><span class="nav-text">一次读写操作时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-1"><span class="nav-text">调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F"><span class="nav-text">减少延迟</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98ssd"><span class="nav-text">固态硬盘SSD</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">计算机网络的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">计算机网络的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB-1"><span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-2"><span class="nav-text">性能指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#osi%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-text">OSI参考模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpip"><span class="nav-text">TCP&#x2F;IP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B"><span class="nav-text">5层协议模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E4%B8%93%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="nav-text">体系结构中的专用术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93"><span class="nav-text">实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE"><span class="nav-text">协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1"><span class="nav-text">服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-text">物理层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93"><span class="nav-text">传输媒体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7"><span class="nav-text">物理层接口特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="nav-text">传输方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6"><span class="nav-text">编码与调制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-text">编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%88%B6"><span class="nav-text">调制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99"><span class="nav-text">奈氏准则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F"><span class="nav-text">香农公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="nav-text">数据交换方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="nav-text">电路交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2"><span class="nav-text">报文交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-text">分组交换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="nav-text">物理层设备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text">数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E9%97%AE%E9%A2%98"><span class="nav-text">三个重要问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7"><span class="nav-text">封装成帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6"><span class="nav-text">差错控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-text">可靠传输</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6mac"><span class="nav-text">介质访问控制（MAC）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%92%E5%88%86%E4%BF%A1%E9%81%93"><span class="nav-text">静态划分信道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%8E%A5%E5%85%A5%E6%8E%A7%E5%88%B6"><span class="nav-text">动态接入控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">随机访问介质访问控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE"><span class="nav-text">轮询访问：令牌传递协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="nav-text">局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">基本概念和体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91ieee-802.3"><span class="nav-text">以太网（IEEE 802.3）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91ieee802.11"><span class="nav-text">无线局域网（IEEE802.11）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vlan"><span class="nav-text">VLAN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91"><span class="nav-text">广域网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ppp%E5%8D%8F%E8%AE%AE"><span class="nav-text">PPP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hdlc%E5%8D%8F%E8%AE%AE%E8%80%83%E7%BA%B2%E5%88%A0%E9%99%A4"><span class="nav-text">HDLC协议（考纲删除）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="nav-text">数据链路层设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">以太网交换机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">网络层的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sdn"><span class="nav-text">SDN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="nav-text">路由算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipv4"><span class="nav-text">IPv4</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ipv4%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">IPv4分组格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ipv4%E5%9C%B0%E5%9D%80"><span class="nav-text">IPv4地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nat"><span class="nav-text">NAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86"><span class="nav-text">子网划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cidr"><span class="nav-text">CIDR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arpdhcpicmp"><span class="nav-text">ARP、DHCP、ICMP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#arp%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-text">ARP（网络层）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dhcp%E5%BA%94%E7%94%A8%E5%B1%82-udp"><span class="nav-text">DHCP（应用层-UDP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#icmp%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-text">ICMP（网络层）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipv6"><span class="nav-text">IPv6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="nav-text">路由协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rip"><span class="nav-text">RIP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ospf"><span class="nav-text">OSPF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bgp"><span class="nav-text">BGP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ip%E7%BB%84%E6%92%AD"><span class="nav-text">IP组播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%92%AD"><span class="nav-text">硬件组播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#igmp%E5%92%8C%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="nav-text">IGMP和组播路由算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8ip"><span class="nav-text">移动IP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="nav-text">网络层设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="nav-text">路由器的组成和功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E8%A1%A8%E5%92%8C%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-text">路由表和路由选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8A%9F%E8%83%BD%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-text">传输层功能及特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3"><span class="nav-text">端口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%AB%AF%E5%8F%A3"><span class="nav-text">服务器端端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AB%AF%E5%8F%A3"><span class="nav-text">客户端端口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#udp"><span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#udp%E7%89%B9%E7%82%B9"><span class="nav-text">UDP特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#udp%E9%A6%96%E9%83%A8"><span class="nav-text">UDP首部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#udp%E6%A0%A1%E9%AA%8C"><span class="nav-text">UDP校验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp"><span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E7%89%B9%E7%82%B9"><span class="nav-text">TCP特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E9%A6%96%E9%83%A8"><span class="nav-text">TCP首部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-text">TCP连接管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-text">TCP可靠传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">TCP流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">TCP拥塞控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-text">网络应用模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cs%E6%A8%A1%E5%9E%8B"><span class="nav-text">C&#x2F;S模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#p2p%E6%A8%A1%E5%9E%8B"><span class="nav-text">P2P模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns"><span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">域名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">域名服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-text">域名解析过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ftp%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-text">FTP（文件传输协议）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5"><span class="nav-text">控制连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5"><span class="nav-text">数据连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-text">电子邮件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="nav-text">电子邮件系统组成结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Cmime"><span class="nav-text">邮件格式和MIME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smtp"><span class="nav-text">SMTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pop3"><span class="nav-text">POP3</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#www%E4%B8%87%E7%BB%B4%E7%BD%91"><span class="nav-text">WWW(万维网)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%84%E6%88%90"><span class="nav-text">概念和组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http"><span class="nav-text">HTTP</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxt"
      src="/images/hxt.jpg">
  <p class="site-author-name" itemprop="name">hxt</p>
  <div class="site-description" itemprop="description">May the Force be with you.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">187</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">79</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">493k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:28</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
