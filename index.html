<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="May the Force be with you.">
<meta property="og:type" content="website">
<meta property="og:title" content="hxt&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="hxt&#39;s Blog">
<meta property="og:description" content="May the Force be with you.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hxt">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hxt's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxt's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/14/%E6%8B%BC%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/14/%E6%8B%BC%E8%BD%A6/" class="post-title-link" itemprop="url">拼车</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-14 00:00:00 / 修改时间：20:18:18" itemprop="dateCreated datePublished" datetime="2025-09-14T00:00:00+08:00">2025-09-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>题目地址：https://leetcode.cn/problems/car-pooling/description/</p>
<h2 id="问题描述">问题描述</h2>
<p>你是一名出租车司机，车上最初有 <code>capacity</code>
个空座位。车辆只能向一个方向行驶（不允许掉头或改变方向）。给定整数
<code>capacity</code> 和一个行程数组 <code>trips</code>，其中
<code>trips[i] = [numPassengers, from, to]</code> 表示第 i 次行程有
<code>numPassengers</code> 名乘客，上车和下车的位置分别是
<code>from</code> 和
<code>to</code>（这些位置是从汽车的初始位置向东的公里数）。只有当你可以完成所有给定的行程时（即<strong>不会出现超载的情况</strong>），返回
<code>true</code>，否则返回 <code>false</code>。</p>
<h2 id="解题思路">解题思路</h2>
<p>主要就是判断重叠区间需要搭载的人数是否超载</p>
<h3 id="排序-优先队列最小堆">排序 + 优先队列（最小堆）</h3>
<p>这个问题的关键在于我们需要实时跟踪车辆在每个位置上的乘客数量，确保在任何时候乘客数量都不超过车辆的容量。</p>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li><strong>按上车地点排序</strong>：首先将所有行程按照乘客的上车地点（<code>from</code>）进行升序排序。这样我们可以按照车辆行驶的顺序处理每个行程。</li>
<li><strong>使用优先队列跟踪下车事件</strong>：我们使用一个最小堆（优先队列）来记录当前车上的乘客组，堆顶元素是最近要下车的乘客组（即下车地点最小的）。堆中存储的是<code>(乘客数量, 下车地点)</code>这样的元素对。</li>
<li><strong>模拟乘车过程</strong>：
<ul>
<li>遍历排序后的行程，对于每个行程：
<ul>
<li>检查当前是否有乘客需要下车：如果堆顶元素的下车地点小于等于当前行程的上车地点，说明这些乘客应该在下个行程开始前下车，我们将它们从堆中弹出，并减少当前乘客数量。</li>
<li>将当前行程的乘客加入堆中，并增加当前乘客数量。</li>
<li>检查当前乘客数量是否超过车辆容量，如果超过则返回<code>false</code>。</li>
</ul></li>
<li>如果所有行程都能顺利完成，返回<code>true</code>。</li>
</ul></li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义比较函数对象</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ComparePair</span> {</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">            <span class="comment">// 根据第二个值排序</span></span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="type">int</span> current_num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(trips.<span class="built_in">begin</span>(), trips.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) {</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; <span class="comment">// 按第二个元素升序</span></span><br><span class="line">    });</span><br><span class="line">        <span class="comment">// 存放人数和目的地</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, ComparePair&gt; pq;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; trips.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {  <span class="comment">// 减去需要下车的乘客数量</span></span><br><span class="line">                <span class="keyword">auto</span> top = pq.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (top.second &lt;= trips[i][<span class="number">1</span>]) {</span><br><span class="line">                    current_num -= top.first;</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            pq.<span class="built_in">push</span>({trips[i][<span class="number">0</span>], trips[i][<span class="number">2</span>]});</span><br><span class="line">            current_num += trips[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (current_num &gt; capacity)  <span class="comment">// 判断是否超载</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/27/Transformer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/27/Transformer/" class="post-title-link" itemprop="url">Transformer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-27 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-27T00:00:00+08:00">2025-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-14 19:56:13" itemprop="dateModified" datetime="2025-09-14T19:56:13+08:00">2025-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Transformer/" itemprop="url" rel="index"><span itemprop="name">Transformer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/datawhalechina/leedl-tutorial/releases/tag/v1.2.4">李宏毅深度学习教程</a></li>
<li><a target="_blank" rel="noopener" href="https://datawhalechina.github.io/happy-llm/#/">Happy-LLM</a></li>
</ul>
<p>总结构如下，被框住的部分一般都有N个</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727221346536.png" alt="image-20250727221346536">
<figcaption aria-hidden="true">image-20250727221346536</figcaption>
</figure>
<h2 id="自注意力机制">自注意力机制</h2>
<p>自注意力模型会“吃”整个序列的数据，输入几个向量，它就输出几个向量</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727225641856.png" alt="image-20250727225641856" style="zoom:67%;"></p>
<p>对于输入序列中的每个
token（向量），我们会计算出三个矩阵：（X为输入矩阵即多个向量的组合，乘以对应的矩阵得到
Q、K、V）</p>
<ul>
<li><strong>Query (Q)</strong>：查询向量，<span class="math inline">\(Q
= W^QX\)</span></li>
<li><strong>Key (K)</strong>：键向量，<span class="math inline">\(K =
W^KX\)</span></li>
<li><strong>Value (V)</strong>：值向量，<span class="math inline">\(V =
W^VX\)</span></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727230428672.png" alt="image-20250727230428672" style="zoom:80%;"></p>
<p>计算注意力权重（softmax 后）： <span class="math display">\[
\text{Attention}(Q, K, V) =
\text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
\]</span> <span class="math inline">\(d_k\)</span> 是 Key
向量的维度（用于缩放避免梯度过大）</p>
<blockquote>
<p><strong>多头注意力机制</strong>：</p>
<p>Transformer 实际使用的是
<strong>多头自注意力</strong>，先计算整个向量的
Q、K、V，再进行拆分，下面是完整步骤</p>
<p><strong>Step 1: 线性变换</strong></p>
<p>先通过三组权重矩阵，计算整个序列的 Q、K、V：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python复制编辑Q = X @ W_Q  # [batch, seq_len, d_model] @ [d_model, d_model] -&gt; [batch, seq_len, d_model]</span><br><span class="line">K = X @ W_K</span><br><span class="line">V = X @ W_V</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Step 2: 拆分成多头</strong></p>
<p>再把 Q/K/V 拆成多个头（通常是 reshape + transpose）：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拆成多头，每一头的维度是 d_head</span></span><br><span class="line">Q = Q.reshape(batch_size, seq_len, num_heads, d_head).transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># Q 形状变为 [batch, num_heads, seq_len, d_head]</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>Step 3: 每个头独立进行注意力计算</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attention_scores = softmax(Q @ K.transpose(-<span class="number">1</span>, -<span class="number">2</span>) / sqrt(d_head))  <span class="comment"># shape: [batch, num_heads, seq_len, seq_len]</span></span><br><span class="line">output_heads = attention_scores @ V  <span class="comment"># shape: [batch, num_heads, seq_len, d_head]</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>Step 4: 拼接所有头 &amp; 最终线性变换</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拼接所有头</span></span><br><span class="line">output = output_heads.transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).reshape(batch_size, seq_len, d_model)</span><br><span class="line">output = output @ W_O  <span class="comment"># 最终线性变换</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727230452594.png" alt="image-20250727230452594" style="zoom:80%;"></p>
</blockquote>
<h2 id="编码器">编码器</h2>
<p>编码器输入一排向量，输出另外一排向量</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727220019098.png" alt="image-20250727220019098" style="zoom:50%;"></p>
<p>编码器内部可以分为多个块，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727220057077.png" alt="image-20250727220057077" style="zoom:67%;"></p>
<p>接下来就是每个块的细节</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727221138994.png" alt="image-20250727221138994">
<figcaption aria-hidden="true">image-20250727221138994</figcaption>
</figure>
<p>这里使用层归一化，因为层归一化会在每个样本上计算其所有层的均值和方差，从而使每个样本的分布达到稳定。</p>
<h2 id="解码器">解码器</h2>
<h3 id="自回归解码器">自回归解码器</h3>
<p>在生成序列时，每一步仅基于<strong>当前及之前的token</strong>预测下一个token，这就要用到掩蔽自注意力（masked
self-attention），掩蔽自注意力可以通过一个掩码（mask）来阻止每个位置选择其后面的输入信息。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727221042825.png" alt="image-20250727221042825">
<figcaption aria-hidden="true">image-20250727221042825</figcaption>
</figure>
<h3 id="非自回归解码器">非自回归解码器</h3>
<p>是一种并行生成序列的模型，与自回归（AR）解码器逐步生成的方式不同，它一次性输出整个序列，显著提升了推理速度，但可能牺牲生成质量。</p>
<p>例如：给编码器一堆 <code>&lt;BOS&gt;</code>
的词元。假设输出的句子的长度有上限，绝对不会超过 300 个字。给编码器 300
个 <code>&lt;BOS&gt;</code>，就会输出 300 个字，输出
<code>&lt;EOS&gt;</code> 右边的的输出就当它没有输出。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727221617793.png" alt="image-20250727221617793">
<figcaption aria-hidden="true">image-20250727221617793</figcaption>
</figure>
<h2 id="编码器-解码器注意力">编码器-解码器注意力</h2>
<p>编码器的最终输出（即最后一层的隐藏状态）会作为<strong>Key和Value</strong>输入到解码器的<strong>每一层</strong>的交叉注意力（Cross-Attention）模块中。</p>
<p><img src="https://raw.githubusercontent.com/datawhalechina/happy-llm/main/docs/images/2-figures/2-0.jpg" style="zoom: 67%;"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250727224644292.png" alt="image-20250727224644292" style="zoom:80%;"></p>
<h2 id="流程总结">流程总结</h2>
<ol type="1">
<li><p><strong>输入预处理</strong></p>
<ul>
<li><p><strong>Tokenization</strong>：文本 → Token IDs（如
<code>[I, love, NLP]</code> →
<code>[1045, 2293, 4263]</code>）。</p></li>
<li><p><strong>Embedding</strong>：Token IDs →
词向量（<code>d_model</code> 维，如 512 维）。</p></li>
<li><p><strong>Positional Encoding</strong>：加入位置信息 → 最终输入向量
<code>X = WordEmbedding + PositionalEncoding</code>。</p>
<blockquote>
<p><strong>位置编码的区别</strong></p>
<ul>
<li><p><strong>Transformer（原始模型）</strong>：</p>
<ul>
<li><p>使用
<strong>固定的数学函数</strong>（正弦和余弦函数）生成位置编码，与输入嵌入（token
embeddings）<strong>相加</strong>。</p></li>
<li><p>公式： <span class="math display">\[
PE_{(pos, 2i)} =
\sin\left(\frac{pos}{10000^{2i/d_{\text{model}}}}\right), \quad
PE_{(pos, 2i+1)} =
\cos\left(\frac{pos}{10000^{2i/d_{\text{model}}}}\right)
\]</span></p>
<p>其中 pos 是位置，i 是维度索引，d<sub>model</sub>
是模型维度。</p></li>
<li><p>这种编码是确定性的，无需学习，能捕捉绝对位置和相对位置关系。</p></li>
</ul></li>
<li><p><strong>BERT</strong>：</p>
<ul>
<li>使用 <strong>可学习的位置嵌入（Learned Positional
Embeddings）</strong>，即每个位置（如最大长度512）对应一个随机初始化的向量，通过训练更新。</li>
<li>位置嵌入与 token embeddings <strong>相加</strong>，类似
Transformer，但嵌入值是模型学到的，而非预设的数学函数</li>
</ul></li>
</ul>
</blockquote></li>
</ul></li>
<li><p><strong>Encoder 阶段（N 一般是 6 层）</strong></p>
<ul>
<li>每层执行：
<ul>
<li><strong>多头自注意力</strong>（计算全局依赖）</li>
<li><strong>前馈网络 FFN</strong>（非线性变换）</li>
<li><strong>残差连接 + LayerNorm</strong>（稳定训练）</li>
</ul></li>
<li>输出：上下文感知的编码表示 <code>Z</code>（供 Decoder 使用）。</li>
</ul></li>
<li><p><strong>Decoder 阶段（N 一般是 6 层）</strong></p>
<ul>
<li>每层执行：
<ul>
<li><strong>掩码自注意力</strong>（防止未来信息泄漏）</li>
<li><strong>残差连接 + LayerNorm</strong></li>
<li><strong>Encoder-Decoder 注意力</strong>（关注 <code>Z</code>）</li>
<li><strong>残差连接 + LayerNorm</strong></li>
<li><strong>前馈网络 FFN</strong></li>
<li><strong>残差连接 + LayerNorm</strong></li>
</ul></li>
<li>输出：解码后的隐藏状态 <code>H</code>。</li>
</ul></li>
<li><p><strong>输出生成</strong></p>
<ul>
<li><strong>线性层</strong>：将 <code>H</code> 投影到词表大小维度（如
50,000 维）。</li>
<li><strong>Softmax</strong>：生成概率分布 → 选择概率最高的 Token
作为输出（或采样）。</li>
</ul></li>
<li><p><strong>自回归（Autoregressive）</strong></p>
<ul>
<li>若为生成任务（如
GPT），将当前输出作为下一步输入，循环直至结束。</li>
</ul></li>
</ol>
<h2 id="bert和gpt">BERT和GPT</h2>
<ul>
<li><strong>BERT</strong>（Bidirectional Encoder Representations from
Transformers）——填空
<ul>
<li><strong>双向编码器</strong>：使用Transformer的<strong>Encoder</strong>部分，能同时利用上下文信息（左右双向上下文）。</li>
<li>适合理解型任务（如文本分类、实体识别、问答）。</li>
<li>结构：Transformer编码器 + <strong>MLM</strong>(随机掩码) /
<strong>NSP</strong>(下一句预测)</li>
</ul></li>
<li><strong>GPT</strong>（Generative Pre-trained
Transformer）——预测下一个词
<ul>
<li><strong>单向解码器</strong>：使用Transformer的<strong>Decoder</strong>部分（掩码自注意力），没有交叉注意力（因为没有编码器的输出作为输入），仅依赖左侧上下文生成文本。</li>
<li>适合生成型任务（如文本生成、对话、续写）。</li>
</ul></li>
</ul>
<h2 id="post-norm-和-pre-norm">Post-Norm 和 Pre-Norm</h2>
<p>在 Transformer 及其变体模型中，<strong>Pre-Norm</strong> 和
<strong>Post-Norm</strong> 是两种不同的层归一化（Layer Normalization,
LayerNorm）放置方式，直接影响模型的训练稳定性、收敛速度和性能。以下是它们的详细对比：</p>
<h3 id="post-norm原始-transformer-设计"><strong>1. Post-Norm（原始
Transformer 设计）</strong></h3>
<ul>
<li><p><strong>结构顺序</strong>：</p>
<p><code>残差连接 → LayerNorm</code></p>
<p>即：<br>
<span class="math display">\[
\text{Output} = \text{LayerNorm}(x + \text{Sublayer}(x))
\]</span></p>
<ul>
<li>例如：多头注意力或前馈网络（FFN）的输出先与输入残差连接，再进行归一化。</li>
</ul></li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><strong>原始 Transformer</strong>（论文中的编码器/解码器）和
<strong>GLM</strong>（由智谱开发的主流中文 LLM 之一）使用
Post-Norm。</li>
<li>训练初期可能不稳定（梯度方差大），需要配合 <strong>warm-up</strong>
学习率调度。</li>
<li>更深的模型容易因梯度消失/爆炸而难以训练。</li>
<li>理论上有更强的表达能力（因归一化在非线性变换后），但实际需要精细调参。</li>
</ul></li>
</ul>
<h3 id="pre-norm主流变体设计"><strong>2.
Pre-Norm（主流变体设计）</strong></h3>
<ul>
<li><p><strong>结构顺序</strong>：</p>
<p><code>LayerNorm → 残差连接</code></p>
<p>即： <span class="math display">\[
\text{Output} = x + \text{Sublayer}(\text{LayerNorm}(x))
\]</span></p>
<ul>
<li>先对输入归一化，再通过子层（如注意力或
FFN），最后与原始输入残差连接。</li>
</ul></li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><strong>BERT、GPT 等现代模型普遍采用 Pre-Norm</strong>。</li>
<li>训练更稳定，无需 warm-up 也能快速收敛。</li>
<li>支持更深的网络（如 100+ 层），梯度传播更顺畅。</li>
<li>牺牲少量理论表达能力，换取实际训练的鲁棒性。</li>
</ul></li>
</ul>
<h3 id="核心区别对比"><strong>3. 核心区别对比</strong></h3>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 42%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>Post-Norm</th>
<th>Pre-Norm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>归一化位置</strong></td>
<td>残差连接后</td>
<td>残差连接前（子层输入）</td>
</tr>
<tr class="even">
<td><strong>训练稳定性</strong></td>
<td>依赖 warm-up，易不稳定</td>
<td>更稳定，适合深层模型</td>
</tr>
<tr class="odd">
<td><strong>梯度传播</strong></td>
<td>可能梯度消失/爆炸（深模型）</td>
<td>梯度更平缓，易于优化</td>
</tr>
<tr class="even">
<td><strong>表达能力</strong></td>
<td>理论上更强（非线性后归一化）</td>
<td>稍弱，但实际差距小</td>
</tr>
<tr class="odd">
<td><strong>典型应用</strong></td>
<td>原始 Transformer</td>
<td>BERT、GPT、T5 等现代模型</td>
</tr>
</tbody>
</table>
<h3 id="其他变体与改进"><strong>4. 其他变体与改进</strong></h3>
<ul>
<li><strong>ReZero Norm</strong>：将残差连接乘以可学习的标量（初始为
0），逐步增加非线性强度，结合两者优点。</li>
<li><strong>Sandwich Norm</strong>：在子层前后都加入 LayerNorm（如
<code>Norm → Sublayer → Norm → 残差</code>），进一步提升稳定性。</li>
<li><strong>DeepNorm</strong>（微软）：在 Post-Norm
基础上调整残差权重，用于极深模型（如 1000 层）。</li>
</ul>
<h2 id="llm">LLM</h2>
<p>三个阶段——Pretrain、SFT 和 RLHF</p>
<p>大语言模型（LLM）的训练通常分为三个关键阶段，每个阶段有不同的目标和方法：</p>
<h3 id="pretraining">1. Pretraining</h3>
<p>预训练</p>
<blockquote>
<p><strong>目标：</strong>
学习语言的通用知识（语法、语义、世界常识等）</p>
</blockquote>
<h4 id="过程">过程：</h4>
<ul>
<li>利用大规模通用语料（如网页、书籍、百科等）进行<strong>自监督学习</strong>。</li>
<li>训练任务通常是：
<ul>
<li><strong>因果语言建模（Causal LM）</strong>：预测下一个词（GPT
风格）</li>
<li><strong>掩码语言建模（Masked LM）</strong>：预测被遮盖的词（BERT
风格）</li>
</ul></li>
</ul>
<h4 id="特点">特点：</h4>
<ul>
<li>模型尚未特定任务对齐，仅有通用语言能力</li>
<li>参数量巨大（几十亿到千亿级别）</li>
<li>训练耗费算力与数据</li>
</ul>
<h3 id="sft">2. SFT</h3>
<p>Supervised Fine-Tuning，监督微调</p>
<blockquote>
<p><strong>目标：</strong>
将模型调整为能按照人类期望完成具体任务（如问答、摘要）</p>
</blockquote>
<h4 id="过程-1">过程：</h4>
<ul>
<li><p>使用<strong>人工标注的高质量指令-响应对</strong>进行监督微调（如
Alpaca、OpenAI InstructGPT 数据）</p></li>
<li><p>输入是类似：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令（Instruction）：请写一首关于春天的诗</span><br><span class="line">输出（Response）：春风吹绿柳，暖日照花枝……</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="特点-1">特点：</h4>
<ul>
<li>显著提升对“任务”或“指令”的响应能力</li>
<li>强化了与人类沟通的能力，但输出可能仍存在幻觉或不可靠性</li>
</ul>
<blockquote>
<p>注意指令微调和 Prompt 工程的区别</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 37%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>项目</th>
<th>指令微调（Instruction Tuning）</th>
<th>Prompt 工程（Prompt Engineering）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>是否训练模型</td>
<td>✅ 需要重新训练或微调模型</td>
<td>❌ 不训练，直接用</td>
</tr>
<tr class="even">
<td>成本</td>
<td>高：需要 GPU、数据、训练资源</td>
<td>低：只需要会写 prompt</td>
</tr>
<tr class="odd">
<td>是否修改模型参数</td>
<td>✅ 修改参数</td>
<td>❌ 不修改</td>
</tr>
<tr class="even">
<td>应用阶段</td>
<td>训练阶段（Finetune）</td>
<td>推理阶段（Inference）</td>
</tr>
<tr class="odd">
<td>优点</td>
<td>长期效果好、可扩展</td>
<td>灵活、快速试验</td>
</tr>
<tr class="even">
<td>缺点</td>
<td>昂贵、不易调试</td>
<td>不稳定、易受上下文影响</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="rlhf">3. RLHF</h3>
<p>Reinforcement Learning with Human Feedback</p>
<blockquote>
<p><strong>目标：</strong>
利用人类偏好优化模型行为，提升对齐程度（alignment）</p>
</blockquote>
<h4 id="过程-2">过程：</h4>
<ol type="1">
<li><strong>收集人类偏好数据：</strong>
给出同一个输入，模型生成多个回答，由人类标注哪个更好。</li>
<li><strong>训练奖励模型（RM）：</strong>
学习如何从输入和输出中打分。</li>
<li><strong>强化学习（PPO 等）：</strong>
使用奖励模型对主模型进行强化学习优化。</li>
</ol>
<h4 id="特点-2">特点：</h4>
<ul>
<li>对齐人类偏好（例如：更礼貌、更安全、更有逻辑）</li>
<li>可以显著改善模型的对话体验和安全性（ChatGPT、Claude
等都采用该方式）</li>
</ul>
<h3 id="总结流程图">总结流程图</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始语料（大规模网络文本等）</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">    Pretraining（自监督）</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">SFT（有标注任务数据，提升任务能力）</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">RLHF（通过人类偏好进一步优化）</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/26/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/26/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Go语言项目管理与包管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-26 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-26T00:00:00+08:00">2025-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-27 00:10:36" itemprop="dateModified" datetime="2025-07-27T00:10:36+08:00">2025-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文由 ChatGPT 生成</p>
<h2 id="引言"><strong>引言</strong></h2>
<p>Go 语言以其简洁的语法和强大的工具链著称，但其独特的项目管理机制（如
<code>module</code>、<code>package</code> 和
<code>GOPATH</code>）常让初学者困惑。本文将系统梳理 Go
的项目结构、包管理规则和最佳实践，帮助你高效组织代码。</p>
<hr>
<h2 id="从-gopath-到-go-module演进史"><strong>1. 从 GOPATH 到 Go
Module：演进史</strong></h2>
<h3 id="gopath-时代已淘汰"><strong>1.1 GOPATH
时代（已淘汰）</strong></h3>
<ul>
<li><strong>作用</strong>：全局工作区，所有项目必须放在
<code>$GOPATH/src</code> 下。</li>
<li><strong>问题</strong>：
<ul>
<li>依赖全局共享，易冲突</li>
<li>项目路径不灵活</li>
</ul></li>
<li><strong>目录结构</strong>： <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOPATH/</span><br><span class="line">├── src/github.com/user/project  # 项目代码</span><br><span class="line">├── pkg/                        # 编译后的库</span><br><span class="line">└── bin/                        # 可执行文件</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="go-module现代标准"><strong>1.2 Go
Module（现代标准）</strong></h3>
<ul>
<li><strong>核心文件</strong>：<code>go.mod</code>（定义模块路径、依赖项）。</li>
<li><strong>优势</strong>：
<ul>
<li>项目可放在任意路径</li>
<li>依赖版本锁定（<code>go.sum</code>）</li>
<li>支持语义化版本（如 <code>v1.2.3</code>）</li>
</ul></li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.mod 示例</span></span><br><span class="line">module github.com/user/project  <span class="comment">// 全局唯一标识</span></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.21</span>                        <span class="comment">// Go 版本要求</span></span><br><span class="line">require (</span><br><span class="line">    github.com/gin-gonic/gin v1<span class="number">.9</span><span class="number">.1</span>  <span class="comment">// 依赖项，保存的位置：%GOPATH%\pkg\mod\</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="模块module与包package的关系"><strong>2.
模块（Module）与包（Package）的关系</strong></h2>
<h3 id="module项目的集装箱"><strong>2.1
Module：项目的集装箱</strong></h3>
<ul>
<li><strong>一个项目 = 一个模块 = 一个 <code>go.mod</code>
文件</strong></li>
<li><strong>模块路径</strong>需全局唯一（如 GitHub 仓库地址）：
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init github.com/yourname/project</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="package代码的逻辑单元"><strong>2.2
Package：代码的逻辑单元</strong></h3>
<ul>
<li><strong>规则</strong>：
<ul>
<li>同一目录下所有文件必须属于<strong>同一个包</strong></li>
<li>包名通常与目录名一致（非强制）</li>
<li>大写字母开头的标识符可被其他包访问</li>
</ul></li>
<li><strong>示例</strong>： <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg/utils/strings.go</span></span><br><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> {  <span class="comment">// 可导出的函数</span></span><br><span class="line">    <span class="keyword">return</span> strings.TrimSpace(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>所以一个项目相当于一个 module，包含多个 package</p>
<hr>
<h2 id="关键目录结构设计"><strong>3. 关键目录结构设计</strong></h2>
<h3 id="标准布局"><strong>3.1 标准布局</strong></h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── cmd/</span><br><span class="line">│   └── main.go</span><br><span class="line">├── pkg/</span><br><span class="line">│   └── utils/</span><br><span class="line">│       └── math.go</span><br><span class="line">└── internal/          # 私有代码（仅限当前模块使用）</span><br><span class="line">    └── secret/</span><br><span class="line">        └── secret.go</span><br></pre></td></tr></tbody></table></figure>
<h3 id="特殊目录说明"><strong>3.2 特殊目录说明</strong></h3>
<table>
<thead>
<tr class="header">
<th>目录</th>
<th>用途</th>
<th>可见性规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cmd/</code></td>
<td>存放 <code>main</code> 包的可执行程序</td>
<td>无限制</td>
</tr>
<tr class="even">
<td><code>internal/</code></td>
<td>内部私有代码</td>
<td>仅父模块可导入</td>
</tr>
<tr class="odd">
<td><code>pkg/</code></td>
<td>公共库代码</td>
<td>可被其他模块导入</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="包package的进阶规则"><strong>4.
包（Package）的进阶规则</strong></h2>
<h3 id="main-包的特殊性"><strong>4.1 <code>main</code>
包的特殊性</strong></h3>
<ul>
<li>只有<code>main</code>包才能包含 <code>func main()</code></li>
<li>编译生成可执行文件： <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o app cmd/app/main.go</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="go-中-package-的调用逻辑">4.2 Go 中 <code>package</code>
的调用逻辑</h3>
<p>在 Go 中：</p>
<ul>
<li>每个 <code>.go</code> 文件都属于某个
<code>package</code>（包）。</li>
<li>包名决定了文件之间能否互相引用。</li>
<li><strong>主程序（入口）通常在 <code>package main</code>
中</strong>，其他功能模块则可以定义为自定义包。</li>
<li>如果你想在 <code>main.go</code> 中调用其他包的函数，必须：
<ol type="1">
<li>在目标文件中将函数名 <strong>大写</strong>（表示导出
Exported）；</li>
<li>在 <code>main.go</code> 中使用 <code>import</code> 引入包；</li>
<li>保证代码在模块结构下能找到包路径。</li>
</ol></li>
</ul>
<hr>
<h4 id="示例">🔹 示例</h4>
<h5 id="项目结构">📁 项目结构</h5>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myproject/</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── utils/</span><br><span class="line">    └── mathutil.go</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="go.mod">📄 go.mod</h5>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module example.com/myproject</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.21</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="utilsmathutil.go">📄 utils/mathutil.go</h5>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 是导出的函数（首字母大写），可以被其他包调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="main.go">📄 main.go</h5>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"example.com/myproject/utils"</span>  <span class="comment">// 引入本模块下的 utils 包</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    sum := utils.Add(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment">// 调用 utils 包中的 Add 函数</span></span><br><span class="line">    fmt.Println(<span class="string">"Sum:"</span>, sum)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="总结调用规则">🔹 总结调用规则</h4>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>元素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>package xxx</code></td>
<td>决定该文件属于哪个包</td>
</tr>
<tr class="even">
<td><code>import</code></td>
<td>在另一个文件中引用该包，使用的是
<code>module 路径 + 包相对路径</code></td>
</tr>
<tr class="odd">
<td>导出函数</td>
<td>被调用的函数必须 <strong>首字母大写</strong>，否则是私有的</td>
</tr>
<tr class="even">
<td>go.mod</td>
<td>必须正确声明 <code>module</code>，才能让 <code>import</code>
路径生效</td>
</tr>
</tbody>
</table>
<h3 id="可见性控制"><strong>4.3 可见性控制</strong></h3>
<ul>
<li><strong>大写字母开头</strong>：可被其他包访问（如
<code>func Public()</code>）。</li>
<li><strong>小写字母开头</strong>：仅限包内使用（如
<code>func private()</code>）。</li>
</ul>
<h3 id="初始化函数-init"><strong>4.4 初始化函数
<code>init()</code></strong></h3>
<ul>
<li>每个包可定义多个 <code>init()</code>，按依赖顺序自动执行：
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"数据库连接初始化"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<hr>
<h2 id="依赖管理实战"><strong>5. 依赖管理实战</strong></h2>
<h3 id="添加依赖"><strong>5.1 添加依赖</strong></h3>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin@v1.9.1  <span class="comment"># 指定版本</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="常用命令"><strong>5.2 常用命令</strong></h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>go mod init</code></td>
<td>初始化模块</td>
</tr>
<tr class="even">
<td><code>go mod tidy</code></td>
<td>同步依赖项</td>
</tr>
<tr class="odd">
<td><code>go list -m all</code></td>
<td>查看所有依赖</td>
</tr>
<tr class="even">
<td><code>go mod vendor</code></td>
<td>创建本地依赖副本（离线构建）</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/13/std_thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/13/std_thread/" class="post-title-link" itemprop="url">std::thread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-13T00:00:00+08:00">2025-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-27 00:13:08" itemprop="dateModified" datetime="2025-07-27T00:13:08+08:00">2025-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一基本使用方法">一、基本使用方法</h2>
<h3 id="创建线程">1. 创建线程</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello from thread!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(printMessage)</span></span>; <span class="comment">// 启动线程</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="带参数的线程">2. 带参数的线程</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(printSum, <span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 传值参数</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用-lambda-表达式">3. 使用 Lambda 表达式</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]() {</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">"Lambda thread"</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">})</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用成员函数">4. 使用成员函数</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> times)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Working..."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Worker w;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;Worker::doWork, &amp;w, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="二线程控制">二、线程控制</h2>
<h3 id="detach">1. <code>detach()</code></h3>
<p><code>std::thread::detach()</code> 的意思是：</p>
<ul>
<li>让线程 <strong>后台运行（daemon-like）</strong></li>
<li>主线程 <strong>不再跟踪这个线程</strong>，你不能再
<code>join()</code> 它，也无法控制它</li>
<li>它会在自己工作完成后自动结束</li>
</ul>
<h4 id="但如果-main-提前退出">但如果 <code>main()</code> 提前退出？</h4>
<p>一旦 <code>main()</code>
返回，程序的所有资源都会被释放，<strong>包括所有线程</strong>（不管他们干完了没有）！</p>
<ul>
<li>即使你已经 <code>detach()</code>
了线程，它也可能<strong>没有时间完成任务</strong>；</li>
<li>程序就直接退出了，<strong>线程被强制杀死</strong>，<strong>任务中断</strong>；</li>
<li>所以你可能看不到完整输出，或者文件没下载完。</li>
</ul>
<h4 id="示例">示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>{</span><br><span class="line">    std::<span class="built_in">thread</span>([] {</span><br><span class="line">        <span class="built_in">download</span>(<span class="string">"file.zip"</span>); <span class="comment">// 下载需要 4 秒</span></span><br><span class="line">    }).<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">myfunc</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 马上退出！后台线程直接被终止</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 运行结果：可能只打印出 1～2 行“Downloading ...”，甚至什么都不打印。*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>解决方法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([] {</span></span></span><br><span class="line"><span class="params"><span class="function">        download(<span class="string">"file.zip"</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    })</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等它干完</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="join">2. <code>join()</code></h3>
<p><code>std::thread::join()</code>
的作用是：<strong>阻塞当前线程，直到目标线程执行完成</strong>。</p>
<ul>
<li>当你调用
<code>t.join();</code>，当前线程（比如主线程）会<strong>暂停运行</strong>；</li>
<li>一直等到 <code>t</code> 所代表的那个子线程跑完；</li>
<li>然后继续执行后面的语句。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ol type="1">
<li><p>一个线程只能 <code>join()</code> 一次</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(work)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">t.<span class="built_in">join</span>(); <span class="comment">// 再次调用会崩溃，线程已经结束</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>线程未启动不能 <code>join()</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread t;  <span class="comment">// 默认构造，未绑定函数</span></span><br><span class="line">t.<span class="built_in">join</span>();       <span class="comment">// 崩溃，线程未启动</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>通常在 <code>joinable()</code> 判断后调用</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) {</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是一种<strong>良好的编程习惯</strong>，避免调用非法
<code>join()</code>。</p></li>
</ol>
<hr>
<h2 id="三常见注意事项">三、常见注意事项</h2>
<ol type="1">
<li><p><strong>不要忘记调用 <code>join()</code> 或
<code>detach()</code></strong>，否则程序会崩溃。</p></li>
<li><p><strong>传递引用参数时要使用 <code>std::ref</code></strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>{ x++; }</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update, std::ref(myInt))</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>避免使用局部变量传给线程（可能悬空）</strong>。</p></li>
<li><p><strong>多线程共享资源要注意加锁</strong>，使用
<code>std::mutex</code> 等同步原语。</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Linux网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-03 00:00:00 / 修改时间：13:38:57" itemprop="dateCreated datePublished" datetime="2025-04-03T00:00:00+08:00">2025-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络编程基础api">网络编程基础API</h2>
<p><strong>补充知识</strong></p>
<ul>
<li>主机字节序：一般为<strong>小端序</strong>（低位放在较小的地址处，高位放在较大的地址处）</li>
<li>网络字节序：一般为<strong>大端序</strong></li>
</ul>
<p>示例：0x01234567，其中 0x01 是最高位有效字节，0x67
是最低位有效字节</p>
<h3 id="套接字地址">套接字地址</h3>
<p>套接字地址（<strong>Socket Address</strong>）是 <strong>IP
地址和端口号的组合</strong>，用于唯一标识网络上的一个进程。</p>
<ol type="1">
<li><p><code>struct sockaddr</code></p>
<p><code>sockaddr</code>
是一个<strong>通用的地址结构体</strong>，它的定义如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// 地址族（AF_INET, AF_INET6等）</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// 地址数据（具体的地址信息）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>成员解析</strong>：</p>
<ul>
<li><code>sa_family_t sa_family</code>：地址族（例如
<code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6）。</li>
<li><code>char sa_data[14]</code>：存储具体的地址数据（IP 地址 +
端口）。</li>
</ul>
<p><strong>⚠️ <code>sockaddr</code>
本身不会直接使用，而是由更具体的结构体（如 <code>sockaddr_in</code> 和
<code>sockaddr_in6</code>）进行扩展。</strong></p></li>
<li><p><code>sockaddr_in</code>（IPv4 地址）</p>
<p><code>sockaddr_in</code> 结构体是 <code>sockaddr</code>
的<strong>专门版本</strong>，用于<strong>IPv4 地址</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// sockaddr_in 定义在这个头文件中</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">// 地址族（必须是 AF_INET）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;       <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;  <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">// 备用字段（填充用，一般不用）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这里的<code>struct in_addrc</code>的详细代码定义在<code>&lt;netinet/in.h&gt;</code>文件头中：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> {</span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32 位 IPv4 地址（网络字节序）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>示例代码（IPv4 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// 包含 inet_pton 和 inet_ntoa</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">"192.168.1.1"</span>, &amp;addr.sin_addr);  <span class="comment">// 将IP字符串转换为二进制格式</span></span><br><span class="line">    <span class="comment">// 第三个参数 &amp;addr.sin_addr 表示转换后的二进制 IP 地址的存储位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印转换后的信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IP: "</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr.sin_port) &lt;&lt; std::endl;  <span class="comment">// 端口转换回主机字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>函数解析</strong>：</p>
<ul>
<li><code>htons(port)</code>：将主机字节序的<strong>端口号</strong>转换为<strong>网络字节序</strong>。</li>
<li><code>ntohs(port)</code>：将网络字节序的<strong>端口号</strong>转换回<strong>主机字节序</strong>。</li>
<li><code>inet_pton(AF_INET, "192.168.1.1", &amp;addr.sin_addr)</code>：将
IPv4 字符串转换为二进制格式。为了后续的 socket 操作（例如
<code>connect</code> 或 <code>bind</code>）能够使用正确的二进制格式的 IP
地址。</li>
<li><code>inet_ntoa(addr.sin_addr)</code>：将二进制 <strong>IP
地址</strong>转换为可读的字符串。</li>
</ul></li>
<li><p><code>sockaddr_in6</code>（IPv6 地址）</p>
<p>IPv6 地址使用 <code>sockaddr_in6</code> 结构体：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;     <span class="comment">// 地址族（必须是 AF_INET6）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;         <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;      <span class="comment">// IPv6 流量控制信息（一般设为 0）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;   <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;      <span class="comment">// 作用域 ID（用于本地连接）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>示例代码（IPv6 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> addr6;</span><br><span class="line">    addr6.sin6_family = AF_INET6;</span><br><span class="line">    addr6.sin6_port = <span class="built_in">htons</span>(<span class="number">9090</span>);  <span class="comment">// 端口号</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET6, <span class="string">"::1"</span>, &amp;addr6.sin6_addr);  <span class="comment">// 将 IPv6 地址转换为二进制</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ip_str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET6, &amp;addr6.sin6_addr, ip_str, <span class="built_in">sizeof</span>(ip_str));  <span class="comment">// 转换回可读字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IPv6: "</span> &lt;&lt; ip_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr6.sin6_port) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>IPv6 相关函数</strong>：</p>
<ul>
<li><code>inet_pton(AF_INET6, "::1", &amp;addr6.sin6_addr)</code>：将
IPv6 地址字符串转换为二进制格式。</li>
<li><code>inet_ntop(AF_INET6, &amp;addr6.sin6_addr, ip_str, sizeof(ip_str))</code>：将
IPv6 二进制地址转换回字符串。</li>
</ul></li>
</ol>
<h3 id="创建套接字">创建套接字</h3>
<p>socket系统调⽤成功时返回⼀个socket⽂件描述符，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>domain</code>（协议族）：<code>AF_INET</code>（IPv4）、<code>AF_INET6</code>（IPv6）、<code>AF_UNIX</code>（本地通信）</li>
<li><code>type</code>（套接字类型）：<code>SOCK_STREAM</code>（流服务，TCP）、<code>SOCK_DGRAM</code>（数据报服务，UDP）</li>
<li><code>protocol</code>（协议）：<code>0</code>（默认），<code>IPPROTO_TCP</code>（TCP），<code>IPPROTO_UDP</code>（UDP）</li>
</ul>
<h3 id="绑定套接字">绑定套接字</h3>
<p><code>bind</code>函数<strong>将套接字（socket）与本地 IP
地址和端口号绑定</strong>，即上面提到的两个关键字，这样客户端可以连接到该地址。成功时返回0，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：<strong>要绑定的 socket 文件描述符</strong>（由
<code>socket()</code> 创建）</li>
<li><code>addr</code>：<strong>要绑定的本地地址（IP +
端口）</strong>，需要转换为 <code>sockaddr*</code>
类型（默认套接字地址类型）</li>
<li><code>addrlen</code>：<strong>地址结构体的大小</strong>（通常用
<code>sizeof(struct sockaddr_in)</code>）</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr {};</span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// 使用 IPv4</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定到本机所有 IP</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 绑定端口 8080</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"bind failed"</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Socket bound to port 8080"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="监听套接字">监听套接字</h3>
<p><code>listen</code>函数创建⼀个监听队列以存放待处理的客户连接。成功时返回0，失败则返回-1。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket 文件描述符，通常是通过
<code>socket()</code> 创建并已绑定地址和端口的 socket</li>
<li><code>backlog</code>：连接队列的最大长度。
<ul>
<li>当多个客户端同时尝试连接服务器时，未处理的连接请求会被放入队列中。</li>
<li><code>backlog</code>
指定了队列的最大长度。如果队列已满，新的连接请求会被拒绝。</li>
</ul></li>
</ul>
<blockquote>
<p>监听队列中<strong><code>ESTABLISHED</code> 状态</strong> 的连接表示
<strong>三次握手成功</strong>，连接已建立，可以通信。但此时连接还在
<strong>监听队列</strong> 中，服务器端还
<strong>不能直接读写数据</strong>，需要通过 <code>accept()</code>
取出连接。</p>
</blockquote>
<h3 id="接受连接">接受连接</h3>
<p><code>accept</code>函数从<code>listen</code>监听队列中接受⼀个连接。成功返回新的<strong>已连接套接字描述符</strong>，用于与客户端通信；失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket文件描述符（这里是被监听的socket）</li>
<li><code>addr</code>：指向存储客户端地址信息的结构体，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：指向地址长度的指针，调用前应设置为
<code>addr</code> 的长度，调用后会被修改为实际地址长度。</li>
</ul>
<h3 id="发起连接">发起连接</h3>
<p><code>connect</code>函数⽤来主动与服务器建⽴连接。成功返回<code>0</code>，失败返回<code>-1</code>。⼀旦成功建⽴连接，sockfd就唯⼀地标识了这个连接，客户端就可以通过读写<code>sockfd</code>来与服务器通信。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：文件描述符</li>
<li><code>addr</code>：<strong>服务器地址</strong>信息，包括 IP
和端口。</li>
<li><code>addrlen</code>：<code>addr</code>的大小</li>
</ul>
<blockquote>
<p><strong><code>connect</code> 是客户端主动建立连接</strong></p>
<p><strong><code>accept</code>是服务器被动接受连接</strong></p>
</blockquote>
<h3 id="关闭连接">关闭连接</h3>
<h4 id="close">close</h4>
<p>关闭<code>sockfd</code>对应的socket连接。成功返回<code>0</code>，失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用计数机制</strong>：</p>
<ul>
<li>内核维护<strong>文件描述符的引用计数</strong>。</li>
<li>调用 <code>close()</code> 时，引用计数 <strong>减 1</strong>。</li>
<li>当引用计数为 0，才真正关闭连接</li>
</ul>
<h4 id="shutdown">shutdown</h4>
<p>如果⽆论如何都要⽴即终⽌连接（⽽不是将socket的引⽤计数减1），可以使⽤的<code>shutdown</code>系统调⽤。成功时返回<code>0</code>，失败则返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line"><span class="comment">/* how 参数表示关闭方式：SHUT_RD、SHUT_WR、SHUT_RDWR */</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>shutdown</code>能够分别关闭socket上的读或写，或者都关闭。⽽<code>close</code>在关闭连接时只能将socket上的读和写同时关闭。</p>
<h3 id="数据读写">数据读写</h3>
<p>对文件的读写操作<code>read</code>和<code>write</code>同样适用于socket</p>
<h4 id="tcp数据读写">TCP数据读写</h4>
<ol type="1">
<li><p><code>send()</code></p>
<p><strong>发送数据</strong>到已连接的 <strong>TCP
套接字</strong>中。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code> 。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>待发送数据</strong>的缓冲区</li>
<li><code>len</code>：带发送数据的长度</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞发送</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞发送</strong>，若缓冲区满，则立即返回</li>
<li><code>MSG_NOSIGNAL</code>：<strong>不触发 SIGPIPE
信号</strong>，在对端关闭时返回错误</li>
</ul></li>
</ul></li>
<li><p><code>recv()</code></p>
<p><strong>从 TCP
套接字接收数据</strong>并存入缓冲区。成功则返回<strong>接收到的字节数</strong>（<code>0</code>：表示
<strong>对方关闭连接</strong>，即发送了 <code>FIN</code>
包），失败则返回<code>-1</code>。可能要多次调⽤<code>recv</code></p>
<p><strong>失败</strong>：返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞接收</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞接收</strong>，若无数据则立即返回</li>
<li><code>MSG_PEEK</code>：<strong>窥视模式</strong>，读取数据但不删除缓冲区中的内容</li>
</ul></li>
</ul></li>
</ol>
<h4 id="udp数据报读写">UDP数据报读写</h4>
<ol type="1">
<li><p><code>sendto()</code></p>
<p>发送 UDP
数据报到指定的目标地址。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>： 套接字描述符</li>
<li><code>buf</code>：指向 <strong>待发送数据</strong> 的缓冲区</li>
<li><code>len</code>：待发送数据长度</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>dest_addr</code>（结构体）：目标地址，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：目标地址结构体的大小</li>
</ul></li>
<li><p><code>recvfrom()</code></p>
<p>接收 UDP
数据报并保存到缓冲区中。成功则返回<strong>实际接收的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>src_addr</code>：存放发送地址的结构体指针</li>
<li><code>addrlen</code>：发送方地址结构体的大小</li>
</ul></li>
</ol>
<h4 id="通用数据读写">通用数据读写</h4>
<p>不仅能⽤于TCP流数据，也能⽤于UDP数据报</p>
<ol type="1">
<li><p><code>sendmsg</code></p>
<p>成功则返回发送的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符。</li>
<li><code>msg</code>：指向 <strong><code>msghdr</code>
结构体</strong>，包含要发送的数据、目标地址、控制信息。</li>
<li><code>flags</code>：发送标志，如
<code>MSG_DONTWAIT</code>、<code>MSG_EOR</code>。</li>
</ul></li>
<li><p><code>recvmsg</code></p>
<p>成功则返回接收的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p><code>msghdr</code>结构体详解</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> {</span><br><span class="line">    <span class="type">void</span>         *msg_name;       <span class="comment">// 地址信息 (UDP：目标地址 / 源地址；对于⾯向连接的TCP协议，该成员没有意义)</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;        <span class="comment">// 数据缓冲区数组</span></span><br><span class="line">    <span class="type">size_t</span>        msg_iovlen;     <span class="comment">// 数据缓冲区个数</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;    <span class="comment">// 控制信息缓冲区</span></span><br><span class="line">    <span class="type">size_t</span>        msg_controllen; <span class="comment">// 控制信息长度</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;      <span class="comment">// 消息标志</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="总结">总结</h3>
<h4 id="服务端-tcp">服务端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>bind()</code></strong>：绑定 IP 地址和端口号</li>
<li><strong><code>listen()</code></strong>：监听客户端连接请求</li>
<li><strong><code>accept()</code></strong>：接受客户端连接</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<h4 id="客户端-tcp">客户端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>connect()</code></strong>：连接服务器</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<blockquote>
<p><strong>客户端</strong> 不调用 <code>bind()</code> 是为了
<strong>简化编程</strong> 和
<strong>方便操作系统自动分配端口</strong>。</p>
<p><strong>服务端</strong> 必须调用 <code>bind()</code> 来
<strong>指定监听的 IP 地址和端口号</strong>，以便
<strong>客户端能够连接</strong>。</p>
</blockquote>
<h2 id="高级io函数">高级I/O函数</h2>
<p><code>pipe</code>、<code>dup</code>、<code>readv</code>、<code>sendfile</code>、<code>mmap</code>、<code>tee</code>、<code>fcntl</code></p>
<p><code>splice</code>：用于在两个文件描述符之间移动数据，而无需将数据从内核空间复制到用户空间，<strong>直接在内核空间</strong>中完成数据的传输。。它通常用于高效地将数据从一个文件描述符（例如管道、socket
或文件）传输到另一个文件描述符。核心原理是它利用了 Linux
内核的<strong>零拷贝（Zero-Copy）技术</strong></p>
<h2 id="linux服务器程序规范">Linux服务器程序规范</h2>
<p><strong>AF_UNIX Socket 类型</strong></p>
<ul>
<li><strong>AF_UNIX</strong> 是一种本地进程间通信（IPC）的 Socket
类型，也称为 <strong>Unix Domain Socket (UDS)</strong>。</li>
<li>它用于 <strong>同一台机器</strong>
上不同进程之间的通信，不涉及网络传输。</li>
<li>通信数据不会经过网络协议栈，因此
<strong>效率高、延迟低、开销小</strong>。</li>
</ul>
<h3 id="日志">日志</h3>
<ul>
<li><p><code>rsyslog</code> 是 Linux
系统中功能强大的日志管理工具，具有高性能、模块化、支持多种协议和格式化输出的特点。</p></li>
<li><p><strong>rsyslogd 守护进程</strong> 在接收到
<strong>用户进程</strong> 或 <strong>内核</strong>
输入的日志后，会按照配置文件中的规则，将它们输出到特定的
<strong>日志文件</strong> 中。</p></li>
</ul>
<p>下面是<strong>日志处理流程</strong></p>
<ol type="1">
<li><p><strong>日志收集</strong>：</p>
<ul>
<li><p><strong>用户进程日志</strong>：通过调用 <code>syslog()</code>
函数，将日志写入 <code>/dev/log</code>（AF_UNIX Socket）。</p>
<blockquote>
<ul>
<li><p><strong><code>syslog()</code></strong> 是 C
语言标准库中的一个函数，用于
<strong>向系统日志发送消息</strong>。</p></li>
<li><p>日志通过 <strong>AF_UNIX Socket</strong> 发送到
<code>/dev/log</code> 文件，由 <code>rsyslogd</code>
或其他系统日志守护进程收集、处理并写入日志文件。</p></li>
<li><p>典型用途：记录程序运行状态、错误信息、安全事件等，便于调试和维护</p></li>
</ul>
</blockquote></li>
<li><p><strong>内核日志</strong>：通过 <code>klog</code>
模块从内核中收集日志，例如启动、硬件、中断等信息。</p></li>
</ul></li>
<li><p><strong>rsyslogd 获取日志</strong>：</p>
<ul>
<li><code>rsyslogd</code> 守护进程监听 <code>/dev/log</code> 和
<code>/proc/kmsg</code>（内核日志），获取日志数据。</li>
</ul></li>
<li><p><strong>日志过滤与分类</strong>：</p>
<ul>
<li>根据配置文件（如 <code>/etc/rsyslog.conf</code> 和
<code>/etc/rsyslog.d/*.conf</code>）中的规则进行过滤和分类。</li>
<li>规则由 Facility（日志来源） 和 Level（日志级别） 组成</li>
</ul></li>
<li><p><strong>日志输出与存储</strong>：</p>
<ul>
<li>日志被写入到指定的日志文件，如：
<ul>
<li><code>/var/log/messages</code>：系统通用日志</li>
<li><code>/var/log/secure</code>：认证和安全相关日志</li>
<li><code>/var/log/maillog</code>：邮件日志</li>
<li><code>/var/log/cron</code>：定时任务日志</li>
<li><code>/var/log/kern.log</code>：内核日志</li>
</ul></li>
<li>或者转发至 <strong>远程日志服务器</strong> 或
<strong>数据库</strong> 进行集中存储和分析。</li>
</ul></li>
</ol>
<h3 id="用户信息">用户信息</h3>
<p>EGID/EUID
存在的⽬的是⽅便资源访问，给运⾏⽬标程序的(组)⽤户提供有效(组)用户的权限。</p>
<blockquote>
<p>示例：</p>
<ul>
<li><p><strong><code>su</code> 程序</strong> 在
<strong>普通用户启动时</strong>，<strong>EUID 临时变为
<code>root</code></strong>，从而拥有 <code>root</code> 权限。</p></li>
<li><p>由于 SUID 位（即set-user-id 标志）被设置，则 <strong>EUID 变为
root</strong>，进程可以 <strong>访问和修改 <code>/etc/passwd</code>
文件</strong>，并执行切换用户的操作。</p></li>
</ul>
</blockquote>
<ol type="1">
<li><p>获取用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实用户 ID (UID)</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效用户 ID (EUID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实组 ID (GID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效组 ID (EGID)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设置用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;       <span class="comment">// 设置 真实用户 ID 和 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span></span>;     <span class="comment">// 设置 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;       <span class="comment">// 设置 真实组 ID 和 有效组 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span></span>;     <span class="comment">// 设置 有效组 ID</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="进程间关系">进程间关系</h3>
<h4 id="进程组">进程组</h4>
<ul>
<li>每个进程组都有一个唯一的 <strong>进程组 ID
(PGID)</strong>，用于标识该组中的所有进程。</li>
<li><strong>PGID（Process Group
ID）</strong>：进程组的唯一标识符，等于该组<strong>首领进程（Leader
Process）</strong> 的 PID（进程 ID）。</li>
<li><strong>首领进程</strong>：最先创建进程组的进程，PGID 等于它的
PID。如果首领进程退出，进程组不会消失，但其他进程的 PGID
不变。进程组将⼀直存在，直到其中<strong>所有进程</strong>都退出，或者加⼊到其他进程组。</li>
</ul>
<h4 id="会话">会话</h4>
<ul>
<li><p>一组相关的进程组组成一个会话，每个会话有一个唯一的
<strong>SID（Session ID）</strong>。</p></li>
<li><p><strong>Session ID
(SID)</strong>：会话的唯一标识符，等于会话首领进程（Session Leader）的
PID。</p></li>
<li><p><strong>会话首领进程</strong>：创建会话的进程，SID 等于它的
PID。这个进程可以成为<strong>守护进程</strong>。</p>
<blockquote>
<p><strong>调用进程不能是当前进程组的组长</strong>，否则会返回错误。这是因为：</p>
<ul>
<li>如果组长进程调用 <code>setsid()</code>，那么它的 <strong>PGID
(Process Group ID)</strong> 和 <strong>PID (Process ID)</strong>
相同，而 <code>setsid()</code>
要求调用进程成为<strong>新进程组的组长</strong>，即 <strong>PGID =
PID</strong>。如果它本身已经是组长，就无法改变 PGID，因此被禁止。</li>
</ul>
</blockquote></li>
</ul>
<h4 id="ps命令"><code>ps</code>命令</h4>
<p>用于<strong>查看系统中正在运行的进程</strong>。它可以显示进程的
PID、PPID、PGID、SID、TTY、状态、内存占用等详细信息。</p>
<ol type="1">
<li><p>查看所有进程的层级关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef --forest</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看会话、进程组和 PID 的关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看当前 Shell 会话中的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看前后台作业及进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某个用户的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u username</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="系统资源限制">系统资源限制</h3>
<ul>
<li><strong><code>getrlimit(int resource, struct rlimit \*rlim)</code></strong>：获取指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
<li><strong><code>setrlimit(int resource, const struct rlimit \*rlim)</code></strong>：设置指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
</ul>
<h3 id="改变目录">改变目录</h3>
<ol type="1">
<li><p>获取<strong>当前工作目录</strong>的<strong>绝对路径</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>buf</code>：用于存储路径的缓冲区。</li>
<li><code>size</code>：缓冲区大小。</li>
<li>返回值：成功返回 <code>buf</code>；失败返回
<code>NULL</code>，并设置 <code>errno</code></li>
</ul></li>
<li><p>切换目录</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>path</code>：目标目录的路径（绝对路径或相对路径）。</li>
<li>返回值：成功返回 <code>0</code>；失败返回 <code>-1</code>，并设置
<code>errno</code></li>
</ul></li>
</ol>
<h3 id="服务器程序后台化">服务器程序后台化</h3>
<ol type="1">
<li><strong>创建子进程</strong> 并退出父进程，防止继续占用
<strong>终端</strong>。</li>
<li><strong>调用 <code>setsid()</code></strong>：
<ul>
<li>创建新会话 (<code>session</code>)，并成为会话首进程。</li>
<li>成为新进程组的<strong>组长</strong>。</li>
<li><strong>脱离</strong> 控制终端。</li>
</ul></li>
<li><strong>重设文件权限掩码</strong>：
<ul>
<li>使用 <code>umask(0)</code> 确保子进程可以创建任何权限的文件。</li>
</ul></li>
<li><strong>更改工作目录</strong>：
<ul>
<li>通常切换到根目录：<code>chdir("/")</code>，防止
<strong>占用文件系统</strong>。</li>
</ul></li>
<li><strong>关闭文件描述符</strong>：
<ul>
<li>关闭 <strong>stdin, stdout, stderr</strong>
(<code>0, 1, 2</code>)，防止<strong>占用终端资源</strong>。</li>
</ul></li>
<li><strong>重定向文件描述符</strong>：
<ul>
<li>重定向 <code>stdin, stdout, stderr</code> 到
<strong><code>/dev/null</code></strong> 或
<strong>日志文件</strong>。</li>
</ul></li>
</ol>
<h2 id="io模型">I/O模型</h2>
<p>其中最重要的就是<strong>I/O复用</strong></p>
<h3 id="阻塞io">阻塞I/O</h3>
<p>进程发起 I/O
请求后，线程会一直阻塞，直到数据准备好并被复制到用户空间，I/O
操作才完成。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>，如果数据未准备好，进程进入
<strong>阻塞状态</strong>。</li>
<li>内核等待数据准备好，并从内核缓冲区复制到用户空间。</li>
<li><code>read()</code> 返回，进程继续执行。</li>
</ol>
<h3 id="非阻塞io">非阻塞I/O</h3>
<p>进程发起I/O请求后，不管数据是否准备好都会直接返回。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>：
<ul>
<li><strong>如果数据已准备好</strong>，<code>read()</code>
立即返回数据。</li>
<li><strong>如果数据未准备好</strong>，<code>read()</code> 立即返回
<code>-1</code>，并设置 <code>errno = EAGAIN</code>（不会阻塞）。</li>
</ul></li>
<li>进程通常会<strong>轮询</strong>（不断调用
<code>read()</code>）直到数据可用。</li>
</ol>
<h3 id="信号驱动io">信号驱动I/O</h3>
<p>让内核在 I/O 事件发生时发送信号 (<code>SIGIO</code>)
通知进程，进程在信号处理程序中执行 I/O 操作。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>fcntl()</code> 启用 <code>O_ASYNC</code>
标志，让内核在 I/O 事件发生时发送 <code>SIGIO</code> 信号。</li>
<li>进程继续执行其他任务，不阻塞。</li>
<li>当数据可用时，内核发送 <code>SIGIO</code> 信号。</li>
<li>信号处理函数调用 <code>read()</code> 读取数据。</li>
</ol>
<h3 id="异步io">异步I/O</h3>
<p>进程发起 I/O 请求后<strong>不会阻塞</strong>，内核在 I/O
操作完成后通知进程。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>aio_read()</code> 让内核执行 I/O 操作。</li>
<li>进程立即继续执行其他任务，不阻塞。</li>
<li>内核完成 I/O 后，主动通知进程（如回调函数或 <code>SIGEV</code>
机制）。</li>
<li>进程获取数据，I/O 操作完成。</li>
</ol>
<blockquote>
<p>异步I/O与信号驱动I/O的区别</p>
<p><strong>信号驱动 I/O (<code>SIGIO</code>)</strong>：</p>
<ul>
<li>只是<strong>提前通知</strong>进程 “数据可读”，但进程仍需
<code>read()</code> 获取数据。</li>
<li>适用于<strong>高并发网络 I/O</strong>（但现代高性能服务器一般用
<code>epoll</code>）。</li>
</ul>
<p><strong>异步 I/O (AIO)</strong>：</p>
<ul>
<li><strong>真正的异步</strong>，内核完成 I/O 后数据已就绪，无需
<code>read()</code>。</li>
<li>适用于<strong>高吞吐文件 I/O</strong>，如数据库、存储系统
(<code>io_uring</code> 适用于网络和文件)。</li>
</ul>
</blockquote>
<h3 id="io复用">I/O复用</h3>
<p>通过 <code>select()</code>、<code>poll()</code> 或
<code>epoll()</code> 让一个线程同时监视多个 I/O 事件，提高并发能力。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用
<code>select()</code>/<code>poll()</code>/<code>epoll_wait()</code>，等待多个文件描述符的状态变化。</li>
<li>如果某个描述符准备好，进程再去执行 <code>read()</code>。</li>
<li><code>read()</code>
仍然是阻塞的，但因为之前已经确认了数据可读，阻塞时间很短。</li>
</ol>
<h4 id="select">select</h4>
<p><code>select()</code> 函数是一种 <strong>I/O 多路复用</strong>
技术，它可以 <strong>同时监听多个文件描述符 (File Descriptor,
FD)</strong> 的状态。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>nfds</code></td>
<td>监听的最大文件描述符的值加 1（仅 Linux 需要，Windows
忽略此参数）。</td>
</tr>
<tr class="even">
<td><code>readfds</code></td>
<td>监听可读事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>writefds</code></td>
<td>监听可写事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="even">
<td><code>exceptfds</code></td>
<td>监听异常事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>timeout</code></td>
<td>设定超时时间，可为 <code>NULL</code>（表示无限等待）。</td>
</tr>
</tbody>
</table>
<p>select成功时返回就绪（可读、可写和异常）⽂件描述符的总数。如果在超时时间内没有任何⽂件描述符就绪，select将返回0。select失败时返回-1。</p>
<p>下面是<code>select</code>监听的文件操作符可能出现的状态：（<code>FD_ISSET</code>用于判断状态是否变化即是否就绪，例如<code>FD_ISSET(fd, &amp;readfds)</code>
用于检查某个文件描述符 (<code>fd</code>) 是否<strong>在
<code>readfds</code> 集合中被标记为可读</strong>。）</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">监听类型</th>
<th style="text-align: center;">触发条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>可读
<code>readfds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 有数据可读
<br>2. <code>accept()</code> 有新连接 <br>3. <code>read()</code>
返回 0（对端关闭） <br>4. 终端、管道、文件可读</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>可写
<code>writefds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 发送缓冲区可用
<br>2. <code>connect()</code> 非阻塞模式完成 <br>3.
<code>write()</code> 不会阻塞</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>异常
<code>exceptfds</code></strong></td>
<td style="text-align: center;">1. <code>connect()</code> 失败 <br>2.
<code>MSG_OOB</code> <strong>带外数据</strong> <br>3. TCP 连接复位
(RST)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>fd_set</code>：<strong>文件描述符（file
descriptor）集合</strong>，只能存 1024 个文件描述符</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;    <span class="comment">// 清空集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 添加文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 从集合中移除文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">// 检查文件描述符是否准备就绪</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>两种应用：</p>
<p><strong><code>select()</code> + 非阻塞
I/O（纯事件驱动模型）</strong>：</p>
<ul>
<li>适用于 <strong>高并发、轻量级连接</strong> 的场景，如
<strong>聊天室、HTTP 代理服务器</strong>。</li>
<li>无需多进程或多线程，<strong>单线程即可管理和处理多个连接</strong>。</li>
</ul>
<p><strong><code>select()</code> +
<code>fork()</code>（混合模型）</strong>：</p>
<ul>
<li>适用于 <strong>中小规模并发</strong> 且
<strong>每个连接需要较重业务处理</strong> 的场景，如
<strong>文件上传、数据计算</strong>。</li>
<li>通过 <strong>子进程避免阻塞主进程</strong>，简化了 <strong>I/O
操作的编程模型</strong>。</li>
</ul>
<h4 id="poll">poll</h4>
<p><code>poll()</code> 是 <code>select()</code> 的改进版，<strong>去除了
1024 个文件描述符（fd）的限制</strong>，但仍然需要遍历整个 fd
列表。poll系统调⽤的返回值的含义与select相同。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> {</span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 监听的事件（POLLIN-可读, POLLOUT-可写, POLLERR-错误）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 触发的事件（由内核填充）</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>fds</code>: <code>pollfd</code>
结构体数组，存放要监听的文件描述符及其事件。</li>
<li><code>nfds</code>: <code>fds</code> 数组的大小。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<h4 id="epoll">epoll</h4>
<p><code>epoll</code> 是 Linux 特有的 <strong>高效 I/O 复用</strong>
机制，适用于 <strong>高并发场景（如 1 万个 socket）</strong>。</p>
<p><strong>(1) <code>epoll_create()</code>
创建内核事件表（epoll实例）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>创建内核事件表</strong>，返回 <code>epfd</code>（失败返回
<code>-1</code>）。</li>
</ul>
<p><strong>(2) <code>epoll_ctl()</code> 添加/删除/修改 fd（即管理
fd）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_event 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> {</span><br><span class="line">    <span class="type">uint32_t</span> events;  <span class="comment">// 监听的事件（EPOLLIN, EPOLLOUT 等，还包括EPOLLET-边缘触发模式）</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据（通常存 fd）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>op</code>: 操作类型：
<ul>
<li><code>EPOLL_CTL_ADD</code>：添加 <code>fd</code>。</li>
<li><code>EPOLL_CTL_MOD</code>：修改 <code>fd</code> 监听的事件。</li>
<li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code>。</li>
</ul></li>
<li><code>fd</code>: 需要监听的文件描述符（socket）。</li>
<li><code>event</code>: 监听的事件。</li>
</ul>
<p><strong>(3) <code>epoll_wait()</code> 获取发生事件的 fd</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>events</code>: 用于存储触发事件的 <code>epoll_event</code>
数组。</li>
<li><code>maxevents</code>: <code>events</code> 数组的大小（建议设置为
<code>10</code>~<code>1000</code>）。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<p><strong>(4) LT（水平触发）和ET（边缘触发）模式</strong></p>
<p>LT：只要数据未被读取，<code>epoll_wait()</code>
<strong>一直返回</strong> 可读事件。</p>
<p>ET：<strong>只在状态变化时通知一次</strong>，如果不立即处理，<code>epoll_wait()</code>
<strong>不会再次通知</strong>。</p>
<ol type="1">
<li><strong>LT（Level Triggered，水平触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>：
<ul>
<li>只要文件描述符处于就绪状态（即有数据可读或可写），epoll
就会持续通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll 会在下一次调用 epoll_wait
时再次通知。</li>
</ul></li>
<li>特点:
<ul>
<li>简单易用: 适合初学者或简单的应用场景。</li>
<li>容错性强:
即使应用程序没有一次性处理完所有数据，也不会丢失事件。</li>
<li>可能效率较低: 如果应用程序没有及时处理数据，epoll
会频繁通知，导致不必要的开销。</li>
</ul></li>
<li>适用场景:
<ul>
<li>需要兼容性强的场景（如传统的 select 或 poll 迁移到 epoll）。</li>
<li>对性能要求不高的场景。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>ET（Edge Triggered，边缘触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>:
<ul>
<li>只有当文件描述符的状态发生变化时（如从无数据变为有数据），epoll
才会通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll
不会再次通知，除非文件描述符的状态再次发生变化。</li>
</ul></li>
<li>特点:
<ul>
<li>高效: 减少了不必要的通知，适合高性能场景。</li>
<li>需要一次性处理完数据:
应用程序必须确保在一次事件通知中处理完所有数据，否则可能会丢失后续事件。</li>
<li>复杂性较高: 需要更精细的控制，通常与非阻塞 I/O 结合使用。</li>
</ul></li>
<li>适用场景:
<ul>
<li>高性能服务器（如 Web 服务器、游戏服务器）。</li>
<li>需要处理大量并发连接的场景。</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN; <span class="comment">// LT 模式</span></span><br><span class="line"><span class="comment">// event.events = EPOLLIN | EPOLLET; // ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>EPOLLONESHOT</code> 是 <code>epoll</code>
监听事件的一个<strong>特殊标志</strong>，它的作用是：</p>
<ul>
<li><strong>事件触发一次后，自动从 <code>epoll</code>
监听列表中移除</strong>。</li>
<li><strong>适用于多线程环境</strong>，防止多个线程同时处理同一个
<code>fd</code>。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内核事件表（Kernel Event Table）</strong> 是
<strong><code>epoll</code></strong>
机制的<strong>核心数据结构</strong>，用于<strong>存储和管理需要监听的文件描述符（fd）及其事件</strong>。它由
Linux 内核维护，提供了高效的事件通知机制。</p>
<ol type="1">
<li><p>为什么需要内核事件表？</p>
<p>在 <code>select()</code> 和 <code>poll()</code>
机制中，用户进程<strong>每次调用</strong>都要<strong>传递所有监听的
fd</strong>，导致<strong>大量数据拷贝和遍历</strong>，影响性能。</p>
<p><strong><code>epoll</code> 的改进：</strong></p>
<ol type="1">
<li><p><strong>fd 只需注册一次</strong>，存入
<strong>内核事件表</strong>，后续内核自动管理。</p></li>
<li><p><strong>避免无效 fd 遍历</strong>，只返回<strong>发生事件的
fd</strong>，提高效率（<code>O(1)</code>）。</p></li>
</ol></li>
<li><p>内核事件表的组成</p>
<p>内核事件表可以理解为一个<strong>红黑树 + 就绪列表</strong>：</p>
<ol type="1">
<li><strong>监听 fd 的红黑树</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>所有已注册的 fd</strong>，支持高效的
<strong>增/删/改</strong>。</li>
<li>由 <code>epoll_ctl()</code> 进行管理。</li>
</ul>
<ol start="2" type="1">
<li><strong>事件就绪列表</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>发生事件的 fd</strong>。</li>
<li><code>epoll_wait()</code> 只返回<strong>就绪列表中的
fd</strong>，避免无效遍历，提高性能</li>
</ul></li>
</ol>
</blockquote>
<h2 id="两种事件处理模式">两种事件处理模式</h2>
<h3 id="reactor模式">Reactor模式</h3>
<p>使⽤<strong>同步I/O模型</strong>实现。其主要特点是<strong>由一个或多个
I/O 多路复用器（如
<code>select</code>、<code>poll</code>、<code>epoll</code>）监听事件</strong>，当事件发生时，通知相应的事件处理器进行处理。</p>
<ul>
<li><strong>主线程</strong> 监听 I/O 事件，分发任务。</li>
<li><strong>工作线程</strong> 处理 I/O 和业务逻辑，通常使用线程池。</li>
<li>适用于 <strong>高并发短 I/O 操作</strong>，如 <code>epoll</code>
服务器（Nginx、Redis）。</li>
</ul>
<h3 id="proactor模式">Proactor模式</h3>
<p>使⽤<strong>异步I/O模型</strong>实现。其核心思想是<strong>由操作系统内核完成
I/O
操作后再通知应用程序</strong>，即事件的处理由内核负责，而不是应用程序主动去检查事件状态。</p>
<ul>
<li><strong>主线程</strong> 提交异步 I/O，等待操作系统通知完成。</li>
<li><strong>操作系统</strong> 负责实际 I/O 读取和写入。</li>
<li><strong>工作线程</strong> 只处理完成的 I/O 数据，执行业务逻辑。</li>
<li>适用于 <strong>长时间异步 I/O 操作</strong>，如 Windows IOCP。</li>
</ul>
<h2 id="两种并发模式">两种并发模式</h2>
<h3 id="半同步半异步">半同步/半异步</h3>
<ol type="1">
<li><p>下面这种也叫<strong>半同步/半反应堆</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222231946543.png" alt="image-20250222231946543">
<figcaption aria-hidden="true">image-20250222231946543</figcaption>
</figure>
<p>上图中的异步线程只有⼀个，由主线程来充当，工作线程都是同步线程</p></li>
<li><p>下面是⾼效的<strong>半同步/半异步</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222232510227.png" alt="image-20250222232510227">
<figcaption aria-hidden="true">image-20250222232510227</figcaption>
</figure>
<p>注意这里的主线程只管理<strong>监听socket</strong>，而<strong>连接socket</strong>交给工作线程管理。在这种⾼效的半同步/半异步模式中，每个线程都⼯作在异步模式。所以它并⾮严格意义上的半同步/半异步模式。</p></li>
</ol>
<h3 id="领导者追随者模式">领导者/追随者模式</h3>
<ul>
<li>多个⼯作线程轮流获得事件源集合，轮流监听、分发并处理事件</li>
<li>在任意时间点，程序都仅有⼀个领导者线程，它负责监听I/O事件。</li>
<li>其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者</li>
<li>当前的领导者如果检测到I/O事件，⾸先要从线程池中推选出新的领导者线程，然后(当前领导者)处理I/O事件，新领导者等待新的I/O事件</li>
</ul>
<h2 id="libevent-框架">Libevent 框架</h2>
<p><code>libevent</code> 的核心概念可以通过以下方式理解：</p>
<ul>
<li><strong>事件处理器</strong>：事件处理器负责处理特定类型的事件，它们定义了事件的源（如文件描述符、信号等）和触发条件（如可读、可写、信号到来、定时器到期等）。每个事件处理器都绑定了一个回调函数，事件发生时，回调函数会被调用。</li>
<li><strong>事件多路分发器</strong>：事件分发器负责使用操作系统的 I/O
多路复用机制来监听事件源的状态，并触发相应的回调。它管理和调度所有事件的执行。</li>
<li><strong>事件队列</strong>：事件队列是 <code>libevent</code>
用来存储和调度事件的结构，它保证了事件按照正确的顺序（优先级、时间顺序等）进行调度。事件队列也负责管理
I/O、定时器、信号等类型的事件，并将它们传递给事件分发器进行执行。</li>
</ul>
<p><strong>核心结构</strong></p>
<ul>
<li><code>event_base</code>：事件分发器，管理所有事件。</li>
<li><code>event</code>：事件处理器，表示具体的
I/O、信号、定时器事件。</li>
</ul>
<p><strong>主要流程</strong></p>
<ol type="1">
<li><p><strong>创建事件循环</strong> →
<code>event_base_new()</code></p></li>
<li><p><strong>创建事件</strong> → <code>event_new()</code></p></li>
<li><p><strong>注册事件</strong> → <code>event_add()</code></p>
<blockquote>
<p><code>event_add()</code>
只是将事件添加到事件循环中，并将其注册到事件队列。它告诉
<code>libevent</code> 这个事件（例如 I/O
事件、信号事件）应当被监听和调度，但是它并没有
<strong>直接建立事件源与事件处理器之间的映射关系</strong>。对于信号事件（例如
<code>SIGINT</code>），这时就需要通过内部的映射函数来将信号（如
<code>SIGINT</code>）与对应的事件处理器进行关联。具体而言，<code>evmap_signal_add()</code>
就是用来处理这种信号与事件处理器的映射关系。</p>
</blockquote></li>
<li><p><strong>启动事件循环</strong> →
<code>event_base_dispatch()</code></p></li>
<li><p><strong>触发事件并执行回调</strong></p></li>
<li><p><strong>释放资源</strong> → <code>event_free()</code> /
<code>event_base_free()</code></p></li>
</ol>
<p><strong>事件处理机制</strong></p>
<ul>
<li><strong>I/O 事件</strong>：监听文件描述符的可读/可写状态。</li>
<li><strong>信号事件</strong>：监听系统信号（如
<code>SIGINT</code>）。</li>
<li><strong>定时器事件</strong>：在指定时间后触发回调。</li>
</ul>
<h2 id="多进程编程">多进程编程</h2>
<h3 id="exec与fork">exec与fork</h3>
<ol type="1">
<li><p><code>fork</code> 之后的内存状态</p>
<p>当你调用 <code>fork</code>
时，操作系统会创建一个新的进程（子进程），子进程是父进程的副本。这意味着：</p>
<ul>
<li>子进程会复制父进程的代码段、数据段、堆栈、打开的文件描述符等。</li>
<li><strong>在 <code>fork</code>
的瞬间，父进程和子进程的内存内容是完全相同的</strong>。</li>
</ul>
<p>但是，现代操作系统使用了一种称为 <strong>写时复制（Copy-On-Write,
COW）</strong> 的技术来优化 <code>fork</code> 的性能：</p>
<ul>
<li><strong>写时复制的含义</strong>：<code>fork</code>
之后，父进程和子进程共享同一块物理内存，直到其中一个进程尝试修改内存时，操作系统才会为修改的进程复制一份新的内存页。</li>
<li>这种机制避免了不必要的内存复制，提高了性能。</li>
</ul></li>
<li><p><code>exec</code> 的作用</p>
<p><code>exec</code> 的作用是
<strong>替换当前进程的映像</strong>。具体来说：</p>
<ul>
<li><code>exec</code>
会将当前进程的代码段、数据段、堆栈等全部替换为新程序的内容。</li>
<li>调用 <code>exec</code>
后，当前进程的内存空间会被新程序的内容覆盖。</li>
</ul></li>
<li><p>结合 <code>fork</code> 和 <code>exec</code> 的工作流程</p>
<p>当你在子进程中调用 <code>exec</code> 时，会发生以下事情：</p>
<ol type="1">
<li><strong>子进程的内存被替换</strong>：</li>
</ol>
<ul>
<li><code>exec</code>
会加载新程序的代码和数据到子进程的内存空间中。</li>
<li>由于写时复制的机制，子进程的内存修改不会影响父进程。</li>
</ul>
<ol start="2" type="1">
<li><strong>父进程不受影响</strong>：</li>
</ol>
<ul>
<li>父进程的内存空间保持不变，继续执行原来的代码。</li>
</ul>
<ol start="3" type="1">
<li><strong>子进程执行新程序</strong>：</li>
</ol>
<ul>
<li>子进程从新程序的入口点（通常是 <code>main</code>
函数）开始执行。</li>
</ul></li>
</ol>
<h2 id="多线程编程">多线程编程</h2>
<h3 id="互斥锁">1. 互斥锁</h3>
<p>互斥锁（<code>pthread_mutex_t</code>）是一种用于
<strong>保护共享资源</strong>
的同步机制，它确保同一时刻只有一个线程可以访问共享资源。多个线程如果要访问同一资源，必须先获取该互斥锁，获取锁成功后才能访问资源，访问完毕后释放锁。</p>
<ul>
<li><strong>主要作用</strong>：保护共享资源，防止多个线程同时访问导致数据不一致。</li>
<li><strong>行为</strong>：加锁后，其他线程无法加锁，直到锁被释放。</li>
<li><strong>示例用法</strong>：保证线程安全地访问全局变量、共享数据结构等。</li>
</ul>
<h3 id="信号量">2. 信号量</h3>
<p>信号量（<code>sem_t</code>）是一种计数机制，用于控制多个线程对共享资源的访问。信号量通常用于控制并发的线程数，或者用于线程间的同步。当信号量的值大于
0 时，表示可以继续执行，线程会执行
<code>sem_wait</code>（等待）直到信号量大于 0，然后
<code>sem_post</code>（释放）信号量。</p>
<ul>
<li><strong>主要作用</strong>：控制对共享资源的访问数量或线程间的同步。</li>
<li><strong>行为</strong>：信号量的值可以增加或减少，通常用于实现生产者-消费者模式、控制线程池大小等。</li>
<li><strong>示例用法</strong>：控制线程池中同时运行的线程数，或者协调生产者和消费者之间的同步。</li>
</ul>
<h3 id="条件变量">3. 条件变量</h3>
<p>条件变量（<code>pthread_cond_t</code>）是用于
<strong>线程间协调</strong>
的同步机制，允许线程在某个条件满足时被唤醒。它通常与互斥锁配合使用。当一个线程需要等待某个条件满足时，它会在条件变量上等待，并释放互斥锁。一旦条件满足，另一个线程就会通过条件变量通知（<code>signal</code>
或 <code>broadcast</code>）其他线程继续执行。</p>
<ul>
<li><strong>主要作用</strong>：线程间的协调与同步，常用于“等待某个条件满足”后继续执行。</li>
<li><strong>行为</strong>：线程等待条件变量时会释放互斥锁，直到条件满足时被通知。</li>
<li><strong>示例用法</strong>：线程等待某个资源准备好，或者等待某个状态变更，例如生产者-消费者模式中的条件等待。</li>
</ul>
<blockquote>
<p><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>：</p>
<ul>
<li>该函数会使当前线程进入
<strong>阻塞状态</strong>，并且<strong>自动释放</strong>传入的
<code>mutex</code>，直到满足条件并且 <code>pthread_cond_signal()</code>
或 <code>pthread_cond_broadcast()</code>
被调用时，才会唤醒该线程并重新获取锁。</li>
</ul>
<p><code>pthread_cond_signal()</code>：</p>
<ul>
<li>该函数 <strong>不会</strong> 释放 <code>mutex</code>。它的作用是通知
<strong>至少一个</strong> 等待该条件变量的线程可以继续执行。</li>
</ul>
</blockquote>
<h2 id="线程池">线程池</h2>
<h3 id="pthread_create"><code>pthread_create()</code></h3>
<p>父线程调用 <code>pthread_create()</code>
来创建子线程。在这个过程中，父线程提供一个回调函数（通常称为线程函数），该回调函数定义了子线程的行为。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>:
线程标识符的指针，函数成功后会填充该值，表示新创建的子线程。</li>
<li><code>attr</code>: 用于线程属性的结构体，通常可以为
<code>NULL</code>，表示使用默认属性。</li>
<li><code>start_routine</code>: 子线程执行的函数（线程函数）。</li>
<li><code>arg</code>: 传递给子线程函数的参数。</li>
</ul>
<h3 id="pthread_detach"><code>pthread_detach</code></h3>
<p><code>pthread_detach</code> 是 POSIX
线程库（<code>pthread</code>）中的一个函数，用于<strong>分离线程</strong>，使其在结束时自动释放资源，而不需要
<code>pthread_join()</code> 进行回收。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>：要分离的线程 ID（<code>pthread_t</code>
类型）。</li>
</ul>
<p>返回值</p>
<ul>
<li><strong>成功</strong>：返回 <code>0</code>。</li>
<li>失败：返回错误码（例如 EINVAL或 ESRCH）。
<ul>
<li><code>EINVAL</code>（Invalid
Argument）：线程已经是<strong>分离状态</strong>。</li>
<li><code>ESRCH</code>（No Such Process）：线程 ID
无效，线程不存在。</li>
</ul></li>
</ul>
<blockquote>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 37%">
<col style="width: 12%">
<col style="width: 14%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
<th><strong>回收资源</strong></th>
<th><strong>主线程等待</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>pthread_detach</code></td>
<td>让线程<strong>自动释放</strong>，无需 <code>join</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>长期运行的工作线程</td>
</tr>
<tr class="even">
<td><code>pthread_join</code></td>
<td><strong>阻塞</strong>等待线程执行完，并获取返回值</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>需要获取线程结果</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<ol type="1">
<li><p><strong>构造函数必须私有化</strong>（否则不是单例）</p></li>
<li><p>析构函数根据需求选择：</p>
<ul>
<li>需要防止外部删除 → 私有化 + 自定义销毁逻辑（如 atexit）
<ul>
<li>禁止用户直接销毁对象，通常用于单例模式或对象池。</li>
<li>控制对象的生命周期，只能通过特定的成员函数销毁对象。</li>
</ul></li>
<li>使用 Meyer's Singleton（局部静态变量）→ 可公开析构</li>
</ul></li>
</ol>
</blockquote>
<h3 id="懒汉模式">懒汉模式</h3>
<p>实例在第一次使用时创建</p>
<ul>
<li>在 C++11
及以上版本中，局部静态变量的初始化是线程安全的，可以简化单例模式的实现</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>() {}</span><br><span class="line">    ~<span class="built_in">single</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single&amp; <span class="title">getinstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> single instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="饿汉模式">饿汉模式</h3>
<p>实例在程序启动时创建</p>
<ul>
<li>利用局部静态变量的特性实现线程安全的单例模式。</li>
<li>C++11 及以上版本保证局部静态变量的初始化是线程安全的</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() {}  <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">// 静态成员初始化</span></span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/24/VSCode%20%E5%8A%A0%E8%BD%BD%20.vscode%20%E8%A7%84%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/24/VSCode%20%E5%8A%A0%E8%BD%BD%20.vscode%20%E8%A7%84%E5%88%99/" class="post-title-link" itemprop="url">VSCode加载`.vscode`的规则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-24 23:22:06" itemprop="dateCreated datePublished" datetime="2025-03-24T23:22:06+08:00">2025-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-15 21:23:48" itemprop="dateModified" datetime="2025-05-15T21:23:48+08:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VSCode/" itemprop="url" rel="index"><span itemprop="name">VSCode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>622</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下面是我的文件结构</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">D:\CodeFile\</span><br><span class="line">│── .vscode\                 ← 父目录 `.vscode`</span><br><span class="line">│   ├── settings.json        (影响整个 `CodeFile` 及所有子目录)</span><br><span class="line">│   ├── tasks.json           (VSCode 任务系统会使用这个)</span><br><span class="line">│   ├── launch.json          (VSCode 调试器会使用这个)</span><br><span class="line">│</span><br><span class="line">├── CPP\</span><br><span class="line">│   ├── .vscode\             ← 子目录 `.vscode`（默认不会生效）</span><br><span class="line">│   │   ├── settings.json    (不会生效，除非 VSCode 直接打开 `CPP` 目录)</span><br><span class="line">│   │   ├── tasks.json       (不会生效)</span><br><span class="line">│   │   ├── launch.json      (不会生效)</span><br><span class="line">│   ├── test.cpp</span><br><span class="line">│   └── ...</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>VSCode 的 <code>settings.json</code> 是
<strong>基于当前打开的“工作区”</strong> 来生效的：</p>
<ul>
<li><strong>如果你打开 <code>CodeFile</code> 目录</strong>：
<ul>
<li><code>CodeFile/.vscode/settings.json</code> 生效（影响
<code>CodeFile</code> 下所有子文件夹，包括 <code>CPP</code>）。</li>
<li>你的 <code>"cpp"</code> 运行配置会作用于整个 <code>CodeFile</code>
目录。</li>
<li><strong><code>$workspaceFolder</code> 变为
<code>d:\CodeFile\</code></strong>，Code Runner 解析 <code>$dir</code>
时可能会有路径问题。</li>
</ul></li>
<li><strong>如果你只打开 <code>CPP</code> 目录</strong>：
<ul>
<li><code>CodeFile/.vscode/settings.json</code> 不会生效（因为
<code>.vscode</code> 在 <code>CodeFile</code> 目录下）。</li>
<li>需要 <code>CPP</code> 目录下也有一个
<code>.vscode/settings.json</code> 才能影响 <code>CPP</code> 目录。</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/CS106L/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/04/CS106L/" class="post-title-link" itemprop="url">CS106L-24Autumn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-04T00:00:00+08:00">2025-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-26 23:51:41" itemprop="dateModified" datetime="2025-07-26T23:51:41+08:00">2025-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS106L/" itemprop="url" rel="index"><span itemprop="name">CS106L</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>课程官网：http://web.stanford.edu/class/cs106l/</p>
<p>Assignment代码：https://github.com/cs106l/cs106l-assignments/tree/main</p>
<h2 id="stdpair">std::pair</h2>
<p>是一种类模板，它将<strong>两个</strong>异质对象作为一个单元存储，由头文件<code>#include &lt;utility&gt;</code>定义</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T1</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; dozen {<span class="string">"eggs"</span>, <span class="number">12</span>};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="using">using</h2>
<p><code>using</code>关键字可以定义别名，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zeros 是 std::pair&lt;double, double&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Zeros = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution 是 std::pair&lt;bool, Zeros&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Solution = std::pair&lt;<span class="type">bool</span>, Zeros&gt;;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="auto">auto</h2>
<p><code>auto</code>关键字让编译器推断变量的类型，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未简化</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用auto关键字</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="统一初始化c11">统一初始化（C++11）</h2>
<p>使用<code>=</code>或者<code>()</code>进行初始化会默认进行类型转换，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne = <span class="number">12.0</span>; <span class="comment">// numOne是12</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTwo</span><span class="params">(<span class="number">12.0</span>)</span></span>; <span class="comment">// numTwo也是12</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>统一初始化</strong>（<strong>Uniform
Initialization</strong>）是 C++11 引入的一种新的初始化语法，旨在提供一种
<strong>统一且更安全</strong> 的方式来初始化变量和对象。它通过
<strong>大括号 <code>{}</code></strong> 实现初始化。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne{<span class="number">12.0</span>}; <span class="comment">// 编译时报错，不允许类型缩小转换（double-&gt;int）</span></span><br><span class="line"><span class="type">float</span> numTwo{<span class="number">12.0</span>}; <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>
<p>除了基本类型，统一初始化还可用于<code>vector</code>、<code>map</code>等不同容器</p>
<h2 id="结构化绑定c17">结构化绑定（C++17）</h2>
<p>结构化绑定是C++17引入的一种新特性，用于将<strong>元组（<code>std::tuple</code>）</strong>、<strong>结构体</strong>或类似的可解构对象分解为多个独立变量。它提供了一种简便的方法来直接解构数据。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, std::string, std::string&gt; <span class="title">getClassInfo</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string className = <span class="string">"CS106L"</span>;</span><br><span class="line">    std::string buildingName = <span class="string">"Thornton 110"</span>;</span><br><span class="line">    std::string language = <span class="string">"C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> {className, buildingName, language}; <span class="comment">// 这里返回的是tuple对象</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> [className, buildingName, language] = <span class="built_in">getClassInfo</span>(); <span class="comment">// 注意这一行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Come to "</span> &lt;&lt; buildingName &lt;&lt; <span class="string">" and join us for "</span> &lt;&lt; className</span><br><span class="line">              &lt;&lt; <span class="string">" to learn "</span> &lt;&lt; language &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我疑惑的点在于，明明<code>getClassInfo()</code>返回值是tuple对象，为什么最后变成了三个对象？因为第八行的<code>[ ]</code>
是结构化绑定的标准语法，用于<strong>解构</strong>
<code>getClassInfo</code> 返回的
<code>std::tuple</code>，<strong>将元组中的每个元素绑定到独立变量中</strong>。</p>
<h3 id="引用与结构化绑定">引用与结构化绑定</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;nums)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [num1, num2] : nums) { <span class="comment">// 值绑定：产生副本，修改不影响原始数据</span></span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用该函数是无法该改变<code>nums</code>的，应该在<code>auto</code>后面添加<code>&amp;</code>符号</p>
<h2 id="左值和右值">左值和右值</h2>
<h3 id="左值-l-value">左值 l-value</h3>
<p>左值可以放置在<code>=</code>符号的左边或者右边</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是左值，下面两个式子均成立</span></span><br><span class="line"><span class="type">int</span> y = x;</span><br><span class="line">x = <span class="number">344</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="右值-r-value">右值 r-value</h3>
<p>右值只能放置在<code>=</code>符号的右边</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 21 是右值</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">21</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> = y; <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong>：当函数的参数声明为引用时，则不能在调用时使用右值作为参数</p>
<h2 id="stream">stream</h2>
<h3 id="stdcout">std::cout</h3>
<p>输出流在中的字符在被刷新到目标（终端）之前存储在中间缓冲区中</p>
<h3 id="stdstringstream">std::stringstream</h3>
<p>字符串流，用于处理（例如：分割）字符串。 示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// partial Bjarne Quote</span></span><br><span class="line">    std::string initial_quote = “Bjarne Stroustrup C makes it easy to shoot yourself in the foot\n<span class="string">"</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // create a stringstream</span></span><br><span class="line"><span class="string">    std::stringstream ss(initial_quote); // 初始化字符串流，可以用下面两行代替</span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    std::stringstream ss;</span></span><br><span class="line"><span class="string">	ss &lt;&lt; initial_quote;</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // data destinations</span></span><br><span class="line"><span class="string">    std::string first;</span></span><br><span class="line"><span class="string">    std::string last;</span></span><br><span class="line"><span class="string">    std::string language, extracted_quote;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // &gt;&gt;运算符只读取到下一个whitespace(空格，\n，\t)</span></span><br><span class="line"><span class="string">    ss &gt;&gt; first &gt;&gt; last &gt;&gt; language;</span></span><br><span class="line"><span class="string">    // 要让extracted_quote等于"</span>makes it easy to shoot yourself in the foot<span class="string">"需要使用getline()</span></span><br><span class="line"><span class="string">    std::getline(ss, extracted_quote);</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; first &lt;&lt; “ ” &lt;&lt; last &lt;&lt; “ said this: ”&lt;&lt; language &lt;&lt; “ “ &lt;&lt; </span></span><br><span class="line"><span class="string">    extracted_quote &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is, string&amp; str, <span class="type">char</span> delim)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>读取输入流<code>is</code>，直到<code>delim</code>字符（默认是<code>\n</code>），并将其存储在某个缓冲区（变量）<code>str</code>中</p>
</blockquote>
<h3 id="stdflush">std::flush</h3>
<p>用于刷新<code>stream</code>流，将缓冲区中的数据<strong>立即</strong>发送到控制台（终端）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Long operation in progress: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; std::flush;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Operation completed!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 每隔一秒输出一个数字</span></span><br></pre></td></tr></tbody></table></figure>
<p>若上述代码不加<code>std::flush</code>，那么输出会在五秒后全部<strong>一次性显示</strong>。</p>
<p><code>std::cout</code>通常是行缓冲的，所以<code>std::endl</code>也会使得<code>stream</code>进行刷新，每次循环都会输出一个数字，但是这种行为使得运行效率低下，所以可以将<code>std::endl</code>换成<code>\n</code>，这样当缓冲区满或者循环结束时才会一次性输出（注意要提前声明<code>std::ios::sync_with_stdio(false);</code>）。</p>
<h3 id="stdofstream">std::ofstream</h3>
<p>Output File Stream，将数据写入文件。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">/// associating file on construction</span></span><br><span class="line">	<span class="function">std::ofstream <span class="title">ofs</span><span class="params">(“hello.txt”)</span></span>; <span class="comment">// 等价于下面两行</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::ofstream ofs; </span></span><br><span class="line"><span class="comment">    ofs.open(“hello.txt”);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (ofs.<span class="built_in">is_open</span>()) {  <span class="comment">// 检查文件是否已打开，如果已打开，则尝试向其写入字符串 </span></span><br><span class="line">		ofs &lt;&lt; “Hello CS106L!” &lt;&lt; ‘\n’; </span><br><span class="line">	}</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	ofs &lt;&lt; “<span class="keyword">this</span> will <span class="keyword">not</span> get written”; <span class="comment">// 由于文件流已关闭，会导致写入失败</span></span><br><span class="line">    </span><br><span class="line">	ofs.<span class="built_in">open</span>(“hello.txt”);</span><br><span class="line">	ofs &lt;&lt; “<span class="keyword">this</span> will though! It’s open again”;  <span class="comment">// 写入成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="stdcin">std::cin</h3>
<p><code>std::cin</code>也会先把字符存入缓冲区，然后从缓冲区中读取内容。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; a;  <span class="comment">// 输入字符，存入缓冲区，然后从缓冲区读取字符到变量a</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>std::cin</code>遇到whitespace则会停止存入缓冲区</p>
<p>Whitespace in C++ includes:</p>
<ul>
<li>“ ” – a literal space（空格）</li>
<li><code>\n</code> character</li>
<li><code>\t</code> character</li>
</ul>
<h2 id="stl">STL</h2>
<p>Standard Template Library</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250105162916455.png" alt="image-20250105162916455">
<figcaption aria-hidden="true">image-20250105162916455</figcaption>
</figure>
<h3 id="sequence-containers">Sequence Containers</h3>
<p>存放线性序列</p>
<h4 id="stdvector">std::vector</h4>
<p>使用 range-based for (适用于所有可迭代容器)遍历 vector</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : vec) {  <span class="comment">// for (const auto&amp; elem : v) 可以节省副本的开销</span></span><br><span class="line">	std::cout &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>push_back()</code>： 会导致容器大小 <code>size()</code>
增加，同时如果没有足够空间，容量 <code>capacity()</code> 也随着增加</li>
<li><code>pop_back()</code>
：移除容器中最后一个元素，并将容器的<code>size()</code>减小，<strong>容量</strong>
(<code>capacity()</code>) 保持不变。</li>
</ul>
<h4 id="stddeque">std::deque</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250107220918767.png" alt="image-20250107220918767">
<figcaption aria-hidden="true">image-20250107220918767</figcaption>
</figure>
<p><code>std::deque</code> 的底层实现结合了 <strong>分段内存</strong> 和
<strong>指针数组</strong> 的设计：</p>
<ol type="1">
<li><strong>分段存储</strong>：
<ul>
<li>与 <code>std::vector</code> 不同，<code>std::deque</code>
不使用一块连续的大内存块，而是将数据分为多个固定大小的内存块（称为缓冲区或
block）。</li>
<li>每个缓冲区的大小通常是固定的（具体大小依赖于实现，通常为 512
字节或更多）。</li>
</ul></li>
<li><strong>指针数组（Map Array）</strong>：
<ul>
<li><code>std::deque</code> 使用一个指针数组（称为 map
或控制块）来管理这些缓冲区。</li>
<li>这个指针数组存储了每个缓冲区的起始地址，并负责定位实际数据的位置。</li>
</ul></li>
</ol>
<h4 id="stdlist">std::list</h4>
<p><code>std::list</code> 是 C++ 标准库中的双向链表（Doubly Linked
List）容器，定义在 <code>&lt;list&gt;</code> 头文件中。与
<code>std::vector</code> 不同，<code>std::list</code>
允许高效地在序列的任意位置进行插入和删除操作，但不支持随机访问。</p>
<ul>
<li><strong>双向链表结构</strong>：每个元素都有前驱和后继指针。</li>
<li><strong>动态大小</strong>：不需要预分配内存，适用于频繁的插入/删除操作。</li>
<li><strong>高效的插入/删除</strong>：<code>O(1)</code>
复杂度，不涉及大规模元素移动。</li>
<li><strong>不支持随机访问</strong>：不能通过 <code>operator[]</code>
访问元素，必须使用迭代器。</li>
</ul>
<h3 id="associative-containers">Associative Containers</h3>
<p>通过 key 来组织元素</p>
<h4 id="stdmap">std::map</h4>
<ul>
<li><p>等价于python中的字典</p></li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map {</span><br><span class="line">  { <span class="string">"Chris"</span>, <span class="number">2</span> },</span><br><span class="line">  { <span class="string">"CS106L"</span>, <span class="number">42</span> },</span><br><span class="line">  { <span class="string">"Keith"</span>, <span class="number">14</span> },</span><br><span class="line">  { <span class="string">"Nick"</span>, <span class="number">51</span> },</span><br><span class="line">  { <span class="string">"Sean"</span>, <span class="number">35</span> },</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> sean = map[<span class="string">"Sean"</span>]; <span class="comment">// 35</span></span><br><span class="line">map[<span class="string">"Chris"</span>] = <span class="number">31</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>std::map</code> 中，每个元素是一个 <code>std::pair</code>
对象，其中包含 <code>first</code> 和 <code>second</code>
两个成员。<code>first</code> 是键（key），<code>second</code>
是值（value）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv : map) {</span><br><span class="line">  <span class="comment">// kv is a std::pair&lt;const std::string, int&gt;</span></span><br><span class="line">  std::string key = kv.first;</span><br><span class="line">  <span class="type">int</span> value = kv.second;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过结构化绑定遍历map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) {</span><br><span class="line">  <span class="comment">// key has type const std::string&amp;</span></span><br><span class="line">  <span class="comment">// value has type const int&amp;</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>底层是通过 <strong>红黑树</strong>（Red-Black
Tree）来实现的。因此<code>std::map&lt;K, V&gt;</code>要求<code>K</code>能够进行<code>operator&lt;</code>操作（比大小，判断进入红黑树的左右哪个分支）</p></li>
</ul>
<h4 id="stdunordered_map">std::unordered_map</h4>
<ul>
<li><p>与 <code>std::map</code> 不同，<code>std::unordered_map</code>
是基于 <strong>哈希表（Hash Table）</strong> 实现的。</p></li>
<li><p>获取负载因子，设置最大负载因子，若超过则重新哈希</p>
<p>负载因子 = 元素个数（size）/ 桶的数量（bucket count）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="type">double</span> lf = map.<span class="built_in">load_factor</span>(); <span class="comment">// Get current load factor</span></span><br><span class="line">map.<span class="built_in">max_load_factor</span>(<span class="number">2.0</span>); <span class="comment">// Set the max load factor</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="stdset">std::set</h4>
<ul>
<li>集合中的每个元素都是唯一的</li>
<li><code>std::set</code> 的实现通常也是基于
<strong>红黑树</strong></li>
</ul>
<h4 id="stdunordered_set">std::unordered_set</h4>
<ul>
<li><code>std::unordered_set</code> 是基于 <strong>哈希表（Hash
Table）</strong> 实现的</li>
<li>如果你不需要排序，并且希望实现快速的查找和插入操作，<code>std::unordered_map</code>
是一个很好的选择。</li>
</ul>
<h3 id="iterator">Iterator</h3>
<p>track where we are in a container（类似于索引）</p>
<ul>
<li><p><code>container.begin()</code>指向容器的第一个元素</p></li>
<li><p><code>container.end()</code>指向容器末端（但不指向末尾元素）</p></li>
<li><p>当容器为空时，<code>container.begin() == container.end()</code></p></li>
<li><p>遍历容器</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两段代码是等价的</span></span><br><span class="line"><span class="keyword">auto</span> b = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> e = s.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = b; it != e; ++it)  <span class="comment">// 这里使用 ++it 可以减少一次不必要的拷贝</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">auto</span> elem = *it;</span><br><span class="line">     std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// range-based for </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : s) </span><br><span class="line">{</span><br><span class="line">	std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="继承inheritance">继承（Inheritance）</h2>
<p>多态性</p>
<h3 id="纯虚函数">纯虚函数</h3>
<p>动态多态，它在基类中被实例化，但在子类中被覆盖</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="虚函数">虚函数</h3>
<p>https://hxt616.github.io/2024/10/26/CS106B/</p>
<h3 id="虚基类">虚基类</h3>
<p>解决菱形继承问题，详见<a target="_blank" rel="noopener" href="https://hxt616.github.io/2024/10/26/CS106B/">CS106B</a></p>
<h2 id="模板类template-classes">模板类（Template Classes）</h2>
<p>模板的声明和实现一般在同一个文件中</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 'typename' 可替换成 'class'</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 在类外定义函数需要进行模板声明</span></span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> i) { <span class="comment">// 注意这里类名后面要添加 &lt;T&gt;</span></span><br><span class="line"> <span class="comment">// Implementation...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="const">const</h2>
<p><code>const</code>
可以加在函数声明的前面或者后面，这两种用法的含义是不同的。主要有两种常见的情况：</p>
<h3 id="const-加在函数返回类型前面"><code>const</code>
加在函数返回类型前面</h3>
<p>这是指 <strong>返回值是 <code>const</code>
类型</strong>，意味着该返回值是不可修改的。</p>
<h4 id="示例">示例：</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个例子中，<code>const</code> 加在 <code>int</code>
前面，表示函数返回的是一个 <code>const int</code>。也就是说，返回的值是
<code>const</code> 类型，调用者不能修改它。</li>
<li>注意：这种 <code>const</code>
修饰符适用于返回值的类型，并不影响函数本身的行为。</li>
</ul>
<h4 id="使用场景">使用场景：</h4>
<ul>
<li>当函数返回一个对象时，如果返回的对象不希望被修改，可以加上
<code>const</code>。</li>
<li>例如，在返回一个指针、引用或常量时，<code>const</code>
会确保返回的对象不能被修改。</li>
</ul>
<h3 id="const-加在成员函数的后面"><code>const</code>
加在成员函数的后面</h3>
<p>这是指 <strong>成员函数是 <code>const</code>
成员函数</strong>，意味着该函数不能修改类的成员变量。</p>
<h4 id="示例-1">示例：</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>{</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个例子中，<code>getValue()</code> 后面的 <code>const</code>
表示该成员函数是 <strong><code>const</code>
成员函数</strong>，即它不会修改类的任何成员变量（即 <code>this</code>
指针指向的对象不会发生变化）。</li>
</ul>
<h4 id="关键点">关键点：</h4>
<ul>
<li><code>const</code> 加在成员函数的后面是为了声明这个成员函数是
<strong>只读的</strong>，即它不会修改对象的状态。</li>
<li>在 C++ 中，<strong><code>const</code> 成员函数只能调用其他
<code>const</code> 成员函数</strong>，不能修改成员变量，不能调用非
<code>const</code> 成员函数，也不能修改 <code>this</code>
指针指向的对象。</li>
</ul>
<h4 id="使用场景-1">使用场景：</h4>
<ul>
<li>当你希望保证某个成员函数不会修改类的状态时，应该将其声明为
<code>const</code> 成员函数。</li>
<li>例如，在查询类状态的函数（如获取值、大小、是否为空等）中，应该将其声明为
<code>const</code>，以便它们能够在 <code>const</code> 对象上调用。</li>
</ul>
<blockquote>
<p><strong>1. 指向常量的指针 (Pointer to const)</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;  <span class="comment">// 或等价的 int const* ptr;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>不能修改指向的对象</strong>：不能通过这个指针修改它指向的值</li>
<li><strong>可以修改指针本身</strong>：可以让指针指向其他地址</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 正确：可以修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>2. 常量指针 (Const pointer)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>不能修改指针本身</strong>：指针不能指向其他地址</li>
<li><strong>可以修改指向的对象</strong>：可以通过指针修改它指向的值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 正确：可以修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>3. 指向常量的常量指针 (Const pointer to const)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>既不能修改指针本身</strong>：不能指向其他地址</li>
<li><strong>也不能修改指向的对象</strong>：不能通过指针修改值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="const_cast不常用"><code>const_cast</code>（不常用）</h3>
<p><code>const_cast</code> 的常见用法：</p>
<ol type="1">
<li><p><strong>去除 <code>const</code> 限定符</strong>： 通过
<code>const_cast</code>，可以将指向 <code>const</code>
对象的指针或引用转换为指向非 <code>const</code> 对象的指针或引用。</p>
<p>这种操作的危险性在于，如果你通过 <code>const_cast</code> 去除
<code>const</code>
限定符并尝试修改对象的内容，而对象本身确实是常量（例如，存储在
<code>const</code>
内存区域），这将导致未定义行为（UB）。因此，<strong>只有在你确定对象可以安全修改时</strong>，才应该去除
<code>const</code>。</p></li>
</ol>
<h2 id="模板函数template-functions">模板函数（Template Functions）</h2>
<ol type="1">
<li><p>示例：取两个变量的较小值</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(<span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式实例化，让编译器判断类型</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">7</span>, <span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>可变参数模板函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a)</span> </span>{ <span class="comment">// 一定要加上，因为下面的模板是递归模板，需要一个终止条件</span></span><br><span class="line">    <span class="keyword">return</span> a;  <span class="comment">// 基本情况：只有一个元素时，返回该元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, Args... args)</span> </span>{</span><br><span class="line">    T temp = <span class="built_in">min</span>(args...);  <span class="comment">// 递归调用：比较剩下的参数</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; temp ? a : temp;  <span class="comment">// 返回较小的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>find</code>函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是不同容器对应的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It begin, It end, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin; it != end; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> end;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法，直接将容器作为参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span><span class="params">(<span class="type">const</span> Container&amp; c, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">  <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> end;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="模板元编程template-metaprogramming">模板元编程（Template
Metaprogramming）</h2>
<p>TMP，它允许程序在编译阶段进行复杂的计算和类型推导，而不需要在运行时进行处理</p>
<ol type="1">
<li><p>示例：通过模板递归计算阶乘，可以在<strong>编译期</strong>执行计算</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归模板计算阶乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;  <span class="comment">// 递归调用</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当 N 为 0 时，阶乘为 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出: 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在模板中使用 <strong>predicates</strong>（谓词）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It first, It last, Pred pred)</span> </span>{ <span class="comment">// 这里的pred其实是一个返回布尔值的函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = first; it != last; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*it)) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="lambda">Lambda</h2>
<p>详见
https://hxt616.github.io/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</p>
<h2 id="functor">Functor</h2>
<p><strong>functor</strong>（仿函数）是一个行为类似函数的对象，具体来说是
<strong>重载了函数调用运算符 <code>()</code>
的类或结构体的实例</strong>。通过这种方式，类或结构体的对象可以像普通函数一样被调用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Called with "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::greater {</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">std::greater&lt;<span class="type">int</span>&gt; g;</span><br><span class="line"><span class="built_in">g</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回值是false</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>当使用lambda表达式时，会生成对应的functor</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) { <span class="keyword">return</span> x * x; };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会生成类似以下的类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaAnonymous</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="algorithm-库"><code>&lt;algorithm&gt;</code> 库</h2>
<p>该库是模板函数的集合</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250123004800250.png" alt="image-20250123004800250">
<figcaption aria-hidden="true">image-20250123004800250</figcaption>
</figure>
<h2 id="操作符重载">操作符重载</h2>
<p>Operator Overloading，自定义操作符的行为</p>
<ul>
<li><p>不能被重载的运算符：<code>::   ?   .   .*   sizeof()   typeid()   cast()</code></p></li>
<li><p>两种重载方式：</p>
<ol type="1">
<li><p>成员重载：在类内对操作符进行重载，调用时通过<code>b.operator&lt;(rhs)</code>（b是对象）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Obj::<span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; rhs) <span class="type">const</span> {...}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>非成员重载：在类外进行重载，同时将两个操作对象作为参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; lhs, <span class="type">const</span> Obj&amp; rhs);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>非成员重载可以通过<strong>友元</strong>实现，这样就能访问私有变量</p>
</blockquote></li>
</ol></li>
</ul>
<h2 id="特殊成员函数">特殊成员函数</h2>
<p>Special Member Functions
(SMFs)，特殊成员函数是类（或结构）成员函数，在某些情况下，编译器会自动为你生成。
包括<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170#default_constructors">默认构造函数</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/destructors-cpp?view=msvc-170">析构函数</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/copy-constructors-and-copy-assignment-operators-cpp?view=msvc-170">复制构造函数和复制赋值运算符</a>，以及<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符</a>。</p>
<ul>
<li><p>Default constructor: T()</p></li>
<li><p>Destructor: ~T()</p></li>
<li><p>Copy constructor: T(const T&amp;)</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo = widgetOne;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容（深拷贝），而不是仅仅赋值指针，否则会引发
浅拷贝（shallow copy） 问题</strong></p>
</blockquote></li>
<li><p>Copy assignment operator: T&amp; operator=(const T&amp;)
（操作对象是<strong>已经存在的对象</strong>，注意与上面函数区别）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo;</span><br><span class="line">widgetOne = widgetTwo</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Move constructor: T(T&amp;&amp;)</p>
<p>移动构造函数的作用是通过<strong>转移资源</strong>来构造一个新对象，而不是深拷贝资源，这样就可以提高空间利用率</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) {</span><br><span class="line">    other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Move Constructor called"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Move assignment operator: T&amp; operator=(T&amp;&amp;)</p>
<p>移动赋值运算符的作用是将一个对象的资源转移到另一个<strong>已经存在</strong>的对象中。它在执行资源转移的同时，释放目标对象的已有资源以防止内存泄漏。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) { <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">delete</span> data;      <span class="comment">// 释放已有资源</span></span><br><span class="line">        data = other.data; <span class="comment">// 转移资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Move Assignment Operator called"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// 调用构造函数</span></span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 触发 移动赋值运算符</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="move-semantics移动语义">Move Semantics（移动语义）</h2>
<p>涉及到了左值右值，下面没有详细展开，主要介绍<code>std::move</code>函数。</p>
<p>移动构造函数、移动赋值运算符均属于该知识点，当要触发这两个函数时，需要用到<code>std::move</code>，例如上面的例子</p>
<h3 id="stdmove">std::move</h3>
<h4 id="定义">定义</h4>
<ul>
<li><code>std::move</code>
是一个标准库函数，用于将左值显式地转为右值引用，从而触发移动语义。</li>
<li>注意：<code>std::move</code>
并不移动对象，而是允许对象的资源被移动。</li>
</ul>
<h4 id="语法">语法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T&amp;&amp; <span class="title">std::move</span><span class="params">(T&amp; t)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="示例-2">示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">"Hello"</span>;</span><br><span class="line">std::string movedStr = std::<span class="built_in">move</span>(str); <span class="comment">// 触发移动构造函数</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="stdoptional">std::optional</h2>
<p><code>std::optional</code> 是 C++17
引入的一个工具类，用来表示一个值可能存在也可能不存在的情形。它提供了一种优雅的方式来处理可能为空的值，而不需要依赖额外的布尔标志或使用指针。</p>
<h3 id="主要特点"><strong>主要特点</strong></h3>
<ol type="1">
<li><strong>值的可选性：</strong>
<ul>
<li>一个 <code>std::optional</code>
对象可以包含一个值，也可以不包含值（即处于 "empty" 状态）。</li>
<li>适合用来表示“可有可无”的数据。</li>
</ul></li>
<li><strong>避免空指针：</strong>
<ul>
<li>比如函数可能返回一个值，也可能不返回值，用
<code>std::optional</code> 替代返回指针避免空指针引发的错误。</li>
</ul></li>
<li><strong>强类型保障：</strong>
<ul>
<li>提供比返回 <code>nullptr</code> 或特殊标志（例如 <code>-1</code> 或
<code>0</code>）更安全的方式，确保程序的行为更加明确。</li>
</ul></li>
</ol>
<h3 id="使用场景-2"><strong>使用场景</strong></h3>
<ol type="1">
<li><p><strong>函数返回值</strong> 当函数不总是能返回有效值时，用
<code>std::optional</code> 表示返回值的可选性。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">findNameById</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 无值的情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">findNameById</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Found: "</span> &lt;&lt; *name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Name not found.\n"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>替代布尔标志：</strong>
用于标志是否存在值，避免额外的布尔变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> {</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Result <span class="title">compute</span><span class="params">(<span class="type">bool</span> flag)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> Result{<span class="number">42</span>};</span><br><span class="line">    <span class="keyword">return</span> Result{std::<span class="literal">nullopt</span>};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>临时对象的状态管理：</strong>
表示某些临时值是否有效，比如缓存结果。</p></li>
</ol>
<blockquote>
<p>注意<code>nullptr</code>和<code>std::nullopt</code>区别</p>
<ul>
<li><code>nullptr</code>：专门用来表示指针不指向任何对象。它可以隐式地转换为任意指针类型，例如
<code>int*</code>, <code>char*</code>, <code>void*</code> 等。</li>
<li><code>std::nullopt</code>：它是 C++17 中引入的
<code>std::optional</code> 的特殊值，用来表示一个
<code>std::optional</code>
对象不包含任何值（为空的状态）。它可以隐式地用于任何
<code>std::optional&lt;T&gt;</code> 类型，用于初始化或重置
<code>optional</code>。</li>
</ul>
</blockquote>
<h2 id="raii">RAII</h2>
<p>RAII，全称为 <strong>资源获取即初始化</strong>（Resource Acquisition
Is Initialization），是一种 C++ 的重要设计理念。RAII
的核心是将资源（如内存、文件、网络连接、锁等）的管理与对象的生命周期绑定。具体来说：</p>
<ul>
<li><strong>在对象构造时获取资源</strong>，确保资源在对象的整个生命周期内可用。</li>
<li><strong>在对象析构时释放资源</strong>，自动清理以防资源泄漏。</li>
</ul>
<p>这种方式可以有效地避免资源泄露问题，简化资源管理。<strong>常见应用场景</strong>：</p>
<ol type="1">
<li><p><strong>智能指针：</strong></p>
<ul>
<li><code>std::unique_ptr</code>, <code>std::shared_ptr</code>
等智能指针利用 RAII 管理动态内存。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 构造时分配内存</span></span><br><span class="line">    <span class="comment">// 无需手动释放内存</span></span><br><span class="line">} <span class="comment">// 离开作用域时，ptr 自动释放内存</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>文件管理：</strong></p>
<ul>
<li>使用 RAII 类管理文件资源，避免文件未关闭的问题。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToFile</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>; <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line">    file &lt;&lt; <span class="string">"Hello, RAII!"</span>;</span><br><span class="line">} <span class="comment">// 离开作用域时，file 自动关闭</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>锁管理：</strong></p>
<ul>
<li>使用 RAII 类如 <code>std::lock_guard</code>
管理线程同步中的锁。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">criticalSection</span><span class="params">()</span> </span>{</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">} <span class="comment">// 离开作用域时，lock_guard 自动解锁</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="智能指针">智能指针</h2>
<p>Smart Pointers</p>
<h3 id="stdunique_ptr">1.
<strong><code>std::unique_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 独占所有权。一个对象只能由一个
<code>std::unique_ptr</code> 所管理。</li>
<li><strong>主要用途</strong>:
用于明确对象所有权的场景，比如局部变量的资源管理。</li>
<li><strong>自动释放</strong>: 离开作用域时自动释放所管理的对象。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uniquePtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 推荐使用 std::make_unique</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能复制，以下代码会报错</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以转移所有权</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"ptr is now empty after move."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>更轻量化，效率最高。</li>
<li>避免重复释放同一个对象的问题。</li>
<li>使用场景清晰，适合独占资源。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不能共享所有权（即多个指针管理同一个资源）。</li>
</ul>
<h3 id="stdshared_ptr">2.
<strong><code>std::shared_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 共享所有权。多个 <code>std::shared_ptr</code>
可以共同管理同一个对象，直到最后一个 <code>std::shared_ptr</code>
被销毁时对象才会释放。</li>
<li><strong>主要用途</strong>:
用于需要多个指针共享资源的场景，比如资源共享和并发场景。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharedPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>); <span class="comment">// 推荐使用 std::make_shared</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>(); <span class="comment">// ptr1 不再管理资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count after reset: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>方便在需要共享资源的场景中使用。</li>
<li>自动进行引用计数，最后一个指针销毁时释放资源。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有一定的性能开销（引用计数管理）。</li>
<li>如果存在循环引用，可能导致内存泄漏（需配合
<code>std::weak_ptr</code> 解决）。</li>
</ul>
<h3 id="stdweak_ptr">3. <strong><code>std::weak_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 弱引用。用于解决 <code>std::shared_ptr</code>
循环引用的问题。</li>
<li><strong>主要用途</strong>: 辅助 <code>std::shared_ptr</code>
使用，不增加引用计数，只能观察（弱引用）资源。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">weakPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// 不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) { <span class="comment">// 检查资源是否仍然存在</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>用于解决 <code>std::shared_ptr</code> 循环引用问题。</li>
<li>允许访问资源但不拥有资源，不影响引用计数。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>只能与 <code>std::shared_ptr</code> 搭配使用，单独意义不大。</li>
</ul>
<h2 id="makefiles-和-cmake">Makefiles 和 CMake</h2>
<h3 id="makefile"><strong>1. Makefile</strong></h3>
<ul>
<li><code>Makefile</code> 是用于 <code>make</code>
工具的配置文件，它定义了一系列规则，告诉编译器如何生成目标文件。</li>
<li>本质上是手写的构建规则，直接调用编译器命令。</li>
</ul>
<h3 id="cmake"><strong>2. CMake</strong></h3>
<p>需要编写编写 <code>CMakeLists.txt</code></p>
<ul>
<li><code>CMake</code>
是一种跨平台的构建系统生成工具，它可以生成不同平台上的项目文件（如
<code>Makefile</code>、Visual Studio 的项目文件）。</li>
<li><code>CMake</code> 本质上是为大型项目提供了高层次的抽象。</li>
</ul>
<h2 id="assignment">Assignment</h2>
<p>参考资料：https://www.zhihu.com/column/c_1839339107211419649</p>
<h3 id="assignment-1">Assignment 1</h3>
<ul>
<li><p>在迭代 <code>std::vector</code>
时，不建议直接修改当前遍历的容器（如删除元素）。一种常见的做法是使用
<strong>后向迭代</strong> 或者
<strong>标记删除</strong>，然后在迭代完成后删除元素。</p>
<p>但是这里不能使用反向迭代，会导致文件内容与正确文件内容不匹配（倒序，从最后一行往第一行读取内容），所以这里定义了一个中间变量存放待删除的元素。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Course&gt; tmp; <span class="comment">// 存放待删除的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c: all_courses) {</span><br><span class="line">    <span class="keyword">if</span>(c.quarter != <span class="string">"null"</span>) {</span><br><span class="line">        ofile &lt;&lt; c.title &lt;&lt; <span class="string">","</span> &lt;&lt; c.number_of_units &lt;&lt; <span class="string">","</span> &lt;&lt; c.quarter &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> t: tmp) {</span><br><span class="line">    <span class="built_in">delete_elem_from_vector</span>(all_courses, t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>创建了一个临时容器
<code>tmp</code>，并在遍历过程中把要删除的元素放入其中。遍历完后，再通过
<code>delete_elem_from_vector</code> 从 <code>all_courses</code>
中删除这些元素。这样可以避免在原容器上进行删除操作时改变容器的大小或顺序，从而避免迭代器失效的问题。</p>
</blockquote></li>
</ul>
<h3 id="assignment-2">Assignment 2</h3>
<p>需要注意作业要求获取 first name 和 last name
的两个首字母，两个都必须参与比较，可以单独写一个函数记录两个字母，然后进行比较</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">get_initials</span><span class="params">(std::string name)</span> </span>{</span><br><span class="line">  <span class="comment">// 初始化结果字符串</span></span><br><span class="line">    std::string res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个字母</span></span><br><span class="line">    res += name[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找空格位置</span></span><br><span class="line">    <span class="type">size_t</span> space_pos = name.<span class="built_in">find</span>(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了空格，获取空格后第一个字母</span></span><br><span class="line">    <span class="keyword">if</span> (space_pos != std::string::npos &amp;&amp; space_pos + <span class="number">1</span> &lt; name.<span class="built_in">size</span>()) {</span><br><span class="line">        res += name[space_pos + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::queue&lt;<span class="type">const</span> std::string*&gt; <span class="title">find_matches</span><span class="params">(std::string name, std::unordered_set&lt;std::string&gt;&amp; students)</span> </span>{</span><br><span class="line">  <span class="comment">// STUDENT <span class="doctag">TODO:</span> Implement this function.</span></span><br><span class="line">  std::queue&lt;<span class="type">const</span> std::string*&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = students.<span class="built_in">begin</span>(); it != students.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get_initials</span>(*it) == <span class="built_in">get_initials</span>(kYourName))</span><br><span class="line">      q.<span class="built_in">push</span>(&amp;(*it)); <span class="comment">// 先解引用it得到字符串，然后再获取该字符串的地址</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="assignment-3">Assignment 3</h3>
<p>CastXML环境有问题，无法生成xml文件导致无法测评</p>
<h3 id="assignment-4">Assignment 4</h3>
<p>主要用到下面这几个函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">min_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line">std::<span class="built_in">accumulate</span>(InputIt first, InputIt last, T init); <span class="comment">// 这里的init是初始值</span></span><br><span class="line">std::<span class="built_in">max_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">transform</span>( InputIt first1, InputIt last1, OutputIt d_first, UnaryOp unary_op ); <span class="comment">// 第四个参数可用lambda表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//std::remove_if 它会 重新排列 指定范围内的元素，使所有 不符合 给定条件的元素排在前面，并返回一个新的 尾部迭代器，指向重新排列后的有效范围的末尾。</span></span><br><span class="line">std::<span class="built_in">remove_if</span>(ForwardIt first, ForwardIt last, UnaryPred p); <span class="comment">// p函数的返回值一般是布尔值</span></span><br><span class="line"></span><br><span class="line">std::erase <span class="comment">// 能够真正删除元素，可与remove_if配合使用</span></span><br></pre></td></tr></tbody></table></figure>
<p>还需注意<code>const</code>的使用，有些函数的参数不能使用<code>const</code>类型变量。</p>
<blockquote>
<p>如果出现以下报错，则在对应的文件打开函数中添加编码参数，例如：<code>open(file_path, "r", encoding="utf-8")</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 181, in &lt;module&gt;</span><br><span class="line">    add_matcher_tests(grader)</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 138, in add_matcher_tests     </span><br><span class="line">    student_methods = parse_methods(MAIN_CPP_PATH)</span><br><span class="line">                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 97, in parse_methods</span><br><span class="line">    content = file.read()</span><br><span class="line">              ^^^^^^^^^^^</span><br><span class="line">UnicodeDecodeError: 'gbk' codec can't decode byte 0xa8 in position 693: illegal multibyte sequence</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="assignment-5">Assignment 5</h3>
<p>第二部分中注意：对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容，而不是仅仅赋值指针，否则会引发
浅拷贝（shallow copy） 问题</p>
<h3 id="assignment-6">Assignment 6</h3>
<p>考察的知识点是<code>std::optional</code>，可参考上面的笔记</p>
<h3 id="assignment-7">Assignment 7</h3>
<p><strong>需要使用 <code>std::move</code>
来显式触发移动构造函数和移动赋值运算符</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发移动构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">MyClass obj2 = std::<span class="built_in">move</span>(obj1); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发移动赋值运算符</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1);  </span><br></pre></td></tr></tbody></table></figure>
<p>这里还需要使用反向迭代器（reverse_iterator）来实现倒序遍历（逆序遍历），<code>rbegin()</code>指向容器的最后一个元素，<code>rend()</code>
指向容器的前一个位置（即 <code>begin() - 1</code>），下面是相关代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = values.<span class="built_in">rbegin</span>(); i != values.<span class="built_in">rend</span>(); ++i) {</span><br><span class="line">    unique_ptr&lt;ListNode&lt;T&gt;&gt; node = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;T&gt;(*i);</span><br><span class="line">    node-&gt;next = std::<span class="built_in">move</span>(head);</span><br><span class="line">    head = std::<span class="built_in">move</span>(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">gdb在WSL1中报错解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-01-04 00:00:00 / 修改时间：16:58:12" itemprop="dateCreated datePublished" datetime="2025-01-04T00:00:00+08:00">2025-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WSL/" itemprop="url" rel="index"><span itemprop="name">WSL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>550</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我的环境如下：</p>
<figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hxt&gt; wsl <span class="literal">--list</span> <span class="literal">--verbose</span></span><br><span class="line">  NAME      STATE           VERSION</span><br><span class="line">* Ubuntu    Stopped         <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>我想要在该环境下调试一个cpp文件，但是报错：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x1224: file cin_2.cpp, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/hxt/test_code/cin_2</span><br><span class="line">warning: opening /proc/PID/mem file for lwp 399.399 failed: No such file or directory (2)</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint 1.</span><br><span class="line">Cannot access memory at address 0x8001224</span><br></pre></td></tr></tbody></table></figure>
<p>经过搜索发现WSL1（Windows Subsystem for
Linux）中没有对<code>/proc/PID/mem</code>提供支持，导致GDB在尝试访问该文件时出错。老版本的GDB在找不到<code>/proc/PID/mem</code>文件时会使用
ptrace，而新版本的GDB则禁用了这种机制。这里是<a target="_blank" rel="noopener" href="https://github.com/microsoft/WSL/issues/8356">相关讨论和不同解决方案</a>。</p>
<p><strong>我的解决方案</strong>是将WSL1升级到WSL2，使用命令<code>wsl --set-version &lt;发行版名称&gt; 2</code>，问题解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">内存映射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-17T00:00:00+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-16 22:40:59" itemprop="dateModified" datetime="2025-05-16T22:40:59+08:00">2025-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存映射<code>mmap</code>分为普通文件和匿名文件，这里讨论的是Linux环境</p>
<h2 id="文件映射file-mapping">文件映射（File Mapping）</h2>
<blockquote>
<ul>
<li><strong><code>malloc</code>
是高级抽象</strong>，封装了内存分配细节，开发者无需关心底层是
<code>brk</code> 还是 <code>mmap</code>。</li>
<li><strong><code>mmap</code> 是底层机制</strong>，既服务于
<code>malloc</code> 的大内存分配，也用于文件映射等高级功能。</li>
</ul>
</blockquote>
<h3 id="普通文件">普通文件</h3>
<p>将<strong>普通磁盘文件</strong>的某个区域映射到进程的虚拟内存空间。</p>
<h4 id="工作原理">工作原理</h4>
<ul>
<li><strong>页面划分</strong>：文件内容被划分成页面大小（通常为4KB）的片段，每个片段对应虚拟内存中的一个页面。</li>
<li>按需加载（Demand Paging）：
<ul>
<li>初始时，文件内容并不会全部加载到物理内存中。</li>
<li>当CPU<strong>首次</strong>访问某个虚拟页面时，操作系统才将文件对应的页面<strong>从磁盘加载到物理内存</strong>。</li>
</ul></li>
<li><strong>超出文件区域</strong>：若映射区域大于文件大小，超出部分会被<strong>零填充</strong>（Padding
with zeros）。</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>文件的内容直接与虚拟内存对应，可进行高效的文件I/O操作。</li>
<li>用于<strong>程序执行</strong>（如加载可执行文件）或实现<strong>文件共享</strong>。</li>
</ul>
<h3 id="匿名文件">匿名文件</h3>
<p>将一片<strong>不关联磁盘文件</strong>的内存区域映射到进程的虚拟地址空间。这种区域内容初始化为<strong>全零</strong>，由内核创建的<strong>匿名文件</strong>管理。匿名文件的内容全部由<strong>二进制零</strong>组成，因此它是<strong>空白的</strong>、未初始化的。</p>
<h4 id="工作原理-1">工作原理</h4>
<ul>
<li>按需分配：
<ul>
<li>初始时，匿名映射区域并不占用物理内存。</li>
<li>当CPU首次访问某个虚拟页面时，内核会分配一个<strong>物理页面</strong>，并将其内容填充为<strong>二进制零</strong>。</li>
</ul></li>
<li>只有当CPU第一次访问某个虚拟页面时（即“触摸”该页面），内核才会进行以下操作：
<ol type="1">
<li><strong>选择一个牺牲页面</strong>（Victim
Page）：从物理内存中找到一个适合被替换的页面。</li>
<li><strong>交换脏页面</strong>（如有必要）：如果选中的页面是<strong>脏页面</strong>（内容被修改过但尚未写回磁盘），内核会先将其内容写回磁盘。</li>
<li><strong>填充零值</strong>：内核将物理页面的内容全部填充为<strong>二进制零</strong>。</li>
<li><strong>更新页表</strong>：内核将虚拟页面与新分配的物理页面关联起来，并将页面标记为<strong>已驻留</strong>（Resident）。</li>
</ol></li>
</ul>
<h4 id="特点-1">特点</h4>
<ul>
<li>适用于分配需要初始化为零的内存区域，例如堆内存、栈内存。</li>
<li>不涉及磁盘文件，因此无需磁盘I/O。</li>
<li>由于这种机制不会涉及磁盘和内存之间的数据传输，内核只是在分配物理页面时填充零值，因此这类页面被称为<strong>需求零页面</strong>（Demand-Zero
Pages）。</li>
</ul>
<blockquote>
<p><code>malloc</code> 的实现（如 glibc 的
ptmalloc）通常会结合两种方式分配内存：</p>
<ol type="1">
<li><strong>小内存块（&lt; 128KB 或阈值）</strong>：
<ul>
<li>通过 <code>brk</code>/<code>sbrk</code>
系统调用扩展堆空间，从堆中分配。</li>
<li>优点：高效，减少内存碎片（通过内存池管理）。</li>
</ul></li>
<li><strong>大内存块（≥ 128KB 或阈值）</strong>：
<ul>
<li>直接使用 <code>mmap</code>
分配匿名内存（<code>MAP_ANONYMOUS</code>）。</li>
<li>优点：大块内存独立管理，避免堆空间碎片化；释放时直接通过
<code>munmap</code> 归还给操作系统。</li>
</ul></li>
</ol>
</blockquote>
<h2 id="fork-函数">fork 函数</h2>
<p><strong>1. 调用 <code>fork()</code> 时的内存复制：</strong></p>
<ul>
<li><p>在调用 <code>fork()</code>
时，操作系统并不会立即复制整个父进程的内存空间，而是通过<strong>写时复制（Copy-On-Write,
COW）机制</strong>优化内存使用。</p>
<blockquote>
<p><strong>写时复制</strong>只有在任⼀进程（⽗进程或⼦进程）对数据执⾏了写操作时，复制才会发⽣（先是缺⻚中断，然后操作系统给⼦进程分配内存并复制⽗进程的数据）</p>
</blockquote></li>
<li><p>父子进程会<strong>共享同一块物理内存页面</strong>（只读）。</p></li>
<li><p>只有当父进程或子进程尝试修改内存时，写时复制机制会为对应的进程创建一个新页面，从而为每个进程保持了私有地址空间的抽象概念。</p></li>
</ul>
<p><strong>2. 创建子进程：</strong></p>
<ul>
<li>内核会为子进程分配一个新的<strong>进程控制块（PCB）</strong>，用于存储子进程的状态信息。</li>
<li>子进程获得与父进程相同的内存空间（通过 COW 实现共享）。</li>
<li>子进程会继承父进程的大部分资源，例如：
<ul>
<li>程序代码（代码段）</li>
<li>堆、栈（通过 COW 共享）</li>
<li>打开的文件描述符</li>
<li>环境变量等</li>
</ul></li>
</ul>
<p><strong>3. 返回值不同：</strong></p>
<ul>
<li><code>fork()</code>在父进程和子进程中都会返回：
<ul>
<li>在<strong>父进程</strong>中，<code>fork()</code>
返回<strong>子进程的PID</strong>。</li>
<li>在<strong>子进程</strong>中，<code>fork()</code>
返回<strong>0</strong>。</li>
<li>如果 <code>fork()</code> 失败，返回
<strong>-1</strong>，表示子进程创建失败。</li>
</ul></li>
</ul>
<p>通过返回值的不同，程序可以判断当前正在运行的是父进程还是子进程。</p>
<p><strong>4. 进程调度：</strong></p>
<ul>
<li>父进程和子进程会被操作系统调度器视为两个独立的进程，独立运行。</li>
<li>由于父子进程共享同一个代码段，它们可以执行不同的代码路径（如通过
<code>if</code> 判断 <code>fork()</code> 返回值）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">lambda表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-02T00:00:00+08:00">2024-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-23 00:31:45" itemprop="dateModified" datetime="2025-01-23T00:31:45+08:00">2025-01-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内容参考《C++ primer》</p>
<h2 id="定义">定义</h2>
<ul>
<li><p>一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的
内联函数。</p></li>
<li><p>表达式形式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; return type { function body }</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>lambda表达式必须使用尾置返回，尾置返回示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></tbody></table></figure>
</blockquote></li>
<li><p>若忽略括号和参数列表，则等价于指定一个空参数列表</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] { <span class="keyword">return</span> <span class="number">42</span>; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">//打印42</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="向lambda传递参数">向lambda传递参数</h3>
<ul>
<li><p>包含参数的lambda表达式，可作为<code>find_if</code>函数的一个参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); }</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="使用捕获列表">使用捕获列表</h3>
<ul>
<li><p>lambda表达式通过将局部变量包含在其捕获列表中来指出将会使用这些变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sz](<span class="type">const</span> string &amp;a) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; };</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="变量的捕获方式">变量的捕获方式</h2>
<h3 id="值捕获">值捕获</h3>
<ul>
<li>lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。</li>
<li>与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">//将v1拷贝到名为f的可调用对象</span></span><br><span class="line">	<span class="keyword">auto</span> f = [v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">	v1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 42，f保存了我们创建它时v1的拷贝</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="引用捕获">引用捕获</h3>
<ul>
<li>v1之前的<code>&amp;</code>指出v1应该以引用方式捕获。</li>
<li>当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。</li>
<li>在本例中，当lambda返回v1时，它返回的是v1指向的对象的值。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">// f包含对v1的引用</span></span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">	v1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 0，f保存了v1的引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="隐式捕获">隐式捕获</h3>
<ul>
<li>让编译器根据lambda体中的代码来推断我们要使用哪些变量</li>
<li><code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式</li>
<li>混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式捕获，值捕获方式，这里的lambda表达式是find_if的第三个参数</span></span><br><span class="line">wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(), </span><br><span class="line">             [=](<span class="type">const</span> string &amp;s)</span><br><span class="line">                { <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; });</span><br></pre></td></tr></tbody></table></figure>
<h2 id="可变lambda">可变lambda</h2>
<ul>
<li><p>对于一个值被拷贝的变量，若要改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fen3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">size_t</span> v1 = <span class="number">42</span>;<span class="comment">//局部变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">// f可以改变它所捕获的变量的值</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">auto</span> f = [v1] ()  <span class="keyword">mutable</span> { <span class="keyword">return</span> ++v1;};</span></span></span><br><span class="line"><span class="params"><span class="function">	v1 =<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">auto</span> j = f();<span class="comment">//j为43</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>对于引用捕获的变量可以直接修改，不用添加mutable关键字</p></li>
</ul>
<h2 id="指定返回类型">指定返回类型</h2>
<ul>
<li><p>默认情况下，如果一个lambda体包含<code>return</code>之外的任何语句，则编译器假定此lambda返回void。例如下面的代码就是错误的</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：不能推断lambda的返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i)</span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;};</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>若lambda表达式包含其他语句，且返回值其实不是void，则使用尾置返回类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i) -&gt; <span class="type">int</span>  <span class="comment">// 这里指定了返回类型</span></span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; });</span><br></pre></td></tr></tbody></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxt"
      src="/images/hxt.jpg">
  <p class="site-author-name" itemprop="name">hxt</p>
  <div class="site-description" itemprop="description">May the Force be with you.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">183</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">75</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">423k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
