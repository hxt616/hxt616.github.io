<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="May the Force be with you.">
<meta property="og:type" content="website">
<meta property="og:title" content="hxt&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="hxt&#39;s Blog">
<meta property="og:description" content="May the Force be with you.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hxt">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hxt's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxt's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/13/std_thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/13/std_thread/" class="post-title-link" itemprop="url">std::thread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-13 21:52:02 / 修改时间：22:22:05" itemprop="dateCreated datePublished" datetime="2025-05-13T21:52:02+08:00">2025-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一基本使用方法">一、基本使用方法</h2>
<h3 id="创建线程">1. 创建线程</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello from thread!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(printMessage)</span></span>; <span class="comment">// 启动线程</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="带参数的线程">2. 带参数的线程</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(printSum, <span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 传值参数</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用-lambda-表达式">3. 使用 Lambda 表达式</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]() {</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">"Lambda thread"</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">})</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用成员函数">4. 使用成员函数</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> times)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Working..."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Worker w;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;Worker::doWork, &amp;w, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="二线程控制">二、线程控制</h2>
<h3 id="detach">1. <code>detach()</code></h3>
<p><code>std::thread::detach()</code> 的意思是：</p>
<ul>
<li>让线程 <strong>后台运行（daemon-like）</strong></li>
<li>主线程 <strong>不再跟踪这个线程</strong>，你不能再
<code>join()</code> 它，也无法控制它</li>
<li>它会在自己工作完成后自动结束</li>
</ul>
<h4 id="但如果-main-提前退出">但如果 <code>main()</code> 提前退出？</h4>
<p>一旦 <code>main()</code>
返回，程序的所有资源都会被释放，<strong>包括所有线程</strong>（不管他们干完了没有）！</p>
<ul>
<li>即使你已经 <code>detach()</code>
了线程，它也可能<strong>没有时间完成任务</strong>；</li>
<li>程序就直接退出了，<strong>线程被强制杀死</strong>，<strong>任务中断</strong>；</li>
<li>所以你可能看不到完整输出，或者文件没下载完。</li>
</ul>
<h4 id="示例">示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>{</span><br><span class="line">    std::<span class="built_in">thread</span>([] {</span><br><span class="line">        <span class="built_in">download</span>(<span class="string">"file.zip"</span>); <span class="comment">// 下载需要 4 秒</span></span><br><span class="line">    }).<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">myfunc</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 马上退出！后台线程直接被终止</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 运行结果：可能只打印出 1～2 行“Downloading ...”，甚至什么都不打印。*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>解决方法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([] {</span></span></span><br><span class="line"><span class="params"><span class="function">        download(<span class="string">"file.zip"</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    })</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等它干完</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="join">2. <code>join()</code></h3>
<p><code>std::thread::join()</code>
的作用是：<strong>阻塞当前线程，直到目标线程执行完成</strong>。</p>
<ul>
<li>当你调用
<code>t.join();</code>，当前线程（比如主线程）会<strong>暂停运行</strong>；</li>
<li>一直等到 <code>t</code> 所代表的那个子线程跑完；</li>
<li>然后继续执行后面的语句。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ol type="1">
<li><p>一个线程只能 <code>join()</code> 一次</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(work)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">t.<span class="built_in">join</span>(); <span class="comment">// 再次调用会崩溃，线程已经结束</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>线程未启动不能 <code>join()</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread t;  <span class="comment">// 默认构造，未绑定函数</span></span><br><span class="line">t.<span class="built_in">join</span>();       <span class="comment">// 崩溃，线程未启动</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>通常在 <code>joinable()</code> 判断后调用</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) {</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是一种<strong>良好的编程习惯</strong>，避免调用非法
<code>join()</code>。</p></li>
</ol>
<hr>
<h2 id="三常见注意事项">三、常见注意事项</h2>
<ol type="1">
<li><p><strong>不要忘记调用 <code>join()</code> 或
<code>detach()</code></strong>，否则程序会崩溃。</p></li>
<li><p><strong>传递引用参数时要使用 <code>std::ref</code></strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>{ x++; }</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update, std::ref(myInt))</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>避免使用局部变量传给线程（可能悬空）</strong>。</p></li>
<li><p><strong>多线程共享资源要注意加锁</strong>，使用
<code>std::mutex</code> 等同步原语。</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Linux网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-03 00:00:00 / 修改时间：13:38:57" itemprop="dateCreated datePublished" datetime="2025-04-03T00:00:00+08:00">2025-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络编程基础api">网络编程基础API</h2>
<p><strong>补充知识</strong></p>
<ul>
<li>主机字节序：一般为<strong>小端序</strong>（低位放在较小的地址处，高位放在较大的地址处）</li>
<li>网络字节序：一般为<strong>大端序</strong></li>
</ul>
<p>示例：0x01234567，其中 0x01 是最高位有效字节，0x67
是最低位有效字节</p>
<h3 id="套接字地址">套接字地址</h3>
<p>套接字地址（<strong>Socket Address</strong>）是 <strong>IP
地址和端口号的组合</strong>，用于唯一标识网络上的一个进程。</p>
<ol type="1">
<li><p><code>struct sockaddr</code></p>
<p><code>sockaddr</code>
是一个<strong>通用的地址结构体</strong>，它的定义如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// 地址族（AF_INET, AF_INET6等）</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// 地址数据（具体的地址信息）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>成员解析</strong>：</p>
<ul>
<li><code>sa_family_t sa_family</code>：地址族（例如
<code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6）。</li>
<li><code>char sa_data[14]</code>：存储具体的地址数据（IP 地址 +
端口）。</li>
</ul>
<p><strong>⚠️ <code>sockaddr</code>
本身不会直接使用，而是由更具体的结构体（如 <code>sockaddr_in</code> 和
<code>sockaddr_in6</code>）进行扩展。</strong></p></li>
<li><p><code>sockaddr_in</code>（IPv4 地址）</p>
<p><code>sockaddr_in</code> 结构体是 <code>sockaddr</code>
的<strong>专门版本</strong>，用于<strong>IPv4 地址</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// sockaddr_in 定义在这个头文件中</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">// 地址族（必须是 AF_INET）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;       <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;  <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">// 备用字段（填充用，一般不用）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这里的<code>struct in_addrc</code>的详细代码定义在<code>&lt;netinet/in.h&gt;</code>文件头中：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> {</span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32 位 IPv4 地址（网络字节序）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>示例代码（IPv4 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// 包含 inet_pton 和 inet_ntoa</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">"192.168.1.1"</span>, &amp;addr.sin_addr);  <span class="comment">// 将IP字符串转换为二进制格式</span></span><br><span class="line">    <span class="comment">// 第三个参数 &amp;addr.sin_addr 表示转换后的二进制 IP 地址的存储位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印转换后的信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IP: "</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr.sin_port) &lt;&lt; std::endl;  <span class="comment">// 端口转换回主机字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>函数解析</strong>：</p>
<ul>
<li><code>htons(port)</code>：将主机字节序的<strong>端口号</strong>转换为<strong>网络字节序</strong>。</li>
<li><code>ntohs(port)</code>：将网络字节序的<strong>端口号</strong>转换回<strong>主机字节序</strong>。</li>
<li><code>inet_pton(AF_INET, "192.168.1.1", &amp;addr.sin_addr)</code>：将
IPv4 字符串转换为二进制格式。为了后续的 socket 操作（例如
<code>connect</code> 或 <code>bind</code>）能够使用正确的二进制格式的 IP
地址。</li>
<li><code>inet_ntoa(addr.sin_addr)</code>：将二进制 <strong>IP
地址</strong>转换为可读的字符串。</li>
</ul></li>
<li><p><code>sockaddr_in6</code>（IPv6 地址）</p>
<p>IPv6 地址使用 <code>sockaddr_in6</code> 结构体：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;     <span class="comment">// 地址族（必须是 AF_INET6）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;         <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;      <span class="comment">// IPv6 流量控制信息（一般设为 0）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;   <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;      <span class="comment">// 作用域 ID（用于本地连接）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>示例代码（IPv6 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> addr6;</span><br><span class="line">    addr6.sin6_family = AF_INET6;</span><br><span class="line">    addr6.sin6_port = <span class="built_in">htons</span>(<span class="number">9090</span>);  <span class="comment">// 端口号</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET6, <span class="string">"::1"</span>, &amp;addr6.sin6_addr);  <span class="comment">// 将 IPv6 地址转换为二进制</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ip_str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET6, &amp;addr6.sin6_addr, ip_str, <span class="built_in">sizeof</span>(ip_str));  <span class="comment">// 转换回可读字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IPv6: "</span> &lt;&lt; ip_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr6.sin6_port) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>IPv6 相关函数</strong>：</p>
<ul>
<li><code>inet_pton(AF_INET6, "::1", &amp;addr6.sin6_addr)</code>：将
IPv6 地址字符串转换为二进制格式。</li>
<li><code>inet_ntop(AF_INET6, &amp;addr6.sin6_addr, ip_str, sizeof(ip_str))</code>：将
IPv6 二进制地址转换回字符串。</li>
</ul></li>
</ol>
<h3 id="创建套接字">创建套接字</h3>
<p>socket系统调⽤成功时返回⼀个socket⽂件描述符，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>domain</code>（协议族）：<code>AF_INET</code>（IPv4）、<code>AF_INET6</code>（IPv6）、<code>AF_UNIX</code>（本地通信）</li>
<li><code>type</code>（套接字类型）：<code>SOCK_STREAM</code>（流服务，TCP）、<code>SOCK_DGRAM</code>（数据报服务，UDP）</li>
<li><code>protocol</code>（协议）：<code>0</code>（默认），<code>IPPROTO_TCP</code>（TCP），<code>IPPROTO_UDP</code>（UDP）</li>
</ul>
<h3 id="绑定套接字">绑定套接字</h3>
<p><code>bind</code>函数<strong>将套接字（socket）与本地 IP
地址和端口号绑定</strong>，即上面提到的两个关键字，这样客户端可以连接到该地址。成功时返回0，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：<strong>要绑定的 socket 文件描述符</strong>（由
<code>socket()</code> 创建）</li>
<li><code>addr</code>：<strong>要绑定的本地地址（IP +
端口）</strong>，需要转换为 <code>sockaddr*</code>
类型（默认套接字地址类型）</li>
<li><code>addrlen</code>：<strong>地址结构体的大小</strong>（通常用
<code>sizeof(struct sockaddr_in)</code>）</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr {};</span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// 使用 IPv4</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定到本机所有 IP</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 绑定端口 8080</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"bind failed"</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Socket bound to port 8080"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="监听套接字">监听套接字</h3>
<p><code>listen</code>函数创建⼀个监听队列以存放待处理的客户连接。成功时返回0，失败则返回-1。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket 文件描述符，通常是通过
<code>socket()</code> 创建并已绑定地址和端口的 socket</li>
<li><code>backlog</code>：连接队列的最大长度。
<ul>
<li>当多个客户端同时尝试连接服务器时，未处理的连接请求会被放入队列中。</li>
<li><code>backlog</code>
指定了队列的最大长度。如果队列已满，新的连接请求会被拒绝。</li>
</ul></li>
</ul>
<blockquote>
<p>监听队列中<strong><code>ESTABLISHED</code> 状态</strong> 的连接表示
<strong>三次握手成功</strong>，连接已建立，可以通信。但此时连接还在
<strong>监听队列</strong> 中，服务器端还
<strong>不能直接读写数据</strong>，需要通过 <code>accept()</code>
取出连接。</p>
</blockquote>
<h3 id="接受连接">接受连接</h3>
<p><code>accept</code>函数从<code>listen</code>监听队列中接受⼀个连接。成功返回新的<strong>已连接套接字描述符</strong>，用于与客户端通信；失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket文件描述符（这里是被监听的socket）</li>
<li><code>addr</code>：指向存储客户端地址信息的结构体，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：指向地址长度的指针，调用前应设置为
<code>addr</code> 的长度，调用后会被修改为实际地址长度。</li>
</ul>
<h3 id="发起连接">发起连接</h3>
<p><code>connect</code>函数⽤来主动与服务器建⽴连接。成功返回<code>0</code>，失败返回<code>-1</code>。⼀旦成功建⽴连接，sockfd就唯⼀地标识了这个连接，客户端就可以通过读写<code>sockfd</code>来与服务器通信。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：文件描述符</li>
<li><code>addr</code>：<strong>服务器地址</strong>信息，包括 IP
和端口。</li>
<li><code>addrlen</code>：<code>addr</code>的大小</li>
</ul>
<blockquote>
<p><strong><code>connect</code> 是客户端主动建立连接</strong></p>
<p><strong><code>accept</code>是服务器被动接受连接</strong></p>
</blockquote>
<h3 id="关闭连接">关闭连接</h3>
<h4 id="close">close</h4>
<p>关闭<code>sockfd</code>对应的socket连接。成功返回<code>0</code>，失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用计数机制</strong>：</p>
<ul>
<li>内核维护<strong>文件描述符的引用计数</strong>。</li>
<li>调用 <code>close()</code> 时，引用计数 <strong>减 1</strong>。</li>
<li>当引用计数为 0，才真正关闭连接</li>
</ul>
<h4 id="shutdown">shutdown</h4>
<p>如果⽆论如何都要⽴即终⽌连接（⽽不是将socket的引⽤计数减1），可以使⽤的<code>shutdown</code>系统调⽤。成功时返回<code>0</code>，失败则返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line"><span class="comment">/* how 参数表示关闭方式：SHUT_RD、SHUT_WR、SHUT_RDWR */</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>shutdown</code>能够分别关闭socket上的读或写，或者都关闭。⽽<code>close</code>在关闭连接时只能将socket上的读和写同时关闭。</p>
<h3 id="数据读写">数据读写</h3>
<p>对文件的读写操作<code>read</code>和<code>write</code>同样适用于socket</p>
<h4 id="tcp数据读写">TCP数据读写</h4>
<ol type="1">
<li><p><code>send()</code></p>
<p><strong>发送数据</strong>到已连接的 <strong>TCP
套接字</strong>中。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code> 。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>待发送数据</strong>的缓冲区</li>
<li><code>len</code>：带发送数据的长度</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞发送</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞发送</strong>，若缓冲区满，则立即返回</li>
<li><code>MSG_NOSIGNAL</code>：<strong>不触发 SIGPIPE
信号</strong>，在对端关闭时返回错误</li>
</ul></li>
</ul></li>
<li><p><code>recv()</code></p>
<p><strong>从 TCP
套接字接收数据</strong>并存入缓冲区。成功则返回<strong>接收到的字节数</strong>（<code>0</code>：表示
<strong>对方关闭连接</strong>，即发送了 <code>FIN</code>
包），失败则返回<code>-1</code>。可能要多次调⽤<code>recv</code></p>
<p><strong>失败</strong>：返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞接收</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞接收</strong>，若无数据则立即返回</li>
<li><code>MSG_PEEK</code>：<strong>窥视模式</strong>，读取数据但不删除缓冲区中的内容</li>
</ul></li>
</ul></li>
</ol>
<h4 id="udp数据报读写">UDP数据报读写</h4>
<ol type="1">
<li><p><code>sendto()</code></p>
<p>发送 UDP
数据报到指定的目标地址。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>： 套接字描述符</li>
<li><code>buf</code>：指向 <strong>待发送数据</strong> 的缓冲区</li>
<li><code>len</code>：待发送数据长度</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>dest_addr</code>（结构体）：目标地址，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：目标地址结构体的大小</li>
</ul></li>
<li><p><code>recvfrom()</code></p>
<p>接收 UDP
数据报并保存到缓冲区中。成功则返回<strong>实际接收的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>src_addr</code>：存放发送地址的结构体指针</li>
<li><code>addrlen</code>：发送方地址结构体的大小</li>
</ul></li>
</ol>
<h4 id="通用数据读写">通用数据读写</h4>
<p>不仅能⽤于TCP流数据，也能⽤于UDP数据报</p>
<ol type="1">
<li><p><code>sendmsg</code></p>
<p>成功则返回发送的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符。</li>
<li><code>msg</code>：指向 <strong><code>msghdr</code>
结构体</strong>，包含要发送的数据、目标地址、控制信息。</li>
<li><code>flags</code>：发送标志，如
<code>MSG_DONTWAIT</code>、<code>MSG_EOR</code>。</li>
</ul></li>
<li><p><code>recvmsg</code></p>
<p>成功则返回接收的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p><code>msghdr</code>结构体详解</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> {</span><br><span class="line">    <span class="type">void</span>         *msg_name;       <span class="comment">// 地址信息 (UDP：目标地址 / 源地址；对于⾯向连接的TCP协议，该成员没有意义)</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;        <span class="comment">// 数据缓冲区数组</span></span><br><span class="line">    <span class="type">size_t</span>        msg_iovlen;     <span class="comment">// 数据缓冲区个数</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;    <span class="comment">// 控制信息缓冲区</span></span><br><span class="line">    <span class="type">size_t</span>        msg_controllen; <span class="comment">// 控制信息长度</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;      <span class="comment">// 消息标志</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="总结">总结</h3>
<h4 id="服务端-tcp">服务端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>bind()</code></strong>：绑定 IP 地址和端口号</li>
<li><strong><code>listen()</code></strong>：监听客户端连接请求</li>
<li><strong><code>accept()</code></strong>：接受客户端连接</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<h4 id="客户端-tcp">客户端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>connect()</code></strong>：连接服务器</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<blockquote>
<p><strong>客户端</strong> 不调用 <code>bind()</code> 是为了
<strong>简化编程</strong> 和
<strong>方便操作系统自动分配端口</strong>。</p>
<p><strong>服务端</strong> 必须调用 <code>bind()</code> 来
<strong>指定监听的 IP 地址和端口号</strong>，以便
<strong>客户端能够连接</strong>。</p>
</blockquote>
<h2 id="高级io函数">高级I/O函数</h2>
<p><code>pipe</code>、<code>dup</code>、<code>readv</code>、<code>sendfile</code>、<code>mmap</code>、<code>tee</code>、<code>fcntl</code></p>
<p><code>splice</code>：用于在两个文件描述符之间移动数据，而无需将数据从内核空间复制到用户空间，<strong>直接在内核空间</strong>中完成数据的传输。。它通常用于高效地将数据从一个文件描述符（例如管道、socket
或文件）传输到另一个文件描述符。核心原理是它利用了 Linux
内核的<strong>零拷贝（Zero-Copy）技术</strong></p>
<h2 id="linux服务器程序规范">Linux服务器程序规范</h2>
<p><strong>AF_UNIX Socket 类型</strong></p>
<ul>
<li><strong>AF_UNIX</strong> 是一种本地进程间通信（IPC）的 Socket
类型，也称为 <strong>Unix Domain Socket (UDS)</strong>。</li>
<li>它用于 <strong>同一台机器</strong>
上不同进程之间的通信，不涉及网络传输。</li>
<li>通信数据不会经过网络协议栈，因此
<strong>效率高、延迟低、开销小</strong>。</li>
</ul>
<h3 id="日志">日志</h3>
<ul>
<li><p><code>rsyslog</code> 是 Linux
系统中功能强大的日志管理工具，具有高性能、模块化、支持多种协议和格式化输出的特点。</p></li>
<li><p><strong>rsyslogd 守护进程</strong> 在接收到
<strong>用户进程</strong> 或 <strong>内核</strong>
输入的日志后，会按照配置文件中的规则，将它们输出到特定的
<strong>日志文件</strong> 中。</p></li>
</ul>
<p>下面是<strong>日志处理流程</strong></p>
<ol type="1">
<li><p><strong>日志收集</strong>：</p>
<ul>
<li><p><strong>用户进程日志</strong>：通过调用 <code>syslog()</code>
函数，将日志写入 <code>/dev/log</code>（AF_UNIX Socket）。</p>
<blockquote>
<ul>
<li><p><strong><code>syslog()</code></strong> 是 C
语言标准库中的一个函数，用于
<strong>向系统日志发送消息</strong>。</p></li>
<li><p>日志通过 <strong>AF_UNIX Socket</strong> 发送到
<code>/dev/log</code> 文件，由 <code>rsyslogd</code>
或其他系统日志守护进程收集、处理并写入日志文件。</p></li>
<li><p>典型用途：记录程序运行状态、错误信息、安全事件等，便于调试和维护</p></li>
</ul>
</blockquote></li>
<li><p><strong>内核日志</strong>：通过 <code>klog</code>
模块从内核中收集日志，例如启动、硬件、中断等信息。</p></li>
</ul></li>
<li><p><strong>rsyslogd 获取日志</strong>：</p>
<ul>
<li><code>rsyslogd</code> 守护进程监听 <code>/dev/log</code> 和
<code>/proc/kmsg</code>（内核日志），获取日志数据。</li>
</ul></li>
<li><p><strong>日志过滤与分类</strong>：</p>
<ul>
<li>根据配置文件（如 <code>/etc/rsyslog.conf</code> 和
<code>/etc/rsyslog.d/*.conf</code>）中的规则进行过滤和分类。</li>
<li>规则由 Facility（日志来源） 和 Level（日志级别） 组成</li>
</ul></li>
<li><p><strong>日志输出与存储</strong>：</p>
<ul>
<li>日志被写入到指定的日志文件，如：
<ul>
<li><code>/var/log/messages</code>：系统通用日志</li>
<li><code>/var/log/secure</code>：认证和安全相关日志</li>
<li><code>/var/log/maillog</code>：邮件日志</li>
<li><code>/var/log/cron</code>：定时任务日志</li>
<li><code>/var/log/kern.log</code>：内核日志</li>
</ul></li>
<li>或者转发至 <strong>远程日志服务器</strong> 或
<strong>数据库</strong> 进行集中存储和分析。</li>
</ul></li>
</ol>
<h3 id="用户信息">用户信息</h3>
<p>EGID/EUID
存在的⽬的是⽅便资源访问，给运⾏⽬标程序的(组)⽤户提供有效(组)用户的权限。</p>
<blockquote>
<p>示例：</p>
<ul>
<li><p><strong><code>su</code> 程序</strong> 在
<strong>普通用户启动时</strong>，<strong>EUID 临时变为
<code>root</code></strong>，从而拥有 <code>root</code> 权限。</p></li>
<li><p>由于 SUID 位（即set-user-id 标志）被设置，则 <strong>EUID 变为
root</strong>，进程可以 <strong>访问和修改 <code>/etc/passwd</code>
文件</strong>，并执行切换用户的操作。</p></li>
</ul>
</blockquote>
<ol type="1">
<li><p>获取用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实用户 ID (UID)</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效用户 ID (EUID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实组 ID (GID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效组 ID (EGID)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设置用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;       <span class="comment">// 设置 真实用户 ID 和 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span></span>;     <span class="comment">// 设置 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;       <span class="comment">// 设置 真实组 ID 和 有效组 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span></span>;     <span class="comment">// 设置 有效组 ID</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="进程间关系">进程间关系</h3>
<h4 id="进程组">进程组</h4>
<ul>
<li>每个进程组都有一个唯一的 <strong>进程组 ID
(PGID)</strong>，用于标识该组中的所有进程。</li>
<li><strong>PGID（Process Group
ID）</strong>：进程组的唯一标识符，等于该组<strong>首领进程（Leader
Process）</strong> 的 PID（进程 ID）。</li>
<li><strong>首领进程</strong>：最先创建进程组的进程，PGID 等于它的
PID。如果首领进程退出，进程组不会消失，但其他进程的 PGID
不变。进程组将⼀直存在，直到其中<strong>所有进程</strong>都退出，或者加⼊到其他进程组。</li>
</ul>
<h4 id="会话">会话</h4>
<ul>
<li><p>一组相关的进程组组成一个会话，每个会话有一个唯一的
<strong>SID（Session ID）</strong>。</p></li>
<li><p><strong>Session ID
(SID)</strong>：会话的唯一标识符，等于会话首领进程（Session Leader）的
PID。</p></li>
<li><p><strong>会话首领进程</strong>：创建会话的进程，SID 等于它的
PID。这个进程可以成为<strong>守护进程</strong>。</p>
<blockquote>
<p><strong>调用进程不能是当前进程组的组长</strong>，否则会返回错误。这是因为：</p>
<ul>
<li>如果组长进程调用 <code>setsid()</code>，那么它的 <strong>PGID
(Process Group ID)</strong> 和 <strong>PID (Process ID)</strong>
相同，而 <code>setsid()</code>
要求调用进程成为<strong>新进程组的组长</strong>，即 <strong>PGID =
PID</strong>。如果它本身已经是组长，就无法改变 PGID，因此被禁止。</li>
</ul>
</blockquote></li>
</ul>
<h4 id="ps命令"><code>ps</code>命令</h4>
<p>用于<strong>查看系统中正在运行的进程</strong>。它可以显示进程的
PID、PPID、PGID、SID、TTY、状态、内存占用等详细信息。</p>
<ol type="1">
<li><p>查看所有进程的层级关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef --forest</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看会话、进程组和 PID 的关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看当前 Shell 会话中的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看前后台作业及进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某个用户的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u username</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="系统资源限制">系统资源限制</h3>
<ul>
<li><strong><code>getrlimit(int resource, struct rlimit \*rlim)</code></strong>：获取指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
<li><strong><code>setrlimit(int resource, const struct rlimit \*rlim)</code></strong>：设置指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
</ul>
<h3 id="改变目录">改变目录</h3>
<ol type="1">
<li><p>获取<strong>当前工作目录</strong>的<strong>绝对路径</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>buf</code>：用于存储路径的缓冲区。</li>
<li><code>size</code>：缓冲区大小。</li>
<li>返回值：成功返回 <code>buf</code>；失败返回
<code>NULL</code>，并设置 <code>errno</code></li>
</ul></li>
<li><p>切换目录</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>path</code>：目标目录的路径（绝对路径或相对路径）。</li>
<li>返回值：成功返回 <code>0</code>；失败返回 <code>-1</code>，并设置
<code>errno</code></li>
</ul></li>
</ol>
<h3 id="服务器程序后台化">服务器程序后台化</h3>
<ol type="1">
<li><strong>创建子进程</strong> 并退出父进程，防止继续占用
<strong>终端</strong>。</li>
<li><strong>调用 <code>setsid()</code></strong>：
<ul>
<li>创建新会话 (<code>session</code>)，并成为会话首进程。</li>
<li>成为新进程组的<strong>组长</strong>。</li>
<li><strong>脱离</strong> 控制终端。</li>
</ul></li>
<li><strong>重设文件权限掩码</strong>：
<ul>
<li>使用 <code>umask(0)</code> 确保子进程可以创建任何权限的文件。</li>
</ul></li>
<li><strong>更改工作目录</strong>：
<ul>
<li>通常切换到根目录：<code>chdir("/")</code>，防止
<strong>占用文件系统</strong>。</li>
</ul></li>
<li><strong>关闭文件描述符</strong>：
<ul>
<li>关闭 <strong>stdin, stdout, stderr</strong>
(<code>0, 1, 2</code>)，防止<strong>占用终端资源</strong>。</li>
</ul></li>
<li><strong>重定向文件描述符</strong>：
<ul>
<li>重定向 <code>stdin, stdout, stderr</code> 到
<strong><code>/dev/null</code></strong> 或
<strong>日志文件</strong>。</li>
</ul></li>
</ol>
<h2 id="io模型">I/O模型</h2>
<p>其中最重要的就是<strong>I/O复用</strong></p>
<h3 id="阻塞io">阻塞I/O</h3>
<p>进程发起 I/O
请求后，线程会一直阻塞，直到数据准备好并被复制到用户空间，I/O
操作才完成。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>，如果数据未准备好，进程进入
<strong>阻塞状态</strong>。</li>
<li>内核等待数据准备好，并从内核缓冲区复制到用户空间。</li>
<li><code>read()</code> 返回，进程继续执行。</li>
</ol>
<h3 id="非阻塞io">非阻塞I/O</h3>
<p>进程发起I/O请求后，不管数据是否准备好都会直接返回。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>：
<ul>
<li><strong>如果数据已准备好</strong>，<code>read()</code>
立即返回数据。</li>
<li><strong>如果数据未准备好</strong>，<code>read()</code> 立即返回
<code>-1</code>，并设置 <code>errno = EAGAIN</code>（不会阻塞）。</li>
</ul></li>
<li>进程通常会<strong>轮询</strong>（不断调用
<code>read()</code>）直到数据可用。</li>
</ol>
<h3 id="信号驱动io">信号驱动I/O</h3>
<p>让内核在 I/O 事件发生时发送信号 (<code>SIGIO</code>)
通知进程，进程在信号处理程序中执行 I/O 操作。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>fcntl()</code> 启用 <code>O_ASYNC</code>
标志，让内核在 I/O 事件发生时发送 <code>SIGIO</code> 信号。</li>
<li>进程继续执行其他任务，不阻塞。</li>
<li>当数据可用时，内核发送 <code>SIGIO</code> 信号。</li>
<li>信号处理函数调用 <code>read()</code> 读取数据。</li>
</ol>
<h3 id="异步io">异步I/O</h3>
<p>进程发起 I/O 请求后<strong>不会阻塞</strong>，内核在 I/O
操作完成后通知进程。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>aio_read()</code> 让内核执行 I/O 操作。</li>
<li>进程立即继续执行其他任务，不阻塞。</li>
<li>内核完成 I/O 后，主动通知进程（如回调函数或 <code>SIGEV</code>
机制）。</li>
<li>进程获取数据，I/O 操作完成。</li>
</ol>
<blockquote>
<p>异步I/O与信号驱动I/O的区别</p>
<p><strong>信号驱动 I/O (<code>SIGIO</code>)</strong>：</p>
<ul>
<li>只是<strong>提前通知</strong>进程 “数据可读”，但进程仍需
<code>read()</code> 获取数据。</li>
<li>适用于<strong>高并发网络 I/O</strong>（但现代高性能服务器一般用
<code>epoll</code>）。</li>
</ul>
<p><strong>异步 I/O (AIO)</strong>：</p>
<ul>
<li><strong>真正的异步</strong>，内核完成 I/O 后数据已就绪，无需
<code>read()</code>。</li>
<li>适用于<strong>高吞吐文件 I/O</strong>，如数据库、存储系统
(<code>io_uring</code> 适用于网络和文件)。</li>
</ul>
</blockquote>
<h3 id="io复用">I/O复用</h3>
<p>通过 <code>select()</code>、<code>poll()</code> 或
<code>epoll()</code> 让一个线程同时监视多个 I/O 事件，提高并发能力。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用
<code>select()</code>/<code>poll()</code>/<code>epoll_wait()</code>，等待多个文件描述符的状态变化。</li>
<li>如果某个描述符准备好，进程再去执行 <code>read()</code>。</li>
<li><code>read()</code>
仍然是阻塞的，但因为之前已经确认了数据可读，阻塞时间很短。</li>
</ol>
<h4 id="select">select</h4>
<p><code>select()</code> 函数是一种 <strong>I/O 多路复用</strong>
技术，它可以 <strong>同时监听多个文件描述符 (File Descriptor,
FD)</strong> 的状态。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>nfds</code></td>
<td>监听的最大文件描述符的值加 1（仅 Linux 需要，Windows
忽略此参数）。</td>
</tr>
<tr class="even">
<td><code>readfds</code></td>
<td>监听可读事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>writefds</code></td>
<td>监听可写事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="even">
<td><code>exceptfds</code></td>
<td>监听异常事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>timeout</code></td>
<td>设定超时时间，可为 <code>NULL</code>（表示无限等待）。</td>
</tr>
</tbody>
</table>
<p>select成功时返回就绪（可读、可写和异常）⽂件描述符的总数。如果在超时时间内没有任何⽂件描述符就绪，select将返回0。select失败时返回-1。</p>
<p>下面是<code>select</code>监听的文件操作符可能出现的状态：（<code>FD_ISSET</code>用于判断状态是否变化即是否就绪，例如<code>FD_ISSET(fd, &amp;readfds)</code>
用于检查某个文件描述符 (<code>fd</code>) 是否<strong>在
<code>readfds</code> 集合中被标记为可读</strong>。）</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">监听类型</th>
<th style="text-align: center;">触发条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>可读
<code>readfds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 有数据可读
<br>2. <code>accept()</code> 有新连接 <br>3. <code>read()</code>
返回 0（对端关闭） <br>4. 终端、管道、文件可读</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>可写
<code>writefds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 发送缓冲区可用
<br>2. <code>connect()</code> 非阻塞模式完成 <br>3.
<code>write()</code> 不会阻塞</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>异常
<code>exceptfds</code></strong></td>
<td style="text-align: center;">1. <code>connect()</code> 失败 <br>2.
<code>MSG_OOB</code> <strong>带外数据</strong> <br>3. TCP 连接复位
(RST)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>fd_set</code>：<strong>文件描述符（file
descriptor）集合</strong>，只能存 1024 个文件描述符</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;    <span class="comment">// 清空集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 添加文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 从集合中移除文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">// 检查文件描述符是否准备就绪</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>两种应用：</p>
<p><strong><code>select()</code> + 非阻塞
I/O（纯事件驱动模型）</strong>：</p>
<ul>
<li>适用于 <strong>高并发、轻量级连接</strong> 的场景，如
<strong>聊天室、HTTP 代理服务器</strong>。</li>
<li>无需多进程或多线程，<strong>单线程即可管理和处理多个连接</strong>。</li>
</ul>
<p><strong><code>select()</code> +
<code>fork()</code>（混合模型）</strong>：</p>
<ul>
<li>适用于 <strong>中小规模并发</strong> 且
<strong>每个连接需要较重业务处理</strong> 的场景，如
<strong>文件上传、数据计算</strong>。</li>
<li>通过 <strong>子进程避免阻塞主进程</strong>，简化了 <strong>I/O
操作的编程模型</strong>。</li>
</ul>
<h4 id="poll">poll</h4>
<p><code>poll()</code> 是 <code>select()</code> 的改进版，<strong>去除了
1024 个文件描述符（fd）的限制</strong>，但仍然需要遍历整个 fd
列表。poll系统调⽤的返回值的含义与select相同。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> {</span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 监听的事件（POLLIN-可读, POLLOUT-可写, POLLERR-错误）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 触发的事件（由内核填充）</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>fds</code>: <code>pollfd</code>
结构体数组，存放要监听的文件描述符及其事件。</li>
<li><code>nfds</code>: <code>fds</code> 数组的大小。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<h4 id="epoll">epoll</h4>
<p><code>epoll</code> 是 Linux 特有的 <strong>高效 I/O 复用</strong>
机制，适用于 <strong>高并发场景（如 1 万个 socket）</strong>。</p>
<p><strong>(1) <code>epoll_create()</code>
创建内核事件表（epoll实例）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>创建内核事件表</strong>，返回 <code>epfd</code>（失败返回
<code>-1</code>）。</li>
</ul>
<p><strong>(2) <code>epoll_ctl()</code> 添加/删除/修改 fd（即管理
fd）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_event 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> {</span><br><span class="line">    <span class="type">uint32_t</span> events;  <span class="comment">// 监听的事件（EPOLLIN, EPOLLOUT 等，还包括EPOLLET-边缘触发模式）</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据（通常存 fd）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>op</code>: 操作类型：
<ul>
<li><code>EPOLL_CTL_ADD</code>：添加 <code>fd</code>。</li>
<li><code>EPOLL_CTL_MOD</code>：修改 <code>fd</code> 监听的事件。</li>
<li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code>。</li>
</ul></li>
<li><code>fd</code>: 需要监听的文件描述符（socket）。</li>
<li><code>event</code>: 监听的事件。</li>
</ul>
<p><strong>(3) <code>epoll_wait()</code> 获取发生事件的 fd</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>events</code>: 用于存储触发事件的 <code>epoll_event</code>
数组。</li>
<li><code>maxevents</code>: <code>events</code> 数组的大小（建议设置为
<code>10</code>~<code>1000</code>）。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<p><strong>(4) LT（水平触发）和ET（边缘触发）模式</strong></p>
<p>LT：只要数据未被读取，<code>epoll_wait()</code>
<strong>一直返回</strong> 可读事件。</p>
<p>ET：<strong>只在状态变化时通知一次</strong>，如果不立即处理，<code>epoll_wait()</code>
<strong>不会再次通知</strong>。</p>
<ol type="1">
<li><strong>LT（Level Triggered，水平触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>：
<ul>
<li>只要文件描述符处于就绪状态（即有数据可读或可写），epoll
就会持续通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll 会在下一次调用 epoll_wait
时再次通知。</li>
</ul></li>
<li>特点:
<ul>
<li>简单易用: 适合初学者或简单的应用场景。</li>
<li>容错性强:
即使应用程序没有一次性处理完所有数据，也不会丢失事件。</li>
<li>可能效率较低: 如果应用程序没有及时处理数据，epoll
会频繁通知，导致不必要的开销。</li>
</ul></li>
<li>适用场景:
<ul>
<li>需要兼容性强的场景（如传统的 select 或 poll 迁移到 epoll）。</li>
<li>对性能要求不高的场景。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>ET（Edge Triggered，边缘触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>:
<ul>
<li>只有当文件描述符的状态发生变化时（如从无数据变为有数据），epoll
才会通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll
不会再次通知，除非文件描述符的状态再次发生变化。</li>
</ul></li>
<li>特点:
<ul>
<li>高效: 减少了不必要的通知，适合高性能场景。</li>
<li>需要一次性处理完数据:
应用程序必须确保在一次事件通知中处理完所有数据，否则可能会丢失后续事件。</li>
<li>复杂性较高: 需要更精细的控制，通常与非阻塞 I/O 结合使用。</li>
</ul></li>
<li>适用场景:
<ul>
<li>高性能服务器（如 Web 服务器、游戏服务器）。</li>
<li>需要处理大量并发连接的场景。</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN; <span class="comment">// LT 模式</span></span><br><span class="line"><span class="comment">// event.events = EPOLLIN | EPOLLET; // ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>EPOLLONESHOT</code> 是 <code>epoll</code>
监听事件的一个<strong>特殊标志</strong>，它的作用是：</p>
<ul>
<li><strong>事件触发一次后，自动从 <code>epoll</code>
监听列表中移除</strong>。</li>
<li><strong>适用于多线程环境</strong>，防止多个线程同时处理同一个
<code>fd</code>。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内核事件表（Kernel Event Table）</strong> 是
<strong><code>epoll</code></strong>
机制的<strong>核心数据结构</strong>，用于<strong>存储和管理需要监听的文件描述符（fd）及其事件</strong>。它由
Linux 内核维护，提供了高效的事件通知机制。</p>
<ol type="1">
<li><p>为什么需要内核事件表？</p>
<p>在 <code>select()</code> 和 <code>poll()</code>
机制中，用户进程<strong>每次调用</strong>都要<strong>传递所有监听的
fd</strong>，导致<strong>大量数据拷贝和遍历</strong>，影响性能。</p>
<p><strong><code>epoll</code> 的改进：</strong></p>
<ol type="1">
<li><p><strong>fd 只需注册一次</strong>，存入
<strong>内核事件表</strong>，后续内核自动管理。</p></li>
<li><p><strong>避免无效 fd 遍历</strong>，只返回<strong>发生事件的
fd</strong>，提高效率（<code>O(1)</code>）。</p></li>
</ol></li>
<li><p>内核事件表的组成</p>
<p>内核事件表可以理解为一个<strong>红黑树 + 就绪列表</strong>：</p>
<ol type="1">
<li><strong>监听 fd 的红黑树</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>所有已注册的 fd</strong>，支持高效的
<strong>增/删/改</strong>。</li>
<li>由 <code>epoll_ctl()</code> 进行管理。</li>
</ul>
<ol start="2" type="1">
<li><strong>事件就绪列表</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>发生事件的 fd</strong>。</li>
<li><code>epoll_wait()</code> 只返回<strong>就绪列表中的
fd</strong>，避免无效遍历，提高性能</li>
</ul></li>
</ol>
</blockquote>
<h2 id="两种事件处理模式">两种事件处理模式</h2>
<h3 id="reactor模式">Reactor模式</h3>
<p>使⽤<strong>同步I/O模型</strong>实现。其主要特点是<strong>由一个或多个
I/O 多路复用器（如
<code>select</code>、<code>poll</code>、<code>epoll</code>）监听事件</strong>，当事件发生时，通知相应的事件处理器进行处理。</p>
<ul>
<li><strong>主线程</strong> 监听 I/O 事件，分发任务。</li>
<li><strong>工作线程</strong> 处理 I/O 和业务逻辑，通常使用线程池。</li>
<li>适用于 <strong>高并发短 I/O 操作</strong>，如 <code>epoll</code>
服务器（Nginx、Redis）。</li>
</ul>
<h3 id="proactor模式">Proactor模式</h3>
<p>使⽤<strong>异步I/O模型</strong>实现。其核心思想是<strong>由操作系统内核完成
I/O
操作后再通知应用程序</strong>，即事件的处理由内核负责，而不是应用程序主动去检查事件状态。</p>
<ul>
<li><strong>主线程</strong> 提交异步 I/O，等待操作系统通知完成。</li>
<li><strong>操作系统</strong> 负责实际 I/O 读取和写入。</li>
<li><strong>工作线程</strong> 只处理完成的 I/O 数据，执行业务逻辑。</li>
<li>适用于 <strong>长时间异步 I/O 操作</strong>，如 Windows IOCP。</li>
</ul>
<h2 id="两种并发模式">两种并发模式</h2>
<h3 id="半同步半异步">半同步/半异步</h3>
<ol type="1">
<li><p>下面这种也叫<strong>半同步/半反应堆</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222231946543.png" alt="image-20250222231946543">
<figcaption aria-hidden="true">image-20250222231946543</figcaption>
</figure>
<p>上图中的异步线程只有⼀个，由主线程来充当，工作线程都是同步线程</p></li>
<li><p>下面是⾼效的<strong>半同步/半异步</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222232510227.png" alt="image-20250222232510227">
<figcaption aria-hidden="true">image-20250222232510227</figcaption>
</figure>
<p>注意这里的主线程只管理<strong>监听socket</strong>，而<strong>连接socket</strong>交给工作线程管理。在这种⾼效的半同步/半异步模式中，每个线程都⼯作在异步模式。所以它并⾮严格意义上的半同步/半异步模式。</p></li>
</ol>
<h3 id="领导者追随者模式">领导者/追随者模式</h3>
<ul>
<li>多个⼯作线程轮流获得事件源集合，轮流监听、分发并处理事件</li>
<li>在任意时间点，程序都仅有⼀个领导者线程，它负责监听I/O事件。</li>
<li>其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者</li>
<li>当前的领导者如果检测到I/O事件，⾸先要从线程池中推选出新的领导者线程，然后(当前领导者)处理I/O事件，新领导者等待新的I/O事件</li>
</ul>
<h2 id="libevent-框架">Libevent 框架</h2>
<p><code>libevent</code> 的核心概念可以通过以下方式理解：</p>
<ul>
<li><strong>事件处理器</strong>：事件处理器负责处理特定类型的事件，它们定义了事件的源（如文件描述符、信号等）和触发条件（如可读、可写、信号到来、定时器到期等）。每个事件处理器都绑定了一个回调函数，事件发生时，回调函数会被调用。</li>
<li><strong>事件多路分发器</strong>：事件分发器负责使用操作系统的 I/O
多路复用机制来监听事件源的状态，并触发相应的回调。它管理和调度所有事件的执行。</li>
<li><strong>事件队列</strong>：事件队列是 <code>libevent</code>
用来存储和调度事件的结构，它保证了事件按照正确的顺序（优先级、时间顺序等）进行调度。事件队列也负责管理
I/O、定时器、信号等类型的事件，并将它们传递给事件分发器进行执行。</li>
</ul>
<p><strong>核心结构</strong></p>
<ul>
<li><code>event_base</code>：事件分发器，管理所有事件。</li>
<li><code>event</code>：事件处理器，表示具体的
I/O、信号、定时器事件。</li>
</ul>
<p><strong>主要流程</strong></p>
<ol type="1">
<li><p><strong>创建事件循环</strong> →
<code>event_base_new()</code></p></li>
<li><p><strong>创建事件</strong> → <code>event_new()</code></p></li>
<li><p><strong>注册事件</strong> → <code>event_add()</code></p>
<blockquote>
<p><code>event_add()</code>
只是将事件添加到事件循环中，并将其注册到事件队列。它告诉
<code>libevent</code> 这个事件（例如 I/O
事件、信号事件）应当被监听和调度，但是它并没有
<strong>直接建立事件源与事件处理器之间的映射关系</strong>。对于信号事件（例如
<code>SIGINT</code>），这时就需要通过内部的映射函数来将信号（如
<code>SIGINT</code>）与对应的事件处理器进行关联。具体而言，<code>evmap_signal_add()</code>
就是用来处理这种信号与事件处理器的映射关系。</p>
</blockquote></li>
<li><p><strong>启动事件循环</strong> →
<code>event_base_dispatch()</code></p></li>
<li><p><strong>触发事件并执行回调</strong></p></li>
<li><p><strong>释放资源</strong> → <code>event_free()</code> /
<code>event_base_free()</code></p></li>
</ol>
<p><strong>事件处理机制</strong></p>
<ul>
<li><strong>I/O 事件</strong>：监听文件描述符的可读/可写状态。</li>
<li><strong>信号事件</strong>：监听系统信号（如
<code>SIGINT</code>）。</li>
<li><strong>定时器事件</strong>：在指定时间后触发回调。</li>
</ul>
<h2 id="多进程编程">多进程编程</h2>
<h3 id="exec与fork">exec与fork</h3>
<ol type="1">
<li><p><code>fork</code> 之后的内存状态</p>
<p>当你调用 <code>fork</code>
时，操作系统会创建一个新的进程（子进程），子进程是父进程的副本。这意味着：</p>
<ul>
<li>子进程会复制父进程的代码段、数据段、堆栈、打开的文件描述符等。</li>
<li><strong>在 <code>fork</code>
的瞬间，父进程和子进程的内存内容是完全相同的</strong>。</li>
</ul>
<p>但是，现代操作系统使用了一种称为 <strong>写时复制（Copy-On-Write,
COW）</strong> 的技术来优化 <code>fork</code> 的性能：</p>
<ul>
<li><strong>写时复制的含义</strong>：<code>fork</code>
之后，父进程和子进程共享同一块物理内存，直到其中一个进程尝试修改内存时，操作系统才会为修改的进程复制一份新的内存页。</li>
<li>这种机制避免了不必要的内存复制，提高了性能。</li>
</ul></li>
<li><p><code>exec</code> 的作用</p>
<p><code>exec</code> 的作用是
<strong>替换当前进程的映像</strong>。具体来说：</p>
<ul>
<li><code>exec</code>
会将当前进程的代码段、数据段、堆栈等全部替换为新程序的内容。</li>
<li>调用 <code>exec</code>
后，当前进程的内存空间会被新程序的内容覆盖。</li>
</ul></li>
<li><p>结合 <code>fork</code> 和 <code>exec</code> 的工作流程</p>
<p>当你在子进程中调用 <code>exec</code> 时，会发生以下事情：</p>
<ol type="1">
<li><strong>子进程的内存被替换</strong>：</li>
</ol>
<ul>
<li><code>exec</code>
会加载新程序的代码和数据到子进程的内存空间中。</li>
<li>由于写时复制的机制，子进程的内存修改不会影响父进程。</li>
</ul>
<ol start="2" type="1">
<li><strong>父进程不受影响</strong>：</li>
</ol>
<ul>
<li>父进程的内存空间保持不变，继续执行原来的代码。</li>
</ul>
<ol start="3" type="1">
<li><strong>子进程执行新程序</strong>：</li>
</ol>
<ul>
<li>子进程从新程序的入口点（通常是 <code>main</code>
函数）开始执行。</li>
</ul></li>
</ol>
<h2 id="多线程编程">多线程编程</h2>
<h3 id="互斥锁">1. 互斥锁</h3>
<p>互斥锁（<code>pthread_mutex_t</code>）是一种用于
<strong>保护共享资源</strong>
的同步机制，它确保同一时刻只有一个线程可以访问共享资源。多个线程如果要访问同一资源，必须先获取该互斥锁，获取锁成功后才能访问资源，访问完毕后释放锁。</p>
<ul>
<li><strong>主要作用</strong>：保护共享资源，防止多个线程同时访问导致数据不一致。</li>
<li><strong>行为</strong>：加锁后，其他线程无法加锁，直到锁被释放。</li>
<li><strong>示例用法</strong>：保证线程安全地访问全局变量、共享数据结构等。</li>
</ul>
<h3 id="信号量">2. 信号量</h3>
<p>信号量（<code>sem_t</code>）是一种计数机制，用于控制多个线程对共享资源的访问。信号量通常用于控制并发的线程数，或者用于线程间的同步。当信号量的值大于
0 时，表示可以继续执行，线程会执行
<code>sem_wait</code>（等待）直到信号量大于 0，然后
<code>sem_post</code>（释放）信号量。</p>
<ul>
<li><strong>主要作用</strong>：控制对共享资源的访问数量或线程间的同步。</li>
<li><strong>行为</strong>：信号量的值可以增加或减少，通常用于实现生产者-消费者模式、控制线程池大小等。</li>
<li><strong>示例用法</strong>：控制线程池中同时运行的线程数，或者协调生产者和消费者之间的同步。</li>
</ul>
<h3 id="条件变量">3. 条件变量</h3>
<p>条件变量（<code>pthread_cond_t</code>）是用于
<strong>线程间协调</strong>
的同步机制，允许线程在某个条件满足时被唤醒。它通常与互斥锁配合使用。当一个线程需要等待某个条件满足时，它会在条件变量上等待，并释放互斥锁。一旦条件满足，另一个线程就会通过条件变量通知（<code>signal</code>
或 <code>broadcast</code>）其他线程继续执行。</p>
<ul>
<li><strong>主要作用</strong>：线程间的协调与同步，常用于“等待某个条件满足”后继续执行。</li>
<li><strong>行为</strong>：线程等待条件变量时会释放互斥锁，直到条件满足时被通知。</li>
<li><strong>示例用法</strong>：线程等待某个资源准备好，或者等待某个状态变更，例如生产者-消费者模式中的条件等待。</li>
</ul>
<blockquote>
<p><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>：</p>
<ul>
<li>该函数会使当前线程进入
<strong>阻塞状态</strong>，并且<strong>自动释放</strong>传入的
<code>mutex</code>，直到满足条件并且 <code>pthread_cond_signal()</code>
或 <code>pthread_cond_broadcast()</code>
被调用时，才会唤醒该线程并重新获取锁。</li>
</ul>
<p><code>pthread_cond_signal()</code>：</p>
<ul>
<li>该函数 <strong>不会</strong> 释放 <code>mutex</code>。它的作用是通知
<strong>至少一个</strong> 等待该条件变量的线程可以继续执行。</li>
</ul>
</blockquote>
<h2 id="线程池">线程池</h2>
<h3 id="pthread_create"><code>pthread_create()</code></h3>
<p>父线程调用 <code>pthread_create()</code>
来创建子线程。在这个过程中，父线程提供一个回调函数（通常称为线程函数），该回调函数定义了子线程的行为。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>:
线程标识符的指针，函数成功后会填充该值，表示新创建的子线程。</li>
<li><code>attr</code>: 用于线程属性的结构体，通常可以为
<code>NULL</code>，表示使用默认属性。</li>
<li><code>start_routine</code>: 子线程执行的函数（线程函数）。</li>
<li><code>arg</code>: 传递给子线程函数的参数。</li>
</ul>
<h3 id="pthread_detach"><code>pthread_detach</code></h3>
<p><code>pthread_detach</code> 是 POSIX
线程库（<code>pthread</code>）中的一个函数，用于<strong>分离线程</strong>，使其在结束时自动释放资源，而不需要
<code>pthread_join()</code> 进行回收。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>：要分离的线程 ID（<code>pthread_t</code>
类型）。</li>
</ul>
<p>返回值</p>
<ul>
<li><strong>成功</strong>：返回 <code>0</code>。</li>
<li>失败：返回错误码（例如 EINVAL或 ESRCH）。
<ul>
<li><code>EINVAL</code>（Invalid
Argument）：线程已经是<strong>分离状态</strong>。</li>
<li><code>ESRCH</code>（No Such Process）：线程 ID
无效，线程不存在。</li>
</ul></li>
</ul>
<blockquote>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 37%">
<col style="width: 12%">
<col style="width: 14%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
<th><strong>回收资源</strong></th>
<th><strong>主线程等待</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>pthread_detach</code></td>
<td>让线程<strong>自动释放</strong>，无需 <code>join</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>长期运行的工作线程</td>
</tr>
<tr class="even">
<td><code>pthread_join</code></td>
<td><strong>阻塞</strong>等待线程执行完，并获取返回值</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>需要获取线程结果</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<ol type="1">
<li><p><strong>构造函数必须私有化</strong>（否则不是单例）</p></li>
<li><p>析构函数根据需求选择：</p>
<ul>
<li>需要防止外部删除 → 私有化 + 自定义销毁逻辑（如 atexit）
<ul>
<li>禁止用户直接销毁对象，通常用于单例模式或对象池。</li>
<li>控制对象的生命周期，只能通过特定的成员函数销毁对象。</li>
</ul></li>
<li>使用 Meyer's Singleton（局部静态变量）→ 可公开析构</li>
</ul></li>
</ol>
</blockquote>
<h3 id="懒汉模式">懒汉模式</h3>
<p>实例在第一次使用时创建</p>
<ul>
<li>在 C++11
及以上版本中，局部静态变量的初始化是线程安全的，可以简化单例模式的实现</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>() {}</span><br><span class="line">    ~<span class="built_in">single</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single&amp; <span class="title">getinstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> single instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="饿汉模式">饿汉模式</h3>
<p>实例在程序启动时创建</p>
<ul>
<li>利用局部静态变量的特性实现线程安全的单例模式。</li>
<li>C++11 及以上版本保证局部静态变量的初始化是线程安全的</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() {}  <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">// 静态成员初始化</span></span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/24/VSCode%20%E5%8A%A0%E8%BD%BD%20.vscode%20%E8%A7%84%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/24/VSCode%20%E5%8A%A0%E8%BD%BD%20.vscode%20%E8%A7%84%E5%88%99/" class="post-title-link" itemprop="url">VSCode加载`.vscode`的规则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-24 23:22:06" itemprop="dateCreated datePublished" datetime="2025-03-24T23:22:06+08:00">2025-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-15 21:23:48" itemprop="dateModified" datetime="2025-05-15T21:23:48+08:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VSCode/" itemprop="url" rel="index"><span itemprop="name">VSCode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>622</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下面是我的文件结构</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">D:\CodeFile\</span><br><span class="line">│── .vscode\                 ← 父目录 `.vscode`</span><br><span class="line">│   ├── settings.json        (影响整个 `CodeFile` 及所有子目录)</span><br><span class="line">│   ├── tasks.json           (VSCode 任务系统会使用这个)</span><br><span class="line">│   ├── launch.json          (VSCode 调试器会使用这个)</span><br><span class="line">│</span><br><span class="line">├── CPP\</span><br><span class="line">│   ├── .vscode\             ← 子目录 `.vscode`（默认不会生效）</span><br><span class="line">│   │   ├── settings.json    (不会生效，除非 VSCode 直接打开 `CPP` 目录)</span><br><span class="line">│   │   ├── tasks.json       (不会生效)</span><br><span class="line">│   │   ├── launch.json      (不会生效)</span><br><span class="line">│   ├── test.cpp</span><br><span class="line">│   └── ...</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>VSCode 的 <code>settings.json</code> 是
<strong>基于当前打开的“工作区”</strong> 来生效的：</p>
<ul>
<li><strong>如果你打开 <code>CodeFile</code> 目录</strong>：
<ul>
<li><code>CodeFile/.vscode/settings.json</code> 生效（影响
<code>CodeFile</code> 下所有子文件夹，包括 <code>CPP</code>）。</li>
<li>你的 <code>"cpp"</code> 运行配置会作用于整个 <code>CodeFile</code>
目录。</li>
<li><strong><code>$workspaceFolder</code> 变为
<code>d:\CodeFile\</code></strong>，Code Runner 解析 <code>$dir</code>
时可能会有路径问题。</li>
</ul></li>
<li><strong>如果你只打开 <code>CPP</code> 目录</strong>：
<ul>
<li><code>CodeFile/.vscode/settings.json</code> 不会生效（因为
<code>.vscode</code> 在 <code>CodeFile</code> 目录下）。</li>
<li>需要 <code>CPP</code> 目录下也有一个
<code>.vscode/settings.json</code> 才能影响 <code>CPP</code> 目录。</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/CS106L/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/04/CS106L/" class="post-title-link" itemprop="url">CS106L-24Autumn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-04 20:57:26" itemprop="dateCreated datePublished" datetime="2025-02-04T20:57:26+08:00">2025-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-11 19:51:54" itemprop="dateModified" datetime="2025-05-11T19:51:54+08:00">2025-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS106L/" itemprop="url" rel="index"><span itemprop="name">CS106L</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>课程官网：http://web.stanford.edu/class/cs106l/</p>
<p>Assignment代码：https://github.com/cs106l/cs106l-assignments/tree/main</p>
<h2 id="stdpair">std::pair</h2>
<p>是一种类模板，它将<strong>两个</strong>异质对象作为一个单元存储，由头文件<code>#include &lt;utility&gt;</code>定义</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T1</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; dozen {<span class="string">"eggs"</span>, <span class="number">12</span>};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="using">using</h2>
<p><code>using</code>关键字可以定义别名，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zeros 是 std::pair&lt;double, double&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Zeros = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution 是 std::pair&lt;bool, Zeros&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Solution = std::pair&lt;<span class="type">bool</span>, Zeros&gt;;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="auto">auto</h2>
<p><code>auto</code>关键字让编译器推断变量的类型，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未简化</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用auto关键字</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="统一初始化c11">统一初始化（C++11）</h2>
<p>使用<code>=</code>或者<code>()</code>进行初始化会默认进行类型转换，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne = <span class="number">12.0</span>; <span class="comment">// numOne是12</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTwo</span><span class="params">(<span class="number">12.0</span>)</span></span>; <span class="comment">// numTwo也是12</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>统一初始化</strong>（<strong>Uniform
Initialization</strong>）是 C++11 引入的一种新的初始化语法，旨在提供一种
<strong>统一且更安全</strong> 的方式来初始化变量和对象。它通过
<strong>大括号 <code>{}</code></strong> 实现初始化。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne{<span class="number">12.0</span>}; <span class="comment">// 编译时报错，不允许类型缩小转换（double-&gt;int）</span></span><br><span class="line"><span class="type">float</span> numTwo{<span class="number">12.0</span>}; <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>
<p>除了基本类型，统一初始化还可用于<code>vector</code>、<code>map</code>等不同容器</p>
<h2 id="结构化绑定c17">结构化绑定（C++17）</h2>
<p>结构化绑定是C++17引入的一种新特性，用于将<strong>元组（<code>std::tuple</code>）</strong>、<strong>结构体</strong>或类似的可解构对象分解为多个独立变量。它提供了一种简便的方法来直接解构数据。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, std::string, std::string&gt; <span class="title">getClassInfo</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string className = <span class="string">"CS106L"</span>;</span><br><span class="line">    std::string buildingName = <span class="string">"Thornton 110"</span>;</span><br><span class="line">    std::string language = <span class="string">"C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> {className, buildingName, language}; <span class="comment">// 这里返回的是tuple对象</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> [className, buildingName, language] = <span class="built_in">getClassInfo</span>(); <span class="comment">// 注意这一行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Come to "</span> &lt;&lt; buildingName &lt;&lt; <span class="string">" and join us for "</span> &lt;&lt; className</span><br><span class="line">              &lt;&lt; <span class="string">" to learn "</span> &lt;&lt; language &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我疑惑的点在于，明明<code>getClassInfo()</code>返回值是tuple对象，为什么最后变成了三个对象？因为第八行的<code>[ ]</code>
是结构化绑定的标准语法，用于<strong>解构</strong>
<code>getClassInfo</code> 返回的
<code>std::tuple</code>，<strong>将元组中的每个元素绑定到独立变量中</strong>。</p>
<h3 id="引用与结构化绑定">引用与结构化绑定</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;nums)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [num1, num2] : nums) { <span class="comment">// 值绑定：产生副本，修改不影响原始数据</span></span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用该函数是无法该改变<code>nums</code>的，应该在<code>auto</code>后面添加<code>&amp;</code>符号</p>
<h2 id="左值和右值">左值和右值</h2>
<h3 id="左值-l-value">左值 l-value</h3>
<p>左值可以放置在<code>=</code>符号的左边或者右边</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是左值，下面两个式子均成立</span></span><br><span class="line"><span class="type">int</span> y = x;</span><br><span class="line">x = <span class="number">344</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="右值-r-value">右值 r-value</h3>
<p>右值只能放置在<code>=</code>符号的右边</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 21 是右值</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">21</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> = y; <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong>：当函数的参数声明为引用时，则不能在调用时使用右值作为参数</p>
<h2 id="stream">stream</h2>
<h3 id="stdcout">std::cout</h3>
<p>输出流在中的字符在被刷新到目标（终端）之前存储在中间缓冲区中</p>
<h3 id="stdstringstream">std::stringstream</h3>
<p>字符串流，用于处理（例如：分割）字符串。 示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// partial Bjarne Quote</span></span><br><span class="line">    std::string initial_quote = “Bjarne Stroustrup C makes it easy to shoot yourself in the foot\n<span class="string">"</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // create a stringstream</span></span><br><span class="line"><span class="string">    std::stringstream ss(initial_quote); // 初始化字符串流，可以用下面两行代替</span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    std::stringstream ss;</span></span><br><span class="line"><span class="string">	ss &lt;&lt; initial_quote;</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // data destinations</span></span><br><span class="line"><span class="string">    std::string first;</span></span><br><span class="line"><span class="string">    std::string last;</span></span><br><span class="line"><span class="string">    std::string language, extracted_quote;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // &gt;&gt;运算符只读取到下一个whitespace(空格，\n，\t)</span></span><br><span class="line"><span class="string">    ss &gt;&gt; first &gt;&gt; last &gt;&gt; language;</span></span><br><span class="line"><span class="string">    // 要让extracted_quote等于"</span>makes it easy to shoot yourself in the foot<span class="string">"需要使用getline()</span></span><br><span class="line"><span class="string">    std::getline(ss, extracted_quote);</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; first &lt;&lt; “ ” &lt;&lt; last &lt;&lt; “ said this: ”&lt;&lt; language &lt;&lt; “ “ &lt;&lt; </span></span><br><span class="line"><span class="string">    extracted_quote &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is, string&amp; str, <span class="type">char</span> delim)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>读取输入流<code>is</code>，直到<code>delim</code>字符（默认是<code>\n</code>），并将其存储在某个缓冲区（变量）<code>str</code>中</p>
</blockquote>
<h3 id="stdflush">std::flush</h3>
<p>用于刷新<code>stream</code>流，将缓冲区中的数据<strong>立即</strong>发送到控制台（终端）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Long operation in progress: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; std::flush;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Operation completed!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 每隔一秒输出一个数字</span></span><br></pre></td></tr></tbody></table></figure>
<p>若上述代码不加<code>std::flush</code>，那么输出会在五秒后全部<strong>一次性显示</strong>。</p>
<p><code>std::cout</code>通常是行缓冲的，所以<code>std::endl</code>也会使得<code>stream</code>进行刷新，每次循环都会输出一个数字，但是这种行为使得运行效率低下，所以可以将<code>std::endl</code>换成<code>\n</code>，这样当缓冲区满或者循环结束时才会一次性输出（注意要提前声明<code>std::ios::sync_with_stdio(false);</code>）。</p>
<h3 id="stdofstream">std::ofstream</h3>
<p>Output File Stream，将数据写入文件。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">/// associating file on construction</span></span><br><span class="line">	<span class="function">std::ofstream <span class="title">ofs</span><span class="params">(“hello.txt”)</span></span>; <span class="comment">// 等价于下面两行</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::ofstream ofs; </span></span><br><span class="line"><span class="comment">    ofs.open(“hello.txt”);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (ofs.<span class="built_in">is_open</span>()) {  <span class="comment">// 检查文件是否已打开，如果已打开，则尝试向其写入字符串 </span></span><br><span class="line">		ofs &lt;&lt; “Hello CS106L!” &lt;&lt; ‘\n’; </span><br><span class="line">	}</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	ofs &lt;&lt; “<span class="keyword">this</span> will <span class="keyword">not</span> get written”; <span class="comment">// 由于文件流已关闭，会导致写入失败</span></span><br><span class="line">    </span><br><span class="line">	ofs.<span class="built_in">open</span>(“hello.txt”);</span><br><span class="line">	ofs &lt;&lt; “<span class="keyword">this</span> will though! It’s open again”;  <span class="comment">// 写入成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="stdcin">std::cin</h3>
<p><code>std::cin</code>也会先把字符存入缓冲区，然后从缓冲区中读取内容。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; a;  <span class="comment">// 输入字符，存入缓冲区，然后从缓冲区读取字符到变量a</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>std::cin</code>遇到whitespace则会停止存入缓冲区</p>
<p>Whitespace in C++ includes:</p>
<ul>
<li>“ ” – a literal space（空格）</li>
<li><code>\n</code> character</li>
<li><code>\t</code> character</li>
</ul>
<h2 id="stl">STL</h2>
<p>Standard Template Library</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250105162916455.png" alt="image-20250105162916455">
<figcaption aria-hidden="true">image-20250105162916455</figcaption>
</figure>
<h3 id="sequence-containers">Sequence Containers</h3>
<p>存放线性序列</p>
<h4 id="stdvector">std::vector</h4>
<p>使用 range-based for (适用于所有可迭代容器)遍历 vector</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : vec) {  <span class="comment">// for (const auto&amp; elem : v) 可以节省副本的开销</span></span><br><span class="line">	std::cout &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>push_back()</code>： 会导致容器大小 <code>size()</code>
增加，同时如果没有足够空间，容量 <code>capacity()</code> 也随着增加</li>
<li><code>pop_back()</code>
：移除容器中最后一个元素，并将容器的<code>size()</code>减小，<strong>容量</strong>
(<code>capacity()</code>) 保持不变。</li>
</ul>
<h4 id="stddeque">std::deque</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250107220918767.png" alt="image-20250107220918767">
<figcaption aria-hidden="true">image-20250107220918767</figcaption>
</figure>
<p><code>std::deque</code> 的底层实现结合了 <strong>分段内存</strong> 和
<strong>指针数组</strong> 的设计：</p>
<ol type="1">
<li><strong>分段存储</strong>：
<ul>
<li>与 <code>std::vector</code> 不同，<code>std::deque</code>
不使用一块连续的大内存块，而是将数据分为多个固定大小的内存块（称为缓冲区或
block）。</li>
<li>每个缓冲区的大小通常是固定的（具体大小依赖于实现，通常为 512
字节或更多）。</li>
</ul></li>
<li><strong>指针数组（Map Array）</strong>：
<ul>
<li><code>std::deque</code> 使用一个指针数组（称为 map
或控制块）来管理这些缓冲区。</li>
<li>这个指针数组存储了每个缓冲区的起始地址，并负责定位实际数据的位置。</li>
</ul></li>
</ol>
<h4 id="stdlist">std::list</h4>
<p><code>std::list</code> 是 C++ 标准库中的双向链表（Doubly Linked
List）容器，定义在 <code>&lt;list&gt;</code> 头文件中。与
<code>std::vector</code> 不同，<code>std::list</code>
允许高效地在序列的任意位置进行插入和删除操作，但不支持随机访问。</p>
<ul>
<li><strong>双向链表结构</strong>：每个元素都有前驱和后继指针。</li>
<li><strong>动态大小</strong>：不需要预分配内存，适用于频繁的插入/删除操作。</li>
<li><strong>高效的插入/删除</strong>：<code>O(1)</code>
复杂度，不涉及大规模元素移动。</li>
<li><strong>不支持随机访问</strong>：不能通过 <code>operator[]</code>
访问元素，必须使用迭代器。</li>
</ul>
<h3 id="associative-containers">Associative Containers</h3>
<p>通过 key 来组织元素</p>
<h4 id="stdmap">std::map</h4>
<ul>
<li><p>等价于python中的字典</p></li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map {</span><br><span class="line">  { <span class="string">"Chris"</span>, <span class="number">2</span> },</span><br><span class="line">  { <span class="string">"CS106L"</span>, <span class="number">42</span> },</span><br><span class="line">  { <span class="string">"Keith"</span>, <span class="number">14</span> },</span><br><span class="line">  { <span class="string">"Nick"</span>, <span class="number">51</span> },</span><br><span class="line">  { <span class="string">"Sean"</span>, <span class="number">35</span> },</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> sean = map[<span class="string">"Sean"</span>]; <span class="comment">// 35</span></span><br><span class="line">map[<span class="string">"Chris"</span>] = <span class="number">31</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>std::map</code> 中，每个元素是一个 <code>std::pair</code>
对象，其中包含 <code>first</code> 和 <code>second</code>
两个成员。<code>first</code> 是键（key），<code>second</code>
是值（value）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv : map) {</span><br><span class="line">  <span class="comment">// kv is a std::pair&lt;const std::string, int&gt;</span></span><br><span class="line">  std::string key = kv.first;</span><br><span class="line">  <span class="type">int</span> value = kv.second;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过结构化绑定遍历map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) {</span><br><span class="line">  <span class="comment">// key has type const std::string&amp;</span></span><br><span class="line">  <span class="comment">// value has type const int&amp;</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>底层是通过 <strong>红黑树</strong>（Red-Black
Tree）来实现的。因此<code>std::map&lt;K, V&gt;</code>要求<code>K</code>能够进行<code>operator&lt;</code>操作（比大小，判断进入红黑树的左右哪个分支）</p></li>
</ul>
<h4 id="stdunordered_map">std::unordered_map</h4>
<ul>
<li><p>与 <code>std::map</code> 不同，<code>std::unordered_map</code>
是基于 <strong>哈希表（Hash Table）</strong> 实现的。</p></li>
<li><p>获取负载因子，设置最大负载因子，若超过则重新哈希</p>
<p>负载因子 = 元素个数（size）/ 桶的数量（bucket count）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="type">double</span> lf = map.<span class="built_in">load_factor</span>(); <span class="comment">// Get current load factor</span></span><br><span class="line">map.<span class="built_in">max_load_factor</span>(<span class="number">2.0</span>); <span class="comment">// Set the max load factor</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="stdset">std::set</h4>
<ul>
<li>集合中的每个元素都是唯一的</li>
<li><code>std::set</code> 的实现通常也是基于
<strong>红黑树</strong></li>
</ul>
<h4 id="stdunordered_set">std::unordered_set</h4>
<ul>
<li><code>std::unordered_set</code> 是基于 <strong>哈希表（Hash
Table）</strong> 实现的</li>
<li>如果你不需要排序，并且希望实现快速的查找和插入操作，<code>std::unordered_map</code>
是一个很好的选择。</li>
</ul>
<h3 id="iterator">Iterator</h3>
<p>track where we are in a container（类似于索引）</p>
<ul>
<li><p><code>container.begin()</code>指向容器的第一个元素</p></li>
<li><p><code>container.end()</code>指向容器末端（但不指向末尾元素）</p></li>
<li><p>当容器为空时，<code>container.begin() == container.end()</code></p></li>
<li><p>遍历容器</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两段代码是等价的</span></span><br><span class="line"><span class="keyword">auto</span> b = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> e = s.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = b; it != e; ++it)  <span class="comment">// 这里使用 ++it 可以减少一次不必要的拷贝</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">auto</span> elem = *it;</span><br><span class="line">     std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// range-based for </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : s) </span><br><span class="line">{</span><br><span class="line">	std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="继承inheritance">继承（Inheritance）</h2>
<p>多态性</p>
<h3 id="纯虚函数">纯虚函数</h3>
<p>动态多态，它在基类中被实例化，但在子类中被覆盖</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="虚函数">虚函数</h3>
<p>https://hxt616.github.io/2024/10/26/CS106B/</p>
<h3 id="虚基类">虚基类</h3>
<p>解决菱形继承问题，详见<a target="_blank" rel="noopener" href="https://hxt616.github.io/2024/10/26/CS106B/">CS106B</a></p>
<h2 id="模板类template-classes">模板类（Template Classes）</h2>
<p>模板的声明和实现一般在同一个文件中</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 'typename' 可替换成 'class'</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 在类外定义函数需要进行模板声明</span></span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> i) { <span class="comment">// 注意这里类名后面要添加 &lt;T&gt;</span></span><br><span class="line"> <span class="comment">// Implementation...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="const">const</h2>
<p><code>const</code>
可以加在函数声明的前面或者后面，这两种用法的含义是不同的。主要有两种常见的情况：</p>
<h3 id="const-加在函数返回类型前面"><code>const</code>
加在函数返回类型前面</h3>
<p>这是指 <strong>返回值是 <code>const</code>
类型</strong>，意味着该返回值是不可修改的。</p>
<h4 id="示例">示例：</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个例子中，<code>const</code> 加在 <code>int</code>
前面，表示函数返回的是一个 <code>const int</code>。也就是说，返回的值是
<code>const</code> 类型，调用者不能修改它。</li>
<li>注意：这种 <code>const</code>
修饰符适用于返回值的类型，并不影响函数本身的行为。</li>
</ul>
<h4 id="使用场景">使用场景：</h4>
<ul>
<li>当函数返回一个对象时，如果返回的对象不希望被修改，可以加上
<code>const</code>。</li>
<li>例如，在返回一个指针、引用或常量时，<code>const</code>
会确保返回的对象不能被修改。</li>
</ul>
<h3 id="const-加在成员函数的后面"><code>const</code>
加在成员函数的后面</h3>
<p>这是指 <strong>成员函数是 <code>const</code>
成员函数</strong>，意味着该函数不能修改类的成员变量。</p>
<h4 id="示例-1">示例：</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>{</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个例子中，<code>getValue()</code> 后面的 <code>const</code>
表示该成员函数是 <strong><code>const</code>
成员函数</strong>，即它不会修改类的任何成员变量（即 <code>this</code>
指针指向的对象不会发生变化）。</li>
</ul>
<h4 id="关键点">关键点：</h4>
<ul>
<li><code>const</code> 加在成员函数的后面是为了声明这个成员函数是
<strong>只读的</strong>，即它不会修改对象的状态。</li>
<li>在 C++ 中，<strong><code>const</code> 成员函数只能调用其他
<code>const</code> 成员函数</strong>，不能修改成员变量，不能调用非
<code>const</code> 成员函数，也不能修改 <code>this</code>
指针指向的对象。</li>
</ul>
<h4 id="使用场景-1">使用场景：</h4>
<ul>
<li>当你希望保证某个成员函数不会修改类的状态时，应该将其声明为
<code>const</code> 成员函数。</li>
<li>例如，在查询类状态的函数（如获取值、大小、是否为空等）中，应该将其声明为
<code>const</code>，以便它们能够在 <code>const</code> 对象上调用。</li>
</ul>
<blockquote>
<p><strong>1. 指向常量的指针 (Pointer to const)</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;  <span class="comment">// 或等价的 int const* ptr;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>不能修改指向的对象</strong>：不能通过这个指针修改它指向的值</li>
<li><strong>可以修改指针本身</strong>：可以让指针指向其他地址</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 正确：可以修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>2. 常量指针 (Const pointer)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>不能修改指针本身</strong>：指针不能指向其他地址</li>
<li><strong>可以修改指向的对象</strong>：可以通过指针修改它指向的值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 正确：可以修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>3. 指向常量的常量指针 (Const pointer to const)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>既不能修改指针本身</strong>：不能指向其他地址</li>
<li><strong>也不能修改指向的对象</strong>：不能通过指针修改值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="const_cast不常用"><code>const_cast</code>（不常用）</h3>
<p><code>const_cast</code> 的常见用法：</p>
<ol type="1">
<li><p><strong>去除 <code>const</code> 限定符</strong>： 通过
<code>const_cast</code>，可以将指向 <code>const</code>
对象的指针或引用转换为指向非 <code>const</code> 对象的指针或引用。</p>
<p>这种操作的危险性在于，如果你通过 <code>const_cast</code> 去除
<code>const</code>
限定符并尝试修改对象的内容，而对象本身确实是常量（例如，存储在
<code>const</code>
内存区域），这将导致未定义行为（UB）。因此，<strong>只有在你确定对象可以安全修改时</strong>，才应该去除
<code>const</code>。</p></li>
</ol>
<h2 id="模板函数template-functions">模板函数（Template Functions）</h2>
<ol type="1">
<li><p>示例：取两个变量的较小值</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(<span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式实例化，让编译器判断类型</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">7</span>, <span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>可变参数模板函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a)</span> </span>{ <span class="comment">// 一定要加上，因为下面的模板是递归模板，需要一个终止条件</span></span><br><span class="line">    <span class="keyword">return</span> a;  <span class="comment">// 基本情况：只有一个元素时，返回该元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, Args... args)</span> </span>{</span><br><span class="line">    T temp = <span class="built_in">min</span>(args...);  <span class="comment">// 递归调用：比较剩下的参数</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; temp ? a : temp;  <span class="comment">// 返回较小的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>find</code>函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是不同容器对应的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It begin, It end, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin; it != end; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> end;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法，直接将容器作为参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span><span class="params">(<span class="type">const</span> Container&amp; c, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">  <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> end;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="模板元编程template-metaprogramming">模板元编程（Template
Metaprogramming）</h2>
<p>TMP，它允许程序在编译阶段进行复杂的计算和类型推导，而不需要在运行时进行处理</p>
<ol type="1">
<li><p>示例：通过模板递归计算阶乘，可以在<strong>编译期</strong>执行计算</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归模板计算阶乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;  <span class="comment">// 递归调用</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当 N 为 0 时，阶乘为 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出: 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在模板中使用 <strong>predicates</strong>（谓词）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It first, It last, Pred pred)</span> </span>{ <span class="comment">// 这里的pred其实是一个返回布尔值的函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = first; it != last; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*it)) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="lambda">Lambda</h2>
<p>详见
https://hxt616.github.io/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</p>
<h2 id="functor">Functor</h2>
<p><strong>functor</strong>（仿函数）是一个行为类似函数的对象，具体来说是
<strong>重载了函数调用运算符 <code>()</code>
的类或结构体的实例</strong>。通过这种方式，类或结构体的对象可以像普通函数一样被调用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Called with "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::greater {</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">std::greater&lt;<span class="type">int</span>&gt; g;</span><br><span class="line"><span class="built_in">g</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回值是false</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>当使用lambda表达式时，会生成对应的functor</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) { <span class="keyword">return</span> x * x; };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会生成类似以下的类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaAnonymous</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="algorithm-库"><code>&lt;algorithm&gt;</code> 库</h2>
<p>该库是模板函数的集合</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250123004800250.png" alt="image-20250123004800250">
<figcaption aria-hidden="true">image-20250123004800250</figcaption>
</figure>
<h2 id="操作符重载">操作符重载</h2>
<p>Operator Overloading，自定义操作符的行为</p>
<ul>
<li><p>不能被重载的运算符：<code>::   ?   .   .*   sizeof()   typeid()   cast()</code></p></li>
<li><p>两种重载方式：</p>
<ol type="1">
<li><p>成员重载：在类内对操作符进行重载，调用时通过<code>b.operator&lt;(rhs)</code>（b是对象）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Obj::<span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; rhs) <span class="type">const</span> {...}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>非成员重载：在类外进行重载，同时将两个操作对象作为参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; lhs, <span class="type">const</span> Obj&amp; rhs);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>非成员重载可以通过<strong>友元</strong>实现，这样就能访问私有变量</p>
</blockquote></li>
</ol></li>
</ul>
<h2 id="特殊成员函数">特殊成员函数</h2>
<p>Special Member Functions
(SMFs)，特殊成员函数是类（或结构）成员函数，在某些情况下，编译器会自动为你生成。
包括<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170#default_constructors">默认构造函数</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/destructors-cpp?view=msvc-170">析构函数</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/copy-constructors-and-copy-assignment-operators-cpp?view=msvc-170">复制构造函数和复制赋值运算符</a>，以及<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符</a>。</p>
<ul>
<li><p>Default constructor: T()</p></li>
<li><p>Destructor: ~T()</p></li>
<li><p>Copy constructor: T(const T&amp;)</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo = widgetOne;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容（深拷贝），而不是仅仅赋值指针，否则会引发
浅拷贝（shallow copy） 问题</strong></p>
</blockquote></li>
<li><p>Copy assignment operator: T&amp; operator=(const T&amp;)
（操作对象是<strong>已经存在的对象</strong>，注意与上面函数区别）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo;</span><br><span class="line">widgetOne = widgetTwo</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Move constructor: T(T&amp;&amp;)</p>
<p>移动构造函数的作用是通过<strong>转移资源</strong>来构造一个新对象，而不是深拷贝资源，这样就可以提高空间利用率</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) {</span><br><span class="line">    other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Move Constructor called"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Move assignment operator: T&amp; operator=(T&amp;&amp;)</p>
<p>移动赋值运算符的作用是将一个对象的资源转移到另一个<strong>已经存在</strong>的对象中。它在执行资源转移的同时，释放目标对象的已有资源以防止内存泄漏。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) { <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">delete</span> data;      <span class="comment">// 释放已有资源</span></span><br><span class="line">        data = other.data; <span class="comment">// 转移资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Move Assignment Operator called"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// 调用构造函数</span></span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 触发 移动赋值运算符</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="move-semantics移动语义">Move Semantics（移动语义）</h2>
<p>涉及到了左值右值，下面没有详细展开，主要介绍<code>std::move</code>函数。</p>
<p>移动构造函数、移动赋值运算符均属于该知识点，当要触发这两个函数时，需要用到<code>std::move</code>，例如上面的例子</p>
<h3 id="stdmove">std::move</h3>
<h4 id="定义">定义</h4>
<ul>
<li><code>std::move</code>
是一个标准库函数，用于将左值显式地转为右值引用，从而触发移动语义。</li>
<li>注意：<code>std::move</code>
并不移动对象，而是允许对象的资源被移动。</li>
</ul>
<h4 id="语法">语法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T&amp;&amp; <span class="title">std::move</span><span class="params">(T&amp; t)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="示例-2">示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">"Hello"</span>;</span><br><span class="line">std::string movedStr = std::<span class="built_in">move</span>(str); <span class="comment">// 触发移动构造函数</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="stdoptional">std::optional</h2>
<p><code>std::optional</code> 是 C++17
引入的一个工具类，用来表示一个值可能存在也可能不存在的情形。它提供了一种优雅的方式来处理可能为空的值，而不需要依赖额外的布尔标志或使用指针。</p>
<h3 id="主要特点"><strong>主要特点</strong></h3>
<ol type="1">
<li><strong>值的可选性：</strong>
<ul>
<li>一个 <code>std::optional</code>
对象可以包含一个值，也可以不包含值（即处于 "empty" 状态）。</li>
<li>适合用来表示“可有可无”的数据。</li>
</ul></li>
<li><strong>避免空指针：</strong>
<ul>
<li>比如函数可能返回一个值，也可能不返回值，用
<code>std::optional</code> 替代返回指针避免空指针引发的错误。</li>
</ul></li>
<li><strong>强类型保障：</strong>
<ul>
<li>提供比返回 <code>nullptr</code> 或特殊标志（例如 <code>-1</code> 或
<code>0</code>）更安全的方式，确保程序的行为更加明确。</li>
</ul></li>
</ol>
<h3 id="使用场景-2"><strong>使用场景</strong></h3>
<ol type="1">
<li><p><strong>函数返回值</strong> 当函数不总是能返回有效值时，用
<code>std::optional</code> 表示返回值的可选性。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">findNameById</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 无值的情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">findNameById</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Found: "</span> &lt;&lt; *name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Name not found.\n"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>替代布尔标志：</strong>
用于标志是否存在值，避免额外的布尔变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> {</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Result <span class="title">compute</span><span class="params">(<span class="type">bool</span> flag)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> Result{<span class="number">42</span>};</span><br><span class="line">    <span class="keyword">return</span> Result{std::<span class="literal">nullopt</span>};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>临时对象的状态管理：</strong>
表示某些临时值是否有效，比如缓存结果。</p></li>
</ol>
<blockquote>
<p>注意<code>nullptr</code>和<code>std::nullopt</code>区别</p>
<ul>
<li><code>nullptr</code>：专门用来表示指针不指向任何对象。它可以隐式地转换为任意指针类型，例如
<code>int*</code>, <code>char*</code>, <code>void*</code> 等。</li>
<li><code>std::nullopt</code>：它是 C++17 中引入的
<code>std::optional</code> 的特殊值，用来表示一个
<code>std::optional</code>
对象不包含任何值（为空的状态）。它可以隐式地用于任何
<code>std::optional&lt;T&gt;</code> 类型，用于初始化或重置
<code>optional</code>。</li>
</ul>
</blockquote>
<h2 id="raii">RAII</h2>
<p>RAII，全称为 <strong>资源获取即初始化</strong>（Resource Acquisition
Is Initialization），是一种 C++ 的重要设计理念。RAII
的核心是将资源（如内存、文件、网络连接、锁等）的管理与对象的生命周期绑定。具体来说：</p>
<ul>
<li><strong>在对象构造时获取资源</strong>，确保资源在对象的整个生命周期内可用。</li>
<li><strong>在对象析构时释放资源</strong>，自动清理以防资源泄漏。</li>
</ul>
<p>这种方式可以有效地避免资源泄露问题，简化资源管理。<strong>常见应用场景</strong>：</p>
<ol type="1">
<li><p><strong>智能指针：</strong></p>
<ul>
<li><code>std::unique_ptr</code>, <code>std::shared_ptr</code>
等智能指针利用 RAII 管理动态内存。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 构造时分配内存</span></span><br><span class="line">    <span class="comment">// 无需手动释放内存</span></span><br><span class="line">} <span class="comment">// 离开作用域时，ptr 自动释放内存</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>文件管理：</strong></p>
<ul>
<li>使用 RAII 类管理文件资源，避免文件未关闭的问题。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToFile</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>; <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line">    file &lt;&lt; <span class="string">"Hello, RAII!"</span>;</span><br><span class="line">} <span class="comment">// 离开作用域时，file 自动关闭</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>锁管理：</strong></p>
<ul>
<li>使用 RAII 类如 <code>std::lock_guard</code>
管理线程同步中的锁。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">criticalSection</span><span class="params">()</span> </span>{</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">} <span class="comment">// 离开作用域时，lock_guard 自动解锁</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="智能指针">智能指针</h2>
<p>Smart Pointers</p>
<h3 id="stdunique_ptr">1.
<strong><code>std::unique_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 独占所有权。一个对象只能由一个
<code>std::unique_ptr</code> 所管理。</li>
<li><strong>主要用途</strong>:
用于明确对象所有权的场景，比如局部变量的资源管理。</li>
<li><strong>自动释放</strong>: 离开作用域时自动释放所管理的对象。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uniquePtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 推荐使用 std::make_unique</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能复制，以下代码会报错</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以转移所有权</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"ptr is now empty after move."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>更轻量化，效率最高。</li>
<li>避免重复释放同一个对象的问题。</li>
<li>使用场景清晰，适合独占资源。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不能共享所有权（即多个指针管理同一个资源）。</li>
</ul>
<h3 id="stdshared_ptr">2.
<strong><code>std::shared_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 共享所有权。多个 <code>std::shared_ptr</code>
可以共同管理同一个对象，直到最后一个 <code>std::shared_ptr</code>
被销毁时对象才会释放。</li>
<li><strong>主要用途</strong>:
用于需要多个指针共享资源的场景，比如资源共享和并发场景。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharedPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>); <span class="comment">// 推荐使用 std::make_shared</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>(); <span class="comment">// ptr1 不再管理资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count after reset: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>方便在需要共享资源的场景中使用。</li>
<li>自动进行引用计数，最后一个指针销毁时释放资源。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有一定的性能开销（引用计数管理）。</li>
<li>如果存在循环引用，可能导致内存泄漏（需配合
<code>std::weak_ptr</code> 解决）。</li>
</ul>
<h3 id="stdweak_ptr">3. <strong><code>std::weak_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 弱引用。用于解决 <code>std::shared_ptr</code>
循环引用的问题。</li>
<li><strong>主要用途</strong>: 辅助 <code>std::shared_ptr</code>
使用，不增加引用计数，只能观察（弱引用）资源。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">weakPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// 不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) { <span class="comment">// 检查资源是否仍然存在</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>用于解决 <code>std::shared_ptr</code> 循环引用问题。</li>
<li>允许访问资源但不拥有资源，不影响引用计数。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>只能与 <code>std::shared_ptr</code> 搭配使用，单独意义不大。</li>
</ul>
<h2 id="makefiles-和-cmake">Makefiles 和 CMake</h2>
<h3 id="makefile"><strong>1. Makefile</strong></h3>
<ul>
<li><code>Makefile</code> 是用于 <code>make</code>
工具的配置文件，它定义了一系列规则，告诉编译器如何生成目标文件。</li>
<li>本质上是手写的构建规则，直接调用编译器命令。</li>
</ul>
<h3 id="cmake"><strong>2. CMake</strong></h3>
<p>需要编写编写 <code>CMakeLists.txt</code></p>
<ul>
<li><code>CMake</code>
是一种跨平台的构建系统生成工具，它可以生成不同平台上的项目文件（如
<code>Makefile</code>、Visual Studio 的项目文件）。</li>
<li><code>CMake</code> 本质上是为大型项目提供了高层次的抽象。</li>
</ul>
<h2 id="assignment">Assignment</h2>
<p>参考资料：https://www.zhihu.com/column/c_1839339107211419649</p>
<h3 id="assignment-1">Assignment 1</h3>
<ul>
<li><p>在迭代 <code>std::vector</code>
时，不建议直接修改当前遍历的容器（如删除元素）。一种常见的做法是使用
<strong>后向迭代</strong> 或者
<strong>标记删除</strong>，然后在迭代完成后删除元素。</p>
<p>但是这里不能使用反向迭代，会导致文件内容与正确文件内容不匹配（倒序，从最后一行往第一行读取内容），所以这里定义了一个中间变量存放待删除的元素。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Course&gt; tmp; <span class="comment">// 存放待删除的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c: all_courses) {</span><br><span class="line">    <span class="keyword">if</span>(c.quarter != <span class="string">"null"</span>) {</span><br><span class="line">        ofile &lt;&lt; c.title &lt;&lt; <span class="string">","</span> &lt;&lt; c.number_of_units &lt;&lt; <span class="string">","</span> &lt;&lt; c.quarter &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> t: tmp) {</span><br><span class="line">    <span class="built_in">delete_elem_from_vector</span>(all_courses, t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>创建了一个临时容器
<code>tmp</code>，并在遍历过程中把要删除的元素放入其中。遍历完后，再通过
<code>delete_elem_from_vector</code> 从 <code>all_courses</code>
中删除这些元素。这样可以避免在原容器上进行删除操作时改变容器的大小或顺序，从而避免迭代器失效的问题。</p>
</blockquote></li>
</ul>
<h3 id="assignment-2">Assignment 2</h3>
<p>需要注意作业要求获取 first name 和 last name
的两个首字母，两个都必须参与比较，可以单独写一个函数记录两个字母，然后进行比较</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">get_initials</span><span class="params">(std::string name)</span> </span>{</span><br><span class="line">  <span class="comment">// 初始化结果字符串</span></span><br><span class="line">    std::string res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个字母</span></span><br><span class="line">    res += name[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找空格位置</span></span><br><span class="line">    <span class="type">size_t</span> space_pos = name.<span class="built_in">find</span>(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了空格，获取空格后第一个字母</span></span><br><span class="line">    <span class="keyword">if</span> (space_pos != std::string::npos &amp;&amp; space_pos + <span class="number">1</span> &lt; name.<span class="built_in">size</span>()) {</span><br><span class="line">        res += name[space_pos + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::queue&lt;<span class="type">const</span> std::string*&gt; <span class="title">find_matches</span><span class="params">(std::string name, std::unordered_set&lt;std::string&gt;&amp; students)</span> </span>{</span><br><span class="line">  <span class="comment">// STUDENT <span class="doctag">TODO:</span> Implement this function.</span></span><br><span class="line">  std::queue&lt;<span class="type">const</span> std::string*&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = students.<span class="built_in">begin</span>(); it != students.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get_initials</span>(*it) == <span class="built_in">get_initials</span>(kYourName))</span><br><span class="line">      q.<span class="built_in">push</span>(&amp;(*it)); <span class="comment">// 先解引用it得到字符串，然后再获取该字符串的地址</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="assignment-3">Assignment 3</h3>
<p>CastXML环境有问题，无法生成xml文件导致无法测评</p>
<h3 id="assignment-4">Assignment 4</h3>
<p>主要用到下面这几个函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">min_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line">std::<span class="built_in">accumulate</span>(InputIt first, InputIt last, T init); <span class="comment">// 这里的init是初始值</span></span><br><span class="line">std::<span class="built_in">max_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">transform</span>( InputIt first1, InputIt last1, OutputIt d_first, UnaryOp unary_op ); <span class="comment">// 第四个参数可用lambda表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//std::remove_if 它会 重新排列 指定范围内的元素，使所有 不符合 给定条件的元素排在前面，并返回一个新的 尾部迭代器，指向重新排列后的有效范围的末尾。</span></span><br><span class="line">std::<span class="built_in">remove_if</span>(ForwardIt first, ForwardIt last, UnaryPred p); <span class="comment">// p函数的返回值一般是布尔值</span></span><br><span class="line"></span><br><span class="line">std::erase <span class="comment">// 能够真正删除元素，可与remove_if配合使用</span></span><br></pre></td></tr></tbody></table></figure>
<p>还需注意<code>const</code>的使用，有些函数的参数不能使用<code>const</code>类型变量。</p>
<blockquote>
<p>如果出现以下报错，则在对应的文件打开函数中添加编码参数，例如：<code>open(file_path, "r", encoding="utf-8")</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 181, in &lt;module&gt;</span><br><span class="line">    add_matcher_tests(grader)</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 138, in add_matcher_tests     </span><br><span class="line">    student_methods = parse_methods(MAIN_CPP_PATH)</span><br><span class="line">                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 97, in parse_methods</span><br><span class="line">    content = file.read()</span><br><span class="line">              ^^^^^^^^^^^</span><br><span class="line">UnicodeDecodeError: 'gbk' codec can't decode byte 0xa8 in position 693: illegal multibyte sequence</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="assignment-5">Assignment 5</h3>
<p>第二部分中注意：对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容，而不是仅仅赋值指针，否则会引发
浅拷贝（shallow copy） 问题</p>
<h3 id="assignment-6">Assignment 6</h3>
<p>考察的知识点是<code>std::optional</code>，可参考上面的笔记</p>
<h3 id="assignment-7">Assignment 7</h3>
<p><strong>需要使用 <code>std::move</code>
来显式触发移动构造函数和移动赋值运算符</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发移动构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">MyClass obj2 = std::<span class="built_in">move</span>(obj1); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发移动赋值运算符</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1);  </span><br></pre></td></tr></tbody></table></figure>
<p>这里还需要使用反向迭代器（reverse_iterator）来实现倒序遍历（逆序遍历），<code>rbegin()</code>指向容器的最后一个元素，<code>rend()</code>
指向容器的前一个位置（即 <code>begin() - 1</code>），下面是相关代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = values.<span class="built_in">rbegin</span>(); i != values.<span class="built_in">rend</span>(); ++i) {</span><br><span class="line">    unique_ptr&lt;ListNode&lt;T&gt;&gt; node = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;T&gt;(*i);</span><br><span class="line">    node-&gt;next = std::<span class="built_in">move</span>(head);</span><br><span class="line">    head = std::<span class="built_in">move</span>(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">gdb在WSL1中报错解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-01-04 00:00:00 / 修改时间：16:58:12" itemprop="dateCreated datePublished" datetime="2025-01-04T00:00:00+08:00">2025-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WSL/" itemprop="url" rel="index"><span itemprop="name">WSL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>550</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我的环境如下：</p>
<figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hxt&gt; wsl <span class="literal">--list</span> <span class="literal">--verbose</span></span><br><span class="line">  NAME      STATE           VERSION</span><br><span class="line">* Ubuntu    Stopped         <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>我想要在该环境下调试一个cpp文件，但是报错：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x1224: file cin_2.cpp, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/hxt/test_code/cin_2</span><br><span class="line">warning: opening /proc/PID/mem file for lwp 399.399 failed: No such file or directory (2)</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint 1.</span><br><span class="line">Cannot access memory at address 0x8001224</span><br></pre></td></tr></tbody></table></figure>
<p>经过搜索发现WSL1（Windows Subsystem for
Linux）中没有对<code>/proc/PID/mem</code>提供支持，导致GDB在尝试访问该文件时出错。老版本的GDB在找不到<code>/proc/PID/mem</code>文件时会使用
ptrace，而新版本的GDB则禁用了这种机制。这里是<a target="_blank" rel="noopener" href="https://github.com/microsoft/WSL/issues/8356">相关讨论和不同解决方案</a>。</p>
<p><strong>我的解决方案</strong>是将WSL1升级到WSL2，使用命令<code>wsl --set-version &lt;发行版名称&gt; 2</code>，问题解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">内存映射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-17T00:00:00+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-16 22:40:59" itemprop="dateModified" datetime="2025-05-16T22:40:59+08:00">2025-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存映射<code>mmap</code>分为普通文件和匿名文件，这里讨论的是Linux环境</p>
<h2 id="文件映射file-mapping">文件映射（File Mapping）</h2>
<blockquote>
<ul>
<li><strong><code>malloc</code>
是高级抽象</strong>，封装了内存分配细节，开发者无需关心底层是
<code>brk</code> 还是 <code>mmap</code>。</li>
<li><strong><code>mmap</code> 是底层机制</strong>，既服务于
<code>malloc</code> 的大内存分配，也用于文件映射等高级功能。</li>
</ul>
</blockquote>
<h3 id="普通文件">普通文件</h3>
<p>将<strong>普通磁盘文件</strong>的某个区域映射到进程的虚拟内存空间。</p>
<h4 id="工作原理">工作原理</h4>
<ul>
<li><strong>页面划分</strong>：文件内容被划分成页面大小（通常为4KB）的片段，每个片段对应虚拟内存中的一个页面。</li>
<li>按需加载（Demand Paging）：
<ul>
<li>初始时，文件内容并不会全部加载到物理内存中。</li>
<li>当CPU<strong>首次</strong>访问某个虚拟页面时，操作系统才将文件对应的页面<strong>从磁盘加载到物理内存</strong>。</li>
</ul></li>
<li><strong>超出文件区域</strong>：若映射区域大于文件大小，超出部分会被<strong>零填充</strong>（Padding
with zeros）。</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>文件的内容直接与虚拟内存对应，可进行高效的文件I/O操作。</li>
<li>用于<strong>程序执行</strong>（如加载可执行文件）或实现<strong>文件共享</strong>。</li>
</ul>
<h3 id="匿名文件">匿名文件</h3>
<p>将一片<strong>不关联磁盘文件</strong>的内存区域映射到进程的虚拟地址空间。这种区域内容初始化为<strong>全零</strong>，由内核创建的<strong>匿名文件</strong>管理。匿名文件的内容全部由<strong>二进制零</strong>组成，因此它是<strong>空白的</strong>、未初始化的。</p>
<h4 id="工作原理-1">工作原理</h4>
<ul>
<li>按需分配：
<ul>
<li>初始时，匿名映射区域并不占用物理内存。</li>
<li>当CPU首次访问某个虚拟页面时，内核会分配一个<strong>物理页面</strong>，并将其内容填充为<strong>二进制零</strong>。</li>
</ul></li>
<li>只有当CPU第一次访问某个虚拟页面时（即“触摸”该页面），内核才会进行以下操作：
<ol type="1">
<li><strong>选择一个牺牲页面</strong>（Victim
Page）：从物理内存中找到一个适合被替换的页面。</li>
<li><strong>交换脏页面</strong>（如有必要）：如果选中的页面是<strong>脏页面</strong>（内容被修改过但尚未写回磁盘），内核会先将其内容写回磁盘。</li>
<li><strong>填充零值</strong>：内核将物理页面的内容全部填充为<strong>二进制零</strong>。</li>
<li><strong>更新页表</strong>：内核将虚拟页面与新分配的物理页面关联起来，并将页面标记为<strong>已驻留</strong>（Resident）。</li>
</ol></li>
</ul>
<h4 id="特点-1">特点</h4>
<ul>
<li>适用于分配需要初始化为零的内存区域，例如堆内存、栈内存。</li>
<li>不涉及磁盘文件，因此无需磁盘I/O。</li>
<li>由于这种机制不会涉及磁盘和内存之间的数据传输，内核只是在分配物理页面时填充零值，因此这类页面被称为<strong>需求零页面</strong>（Demand-Zero
Pages）。</li>
</ul>
<blockquote>
<p><code>malloc</code> 的实现（如 glibc 的
ptmalloc）通常会结合两种方式分配内存：</p>
<ol type="1">
<li><strong>小内存块（&lt; 128KB 或阈值）</strong>：
<ul>
<li>通过 <code>brk</code>/<code>sbrk</code>
系统调用扩展堆空间，从堆中分配。</li>
<li>优点：高效，减少内存碎片（通过内存池管理）。</li>
</ul></li>
<li><strong>大内存块（≥ 128KB 或阈值）</strong>：
<ul>
<li>直接使用 <code>mmap</code>
分配匿名内存（<code>MAP_ANONYMOUS</code>）。</li>
<li>优点：大块内存独立管理，避免堆空间碎片化；释放时直接通过
<code>munmap</code> 归还给操作系统。</li>
</ul></li>
</ol>
</blockquote>
<h2 id="fork-函数">fork 函数</h2>
<p><strong>1. 调用 <code>fork()</code> 时的内存复制：</strong></p>
<ul>
<li><p>在调用 <code>fork()</code>
时，操作系统并不会立即复制整个父进程的内存空间，而是通过<strong>写时复制（Copy-On-Write,
COW）机制</strong>优化内存使用。</p>
<blockquote>
<p><strong>写时复制</strong>只有在任⼀进程（⽗进程或⼦进程）对数据执⾏了写操作时，复制才会发⽣（先是缺⻚中断，然后操作系统给⼦进程分配内存并复制⽗进程的数据）</p>
</blockquote></li>
<li><p>父子进程会<strong>共享同一块物理内存页面</strong>（只读）。</p></li>
<li><p>只有当父进程或子进程尝试修改内存时，写时复制机制会为对应的进程创建一个新页面，从而为每个进程保持了私有地址空间的抽象概念。</p></li>
</ul>
<p><strong>2. 创建子进程：</strong></p>
<ul>
<li>内核会为子进程分配一个新的<strong>进程控制块（PCB）</strong>，用于存储子进程的状态信息。</li>
<li>子进程获得与父进程相同的内存空间（通过 COW 实现共享）。</li>
<li>子进程会继承父进程的大部分资源，例如：
<ul>
<li>程序代码（代码段）</li>
<li>堆、栈（通过 COW 共享）</li>
<li>打开的文件描述符</li>
<li>环境变量等</li>
</ul></li>
</ul>
<p><strong>3. 返回值不同：</strong></p>
<ul>
<li><code>fork()</code>在父进程和子进程中都会返回：
<ul>
<li>在<strong>父进程</strong>中，<code>fork()</code>
返回<strong>子进程的PID</strong>。</li>
<li>在<strong>子进程</strong>中，<code>fork()</code>
返回<strong>0</strong>。</li>
<li>如果 <code>fork()</code> 失败，返回
<strong>-1</strong>，表示子进程创建失败。</li>
</ul></li>
</ul>
<p>通过返回值的不同，程序可以判断当前正在运行的是父进程还是子进程。</p>
<p><strong>4. 进程调度：</strong></p>
<ul>
<li>父进程和子进程会被操作系统调度器视为两个独立的进程，独立运行。</li>
<li>由于父子进程共享同一个代码段，它们可以执行不同的代码路径（如通过
<code>if</code> 判断 <code>fork()</code> 返回值）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">lambda表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-02T00:00:00+08:00">2024-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-23 00:31:45" itemprop="dateModified" datetime="2025-01-23T00:31:45+08:00">2025-01-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内容参考《C++ primer》</p>
<h2 id="定义">定义</h2>
<ul>
<li><p>一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的
内联函数。</p></li>
<li><p>表达式形式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; return type { function body }</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>lambda表达式必须使用尾置返回，尾置返回示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></tbody></table></figure>
</blockquote></li>
<li><p>若忽略括号和参数列表，则等价于指定一个空参数列表</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] { <span class="keyword">return</span> <span class="number">42</span>; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">//打印42</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="向lambda传递参数">向lambda传递参数</h3>
<ul>
<li><p>包含参数的lambda表达式，可作为<code>find_if</code>函数的一个参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); }</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="使用捕获列表">使用捕获列表</h3>
<ul>
<li><p>lambda表达式通过将局部变量包含在其捕获列表中来指出将会使用这些变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sz](<span class="type">const</span> string &amp;a) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; };</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="变量的捕获方式">变量的捕获方式</h2>
<h3 id="值捕获">值捕获</h3>
<ul>
<li>lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。</li>
<li>与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">//将v1拷贝到名为f的可调用对象</span></span><br><span class="line">	<span class="keyword">auto</span> f = [v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">	v1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 42，f保存了我们创建它时v1的拷贝</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="引用捕获">引用捕获</h3>
<ul>
<li>v1之前的<code>&amp;</code>指出v1应该以引用方式捕获。</li>
<li>当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。</li>
<li>在本例中，当lambda返回v1时，它返回的是v1指向的对象的值。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">// f包含对v1的引用</span></span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">	v1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 0，f保存了v1的引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="隐式捕获">隐式捕获</h3>
<ul>
<li>让编译器根据lambda体中的代码来推断我们要使用哪些变量</li>
<li><code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式</li>
<li>混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式捕获，值捕获方式，这里的lambda表达式是find_if的第三个参数</span></span><br><span class="line">wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(), </span><br><span class="line">             [=](<span class="type">const</span> string &amp;s)</span><br><span class="line">                { <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; });</span><br></pre></td></tr></tbody></table></figure>
<h2 id="可变lambda">可变lambda</h2>
<ul>
<li><p>对于一个值被拷贝的变量，若要改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fen3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">size_t</span> v1 = <span class="number">42</span>;<span class="comment">//局部变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">// f可以改变它所捕获的变量的值</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">auto</span> f = [v1] ()  <span class="keyword">mutable</span> { <span class="keyword">return</span> ++v1;};</span></span></span><br><span class="line"><span class="params"><span class="function">	v1 =<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">auto</span> j = f();<span class="comment">//j为43</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>对于引用捕获的变量可以直接修改，不用添加mutable关键字</p></li>
</ul>
<h2 id="指定返回类型">指定返回类型</h2>
<ul>
<li><p>默认情况下，如果一个lambda体包含<code>return</code>之外的任何语句，则编译器假定此lambda返回void。例如下面的代码就是错误的</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：不能推断lambda的返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i)</span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;};</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>若lambda表达式包含其他语句，且返回值其实不是void，则使用尾置返回类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i) -&gt; <span class="type">int</span>  <span class="comment">// 这里指定了返回类型</span></span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; });</span><br></pre></td></tr></tbody></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">机器学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-21 13:01:51" itemprop="dateCreated datePublished" datetime="2024-11-21T13:01:51+08:00">2024-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-15 21:30:11" itemprop="dateModified" datetime="2025-05-15T21:30:11+08:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="监督学习">监督学习</h2>
<p>应用最多</p>
<h3 id="回归regression">回归（regression）</h3>
<ul>
<li>给定输入和输出，得到映射函数，再根据不同输入进行预测，得到输出（无限的可能）</li>
</ul>
<h4 id="代价函数">代价函数</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241121191024821.png" alt="image-20241121191024821">
<figcaption aria-hidden="true">image-20241121191024821</figcaption>
</figure>
<p>线性回归的代价函数<code>J</code>与变量<code>w</code>和<code>b</code>的图像是三维的，类似于碗状</p>
<h4 id="线性回归">线性回归</h4>
<ul>
<li>训练集</li>
</ul>
<h4 id="梯度下降">梯度下降</h4>
<p><strong>「梯度的概念」</strong>：梯度就是函数对它的各个自变量求偏导后，由<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=146213942&amp;content_type=Article&amp;match_order=1&amp;q=偏导数&amp;zhida_source=entity">偏导数</a>组成的一个向量。</p>
<p>可以用来最小化任意函数</p>
<ul>
<li><p>找到代价函数的局部最小值即极小值（在代价函数的图像上，朝不同方向找到极小值）</p></li>
<li><p>学习率（learning rate）：α，影响梯度下降的快慢</p></li>
<li><p>用到了偏导，<code>w</code>和<code>b</code>需要同时更新</p>
<p><code>J</code>对<code>w</code>的偏导表示<code>J</code>和<code>w</code>组成的函数图像的切线斜率</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241123134344175.png" alt="image-20241123134344175">
<figcaption aria-hidden="true">image-20241123134344175</figcaption>
</figure></li>
<li><p>批量（batch）梯度下降：每一步梯度下降使用的是所有的训练示例</p></li>
</ul>
<h4 id="多元线性回归">多元线性回归</h4>
<p>系数向量化</p>
<ul>
<li><p><strong>特征缩放</strong>（features
scaling）：不同特征的不同取值范围导致等高线图像细长，需要缩放特征值使图像更加均匀</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241126134526107.png" alt="image-20241126134526107">
<figcaption aria-hidden="true">image-20241126134526107</figcaption>
</figure></li>
<li><p><strong>均值归一化</strong>（mean normalization）</p></li>
<li><p>Z-score 标准化</p></li>
</ul>
<h4 id="特征工程">特征工程</h4>
<p>创建新的特征，得到新的模型</p>
<h4 id="多项式回归">多项式回归</h4>
<ul>
<li><p>包含高次项</p></li>
<li><p>多项式回归是一种扩展线性回归的方法</p></li>
</ul>
<h3 id="分类classification">分类（classification）</h3>
<ul>
<li>分类预测的结果是从有限的可能中选取一个</li>
</ul>
<h4 id="逻辑回归">逻辑回归</h4>
<ul>
<li><p>sigmoid函数</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241202234353128.png" alt="image-20241202234353128">
<figcaption aria-hidden="true">image-20241202234353128</figcaption>
</figure></li>
<li><p>决策边界：z = 0</p></li>
<li><p><strong>损失函数</strong>：对一个训练样本进行计算</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241203141912797.png" alt="image-20241203141912797">
<figcaption aria-hidden="true">image-20241203141912797</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241203142006274.png" alt="image-20241203142006274">
<figcaption aria-hidden="true">image-20241203142006274</figcaption>
</figure></li>
</ul>
<h3 id="过拟合">过拟合</h3>
<p>欠拟合 = 高偏差</p>
<p>过拟合 = 高方差</p>
<h4 id="解决过拟合">解决过拟合</h4>
<ul>
<li><p>增加训练集的样本数</p></li>
<li><p>减少特征（feature）</p></li>
<li><p>正则化（效果等价于修改系数w<sub>j</sub>）：在代价函数后添加一个式子，使用
λ 系数</p>
<ul>
<li>λ 为 0，则过拟合</li>
<li>λ 过大，则欠拟合</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241203141830047.png" alt="image-20241203141830047">
<figcaption aria-hidden="true">image-20241203141830047</figcaption>
</figure></li>
</ul>
<h2 id="非监督学习">非监督学习</h2>
<ul>
<li>聚类-clustering：在没有标签的情况下获取数据，并自动将它们分组到不同集群中（聚类-clustering）</li>
<li>异常检测-anomaly detection：找到异常数据</li>
<li>降维-dimensionality reduction：将大数据集压缩为较小的数据集</li>
</ul>
<h2 id="深度学习">深度学习</h2>
<h3 id="神经元">神经元</h3>
<ul>
<li>单个神经元：多个输入一个输出</li>
</ul>
<h3 id="层">层</h3>
<ul>
<li>隐藏层：每层可以包含多个神经元</li>
<li>默认是全连接层（dense layer，密集层）</li>
</ul>
<h3 id="前向传播">前向传播</h3>
<ul>
<li>由输入经过神经元得到输出的过程（做出预测）</li>
</ul>
<h3 id="激活函数">激活函数</h3>
<ul>
<li><p>激活函数是对神经网络的隐藏层和输出层使用的，而不是神经元</p></li>
<li><p>对于输出层根据输出来决定使用哪个激活函数</p></li>
<li><p>对于隐藏层推荐默认使用ReLU函数</p></li>
<li><p>ReLU函数</p></li>
<li><p>Sigmoid函数：需要计算指数，效率比ReLU低</p></li>
</ul>
<h3 id="矢量化">矢量化</h3>
<p>矩阵乘法，简化计算</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241209123759484.png" alt="image-20241209123759484">
<figcaption aria-hidden="true">image-20241209123759484</figcaption>
</figure>
<h3 id="反向传播">反向传播</h3>
<p>计算偏导数</p>
<h3 id="多类">多类</h3>
<h4 id="softmax">Softmax</h4>
<ul>
<li><p>Softmax是逻辑回归的推广</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241214232411429.png" alt="image-20241214232411429">
<figcaption aria-hidden="true">image-20241214232411429</figcaption>
</figure></li>
<li><p>损失函数和代价函数</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241214232510217.png" alt="image-20241214232510217">
<figcaption aria-hidden="true">image-20241214232510217</figcaption>
</figure></li>
<li><p>Softmax可作为激活函数</p></li>
</ul>
<h4 id="多标签分类">多标签分类</h4>
<ul>
<li>y 的输出不止一个值</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241215204101106.png" alt="image-20241215204101106">
<figcaption aria-hidden="true">image-20241215204101106</figcaption>
</figure>
<h3 id="高级优化方法">高级优化方法</h3>
<h4 id="adam-algorithm">Adam Algorithm</h4>
<ul>
<li>自动调整学习率</li>
<li>对每个参数（w<sub>1</sub>、w<sub>2</sub>......b）有不同的学习率</li>
</ul>
<h3 id="卷积神经网络">卷积神经网络</h3>
<p>包含多个卷积层</p>
<h4 id="卷积层">卷积层</h4>
<ul>
<li>每个神经元只处理图像的一部分</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241215230834569.png" alt="image-20241215230834569">
<figcaption aria-hidden="true">image-20241215230834569</figcaption>
</figure>
<h3 id="模型评估">模型评估</h3>
<h4 id="将数据集分为训练集和测试集">将数据集分为训练集和测试集</h4>
<ul>
<li><p>线性回归：使用代价函数评估</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216140940862.png" alt="image-20241216140940862">
<figcaption aria-hidden="true">image-20241216140940862</figcaption>
</figure></li>
<li><p>逻辑回归（分类问题）：使用代价函数评估</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216141510260.png" alt="image-20241216141510260">
<figcaption aria-hidden="true">image-20241216141510260</figcaption>
</figure>
<p>或者使用下面的方法评估模型：统计预测值与实际值不匹配的样本数</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216141734150.png" alt="image-20241216141734150">
<figcaption aria-hidden="true">image-20241216141734150</figcaption>
</figure></li>
</ul>
<h4 id="把数据集分成训练集交叉验证集测试集">把数据集分成训练集、交叉验证集、测试集</h4>
<ul>
<li><p>交叉验证集：cross validation set（或者validation set、development
set、dev set）</p></li>
<li><p>模型选择，选择<strong>交叉验证集</strong>误差最小的模型，然后用<strong>测试集</strong>进行评估</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216150120549.png" alt="image-20241216150120549">
<figcaption aria-hidden="true">image-20241216150120549</figcaption>
</figure>
<p>图中的 d 表示多项式的度</p></li>
<li><p>对于不同多项式，J<sub>cv</sub> 和 J<sub>train</sub>
的关系：横坐标表示多项式的度即最高次的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216153505696.png" alt="image-20241216153505696" style="zoom:67%;"></p></li>
</ul>
<h3 id="偏差与方差">偏差与方差</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216151835365.png" alt="image-20241216151835365">
<figcaption aria-hidden="true">image-20241216151835365</figcaption>
</figure>
<h4 id="正则化">正则化</h4>
<p>选择合适的 λ 进行正则化，防止欠拟合和过拟合</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216152925723.png" alt="image-20241216152925723">
<figcaption aria-hidden="true">image-20241216152925723</figcaption>
</figure>
<ul>
<li>如何选择 λ：取不同的 λ
值，计算交叉验证集的误差，选择最小的，然后用测试集的误差进行评估</li>
</ul>
<h4 id="基准">基准</h4>
<p>通过建立基准判断是否高方差或高偏差</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216160855644.png" alt="image-20241216160855644">
<figcaption aria-hidden="true">image-20241216160855644</figcaption>
</figure>
<h4 id="学习曲线">学习曲线</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216161331618.png" alt="image-20241216161331618">
<figcaption aria-hidden="true">image-20241216161331618</figcaption>
</figure>
<ul>
<li><p>高偏差情况下：增大训练集样本数量不会降低多少错误率</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216162308834.png" alt="image-20241216162308834" style="zoom:80%;"></p></li>
<li><p>高方差情况下：增大训练集样本数量能够降低错误率</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216162653266.png" alt="image-20241216162653266" style="zoom:80%;"></p></li>
</ul>
<h4 id="总结">总结</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216163658454.png" alt="image-20241216163658454">
<figcaption aria-hidden="true">image-20241216163658454</figcaption>
</figure>
<ol type="1">
<li>修复高方差的方法
<ul>
<li>增加训练集样本</li>
<li>使用更小的特征集合</li>
<li>增大 λ</li>
</ul></li>
<li>修复高偏差的方法
<ul>
<li>增加特征</li>
<li>增加多项式特征（x的高次方）</li>
<li>减小 λ</li>
</ul></li>
</ol>
<h3 id="机器学习的迭代">机器学习的迭代</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241216165124224.png" alt="image-20241216165124224">
<figcaption aria-hidden="true">image-20241216165124224</figcaption>
</figure>
<h4 id="误差分析">误差分析</h4>
<h3 id="迁移学习">迁移学习</h3>
<p>将训练好的神经网络的参数应用在新的神经网络上。</p>
<p>例如下面的示例：将识别物体的神经网络应用在识别手写数字上，手写数字识别神经网络的前四层参数直接引用物体识别神经网络的前四层参数，只有输出层参数不同，然后进行训练，训练方式有两种：</p>
<ul>
<li>只训练输出层参数</li>
<li>训练所有层的参数，但是前几层参数的初始值设置为另一个神经网络的前几层参数</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241218191916654.png" alt="image-20241218191916654">
<figcaption aria-hidden="true">image-20241218191916654</figcaption>
</figure>
<h3 id="精确率和召回率">精确率和召回率</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241218201602616.png" alt="image-20241218201602616">
<figcaption aria-hidden="true">image-20241218201602616</figcaption>
</figure>
<ul>
<li><p>精确率（Precision）是指正确识别的阳性样本与所有标记为阳性的样本的比例。换句话说，它可以理解为在所有标记为阳性结果中，真正阳性的比例。精确率高意味着漏诊少，但可能会因为过度严格而将一些真正阳性样本误认为是阴性。</p></li>
<li><p>召回率（Recall）是指所有真正阳性样本中被正确识别的比例。召回率高意味着很少漏诊，即尽可能多地将阳性样本识别出来，但可能会因为过度宽松而将一些真正阴性样本误认为是阳性。</p></li>
</ul>
<p>在实际应用中，当试图提高召回率时，我们可能会降低精确率，因为更宽松的判定标准可能会导致更多的误判。相反，提高精确率可能会导致召回率下降，因为更严格的判定标准可能错过一些真正的阳性样本。这种权衡关系导致了精确率和召回率的矛盾。</p>
<h3 id="决策树模型">决策树模型</h3>
<ul>
<li><p>每个非叶子节点是特征</p></li>
<li><p>限制决策树的高度</p></li>
<li><p>entropy（熵）：熵表示信息的不确定性或信息量的大小。熵越高，意味着系统越混乱或信息越不确定</p>
<p>下图中H是计算熵的函数</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241221141609541.png" alt="image-20241221141609541">
<figcaption aria-hidden="true">image-20241221141609541</figcaption>
</figure></li>
<li><p>One hot
encoding：解决多类问题，使用二进制表示特征，方便输入神经网络</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241221144408684.png" alt="image-20241221144408684">
<figcaption aria-hidden="true">image-20241221144408684</figcaption>
</figure></li>
</ul>
<h3 id="回归树">回归树</h3>
<p>可预测连续的具体的数值</p>
<h3 id="多个决策树">多个决策树</h3>
<ul>
<li>首先通过放回抽样获取不同的数据集</li>
<li>对于不同的数据集可能得到不同的决策树</li>
<li>根据上述得到的多个决策树预测结果，对结果进行投票得到最终结果</li>
<li>缺点：不同决策树之间可能差异较小</li>
</ul>
<h3 id="随机森林算法">随机森林算法</h3>
<p>基于上述的多个决策树的算法，为了让树与树之间差异较大，所以树的特征节点的选择一般是
特征个数为k 的子集（特征总数为n，k&lt;n），然后从这k个特征中选取节点</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/20/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">顺序容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T00:00:00+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-01 11:17:58" itemprop="dateModified" datetime="2025-01-01T11:17:58+08:00">2025-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内容参考《C++ primer》</p>
<p>遇到具体的容器操作可以查看https://zh.cppreference.com/w/cpp</p>
<h2 id="顺序容器类型">顺序容器类型</h2>
<p><code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>、<code>string</code></p>
<ul>
<li><code>string</code>和<code>vector</code>将元素保存在连续的内存空间中。在这两种容器的中间位置添加或删除元素就会非常耗时——需要移动插入/删除位置之后的所有元素</li>
<li><code>list</code>和<code>forward_list</code>两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。但是这两个容器不支持元素的随机访问。</li>
<li><code>deque</code>（双端队列）支持随机访问，在其两端添加或删除元素都是很快的</li>
<li><code>array</code>对象的大小是固定的。因此，<code>array</code>不支持添加和删除元素以及改变容器大小的操作</li>
<li>顺序容器是可以嵌套的，例如：<code>vector&lt;vector&lt;string&gt;&gt; lines;</code></li>
</ul>
<h2 id="定义和初始化">定义和初始化</h2>
<h3 id="拷贝初始化">拷贝初始化</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec; <span class="comment">//初始状态为空</span></span><br><span class="line"><span class="comment">//在此处给ivec添加一些值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>; <span class="comment">//把ivec的元素拷贝给ivec2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3 = ivec; <span class="comment">//把ivec的元素拷贝给ivec3</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(b, e)</span></span>; <span class="comment">//it初始化为迭代器b和e指定范围中的元素的拷贝。</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="列表初始化">列表初始化</h3>
<p>使用花括号初始化元素值</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vl</span><span class="params">(<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>};<span class="comment">//列表初始化</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v1 = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>}; </span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="创建指定数量的元素">创建指定数量的元素</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>; <span class="comment">//10个int类型的元素，每个都被初始化为-1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>,<span class="string">"hi!"</span>)</span></span>;<span class="comment">// 10个string类型的元素，每个都被初始化为"hi!"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="值初始化">值初始化</h3>
<p>只提供容器容纳的元素数量</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个元素，每个都是空string对象</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="array">array</h3>
<ul>
<li><p>使用该类型时，<strong>必须</strong>指明元素类型和<strong>大小</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; a1;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>数组类型不能进行拷贝或对象赋值操作，但是<code>array</code>类型可以</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digs[<span class="number">10</span>]=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line"><span class="type">int</span> cpy[<span class="number">10</span>] = digs;<span class="comment">//错误：内置数组不支持拷贝或赋值</span></span><br><span class="line">              </span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">10</span>&gt; digits-(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">10</span>&gt; copy = digits;<span class="comment">//正确：只要数组类型和大小匹配即合法</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<blockquote>
<p>注意区别</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v1有10个元素，每个的值都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2{<span class="number">10</span>}; <span class="comment">// v2有1个元素，该元素的值是10</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">// v3有10个元素，每个的值都是1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4{<span class="number">10</span>,<span class="number">1</span>); <span class="comment">// v4有2个元素，值分别是10和1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v5</span><span class="params">(<span class="string">"hi"</span>};<span class="comment">//列表初始化：v5有一个元素</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// vector&lt;string&gt; v6("hi"); 错误：不能使用字符串字面值构建vector对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v7(<span class="number">10</span>}; <span class="comment">// v7有10个默认初始化的元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v8(<span class="number">10</span>,<span class="string">"hi"</span>}; <span class="comment">// v8有10个值为"hi"的元素</span></span></span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h2 id="赋值">赋值</h2>
<h3 id="直接赋值">直接赋值</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1 = v2;</span><br><span class="line">v = {a, b, c ...}; <span class="comment">// 初始化列表赋值，不适用于array</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="swap">swap</h3>
<ul>
<li>两个容器的大小不同也可以使用</li>
<li>例如，假定iter在swap之前指向svec1[3]的元素，那么在swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(v1, v2); </span><br><span class="line">v1.<span class="built_in">swap</span>(v2);<span class="comment">// 交换v1和v2的值，速度比直接赋值快</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="assign">assign</h3>
<p><code>assign</code>操作不适用于关联容器和<code>array</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq.<span class="built_in">assign</span>(b, e); <span class="comment">// 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</span></span><br><span class="line">seq.<span class="built_in">assign</span>(il); <span class="comment">// 将seq中的元素替换为初始化列表il中的元素</span></span><br><span class="line">seq.<span class="built_in">assign</span>(n, t); <span class="comment">// 将seq中的元素替换为n个值为t的元素</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="关系运算">关系运算</h2>
<p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。</li>
<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。</li>
</ul>
<h2 id="迭代器">迭代器</h2>
<p>迭代器范围由一对迭代器组成，分别是<code>begin</code>和<code>end</code>，<code>begin</code>指向第一个元素，<code>end</code>指向最后一个元素之后的位置，所以元素所在的区间范围是左闭右开的<code>[begin, end)</code></p>
<h3 id="迭代器运算">迭代器运算</h3>
<ul>
<li><code>*iter</code> ：返回迭代器所指元素的引用</li>
<li><code>++iter</code>：令迭代器指向下一个元素</li>
<li><code>--iter</code>：令迭代器指向上一个元素</li>
<li><code>iter1 == iter2</code>或<code>iter1 != iter2</code>：判断两个迭代器是否相等</li>
</ul>
<h3 id="迭代器类型">迭代器类型</h3>
<p>分为<code>iterator</code>和<code>const_iterator</code>来表示。</p>
<ul>
<li><code>const_iterator</code>和常量指针差不多，能读取但<strong>不能修改</strong>它所指的元素值。</li>
<li><code>iterator</code>的对象可读可写。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;    <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">string::iterator it2; <span class="comment">// it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;<span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4; <span class="comment">// it4只能读字符，不能写字符</span></span><br></pre></td></tr></tbody></table></figure>
<p>一般使用<code>auto</code>声明迭代器，例如<code>auto it = a.begin()</code></p>
<h2 id="下标访问元素">下标访问元素</h2>
<p>我们希望确保下标是合法的，可以使用<code>at</code>成员函数。如果下标越界，<code>at</code>会抛出一个<code>out_of_range</code>异常</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;<span class="comment">//空vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];<span class="comment">//运行时错误：svec中没有元素!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="改变容器大小">改变容器大小</h2>
<ul>
<li>使用<code>resize(new_size)</code>修改容器大小</li>
<li>注意<code>array</code>不支持修改容器大小</li>
<li>若要增大容器，则会在容器末尾添加</li>
<li>若要缩小容器，则会删去末尾元素</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;<span class="comment">// 10个int:每个的值都是42</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">15</span>);<span class="comment">//将5个值为0的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">25</span>,<span class="number">-1</span>);<span class="comment">//将10个值为-1的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">5</span>);<span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="适配器">适配器</h2>
<p>这里介绍顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。适配器(adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk; </span><br><span class="line"><span class="comment">//此声明的作用是创建一个以 vector&lt;string&gt; 为底层存储容器的堆栈，堆栈中的每个元素都是一个 string</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意要<strong>根据不同适配器的特性重载其默认容器类型</strong>，例如，<code>stack</code>只要求<code>push_back</code>、<code>pop_back</code>和<code>back</code>操作，因此可以使用除<code>array</code>和<code>forward_list</code>之外的任何容器类型来构造<code>stack</code>。<code>queue</code>适配器要求<code>back</code>、<code>push_back</code>、<code>front</code>和<code>push_front</code>，因此它可以构造于<code>list</code>或<code>deque</code>之上，但不能基于<code>vector</code>构造。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/CS106B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/CS106B/" class="post-title-link" itemprop="url">CS106B-22Winter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-26 19:29:42" itemprop="dateCreated datePublished" datetime="2024-10-26T19:29:42+08:00">2024-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-02 00:49:43" itemprop="dateModified" datetime="2025-03-02T00:49:43+08:00">2025-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS106B/" itemprop="url" rel="index"><span itemprop="name">CS106B</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考资料：</p>
<p>https://www.zhihu.com/column/c_1471256108476461057
（实验环境配置/实验代码）</p>
<p>https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1224/schedule.html#
（教学安排）</p>
<p><a target="_blank" rel="noopener" href="https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/">Stanford
C++ Library Documentation</a></p>
<p>https://web.stanford.edu/class/cs106x/res/reader/CS106BX-Reader.pdf
（教材）</p>
<h2 id="chapter-1">Chapter 1</h2>
<h3 id="library-inclusions">library inclusions</h3>
<p>通过<code>#include</code>从对应头文件中读取相关定义，<code>&lt;iostream&gt;</code>中的尖括号表示这是一个系统库，也可以使用自己编写的头文件，则不包含尖括号而是以<code>.h</code>结尾。</p>
<h3 id="namespaces">namespaces</h3>
<p>不同的库或模块可能会定义相同的名称，举个例子，如果一个第三方库定义了一个函数叫“cout”，而你在代码中也使用了标准库的<code>std::cout</code>，为了避免这种情况，C++的命名空间设计允许你将不同的代码片段放在各自的命名空间中，这样就算名称相同，也不会冲突，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mylib {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cout</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"This is mylib's cout!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"This is standard cout!"</span> &lt;&lt; std::endl;  <span class="comment">// std 命名空间中的 cout</span></span><br><span class="line">    mylib::<span class="built_in">cout</span>();  <span class="comment">// mylib 命名空间中的 cout</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>可以使用<code>using namespace std;</code>将该命令空间中的所有成员加入当前域，因此就不用添加namespace前缀了，但是这个功能在大项目中要慎用。</p>
<h3 id="constants">Constants</h3>
<p>常量的值一般不改变，例如 Π 的值，因此可以定义：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265358979323846</span>;  <span class="comment">// 常量一般大写</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="基本数据类型">基本数据类型</h3>
<ol type="1">
<li><p>整型</p>
<blockquote>
<p><strong>0</strong>42——八进制，<strong>0x</strong>51——十六进制</p>
<p>整型结尾有<code>U</code>表示无符号数</p>
</blockquote>
<ul>
<li>short</li>
<li>int</li>
<li>long：在数字结尾加上<code>L</code>则表示<code>long</code>类型</li>
</ul></li>
<li><p>浮点型</p>
<blockquote>
<p>用标准计数法表示光速：2.9979E+8</p>
</blockquote>
<ul>
<li>float</li>
<li>double</li>
<li>long double</li>
</ul></li>
<li><p>字符型</p>
<ul>
<li><p>char：单引号内只能是字符而不是字符串</p></li>
<li><p>string：使用双引号。需要通过<code>#include &lt;string&gt;</code>调用</p>
<blockquote>
<p>字符串类型是标准库命名空间的一部分，即命名空间也是
<strong>std</strong></p>
</blockquote></li>
</ul></li>
<li><p>布尔型</p>
<ul>
<li>bool</li>
</ul></li>
<li><p>枚举型</p>
<ul>
<li><p>enum：语法为<code>enum typename { namelist };</code>（所有类型名称都以大写字母开头，枚举常量的名称完全以大写字母书写），示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> { NORTH, EAST, SOUTH, WEST };</span><br><span class="line"><span class="comment">//从0开始编号来为常量名称赋值。NORTH被赋予值0，EAST被赋予值1，SOUTH被赋予数值2，WEST被赋予数值3</span></span><br><span class="line"><span class="comment">//也支持用户自定义值的大小，例如：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> { </span><br><span class="line">   PENNY = <span class="number">1</span>, </span><br><span class="line">   NICKEL = <span class="number">5</span>, </span><br><span class="line">   DIME = <span class="number">10</span>, </span><br><span class="line">   QUARTER = <span class="number">25</span>, </span><br><span class="line">   HALF_DOLLAR = <span class="number">50</span>, </span><br><span class="line">   DOLLAR = <span class="number">100</span> </span><br><span class="line">};</span><br><span class="line"><span class="comment">//若只为第一个常量赋值，则后续的常量是接着第一个常量连续编号的</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
</ol>
<h3 id="运算符">运算符</h3>
<ul>
<li><p>单目运算符：一个操作数</p></li>
<li><p>双目运算符：两个操作数</p></li>
<li><p>三目运算符：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(condition) ? exp1 : exp2  <span class="comment">//若condition为true，则返回exp1，否则返回exp2</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="类型转换type-cast">类型转换（Type Cast）</h3>
<p>语法如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotient = <span class="built_in">double</span>(num) / den; <span class="comment">//在对应变量 num 前添加转换后的类型</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="赋值">赋值</h3>
<p>下面这个式子的作用是<code>x=6, y=7, z=13</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = (x = <span class="number">6</span>) + (y = <span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>赋值表达式的返回值就是待赋的值</p>
<h3 id="控制语句">控制语句</h3>
<ul>
<li>if</li>
<li>switch</li>
<li>while：条件测试在循环的每个循环之前进行，包括第一个循环</li>
<li>for</li>
</ul>
<h2 id="chapter-2">Chapter 2</h2>
<h3 id="libraries-and-function">Libraries and Function</h3>
<p>当你编写C++程序时，计算机执行的大部分代码不是你自己编写的代码，而是你随应用程序加载的库代码。</p>
<ul>
<li>iostream</li>
<li>cmath：包含多个数学函数</li>
<li>string</li>
</ul>
<h3 id="overloading重载">Overloading（重载）</h3>
<p>不同函数（函数类型不同或参数不同）可以使用相同命名。例如，<code>&lt;cmath&gt;</code>库包含函数<code>abs</code>（求绝对值）的几个不同的版本，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &lt; <span class="number">0</span>) ? -x : x; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">double</span> x)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &lt; <span class="number">0</span>) ? -x : x; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="默认参数">默认参数</h3>
<p>在声明函数时，给参数设定好初始值，在调用时就可以省略该参数，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatInColumns</span><span class="params">(<span class="type">int</span> nColumns = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用，此时nColumns的值自动设为2</span></span><br><span class="line">formatInColumns();</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ul>
<li>默认值的说明只出现在函数原型（声明）中，而不是在函数定义中。</li>
<li>任何默认参数都必须出现在参数列表的末尾。</li>
</ul>
<h3 id="引用参数">引用参数</h3>
<p>对于一般的参数，当你将一个简单变量从一个函数传递到另一个函数时，函数都会得到调用值的副本，该副本的修改影响不到原调用变量的值。例如下面的函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToZero</span><span class="params">(<span class="type">int</span> var)</span> </span>{ </span><br><span class="line">   var = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setToZero</span>(x);   <span class="comment">// 不修改x的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>若要修改调用的变量的值，需要将一般的参数更改为引用参数，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToZero</span><span class="params">(<span class="type">int</span> &amp; var)</span> </span>{ </span><br><span class="line">   var = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setToZero</span>(x);   <span class="comment">// 修改x的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口与实现">接口与实现</h3>
<ul>
<li><strong>接口（Interface）</strong>：接口定义了库的使用方法和约定，它告诉使用者如何与库进行交互。接口包含了库向外部暴露的<strong>函数声明</strong>、<strong>类型定义</strong>和<strong>常量</strong>等内容。这些接口不会包含具体的实现细节，而是只描述了如何调用库中的功能。这些接口通常存放在<strong>头文件（header
files，.h
）</strong>中。接口可以定义函数、常量、类以及枚举，其中枚举无需通过CPP进行实现，直接就可以调用</li>
<li><strong>实现（Implementation）</strong>：实现部分则包含了函数的实际代码、类的具体实现等细节。实现隐藏在库内部，用户无需关心这些细节。实现通常放在<strong>源文件（.cpp）</strong>中，并且编译后生成库文件（静态库或动态库）</li>
</ul>
<p>下面是 error 库的接口</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* File: error.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//检查是否定义了_error_h符号。若 _error_h 符号将已经定义，编译器这次将跳过接口的内容。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _error_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _error_h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>实现（Implementation）如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"error.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(string msg)</span> </span>{</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>在 .h 文件中声明常量或者变量需要使用 <strong>extern</strong>
关键字</p>
<p>https://www.runoob.com/w3cnote/extern-head-h-different.html</p>
</blockquote>
<h3 id="随机数">随机数</h3>
<p>计算机内部算法过程生成的“随机”数被称为伪随机数。</p>
<ul>
<li><p><code>rand()</code>函数（头文件<code>#include&lt;cstdlib&gt;</code>）根据上一次产生的伪随机数（旧随机数）来生成新的伪随机数，范围是
[0, RAND_MAX]</p></li>
<li><p><code>srand(int seed)</code>函数设置随机数种子
s<sub>0</sub>，然后<code>rand</code>根据该种子生成第一个随机数。相同种子产生的随机数序列是相同的（方便调试）。</p>
<p>若不手动设置种子，则默认为1。一般将其设置为一些用户难以预测的起始值，这些起始值通常取自系统时钟的值，因为每次运行程序时，这个值都是不同的，所以随机数序列也会发生变化。具体实现方法是通过调用函数
time 并将结果转换为整数来检索系统时钟的当前值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240912102359091.png" alt="image-20240912102359091">
<figcaption aria-hidden="true">image-20240912102359091</figcaption>
</figure>
<h3 id="static">static</h3>
<ol type="1">
<li>静态局部变量
<ul>
<li>静态局部变量在函数第一次调用时初始化。</li>
<li>变量在后续的函数调用中会保留它之前的值，不会被重新初始化。</li>
<li>它的作用域依然只限于函数内部，但生命周期持续到程序结束</li>
</ul></li>
<li>静态全局变量
<ul>
<li>在全局作用域中，如果变量用<code>static</code>修饰，变量的可见性（链接性）被限制在当前文件中。这种用法称为<strong>内部链接</strong>（internal
linkage）。即该变量无法被其他文件使用，即使它是全局的。</li>
</ul></li>
<li>静态函数
<ul>
<li>只能在定义的源文件中使用，不能被其他文件访问</li>
</ul></li>
<li>类的静态成员变量
<ul>
<li>静态成员变量的存储空间是全局的，在程序启动时就分配。</li>
<li>它不属于任何特定的类实例（对象），所以可以通过类名直接访问。</li>
<li>静态成员变量必须在类定义外进行初始化。</li>
</ul></li>
<li>类的静态成员函数
<ul>
<li>静态成员函数只能访问静态成员变量。</li>
<li>不需要通过类的对象来调用，可以直接通过类名调用。</li>
</ul></li>
</ol>
<h2 id="chapter-3">Chapter 3</h2>
<h3 id="string">string</h3>
<p>访问字符串内部的字符有两种方法：</p>
<ul>
<li><code>str[index]</code></li>
<li><code>str.at(index)</code></li>
</ul>
<p><code>string</code>类型可以通过<code>=</code>直接赋值，例如<code>str1=str2</code>，用<code>str2</code>中包含的字符串副本覆盖<code>str1</code>的先前内容，赋值过后再修改<code>str2</code>无法影响到<code>str1</code></p>
<p><code>string</code>类型包含截断函数<code>substr</code>，例如<code>str.substr(2, 3)</code>，意思是从索引2开始截取三个字符，若省略3，则从2截取到字符串结尾。</p>
<p><code>find</code>函数可以查找子字符串或字符，例如<code>str.find("o")</code></p>
<h3 id="cctype">&lt;cctype&gt;</h3>
<p>用于处理字符的库</p>
<h2 id="chapter-4">Chapter 4</h2>
<h3 id="streams">Streams</h3>
<p><code>&lt;iostream&gt;</code>中的三个标准流：<code>cin</code>、<code>cout</code>、<code>cerr</code></p>
<h3 id="manipulator操纵器">manipulator（操纵器）</h3>
<p>操纵器通常具有以改变后续输出格式的方式设置输出流属性的效果。</p>
<p>例如：<code>&lt;iostream&gt;</code>库中的<code>endl</code>，<code>&lt;iomanip&gt;</code>库中的<code>setw(n)</code>（设置输出宽度）、<code>setprecision(digits)</code>、<code>setfill(ch)</code></p>
<h3 id="file-streamsfstream">File streams（&lt;fstream&gt;）</h3>
<p>在C++中读取或写入文件需要以下步骤：</p>
<ol type="1">
<li><p>声明一个流变量来引用文件。处理文件的程序通常为同时处于活动状态的每个文件声明一个流变量。因此，如果你正在编写一个读取输入文件并使用该数据写入输出文件的程序，你需要声明两个变量，如下所示</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">ifstream infile;  <span class="comment">// 用于读取文件数据</span></span><br><span class="line">ofstream outfile;  <span class="comment">//向文件写入数据</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>打开文件，在使用流变量之前，您需要在该变量和实际文件之间建立关联。此操作称为打开文件，通过调用流方法open来执行。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.<span class="built_in">open</span>(<span class="string">"Jabberwocky.txt"</span>); </span><br></pre></td></tr></tbody></table></figure>
<p>或者：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string filename = <span class="string">"Jabberwocky.txt"</span>;</span><br><span class="line">infile.<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>());  <span class="comment">// open方法需要一个C样式的字符串作为文件名</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>传输数据</p>
<p>打开数据文件之后，就可以使用适当的流操作来执行实际的 I/O
操作。可以逐字符传输，也可以逐行传输。</p></li>
<li><p>关闭文件</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.<span class="built_in">close</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="单个字符-io">单个字符 I/O</h3>
<h4 id="输入流">输入流</h4>
<p>使用<code>get()</code>方法获取单个字符，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch; </span><br><span class="line">infile.<span class="built_in">get</span>(ch);</span><br></pre></td></tr></tbody></table></figure>
<p>连续读取字符：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* get将下一个字符读入变量ch并返回流。如果get操作成功，则该流被解释为true，如果失败，则被解释为false</span></span><br><span class="line"><span class="comment">* 实际上 get 的返回值是 int 类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> ch; </span><br><span class="line"><span class="keyword">while</span> (infile.<span class="built_in">get</span>(ch)) { </span><br><span class="line">   Perform some operation on the character. </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 下面是另一种写法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) { </span><br><span class="line">   <span class="type">int</span> ch = infile.<span class="built_in">get</span>(); </span><br><span class="line">   <span class="keyword">if</span> (ch == EOF) <span class="keyword">break</span>;   <span class="comment">// end-of-file</span></span><br><span class="line">   Perform some operation on the character. </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="输出流">输出流</h4>
<p>使用<code>put</code>函数，该函数采用char值作为参数，并将该字符写入流中，如下所示：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outfile.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="string-streamssstream">String streams（&lt;sstream&gt;）</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istringstream  //字符串输入流 类，可用于字符串转整型</span><br><span class="line">ostringstream  //字符串输出流 类，可用于整型转字符串</span><br></pre></td></tr></tbody></table></figure>
<h2 id="chapter-5">Chapter 5</h2>
<p>集合类（抽象数据类型）：Vector，Stack，Queue，Map，Set</p>
<h3 id="vector">Vector</h3>
<ol type="1">
<li>头文件 <code>#include &lt;vector&gt;</code></li>
<li>定义一个整型vector：<code>vector&lt;int&gt; vec;</code>
（该vector为空）</li>
<li>向结尾添加新元素：<code>vec.push_back(10);</code></li>
<li>向vector中间插入元素：<code>vec.insert(index, num);</code></li>
<li>删除元素：<code>vec.erase(index);</code></li>
<li>访问元素：类似于数组，通过下标访问例如<code>vec[2]</code>，或者通过<code>vec.at(2)</code>访问</li>
<li>获取vector大小：<code>vec.size()</code></li>
<li>二维数组：<code>vector&lt; vector&lt;int&gt; &gt; a;</code>或者指定二维数组的行和列大小<code>vector&lt; vector&lt;int&gt; &gt; a(r, vector&lt;int&gt;(c));</code>（r为行数，c为列数）</li>
</ol>
<h3 id="stack">Stack</h3>
<p>先进后出</p>
<ul>
<li>头文件：<code>#include &lt;stack&gt;</code></li>
<li><code>push()</code>: 在栈顶添加一个元素。</li>
<li><code>pop()</code>: 移除栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用，但不移除它。</li>
<li><code>empty()</code>: 检查栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量</li>
</ul>
<h3 id="queue">Queue</h3>
<p>先进先出</p>
<ul>
<li>头文件：<code>#include &lt;queue&gt;</code></li>
<li><code>empty()</code>: 检查队列是否为空。</li>
<li><code>size()</code>: 返回队列中的元素数量。</li>
<li><code>front()</code>: 返回队首元素的引用。</li>
<li><code>back()</code>: 返回队尾元素的引用。</li>
<li><code>push()</code>: 在队尾添加一个元素。</li>
<li><code>pop()</code>: 移除队首元素。</li>
</ul>
<h3 id="map">Map</h3>
<p>概念上类似于字典。一个<code>key</code>对应一个<code>value</code>（键值对）</p>
<ul>
<li><p>头文件：<code>#include &lt;map&gt;</code></p></li>
<li><p>声明
map：<code>map&lt;key_type, value_type&gt; myMap;</code></p></li>
<li><p>Stanford的<code>map.h</code>库使用<code>put(key, value)</code>将<code>key</code>与<code>value</code>进行关联，使用<code>get(key)</code>获取<code>value</code></p>
<p>或者直接<code>myMap[key] = value;</code></p></li>
<li><p><code>find(key)</code>返回指向该元素的迭代器，示例：https://www.cainiaojc.com/cpp/cpp-map-find-function.html</p></li>
</ul>
<h3 id="set">Set</h3>
<p>set中的每个元素都是唯一的</p>
<ul>
<li>头文件：<code>#include &lt;set&gt;</code></li>
</ul>
<blockquote>
<p>集合类的for循环简化：Range-based
for（只读，不能修改variable；若要修改可通过引用实现）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (type variable : collection) { </span><br><span class="line">   body of the loop </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h2 id="chapter-6">Chapter 6</h2>
<p>类</p>
<h3 id="结构体">结构体</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line">Point p;</span><br></pre></td></tr></tbody></table></figure>
<p>C++中可直接用结构体名称声明变量（<strong>C语言中必须使用</strong><code>struct Point p;</code>进行声明）</p>
<blockquote>
<p><strong>1. 使用 <code>struct</code>
关键字来定义和引用结构体类型</strong></p>
<p>C 语言的结构体类型必须使用 <code>struct</code> 关键字，直接使用
<code>struct</code> 名称进行命名和访问。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> {</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时必须加上 `struct` 关键字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>2. 使用 <code>typedef</code> 为结构体创建别名</strong></p>
<p>如果你不想每次使用结构体时都加上 <code>struct</code> 关键字，可以用
<code>typedef</code> 为结构体创建一个简化的别名。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">} Point;  <span class="comment">// 给结构体类型起别名为 Point</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时不需要 `struct` 关键字</span></span><br><span class="line">Point p;</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="类">类</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="type">int</span> x;</span><br><span class="line">    	<span class="type">int</span> y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>类与结构体的区别在于类中的字段可分为<code>public</code>和<code>private</code>两个部分</p></li>
<li><p>在现代面向对象编程中，不鼓励声明公共实例变量。常见的做法是将所有实例变量设置为私有，这意味着客户端无法直接访问内部变量。而是通过类中的函数来访问私有变量。</p></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> x;</span><br><span class="line">    	<span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>{  <span class="comment">// 通过公有函数访问私有变量</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="构造函数constructor">构造函数（Constructor）</h4>
<ul>
<li>构造函数始终与类同名，大多数类一般会有一个不带参数的默认构造函数。</li>
<li>类通常定义多个版本的构造函数，以考虑不同的初始化模式</li>
<li>构造函数可以进行重载</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Point</span>() {  <span class="comment">// 默认构造函数</span></span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    	</span><br><span class="line">    	<span class="built_in">Point</span>(<span class="type">int</span> xc, <span class="type">int</span> yc) {  <span class="comment">// 含参数的构造函数</span></span><br><span class="line">            x = xc;</span><br><span class="line">            y = yc;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol type="1">
<li><strong>构造函数体内赋值：</strong></li>
</ol>
<ul>
<li>先调用成员变量的默认构造函数，然后在构造函数体内对它们进行赋值操作。</li>
<li>对于基础类型没有明显区别，但对于类成员（如对象、容器等），会多一次默认构造和赋值操作。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) {</span><br><span class="line">        a = x;  <span class="comment">// 先默认构造，再赋值</span></span><br><span class="line">        b = y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol start="2" type="1">
<li><strong>初始化列表：</strong></li>
</ol>
<ul>
<li>在构造对象时直接调用带参数的构造函数进行<strong>初始化</strong>，<strong>避免了不必要的赋值操作</strong>。</li>
<li>对于需要初始化的成员变量（如<code>const</code>成员、引用成员，或者没有默认构造函数的对象），必须使用初始化列表。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) {  <span class="comment">// 初始化列表直接初始化</span></span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="拷贝构造函数">拷贝构造函数</h4>
<blockquote>
<ol type="1">
<li><p>如果你没有定义自己的拷贝构造函数，C++
会为类生成一个<strong>默认</strong>的拷贝构造函数。这个默认拷贝构造函数只是简单地逐成员地复制对象的每个成员变量，称为
<strong>浅拷贝</strong>。</p>
<p>浅拷贝在复制对象时，只会复制指针的地址而不会复制其指向的数据，可能会导致多个对象指向同一块内存区域，这会引发
<strong>双重释放</strong> 或 <strong>悬空指针</strong> 等问题。</p></li>
<li><p>如果类中有需要特殊管理的资源（例如动态分配的内存、文件句柄等），你通常需要编写自定义的拷贝构造函数来实现
<strong>深拷贝</strong>，即复制这些资源，而不仅仅是复制指针。</p></li>
</ol>
</blockquote>
<p>默认拷贝构造函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>拷贝构造函数的参数使用的是<strong>引用</strong>（<code>&amp;</code>），而不是按值传递，这是因为按值传递会调用另一个拷贝构造函数来传递参数，这样就会导致<strong>无限递归调用</strong>。</p></li>
<li><p>使用 <code>const</code>
修饰引用是为了防止在拷贝过程中对传入的对象进行修改。</p></li>
<li><p>使用 <code>const</code>
还能确保拷贝构造函数可以处理<strong>临时对象</strong>（即右值）。如果不加
<code>const</code>，则不能对一个临时对象（如
<code>HeapPQueue()</code>）进行拷贝，因为临时对象无法绑定到非
<code>const</code> 引用。示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapPQueue hq1 = <span class="built_in">HeapPQueue</span>();  <span class="comment">// 临时对象可以绑定到 const 引用</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>拷贝构造函数会在以下情况下被调用：</p>
<ol type="1">
<li><p><strong>对象的按值传递</strong>：当一个对象通过值传递给函数时，C++
会创建该对象的副本，调用拷贝构造函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span></span>;  <span class="comment">// obj 作为参数，是按值传递的，会调用拷贝构造函数</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>对象作为返回值按值返回</strong>：当一个对象从函数中按值返回时，也会调用拷贝构造函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">bar</span><span class="params">()</span> </span>{</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;  <span class="comment">// 按值返回，调用拷贝构造函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>用现有对象初始化新对象</strong>：当用一个现有对象来初始化另一个对象时（例如通过赋值），也会调用拷贝构造函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2 = obj1;  <span class="comment">// obj2 是用 obj1 初始化的，调用拷贝构造函数</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>对象被放入 STL 容器</strong>：当你将对象放入 STL 容器（如
<code>std::vector</code>、<code>std::map</code>
等）中时，这些容器可能会通过拷贝构造函数来复制对象。</p></li>
</ol>
<h4 id="析构函数">析构函数</h4>
<blockquote>
<p><strong>析构函数</strong>的作用是在对象的生命周期结束时执行清理工作，特别是释放对象持有的动态资源（例如内存、文件句柄、网络连接等）。它确保在对象销毁时，相关的资源能够被正确释放，避免内存泄漏等问题。</p>
<p>如果类中没有显式定义析构函数，编译器会生成一个<strong>默认的析构函数</strong>，但这个默认析构函数只会销毁基本数据类型和自动管理的成员。如果类中包含动态分配的内存或其他需要手动管理的资源，默认析构函数不会释放这些资源，可能会导致<strong>内存泄漏</strong>或<strong>资源泄露</strong>。</p>
</blockquote>
<ol type="1">
<li><p>定义</p>
<p>析构函数的名字是类名的前面加一个波浪号
<code>~</code>，并且它没有参数和返回值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ClassName</span>() {</span><br><span class="line">    <span class="comment">// 清理工作，如释放动态内存</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>调用：</p>
<ul>
<li>当对象离开作用域时，自动调用析构函数。</li>
<li>如果对象是通过 <code>new</code> 分配的，当对其调用
<code>delete</code> 时，析构函数会被调用。</li>
<li>当一个类的对象在程序结束时被销毁，析构函数会自动调用。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() {</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 动态分配内存</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] data;  <span class="comment">// 释放内存，防止内存泄漏</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="接口与实现分离">接口与实现分离</h4>
<ul>
<li><p>将类的定义以及类的函数原型写在<code>.h</code>文件中，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File: point.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _point_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _point_h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>();</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xc, <span class="type">int</span> yc);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>#ifndef _point_h</code>：如果符号 <code>_point_h</code>
没有定义，则继续编译。</p>
<p><code>#define _point_h</code>：定义符号
<code>_point_h</code>，防止后续重复包含。</p>
<p><code>#endif</code>：结束条件编译，确保头文件内容只被编译一次。</p>
<p>上述代码是为了防止“重复定义”错误</p>
</blockquote></li>
<li><p>将函数的具体实现写在<code>.cpp</code>文件中（注意函数名前要加类名作为限定符），如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File: point.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>() {</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">int</span> xc，<span class="type">int</span> yc) {</span><br><span class="line">    x = xc;</span><br><span class="line">    y = yc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::getX</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::gety</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="运算符重载">运算符重载</h3>
<ul>
<li><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator
和其后要重载的运算符符号构成的，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="keyword">operator</span>+(Point p1, Point p2);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>&lt;&lt;</code>运算符也可以参与重载，难点在于该运算符的类型，它通常和
<code>std::ostream</code> 类型结合使用，示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, Point point) {   <span class="comment">// 这里的 &amp; 是必须要添加的</span></span><br><span class="line">    <span class="comment">// os表示输出流对象，可以是 std::cout 或文件输出流</span></span><br><span class="line">    os &lt;&lt; <span class="string">"("</span> &lt;&lt; point.x &lt;&lt; <span class="string">", "</span> &lt;&lt; point.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>如果不返回 <code>std::ostream &amp;</code>，而是返回
<code>std::ostream</code>（即按值返回），则每次 <code>&lt;&lt;</code>
操作都会创建一个新的 <code>std::ostream</code>
对象，丢失原始流的上下文信息</p>
</blockquote></li>
<li><p><code>==</code>运算符重载，下面以Point类为例，假设该函数属于类的成员，因此可以访问私有变量x和y</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Point::<span class="keyword">operator</span>==(Point rhs) {   <span class="comment">// 若在类内实现该函数则省略“Point”前缀</span></span><br><span class="line">   <span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>++</code>运算符重载需要注意是前缀还是后缀，后缀情况下（<code>i++</code>），参数里需要添加<code>int</code>，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Direction <span class="keyword">operator</span>++(Direction &amp; dir, <span class="type">int</span>) {  </span><br><span class="line">   Direction old = dir; </span><br><span class="line">   dir = <span class="built_in">Direction</span>(dir + <span class="number">1</span>); </span><br><span class="line">   <span class="keyword">return</span> old;  <span class="comment">// ++ 作为后缀，则操作数先返回原值在自增</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="友元函数">友元函数</h3>
<p>类的友元函数在类中声明，但不属于类的成员，但有权访问类的所有私有（private）成员和保护（protected）成员。</p>
<ul>
<li><p>友元函数在类中声明时需要添加<code>friend</code>前缀</p></li>
<li><p>示例，若<code>==</code>运算符不是Point类的成员但是想要访问私有成员，则需要在类中声明</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">operator</span>==(Point rhs);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>友元类：可以访问另一个类的成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line">	......</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Point</span>; <span class="comment">// Point可以访问Building类中的成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="chapter-7">Chapter 7</h2>
<p>递归</p>
<h2 id="chapter-8">Chapter 8</h2>
<h3 id="汉诺塔问题">汉诺塔问题</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveTower</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> start, <span class="type">char</span> finish, <span class="type">char</span> tmp)</span> </span>{ </span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">1</span>) { </span><br><span class="line">      Move a single disk from start to finish. </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      Move a tower of size n - <span class="number">1</span> from start to tmp. </span><br><span class="line">      Move a single disk from start to finish. </span><br><span class="line">      Move a tower of size n - <span class="number">1</span> from tmp to finish. </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="子集求和">子集求和</h3>
<p>每个元素有两种可能：在子集内，不在子集内</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subsetSumExists</span><span class="params">(Set&lt;<span class="type">int</span>&gt; &amp; set, <span class="type">int</span> target)</span> </span>{ </span><br><span class="line">   <span class="keyword">if</span> (set.<span class="built_in">isEmpty</span>()) { </span><br><span class="line">      <span class="keyword">return</span> target == <span class="number">0</span>; </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      <span class="type">int</span> element = set.<span class="built_in">first</span>(); </span><br><span class="line">      Set&lt;<span class="type">int</span>&gt; rest = set - element; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">subsetSumExists</span>(rest, target)   <span class="comment">// 在子集内</span></span><br><span class="line">          || <span class="built_in">subsetSumExists</span>(rest, target - element);  <span class="comment">// 不在子集内</span></span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="排列">排列</h3>
<p>例如<code>ABC</code>的排列是<code>{ "ABC", "ACB", "BAC", "BCA", "CAB", "CBA" }</code></p>
<p>若是对n个字符进行排列，可先选取一个字符，然后对剩余的 n-1
个字符进行排列</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">generatePermutations</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    set&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="string">""</span>)</span><br><span class="line">        ans.<span class="built_in">insert</span>(str);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">length</span>(); i++) {</span><br><span class="line">            <span class="type">char</span> c = str[i];</span><br><span class="line">            string rest = str.<span class="built_in">substr</span>(<span class="number">0</span>, i) + str.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(string s : <span class="built_in">generatePermutations</span>(rest)) {   <span class="comment">// 递归</span></span><br><span class="line">                ans.<span class="built_in">insert</span>(c+s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="chapter-9">Chapter 9</h2>
<p>回溯算法</p>
<h2 id="chapter-10">Chapter 10</h2>
<p>算法分析</p>
<h3 id="big-o">big-O</h3>
<p>描述算法的时间复杂度</p>
<h3 id="选择算法">选择算法</h3>
<ul>
<li>选取 [i, n-1] 区间内最小/最大的元素与i处的元素交换次序</li>
<li>排序趟数与序列的原始状态无关</li>
<li>比较次数也与序列初始状态无关</li>
<li>时间复杂度：O(n<sup>2</sup>)</li>
</ul>
<h3 id="归并排序">归并排序</h3>
<ul>
<li><p>先从中间划分两个子序列，对左侧子序列递归排序，对右侧子序列递归排序，归并</p></li>
<li><p>时间复杂度：O(nlogn)</p></li>
</ul>
<h3 id="不同时间复杂度">不同时间复杂度</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240926125413614.png" alt="image-20240926125413614">
<figcaption aria-hidden="true">image-20240926125413614</figcaption>
</figure>
<h3 id="快速排序">快速排序</h3>
<p>归并排序在实践中用的不多。快速排序也用到了分治的思想。</p>
<ul>
<li>最简单的策略是选择向量中的第一个元素作为枢轴</li>
<li>两端有low和high指针，一趟排序结束后分为两个子序列。枢轴处于其最终位置</li>
<li>若是从小到大排序，则枢轴左边的子序列所有值小于枢轴右边的子序列所有值</li>
<li>详细步骤：
<ul>
<li>先移动high指针找到比枢轴小的元素。若找不到则会与low重合</li>
<li>若找到满足条件的元素，high指针停止移动，开始移动low指针找到比枢轴大的元素，若找不到则会与high重合</li>
<li>若找到满足条件的元素，且两个指针未重合，交换两个指针指向的元素</li>
<li>若两个指针重合且low指向的元素小于枢轴元素，则交换两个元素</li>
</ul></li>
<li>平均时间复杂度：O(nlogn)</li>
<li>最坏情况——有序：O(n<sup>2</sup>)</li>
</ul>
<h2 id="chapter-11">Chapter 11</h2>
<p>指针与数组</p>
<h3 id="二进制和十六进制">二进制和十六进制</h3>
<ul>
<li>无符号数</li>
<li>有符号数（补码）</li>
<li>内存地址一般用十六进制表示</li>
</ul>
<h3 id="内存">内存</h3>
<ul>
<li>进程地址空间</li>
<li>栈帧：<strong>函数调用</strong>期间保存在栈中的数据结构，用于存储参数、局部变量和返回地址等</li>
</ul>
<h3 id="指针">指针</h3>
<p>存放内存地址的数据项被称为指针</p>
<h4 id="指针声明">指针声明</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">// 指向int的指针</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>* + 指针名</code>：获取指针指向的值</p></li>
<li><p><code>&amp; + 变量名</code>：获取该变量所在的内存地址</p></li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> *p1, *p2;</span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">y = <span class="number">163</span>;</span><br><span class="line">p1 = &amp;y;  <span class="comment">// 使p1指向y</span></span><br><span class="line">p2 = &amp;x;  <span class="comment">// 使p2指向x</span></span><br></pre></td></tr></tbody></table></figure>
<p>经过以上操作后，内存如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241010145846709.png"></p></li>
<li><p>若要修改<code>y</code>的值，可以使用下面的语句：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p1 = <span class="number">17</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>当指针指向一个对象时，可通过<code>-&gt;</code>以及<code>.</code>来访问该对象的成员，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">pt</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; </span><br><span class="line">Point *pp = &amp;pt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行是等价的</span></span><br><span class="line">(*pp).<span class="built_in">getX</span>();</span><br><span class="line">pp-&gt;<span class="built_in">getX</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="关键字-this">关键字 <code>this</code></h3>
<ul>
<li><p><code>this</code>是指向当前变量的指针</p></li>
<li><p>使用<code>this</code>可以避免类中构造函数中的变量冲突，同时方便用户理解：</p></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) { </span><br><span class="line">   <span class="keyword">this</span>-&gt;x = x; </span><br><span class="line">   <span class="keyword">this</span>-&gt;y = y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="空指针">空指针</h3>
<ul>
<li>使用常量<code>NULL</code>表示空指针</li>
<li>对空指针使用<code>*</code>运算符是违法的</li>
</ul>
<h3 id="引用">引用</h3>
<ul>
<li><p>将参数通过引用进行传递时，栈帧会存储指针，指针指向该值所在的调用函数中的位置。对该值的任何更改在函数返回后仍然有效</p></li>
<li><p>不使用引用，而是直接通过指针进行swap操作：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *px, <span class="type">int</span> *py)</span> </span>{ </span><br><span class="line">    <span class="type">int</span> tmp = *px; </span><br><span class="line">    *px = *py; </span><br><span class="line">    *py = tmp; </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">swap</span>(&amp;n1, &amp;n2); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>指针引用：例如<code>int* &amp; p;</code>表示对指针p的引用</p></li>
</ul>
<h3 id="数组">数组</h3>
<ul>
<li><p>数组定义：<code>type name[size];</code></p></li>
<li><p>数组元素访问通过数组下标（索引）</p></li>
<li><p>通过<code>sizeof</code>获取数组长度以及元素大小</p></li>
<li><p>数组名称与指向初始元素的指针相同</p></li>
<li><p>数组作为参数被调用时，与引用的效果相同，例如下面的代码能够对传入的数组进行排序</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> n)</span> </span>{   <span class="comment">// 或者写成 void sort(int *array, int n) </span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> lh = <span class="number">0</span>; lh &lt; n; lh++) { </span><br><span class="line">      <span class="type">int</span> rh = lh; </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = lh + <span class="number">1</span>; i &lt; n; i++) { </span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; array[rh]) rh = i; </span><br><span class="line">      } </span><br><span class="line">      <span class="built_in">swap</span>(array[lh], array[rh]); </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符数组使用<code>strcpy</code>函数时，没有尝试检查目标是否有足够的空间来保存源字符串的副本。如果没有足够的内存来保存完整的字符串，其他特殊用途的内存可能会被覆盖。这种形式的问题称为缓冲区溢出错误</p></li>
</ul>
<h2 id="chapter-12">Chapter 12</h2>
<p>动态内存管理</p>
<ul>
<li>动态内存管理是对<strong>堆</strong>进行操作</li>
<li>vector、map等集合类都是存放在堆上的</li>
</ul>
<h3 id="new操作符"><code>new</code>操作符</h3>
<ul>
<li><p><code>new</code>操作符从<strong>堆</strong>中分配内存，会返回堆中为保存对象而留出的存储位置的<strong>地址</strong>，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip = <span class="keyword">new</span> <span class="type">int</span>;   <span class="comment">// 等号右边返回的是内存指针</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>动态数组：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> *array = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">3</span>];</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>动态对象：在堆上为 Rational 对象分配空间并调用缺省构造函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational *rp = <span class="keyword">new</span> Rational;</span><br></pre></td></tr></tbody></table></figure>
<p>若在类型名称后面提供参数，则会调用对应的构造函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational *rp = <span class="keyword">new</span> <span class="built_in">Rational</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="chapter-13">Chapter 13</h2>
<h3 id="文本编辑软件模式">文本编辑软件模式</h3>
<ul>
<li><strong>MVC</strong>模式：model-view-controller。以手机文本编辑软件为例，键盘代表控制器，显示器代表视图，底层数据结构代表模型</li>
<li>大多数编辑器都是使用模型-视图-控制器模式设计的。在模型内部，编辑器维护一个字符序列，通常称为缓冲区。控制器允许您对缓冲区的内容执行各种操作</li>
</ul>
<h3 id="数组栈链表">数组、栈、链表</h3>
<p>三种方法实现文本编辑功能在效率上的区别</p>
<ul>
<li>数组：插入和删除操作需要O(n)</li>
<li>栈：分为光标左右两个栈，光标移动到开头和结尾需要O(n)</li>
<li>单链表：光标向左移动和移动到结尾需要O(n)</li>
<li>双链表：解决上述单链表的缺点，上述两个操作只需要 O(1)
时间复杂度</li>
</ul>
<h2 id="chapter-14">Chapter 14</h2>
<p>模板</p>
<h3 id="模板函数">模板函数</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;  <span class="comment">// ValueType是占位符，表示数据类型</span></span><br><span class="line"><span class="function">ValueType <span class="title">max</span><span class="params">(ValueType x, ValueType y)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &gt; y) ? x : y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每当编译器遇到一个模板函数应用于它尚未处理过的类型时，它都会生成一个适用于该类型的函数体的全新副本。因此，如果在同一程序中对int、double、char、string使用max函数，编译器将生成四个代码副本，每种类型一个。</p>
<p>“模板”提供的是一种模式，使得编译器可以在需要时从中生成专门定制的版本。</p>
<blockquote>
<p><code>template &lt;class T&gt;</code>：这是早期 C++
规范中的写法，<code>class</code> 关键字用于定义模板参数的类型。</p>
<p><code>template &lt;typename T&gt;</code>：这是 C++
标准化后引入的一种更加语义化的写法，<code>typename</code>
关键字强调模板参数表示的是一种类型</p>
</blockquote>
<h3 id="模板类">模板类</h3>
<ul>
<li><p>在类定义前一行添加<code>template &lt;typename ValueType&gt;</code>，那么类中的所有成员函数都会自动使用这个模板参数
<code>T</code>，因为这个模板参数是与类绑定的。你不需要再为每个成员函数重新声明<code>template &lt;typename ValueType&gt;</code>。</p></li>
<li><p>在模板类中如果你只是声明了函数，并打算在类的<strong>外部</strong>实现它，那么在实现时需要在函数定义之前<strong>添加</strong>
<code>template&lt;typename T&gt;</code>。示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">show</span>() { <span class="comment">// 注意指明该函数是属于MyClass的成员函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Data: "</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="chapter-15">Chapter 15</h2>
<h3 id="maps">Maps</h3>
<ul>
<li>映射：通过查找map查找元素，时间复杂度为O(n)</li>
</ul>
<h3 id="哈希">哈希</h3>
<p>通过key找到value的位置</p>
<ul>
<li><p>选择一个函数将key转换为整数值（哈希码）</p></li>
<li><p>该策略（利用哈希函数进行映射）可抽象出哈希表</p></li>
<li><p>链表数组（数组每个元素是链表）：数组的每一个元素（链表）被称为
<strong>bucket</strong></p></li>
<li><p>哈希码的取值范围通常远大于桶的数量，可以通过模运算（取余数）将哈希码缩小到桶的范围内</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucket是桶编号，nBucket是桶的数量</span></span><br><span class="line"><span class="type">int</span> bucket = <span class="built_in">hashCode</span>(key) % nBuckets;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>将两个或更多不同的键哈希与同一存储桶的键称为<strong>碰撞</strong></p></li>
<li><p>负载因子α：计算公式为：<span class="math inline">\(\alpha =
\frac{n}{m}\)</span></p>
<ul>
<li>n：当前哈希表中存储的元素数量。</li>
<li>m：哈希表中桶（槽）的数量。</li>
<li><strong>较低的负载因子</strong>：表示哈希表中有许多空桶，这通常意味着插入和查找操作的平均时间复杂度较低，因为发生碰撞的概率较小。</li>
<li><strong>较高的负载因子</strong>：表示哈希表中接近满的状态，可能会导致较多的碰撞，从而增加查找和插入操作的时间复杂度</li>
</ul></li>
<li><p><strong>HashMap</strong>：map的查找速度一般是O(n)，而hashMap查找速度是O(1)</p></li>
</ul>
<h2 id="chapter-16">Chapter 16</h2>
<p>树</p>
<h3 id="二叉搜索树bst">二叉搜索树（BST）</h3>
<ul>
<li>二叉搜索树的每个节点的权值都是唯一的</li>
<li>左子树 &lt; 根节点 &lt; 右子树</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> { </span><br><span class="line">   string key; </span><br><span class="line">   BSTNode *left, *right; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="插入节点">插入节点</h4>
<ul>
<li><p>使用二分查找的思想</p></li>
<li><p>从根节点开始递归，小于根节点就进入左子树，否则进入右子树，直到找到插入位置</p>
<p>注意：插入值不能与二叉排序树中的值重复</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *注意这里使用的是对指针的引用，因为函数类型是void，无返回值，只在函数内修改值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(BSTNode * &amp; t, <span class="type">const</span> string &amp; key)</span> </span>{   </span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>) { </span><br><span class="line">      t = <span class="keyword">new</span> BSTNode; </span><br><span class="line">      t-&gt;key = key; </span><br><span class="line">      t-&gt;left = t-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      <span class="keyword">if</span> (key != t-&gt;key) { </span><br><span class="line">         <span class="keyword">if</span> (key &lt; t-&gt;key) { </span><br><span class="line">            <span class="built_in">insertNode</span>(t-&gt;left, key); </span><br><span class="line">         } <span class="keyword">else</span> { </span><br><span class="line">            <span class="built_in">insertNode</span>(t-&gt;right, key); </span><br><span class="line">         } </span><br><span class="line">      } </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="删除节点">删除节点</h4>
<p>共有三种情况，假设要删除的节点为 z</p>
<ul>
<li>叶结点：直接删除</li>
<li>只有一棵子树：让子树成为 z 的父结点的子树</li>
<li>有左右两个子树：令<strong>右子树最左下结点/直接后继（或左子树最右下结点/直接前驱）</strong>代替
z，然后删除直接后继/直接前驱结点</li>
</ul>
<p>注意：删除一个结点可能会影响多个结点，因此可能要操作多次</p>
<h4 id="遍历">遍历</h4>
<ul>
<li><strong>中序遍历</strong>（左根右）可以得到有序序列</li>
<li>先序遍历（根左右）</li>
<li>后序遍历（左右根）</li>
</ul>
<h3 id="平衡二叉树">平衡二叉树</h3>
<p>二叉搜索树的最坏情况是每个节点只有一个子树，此时查找操作的时间复杂度是O(n).</p>
<ul>
<li>平衡二叉树的左右子树高度相差不超过1</li>
<li>二叉搜索树在平衡时才能保证查找的时间复杂度为O(logn)</li>
</ul>
<h4 id="avl算法">AVL算法</h4>
<p>操作对象是最小不平衡子树</p>
<ol type="1">
<li><strong>单旋转操作</strong>
<ul>
<li><strong>LL</strong>平衡旋转（右单旋转）：在左孩子的左子树插入结点，需要旋转<strong>左孩子结点</strong></li>
<li><strong>RR</strong>平衡旋转（左单旋转）：在右孩子的右子树插入结点，需要旋转<strong>右孩子结点</strong></li>
</ul></li>
<li><strong>双旋转操作</strong>
<ul>
<li><strong>LR</strong>平衡旋转（先左后右）：在左孩子的右子树插入结点，旋转<strong>左孩子</strong>的<strong>右子树的根结点</strong>（先左后右，操作的是同一个节点）</li>
<li><strong>RL</strong>平衡旋转（先右后左）：在右孩子的左子树插入结点，旋转<strong>右孩子</strong>的<strong>左子树的根结点</strong>（先右后左，操作的是同一个节点）</li>
</ul></li>
</ol>
<p><strong>代码实现</strong>：需要在节点结构中添加平衡因子（左右节点高度差）</p>
<h2 id="chapter-18">Chapter 18</h2>
<p>图</p>
<h3 id="图的结构">图的结构</h3>
<ul>
<li>vertex ：顶点</li>
<li>edge ：边，弧</li>
<li>有向图</li>
<li>无向图</li>
<li>路径：从一个节点到另一个节点经过的弧的集合</li>
<li>回路：在同一个节点开始和结束</li>
<li>简单路径：不出现重复的节点</li>
<li>度：相邻节点数</li>
<li>入度（进入该节点）、出度（离开该节点）：有向图</li>
<li>连通图（无向图）：任意两个节点是连通的</li>
<li>连通分量：极大连通子图</li>
<li>强连通图（有向图）：任意一对顶点 v、w ，从 v 到 w、从 w 到 v
均有路径</li>
</ul>
<h3 id="图的表示形式">图的表示形式</h3>
<h4 id="邻接表">邻接表</h4>
<ul>
<li>对图的每个顶点建立一个单链表（<strong>边表</strong>），指向单链表的顶点组成顶点表（数组）</li>
<li>更适合处理稀疏图</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815093150181.png"></p>
<h4 id="邻接矩阵">邻接矩阵</h4>
<ul>
<li>使用二维数组存放各个节点的度，或者用布尔值表示弧是否存在</li>
<li>空间复杂度O(n<sup>2</sup>)</li>
<li>更适合处理稠密图</li>
</ul>
<h3 id="图的遍历">图的遍历</h3>
<h4 id="深度优先搜索">深度优先搜索</h4>
<ul>
<li>利用循环遍历节点，在循环中调用递归</li>
<li>记录访问过的节点</li>
</ul>
<h4 id="广度优先搜索">广度优先搜索</h4>
<ul>
<li>每一轮访问与当前节点相邻的节点</li>
<li>使用队列存放当前要访问的节点</li>
<li>访问出队节点的相邻节点</li>
<li>队空则循环结束</li>
</ul>
<h3 id="最短路径">最短路径</h3>
<h4 id="dijkstra-算法">Dijkstra 算法</h4>
<ul>
<li>使用优先队列存放源点到各点的路径长度</li>
<li>利用一个集合 S 存放已被访问过的顶点</li>
<li>步骤：
<ol type="1">
<li>优先队列初始化为空</li>
<li>先将源点添加到 S 中</li>
<li>然后访问与源点相邻的顶点，并将对应的路径存入优先队列中（从小到大排列）</li>
<li>弹出优先队列队顶元素（最小），访问该点的相邻顶点并加入优先队列</li>
<li>重复上述步骤直到目标顶点</li>
</ol></li>
</ul>
<h2 id="chapter-19">Chapter 19</h2>
<p>继承</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">subclass</span> : <span class="keyword">public</span> superclass {</span><br><span class="line">    <span class="comment">// new entries for subclass</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>subclass</code>继承了<code>superclass</code>的所有公共成员，但不能直接访问<code>superclass</code>的私有成员</p>
<p>派生类对象同时也是基类对象</p>
<h3 id="公有派生">公有派生</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">	......  </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent {</span><br><span class="line">	......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>基类的公有成员将成为派生类的公有成员，派生类只能通过基类的<strong>公有方法</strong>或<strong>保护方法</strong>访问基类的私有成员</p></li>
<li><p>构造函数：派生类不能直接访问基类的私有成员，因此派生类的构造函数需要<strong>调用基类构造函数</strong></p>
<blockquote>
<p>子类的构造函数在执行时<strong>一定会</strong>调用父类的构造函数。这是因为子类的对象不仅包含子类自身的数据成员，还包含从父类继承的那些数据成员。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员，派生类无法直接访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类的构造函数，用于初始化私有成员</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) : <span class="built_in">privateVar</span>(x) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base constructor called, privateVar = "</span> &lt;&lt; privateVar &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类的构造函数，通过调用基类的构造函数初始化基类的私有成员</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived constructor called."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 创建派生类对象，间接初始化基类的私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>访问控制：<strong>protected</strong></p>
<ul>
<li>对于外部世界来说，保护成员和私有成员类似，都不能被直接访问</li>
<li><strong>在派生类中</strong>，可以<strong>直接访问</strong>基类的
<code>protected</code> 和 <code>public</code>
成员。这意味着在派生类的成员函数中，可以直接使用 <code>protected</code>
和 <code>public</code> 成员变量或成员函数。</li>
<li><strong>在派生类的对象上</strong>，派生类的 <code>public</code>
成员可以在外部直接访问，而 <code>protected</code>
成员只能在派生类或其子类的成员函数中访问，<strong>不能通过对象在外部访问</strong>。</li>
</ul>
</blockquote></li>
</ul>
<h3 id="虚函数">虚函数</h3>
<p>实现多态</p>
<ul>
<li><p>虚函数：子类中的函数覆盖父类函数。（在对应函数前添加<code>virtual</code>）</p>
<p>函数在基类中被声明为虚的后，它在派生类中将自动成为虚函数，不过在派生类中也使用virtual能更直观</p>
<blockquote>
<p><strong>覆盖</strong>：子类提供了一个与父类虚函数具有相同函数签名（函数名、参数类型、参数个数）的实现，称为覆盖。这个新函数将替代父类中的虚函数实现，当通过基类指针或引用调用该函数时，实际执行的是子类的实现（<strong>动态绑定</strong>）</p>
</blockquote></li>
<li><p>纯虚函数：对应函数在基类中未被实现（除了添加<code>virtual</code>还需要在函数结尾添加<code>= 0</code>，如下）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是<strong>抽象类</strong>，抽象类<strong>不能被用于实例化对象</strong>，它只能作为<strong>接口</strong>使用。</p>
</blockquote></li>
</ul>
<p>注意：构造函数不能是虚函数；友元函数不能是虚函数，因为友元函数不属于类成员</p>
<h3 id="虚析构函数">虚析构函数</h3>
<ul>
<li><p>如果析构函数不是虚的，则将只调用对应于指针类型的析构函数，这意味着即使指针指向的是一个派生类对象，只有基类的析构函数被调用，则会导致派生类中的资源和成员变量不会被正确释放或清理。</p></li>
<li><p>如果析构函数是虚的，将<strong>调用相应对象类型的析构函数</strong>。因此，如果指针指向的是派生类对象，那么将<strong>先调用派生类的析构函数，然后自动调用基类的析构函数</strong>。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</p></li>
</ul>
<h3 id="指向对象的指针">指向对象的指针</h3>
<ul>
<li><p>子类与父类在内存中所占空间大小可能不同，因此不能直接将子类对象赋值给父类对象。</p></li>
<li><p>使用基类指针指向子类对象是为了实现<strong>多态</strong>（polymorphism）和<strong>动态绑定</strong>（dynamic
binding）</p></li>
<li><p>当基类指针指向子类对象时，该指针的<strong>静态类型</strong>（compile-time
type）是基类类型，而指针实际指向对象的<strong>动态类型</strong>（run-time
type）是子类类型。示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Parent's show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Parent's non-virtual function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>{  <span class="comment">// 或者写成 `virtual void show()`</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Child's show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Child's non-virtual function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Parent* ptr = <span class="keyword">new</span> <span class="built_in">Child</span>();</span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();           <span class="comment">// 动态绑定，调用子类的虚函数</span></span><br><span class="line">    ptr-&gt;<span class="built_in">nonVirtualFunc</span>();  <span class="comment">// 静态绑定，调用基类的非虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>当程序执行到一个函数调用时，系统需要决定调用哪个具体的函数，这个过程就叫做<strong>联编</strong>。联编可以在<strong>编译时</strong>或<strong>运行时</strong>进行，这分别被称为<strong>静态联编</strong>和<strong>动态联编</strong>。</p>
<blockquote>
<p>静态联编：在编译过程中进行联编</p>
<p>动态联编：在程序运行时选择正确的虚函数</p>
</blockquote></li>
</ul>
<h2 id="额外知识">额外知识</h2>
<h3 id="内联函数">内联函数</h3>
<p>程序运行时不需要在内存中跳到对应函数的位置执行代码，在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。（空间换时间）</p>
<ul>
<li>在函数声明或函数定义前添加<code>inline</code>关键字</li>
<li>在类内定义的函数，它具有隐式的 <code>inline</code> 说明符</li>
<li>添加<code>inline</code>关键字的函数不一定能被编译器判定为内联函数：
<ul>
<li>函数过大</li>
<li>函数递归</li>
</ul></li>
</ul>
<h3 id="虚表">虚表</h3>
<p>通常，编译器处理虚函数的方法是：<strong>给每个对象添加一个隐藏成员</strong>。隐藏成员中保存了一个指向函数地址数组的<strong>指针</strong>。这种数组称为<strong>虚函数表</strong>(virtual
function
table,vtbl)。虚函数表中存储了为类对象进行声明的<strong>虚函数地址</strong>。</p>
<p>例如，基类对象包含一个指针，该指针指向基类中包含 所有虚函数地址 的
表。同样的，派生类对象也将包含一个指向独立地址表的指针。</p>
<ul>
<li>如果派生类提供了<strong>虚函数的新定义</strong>，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。</li>
<li>如果派生类定义了<strong>新的虛函数</strong>（与基类的虚函数无关），则该函数的地址也将被添加到vtbl中。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241020224758096.png" alt="image-20241020224758096">
<figcaption aria-hidden="true">image-20241020224758096</figcaption>
</figure>
<h3 id="虚基类">虚基类</h3>
<p><strong>虚基类</strong>（Virtual Base
Class）是C++中的一种机制，主要用于解决<strong>多重继承</strong>中<strong>菱形继承问题</strong>（diamond
problem）。菱形继承问题会导致基类的成员在派生类中出现<strong>重复拷贝</strong>，从而产生潜在的二义性问题（派生类对象可能包含多个相同的基类部分成员）。虚基类通过确保在菱形继承结构中，派生类只继承第一个基类，从而避免了这个问题。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">value</span>(<span class="number">0</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    D d;</span><br><span class="line">    d.value = <span class="number">10</span>;  <span class="comment">// 现在 D 中只有一个 A 的成员变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"D::value: "</span> &lt;&lt; d.value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>或者（不使用虚基类）在代码中显式表明作用域来表示子类使用的是哪一个父类的成员：<code>d.B::value</code></p>
<h3 id="函数隐藏name-hiding">函数隐藏（<strong>name
hiding</strong>）</h3>
<p>是指基类中的成员函数被派生类中<strong>同名</strong>但<strong>不同签名</strong>（参数不同或返回不同）的成员函数覆盖，从而导致基类的函数无法在派生类对象中被直接访问。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base class show(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">double</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base class show(double): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived class show(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>(<span class="number">10</span>);        <span class="comment">// 调用 Derived 的 show(int)</span></span><br><span class="line">    <span class="comment">// d.show(3.14);   // 错误：Derived 中没有 show(double)</span></span><br><span class="line">    d.Base::<span class="built_in">show</span>(<span class="number">3.14</span>); <span class="comment">// 需要明确指定调用基类的 show(double)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在派生类 <code>Derived</code> 中，定义了 <code>show(int)</code>
函数，它<strong>隐藏了</strong>基类 <code>Base</code> 中所有同名的
<code>show()</code> 函数（即 <code>show(int)</code> 和
<code>show(double)</code>）。</li>
<li>因此，当调用 <code>d.show(3.14)</code>
时，会报错，因为编译器只能看到 <code>Derived</code> 中的
<code>show(int)</code> 函数，而 <code>Base</code> 中的
<code>show(double)</code> 函数被隐藏。</li>
<li>如果你仍想调用基类的 <code>show(double)</code> 函数，可以使用
<code>d.Base::show(3.14)</code> 来明确指明调用基类的函数。</li>
</ul>
<h2 id="assignment-0">Assignment 0</h2>
<h3 id="配置环境">配置环境</h3>
<p>安装好Qt后，打开 NameHash.pro 文件，构建报错，报错信息如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Cannot find version <span class="number">2021.1</span> of CS106 library. Install CS106 package following instructions at https:<span class="comment">//web.stanford.edu/dept/cs_edu/qt.  Stop.</span></span><br></pre></td></tr></tbody></table></figure>
<p>于是打开 NameHash.pro
文件查看代码，添加下面代码方便构建时查看对应库的位置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message(USER_DATA_DIR = $$USER_DATA_DIR)</span><br><span class="line">message(SPL_DIR = $$SPL_DIR)</span><br><span class="line">message(STATIC_LIB = $$STATIC_LIB)</span><br><span class="line">message(SPL_VERSION_FILE = $$SPL_VERSION_FILE)</span><br></pre></td></tr></tbody></table></figure>
<p>运行得到：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Project MESSAGE: USER_DATA_DIR = C:/Users/hxt/AppData/Local</span><br><span class="line">Project MESSAGE: SPL_DIR = C:/Users/hxt/AppData/Local/cs106</span><br><span class="line">Project MESSAGE: STATIC_LIB = C:\Users\hxt\AppData\Local\cs106\lib\libcs106.a</span><br><span class="line">Project MESSAGE: SPL_VERSION_FILE = C:\Users\hxt\AppData\Local\cs106\lib\version2023.1</span><br></pre></td></tr></tbody></table></figure>
<p>找到<code>lib</code>文件夹，打开发现版本是<code>2023.1</code>，于是尝试修改
NameHash.pro 文件中的版本信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPL_VERSION = 2021.1  ----&gt;  SPL_VERSION = 2023.1</span><br></pre></td></tr></tbody></table></figure>
<p>再次构建，成功！</p>
<h2 id="assignment-1">Assignment 1</h2>
<h3 id="结构体-1">结构体</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PenStyle</span> {</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    std::string color;</span><br><span class="line">};</span><br><span class="line">PenStyle style = = { <span class="number">1</span>, <span class="string">"black"</span> };  <span class="comment">// C++中结构体的名字可以直接用作类型名称，前面不需要再加struct了</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="warning">Warning</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(3x3 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(3x3 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(12x12 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: QObject::killTimer: Timers cannot be stopped from another thread</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 20204</span><br><span class="line"></span><br><span class="line">Qt internal warning: QObject::~QObject: Timers cannot be stopped from another thread</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 20204</span><br></pre></td></tr></tbody></table></figure>
<p>Qt运行Plot时报错，不知道怎么解决</p>
<h2 id="assignment-2">Assignment 2</h2>
<h3 id="part-one">Part One</h3>
<h4 id="milestone-one">Milestone One</h4>
<ul>
<li>将文本中出现的字符串分为不同子字符串（三元组，可能用UTF-8表示），并统计其出现次数</li>
</ul>
<h4 id="milestone-two">Milestone Two</h4>
<ul>
<li><p>归一化：假设每个子字符串出现次数的平方和为s，然后将每个子字符串出现的次数除以<span class="math inline">\(\sqrt{s}\)</span>，得到对应的频率，例如下面的示例：</p>
<blockquote>
<p>"aaa": 3 "baa": 1 "aab": 1</p>
<p>计算平方和：3<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> = 11</p>
<p>计算频率：3/<span class="math inline">\(\sqrt{11}\)</span> =
0.904534，1/<span class="math inline">\(\sqrt{11}\)</span> =
0.301511</p>
</blockquote></li>
<li><p>难点在于如何遍历map，这里我使用的是 range-based for</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用auto遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) {</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">": "</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++17标准</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : myMap) {</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我使用的方法，通过key来遍历map&lt;string, double&gt;</span></span><br><span class="line"><span class="keyword">for</span>(string str1 : input) {  <span class="comment">// 计算频率</span></span><br><span class="line">        frequency[str1] = input[str1] / <span class="built_in">sqrt</span>(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="milestone-three">Milestone Three</h4>
<ul>
<li>要求：保留频率是前k大的元组</li>
<li>优先队列：插入元素后会自动排序，每次出队的是当前队列中权重最小的元素</li>
</ul>
<h4 id="milestone-four">Milestone Four</h4>
<ul>
<li><p>余弦相似度计算方法：https://blog.csdn.net/zz_dd_yy/article/details/51926305</p>
<p>示例：</p>
<blockquote>
<p>Profile 1</p>
<ul>
<li>"aaa": 0.333</li>
<li>"bbb": 0.667</li>
<li>"ccc": 0.667</li>
</ul>
<p>Profile 2</p>
<ul>
<li>"bbb": 0.333</li>
<li>"ccc": 0.667</li>
<li>"ddd": 0.667</li>
</ul>
<p>"ccc"和"bbb"在两个集合中均出现了，因此计算为："ccc"在两个集合的频率之积
+ "bbb"在两个集合的频率之积</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0.667 × 0.333) + (0.667 × 0.667) = 0.667</span><br></pre></td></tr></tbody></table></figure>
</blockquote></li>
</ul>
<h4 id="milestone-five">Milestone Five</h4>
<ul>
<li><p>给定待识别文本和语料库，找到最匹配的语言</p></li>
<li><p>这里我利用<code>int i</code>进行for循环遍历Set，然后使用<code>corpora[i].profile</code>会报错，因此还是使用range-based
for 循环进行遍历，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Corpus c : corpora) {</span><br><span class="line">        <span class="type">double</span> tmp = <span class="built_in">cosineSimilarityOf</span>(textProfile, c.profile);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; tmp) {</span><br><span class="line">            res = tmp;</span><br><span class="line">            ans = c.name;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="milestone-six">Milestone Six</h4>
<ul>
<li>测试语言识别功能</li>
<li>运行程序，点击“Rosetta Stone”，输入字符进行测试</li>
</ul>
<h3 id="part-two">Part Two</h3>
<ul>
<li><p>广度优先搜索</p></li>
<li><p>这题注意数组下标不要超过范围</p></li>
</ul>
<h2 id="assignment-3">Assignment 3</h2>
<h3 id="part-one-1">Part One</h3>
<p>递归画三角形，注意三个顶点的坐标</p>
<h3 id="part-two-1">Part Two</h3>
<p>递归然后利用数组保存递归中间结果从而优化递归</p>
<h3 id="part-three">Part Three</h3>
<p>递归，两个分支，当前字符串大写或小写</p>
<h3 id="part-four">Part Four</h3>
<h4 id="milestone-1">Milestone 1</h4>
<p>递归，需要借助辅助函数实现（两个分支，选择当前时间安排或不选择）</p>
<h2 id="assignment-4">Assignment 4</h2>
<h3 id="part-one-2">Part One</h3>
<p>找到 Permutations.cpp 中的bug，发现多了一个等号</p>
<h3 id="part-two-2">Part Two</h3>
<h4 id="milestone-1-1">Milestone 1</h4>
<p>找到完美匹配（每一个节点都有一个对应节点），示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"A"</span>: { <span class="string">"B"</span> },                    </span><br><span class="line"><span class="string">"B"</span>: { <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"G"</span> },     </span><br><span class="line"><span class="string">"C"</span>: { <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"G"</span> },          </span><br><span class="line"><span class="string">"D"</span>: { <span class="string">"C"</span>, <span class="string">"G"</span>, <span class="string">"H"</span> },          </span><br><span class="line"><span class="string">"E"</span>: { <span class="string">"B"</span>, <span class="string">"F"</span> },               </span><br><span class="line"><span class="string">"F"</span>: { <span class="string">"E"</span>, <span class="string">"G"</span> },               </span><br><span class="line"><span class="string">"G"</span>: { <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>, <span class="string">"H"</span> },</span><br><span class="line"><span class="string">"H"</span>: { <span class="string">"D"</span>, <span class="string">"G"</span> }</span><br><span class="line"></span><br><span class="line">完美匹配：{&lt;A, B&gt;, &lt;C, D&gt;, &lt;E, F&gt;, &lt;G, H&gt;}</span><br></pre></td></tr></tbody></table></figure>
<p>首先第一层for循环遍历map中的key，第二层for循环遍历value中的值（set集合）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (string name : possibleLinks) {  <span class="comment">// 第一层循环</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 第一层循环需要判断当前字符串是否已经匹配过</span></span><br><span class="line"><span class="comment">           若当前key未出现在matching中，则进入第二层循环 */</span></span><br><span class="line">        <span class="keyword">for</span>(string s : possibleLinks[name]) {</span><br><span class="line">            Set&lt;Pair&gt; not_chosen = matching;  <span class="comment">// 记录未添加pair的matching</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 判断当前字符串是否已经匹配过</span></span><br><span class="line">               </span><br><span class="line">            <span class="comment">/* 若当前value中的字符串未出现在matching中</span></span><br><span class="line"><span class="comment">			  将当前的pair添加到matching中，然后进入递归 */</span></span><br><span class="line">            <span class="type">bool</span> a = <span class="built_in">hasPerfectMatching</span>(possibleLinks-tmp1-tmp2, matching);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前pair未添加到matching中，进入递归</span></span><br><span class="line">            <span class="type">bool</span> b = <span class="built_in">hasPerfectMatching</span>(p, not_chosen);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> a || b;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="milestone-2">Milestone 2</h4>
<p>找到权值最大的匹配（不要求完美匹配），具体思路与上面类似</p>
<p>通过编写辅助函数，传入参数v（当前匹配的权值），在递归后进行比较，返回权值较大的那个匹配。</p>
<h3 id="part-three-1">Part Three</h3>
<p>若节点只能访问其相邻节点，需要哪几个节点能够访问整个图</p>
<ul>
<li>第一层循环访问未被覆盖的节点，第二层循环访问该节点的相邻节点</li>
<li>递归的思路：
<ol type="1">
<li>当前节点不加入集合，而是将相邻节点加入集合<br>
</li>
<li>当前节点加入集合，而相邻节点不加入集合</li>
</ol></li>
<li>回溯：当每个递归分支返回时，且返回值为false，则将该分支的参数变量回溯到之前的状态</li>
</ul>
<h2 id="assignment-5">Assignment 5</h2>
<h3 id="part-one-3">Part One</h3>
<p>运行项目，点击<code>Time Tests</code>，选择对应函数，然后点击<code>Time</code>绘制函数运行时间与n的关系。</p>
<h3 id="part-two-3">Part Two</h3>
<p>同上</p>
<h3 id="part-three-2">Part Three</h3>
<p>给一段材料回答问题（没咋看明白）</p>
<h3 id="part-four-1">Part Four</h3>
<ul>
<li><p>归并排序，先通过递归将二维vector分成一个一个vector，然后合并。</p></li>
<li><p>这里主要注意的是两个长度不等的vector的合并，这里定义一个结果vector保存合并后的元素。当短的vector合并完成，则将长的vector剩下的元素添加到结果vector中</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; i&lt;l1 &amp;&amp; j&lt;l2; k++) {</span><br><span class="line">        <span class="keyword">if</span>(a[i].weight &lt; b[j].weight) {</span><br><span class="line">            c.<span class="built_in">add</span>(a[i++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            c.<span class="built_in">add</span>(b[j++]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i &lt; l1) {</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; l1; k++)</span><br><span class="line">            c.<span class="built_in">add</span>(a[i++]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; l2) {</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; l2; k++)</span><br><span class="line">            c.<span class="built_in">add</span>(b[j++]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="assignment-6">Assignment 6</h2>
<h3 id="part-one-4">Part One</h3>
<p>根据注释一步一步运行</p>
<h3 id="part-two-4">Part Two</h3>
<p>小根堆</p>
<ul>
<li>enque：直接将元素插到二叉树的末尾，然后向上调整</li>
<li>deque：弹出最小元素（堆顶元素），先将堆顶元素与堆底元素交换位置，然后向下调整堆</li>
</ul>
<h4 id="milestone-one-1">Milestone one</h4>
<p>实现构造函数、析构函数、size 函数以及 isEmpty 函数</p>
<h4 id="milestone-two-1">Milestone two</h4>
<p>实现 enque 函数，注意数组存储元素的下标是从1开始</p>
<h4 id="milestone-three-1">Milestone three</h4>
<p>实现 peek 、deque 函数。</p>
<p>注意条件判断，所有情况要考虑全</p>
<h3 id="part-three-3">Part Three</h3>
<p>利用题目给定的算法计算每个州的席位，这里不能更改 PartTwo
中的函数，所以这里我乘了一个
<strong>-1</strong>，使得最大的数成为了最小的数，这样就能正确了</p>
<h2 id="assignment-7">Assignment 7</h2>
<h3 id="part-one-5">Part One</h3>
<p>枚举</p>
<ul>
<li><p>enum
type：枚举中的每个常量对应一个整数值，默认从0开始递增，除非显式赋值。</p>
<p>示例</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">    Red,    <span class="comment">// 默认为0</span></span><br><span class="line">    Green,  <span class="comment">// 默认为1</span></span><br><span class="line">    Blue    <span class="comment">// 默认为2</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Color color = Red;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Color: "</span> &lt;&lt; color &lt;&lt; std::endl;  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>enum
class：枚举类中的常量具有自己的作用域，避免了与其他枚举常量的冲突。枚举类是强类型的，不能隐式转换为整数，需要显式转换，或者指定底层的整数类型（即定义枚举类时初始化元素）。</p>
<p>示例</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> {</span><br><span class="line">    Red,    <span class="comment">// 默认从0开始</span></span><br><span class="line">    Green,  <span class="comment">// 默认为1</span></span><br><span class="line">    Blue    <span class="comment">// 默认为2</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Color color = Color::Red;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; color &lt;&lt; std::endl;  // 错误，不能直接输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Color: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color) &lt;&lt; std::endl;  <span class="comment">// 需要显式转换为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="part-two-5">Part Two</h3>
<p>线性探测表（哈希表），发生冲突时元素会存储到其他空位中（向后寻找）</p>
<h3 id="part-three-4">Part Three</h3>
<p>实现线性探测表。</p>
<p>注意：查找操作会根据哈希函数确定第一个查找位置，假如该位置已有元素（不是目标元素），由于是线性探测表，所以目标元素可能存放在其他空位中，需要继续查找。但是若在查找操作之前哈希函数确定的第一个位置清空了，那么我们查找到该空位时不能判定目标元素不存在，而是假装空位不空，继续向后查找</p>
<h3 id="part-four-2">Part Four</h3>
<p>线性探测表的变体：</p>
<ul>
<li>记录每个元素与主槽（哈希函数确定的初始位置）的距离</li>
<li>插入：两种情况
<ul>
<li>主槽为空，则直接插入</li>
<li>当前槽内元素距其主槽的距离 小于
待插入元素距主槽元素的距离，则将待插入元素替换当前槽内元素</li>
</ul></li>
<li>删除：将当前删除元素位置之后的元素（<strong>不能是处于主槽的元素</strong>）向前移动，直到：
<ul>
<li>找到一个空槽或</li>
<li>在找到一个正好位于主槽的元素。</li>
</ul></li>
<li>查找：如果当前遍历到的元素的距离大于待查找元素，则可以直接停止查找</li>
</ul>
<h2 id="assignment-8">Assignment 8</h2>
<h3 id="part-one-6">Part One</h3>
<p>迷宫，找到三件物品</p>
<h4 id="milestone-1-2">Milestone 1</h4>
<p>根据提供的字符串进行路径合法性判断，每次取第一个字符判断方向，然后进入递归</p>
<p>走出迷宫的条件是收集齐三件物品</p>
<h4 id="milestone-2-1">Milestone 2</h4>
<p>利用debug查看指针内容，画出迷宫，然后找到走出迷宫的路（收集三件物品）</p>
<h4 id="milestone-3">Milestone 3</h4>
<p>利用debug查看指针内存地址以及对应的方向，画出迷宫，找到对应序列</p>
<h3 id="part-two-6">Part Two</h3>
<h4 id="milestone-1-3">Milestone 1</h4>
<ul>
<li>删除链表（按照指针进行遍历）</li>
<li>通过指针读取每个节点的数据</li>
</ul>
<h4 id="milestone-2-2">Milestone 2</h4>
<ul>
<li>将输入的字符串存入链表（链表需要创建）</li>
<li>每个节点的创建需要使用<code>new</code></li>
</ul>
<h4 id="milestone-3-1">Milestone 3</h4>
<ul>
<li>我使用的是暴力求解，最好使用KMP算法</li>
<li>查找给出的子序列在DNA序列中出现的位置</li>
<li>双指针进行比较，右边指针同时移动</li>
<li>需要考虑的情况很多，根据测试结果进行修改</li>
</ul>
<h4 id="milestone-4">Milestone 4</h4>
<ul>
<li>删除DNA子序列</li>
</ul>
<h2 id="assignment-9">Assignment 9</h2>
<p>哈夫曼编码</p>
<ul>
<li>没有哪个字符的编码是另一个字符的前缀，防止歧义性</li>
</ul>
<h3 id="part-one-7">Part One</h3>
<p>创建哈夫曼树</p>
<ul>
<li>定义一个结构体<code>Node</code>存放树节点和权值</li>
<li>先定义一个map，存放字符串中出现的字符和出现次数，然后将不同字符存入不同节点<code>Node</code>中，并入队</li>
<li>每次出队两个节点，合并之后入队，直到队列中只剩一个节点</li>
</ul>
<h3 id="part-two-7">Part Two</h3>
<p>编码和解码</p>
<ul>
<li>解码：根据给的01编码对树进行遍历，直到叶子节点，记录该叶子节点的字符，然后从头开始遍历树重复前面步骤</li>
<li>编码：先遍历树，将所有字符对应的编码记录下来，然后根据给定的字符串进行编码</li>
</ul>
<h3 id="part-three-5">Part Three</h3>
<ul>
<li><p>新的编码方式，叶子节点表示‘0’，不是叶子节点则为‘1’。</p></li>
<li><p>使用先序遍历（根左右）解决。</p></li>
</ul>
<h3 id="part-four-3">Part Four</h3>
<ul>
<li>压缩</li>
<li>解压</li>
</ul>
<p>调用上面出现过的函数，别忘记释放内存（<code>deleteTree</code>）</p>
<h2 id="总结">总结</h2>
<p>9个assignment写完，CS106B这门课也就基本完成了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxt"
      src="/images/hxt.jpg">
  <p class="site-author-name" itemprop="name">hxt</p>
  <div class="site-description" itemprop="description">May the Force be with you.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">180</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">413k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
