<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="网络编程基础API 补充知识  主机字节序：一般为小端序（低位放在较小的地址处，高位放在较大的地址处） 网络字节序：一般为大端序  示例：0x01234567，其中 0x01 是最高位有效字节，0x67 是最低位有效字节 套接字地址 套接字地址（Socket Address）是 IP 地址和端口号的组合，用于唯一标识网络上的一个进程。  struct sockaddr sockaddr 是一个通用">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux网络编程">
<meta property="og:url" content="http://example.com/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="hxt&#39;s Blog">
<meta property="og:description" content="网络编程基础API 补充知识  主机字节序：一般为小端序（低位放在较小的地址处，高位放在较大的地址处） 网络字节序：一般为大端序  示例：0x01234567，其中 0x01 是最高位有效字节，0x67 是最低位有效字节 套接字地址 套接字地址（Socket Address）是 IP 地址和端口号的组合，用于唯一标识网络上的一个进程。  struct sockaddr sockaddr 是一个通用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222231946543.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222232510227.png">
<meta property="article:published_time" content="2025-04-02T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-03T05:38:57.674Z">
<meta property="article:author" content="hxt">
<meta property="article:tag" content="CPP">
<meta property="article:tag" content="网络编程">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222231946543.png">

<link rel="canonical" href="http://example.com/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux网络编程 | hxt's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxt's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hxt.jpg">
      <meta itemprop="name" content="hxt">
      <meta itemprop="description" content="May the Force be with you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxt's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux网络编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-03 00:00:00 / 修改时间：13:38:57" itemprop="dateCreated datePublished" datetime="2025-04-03T00:00:00+08:00">2025-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" >
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="网络编程基础api">网络编程基础API</h2>
<p><strong>补充知识</strong></p>
<ul>
<li>主机字节序：一般为<strong>小端序</strong>（低位放在较小的地址处，高位放在较大的地址处）</li>
<li>网络字节序：一般为<strong>大端序</strong></li>
</ul>
<p>示例：0x01234567，其中 0x01 是最高位有效字节，0x67
是最低位有效字节</p>
<h3 id="套接字地址">套接字地址</h3>
<p>套接字地址（<strong>Socket Address</strong>）是 <strong>IP
地址和端口号的组合</strong>，用于唯一标识网络上的一个进程。</p>
<ol type="1">
<li><p><code>struct sockaddr</code></p>
<p><code>sockaddr</code>
是一个<strong>通用的地址结构体</strong>，它的定义如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// 地址族（AF_INET, AF_INET6等）</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// 地址数据（具体的地址信息）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>成员解析</strong>：</p>
<ul>
<li><code>sa_family_t sa_family</code>：地址族（例如
<code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6）。</li>
<li><code>char sa_data[14]</code>：存储具体的地址数据（IP 地址 +
端口）。</li>
</ul>
<p><strong>⚠️ <code>sockaddr</code>
本身不会直接使用，而是由更具体的结构体（如 <code>sockaddr_in</code> 和
<code>sockaddr_in6</code>）进行扩展。</strong></p></li>
<li><p><code>sockaddr_in</code>（IPv4 地址）</p>
<p><code>sockaddr_in</code> 结构体是 <code>sockaddr</code>
的<strong>专门版本</strong>，用于<strong>IPv4 地址</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// sockaddr_in 定义在这个头文件中</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">// 地址族（必须是 AF_INET）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;       <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;  <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">// 备用字段（填充用，一般不用）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这里的<code>struct in_addrc</code>的详细代码定义在<code>&lt;netinet/in.h&gt;</code>文件头中：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> {</span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32 位 IPv4 地址（网络字节序）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>示例代码（IPv4 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// 包含 inet_pton 和 inet_ntoa</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">"192.168.1.1"</span>, &amp;addr.sin_addr);  <span class="comment">// 将IP字符串转换为二进制格式</span></span><br><span class="line">    <span class="comment">// 第三个参数 &amp;addr.sin_addr 表示转换后的二进制 IP 地址的存储位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印转换后的信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IP: "</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr.sin_port) &lt;&lt; std::endl;  <span class="comment">// 端口转换回主机字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>函数解析</strong>：</p>
<ul>
<li><code>htons(port)</code>：将主机字节序的<strong>端口号</strong>转换为<strong>网络字节序</strong>。</li>
<li><code>ntohs(port)</code>：将网络字节序的<strong>端口号</strong>转换回<strong>主机字节序</strong>。</li>
<li><code>inet_pton(AF_INET, "192.168.1.1", &amp;addr.sin_addr)</code>：将
IPv4 字符串转换为二进制格式。为了后续的 socket 操作（例如
<code>connect</code> 或 <code>bind</code>）能够使用正确的二进制格式的 IP
地址。</li>
<li><code>inet_ntoa(addr.sin_addr)</code>：将二进制 <strong>IP
地址</strong>转换为可读的字符串。</li>
</ul></li>
<li><p><code>sockaddr_in6</code>（IPv6 地址）</p>
<p>IPv6 地址使用 <code>sockaddr_in6</code> 结构体：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;     <span class="comment">// 地址族（必须是 AF_INET6）</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;         <span class="comment">// 端口号（网络字节序）</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;      <span class="comment">// IPv6 流量控制信息（一般设为 0）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;   <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;      <span class="comment">// 作用域 ID（用于本地连接）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>示例代码（IPv6 地址转换）：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> addr6;</span><br><span class="line">    addr6.sin6_family = AF_INET6;</span><br><span class="line">    addr6.sin6_port = <span class="built_in">htons</span>(<span class="number">9090</span>);  <span class="comment">// 端口号</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET6, <span class="string">"::1"</span>, &amp;addr6.sin6_addr);  <span class="comment">// 将 IPv6 地址转换为二进制</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ip_str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET6, &amp;addr6.sin6_addr, ip_str, <span class="built_in">sizeof</span>(ip_str));  <span class="comment">// 转换回可读字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"IPv6: "</span> &lt;&lt; ip_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Port: "</span> &lt;&lt; <span class="built_in">ntohs</span>(addr6.sin6_port) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>IPv6 相关函数</strong>：</p>
<ul>
<li><code>inet_pton(AF_INET6, "::1", &amp;addr6.sin6_addr)</code>：将
IPv6 地址字符串转换为二进制格式。</li>
<li><code>inet_ntop(AF_INET6, &amp;addr6.sin6_addr, ip_str, sizeof(ip_str))</code>：将
IPv6 二进制地址转换回字符串。</li>
</ul></li>
</ol>
<h3 id="创建套接字">创建套接字</h3>
<p>socket系统调⽤成功时返回⼀个socket⽂件描述符，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>domain</code>（协议族）：<code>AF_INET</code>（IPv4）、<code>AF_INET6</code>（IPv6）、<code>AF_UNIX</code>（本地通信）</li>
<li><code>type</code>（套接字类型）：<code>SOCK_STREAM</code>（流服务，TCP）、<code>SOCK_DGRAM</code>（数据报服务，UDP）</li>
<li><code>protocol</code>（协议）：<code>0</code>（默认），<code>IPPROTO_TCP</code>（TCP），<code>IPPROTO_UDP</code>（UDP）</li>
</ul>
<h3 id="绑定套接字">绑定套接字</h3>
<p><code>bind</code>函数<strong>将套接字（socket）与本地 IP
地址和端口号绑定</strong>，即上面提到的两个关键字，这样客户端可以连接到该地址。成功时返回0，失败则返回-1</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：<strong>要绑定的 socket 文件描述符</strong>（由
<code>socket()</code> 创建）</li>
<li><code>addr</code>：<strong>要绑定的本地地址（IP +
端口）</strong>，需要转换为 <code>sockaddr*</code>
类型（默认套接字地址类型）</li>
<li><code>addrlen</code>：<strong>地址结构体的大小</strong>（通常用
<code>sizeof(struct sockaddr_in)</code>）</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr {};</span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// 使用 IPv4</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定到本机所有 IP</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);  <span class="comment">// 绑定端口 8080</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"bind failed"</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Socket bound to port 8080"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="监听套接字">监听套接字</h3>
<p><code>listen</code>函数创建⼀个监听队列以存放待处理的客户连接。成功时返回0，失败则返回-1。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket 文件描述符，通常是通过
<code>socket()</code> 创建并已绑定地址和端口的 socket</li>
<li><code>backlog</code>：连接队列的最大长度。
<ul>
<li>当多个客户端同时尝试连接服务器时，未处理的连接请求会被放入队列中。</li>
<li><code>backlog</code>
指定了队列的最大长度。如果队列已满，新的连接请求会被拒绝。</li>
</ul></li>
</ul>
<blockquote>
<p>监听队列中<strong><code>ESTABLISHED</code> 状态</strong> 的连接表示
<strong>三次握手成功</strong>，连接已建立，可以通信。但此时连接还在
<strong>监听队列</strong> 中，服务器端还
<strong>不能直接读写数据</strong>，需要通过 <code>accept()</code>
取出连接。</p>
</blockquote>
<h3 id="接受连接">接受连接</h3>
<p><code>accept</code>函数从<code>listen</code>监听队列中接受⼀个连接。成功返回新的<strong>已连接套接字描述符</strong>，用于与客户端通信；失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：socket文件描述符（这里是被监听的socket）</li>
<li><code>addr</code>：指向存储客户端地址信息的结构体，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：指向地址长度的指针，调用前应设置为
<code>addr</code> 的长度，调用后会被修改为实际地址长度。</li>
</ul>
<h3 id="发起连接">发起连接</h3>
<p><code>connect</code>函数⽤来主动与服务器建⽴连接。成功返回<code>0</code>，失败返回<code>-1</code>。⼀旦成功建⽴连接，sockfd就唯⼀地标识了这个连接，客户端就可以通过读写<code>sockfd</code>来与服务器通信。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>sockfd</code>：文件描述符</li>
<li><code>addr</code>：<strong>服务器地址</strong>信息，包括 IP
和端口。</li>
<li><code>addrlen</code>：<code>addr</code>的大小</li>
</ul>
<blockquote>
<p><strong><code>connect</code> 是客户端主动建立连接</strong></p>
<p><strong><code>accept</code>是服务器被动接受连接</strong></p>
</blockquote>
<h3 id="关闭连接">关闭连接</h3>
<h4 id="close">close</h4>
<p>关闭<code>sockfd</code>对应的socket连接。成功返回<code>0</code>，失败返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用计数机制</strong>：</p>
<ul>
<li>内核维护<strong>文件描述符的引用计数</strong>。</li>
<li>调用 <code>close()</code> 时，引用计数 <strong>减 1</strong>。</li>
<li>当引用计数为 0，才真正关闭连接</li>
</ul>
<h4 id="shutdown">shutdown</h4>
<p>如果⽆论如何都要⽴即终⽌连接（⽽不是将socket的引⽤计数减1），可以使⽤的<code>shutdown</code>系统调⽤。成功时返回<code>0</code>，失败则返回<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line"><span class="comment">/* how 参数表示关闭方式：SHUT_RD、SHUT_WR、SHUT_RDWR */</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>shutdown</code>能够分别关闭socket上的读或写，或者都关闭。⽽<code>close</code>在关闭连接时只能将socket上的读和写同时关闭。</p>
<h3 id="数据读写">数据读写</h3>
<p>对文件的读写操作<code>read</code>和<code>write</code>同样适用于socket</p>
<h4 id="tcp数据读写">TCP数据读写</h4>
<ol type="1">
<li><p><code>send()</code></p>
<p><strong>发送数据</strong>到已连接的 <strong>TCP
套接字</strong>中。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code> 。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>待发送数据</strong>的缓冲区</li>
<li><code>len</code>：带发送数据的长度</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞发送</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞发送</strong>，若缓冲区满，则立即返回</li>
<li><code>MSG_NOSIGNAL</code>：<strong>不触发 SIGPIPE
信号</strong>，在对端关闭时返回错误</li>
</ul></li>
</ul></li>
<li><p><code>recv()</code></p>
<p><strong>从 TCP
套接字接收数据</strong>并存入缓冲区。成功则返回<strong>接收到的字节数</strong>（<code>0</code>：表示
<strong>对方关闭连接</strong>，即发送了 <code>FIN</code>
包），失败则返回<code>-1</code>。可能要多次调⽤<code>recv</code></p>
<p><strong>失败</strong>：返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：已连接的套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）
<ul>
<li><code>0</code>：标准阻塞接收</li>
<li><code>MSG_DONTWAIT</code>：<strong>非阻塞接收</strong>，若无数据则立即返回</li>
<li><code>MSG_PEEK</code>：<strong>窥视模式</strong>，读取数据但不删除缓冲区中的内容</li>
</ul></li>
</ul></li>
</ol>
<h4 id="udp数据报读写">UDP数据报读写</h4>
<ol type="1">
<li><p><code>sendto()</code></p>
<p>发送 UDP
数据报到指定的目标地址。成功则返回<strong>实际发送的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>： 套接字描述符</li>
<li><code>buf</code>：指向 <strong>待发送数据</strong> 的缓冲区</li>
<li><code>len</code>：待发送数据长度</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>dest_addr</code>（结构体）：目标地址，通常为
<code>sockaddr_in</code> 或 <code>sockaddr_in6</code></li>
<li><code>addrlen</code>：目标地址结构体的大小</li>
</ul></li>
<li><p><code>recvfrom()</code></p>
<p>接收 UDP
数据报并保存到缓冲区中。成功则返回<strong>实际接收的字节数</strong>，失败则返回
<code>-1</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符</li>
<li><code>buf</code>：指向<strong>存放接收数据</strong>的缓冲区</li>
<li><code>len</code>：缓冲区大小</li>
<li><code>flags</code>：控制发送行为（一般为0）</li>
<li><code>src_addr</code>：存放发送地址的结构体指针</li>
<li><code>addrlen</code>：发送方地址结构体的大小</li>
</ul></li>
</ol>
<h4 id="通用数据读写">通用数据读写</h4>
<p>不仅能⽤于TCP流数据，也能⽤于UDP数据报</p>
<ol type="1">
<li><p><code>sendmsg</code></p>
<p>成功则返回发送的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符。</li>
<li><code>msg</code>：指向 <strong><code>msghdr</code>
结构体</strong>，包含要发送的数据、目标地址、控制信息。</li>
<li><code>flags</code>：发送标志，如
<code>MSG_DONTWAIT</code>、<code>MSG_EOR</code>。</li>
</ul></li>
<li><p><code>recvmsg</code></p>
<p>成功则返回接收的字节数，失败返回 <code>-1</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p><code>msghdr</code>结构体详解</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> {</span><br><span class="line">    <span class="type">void</span>         *msg_name;       <span class="comment">// 地址信息 (UDP：目标地址 / 源地址；对于⾯向连接的TCP协议，该成员没有意义)</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;        <span class="comment">// 数据缓冲区数组</span></span><br><span class="line">    <span class="type">size_t</span>        msg_iovlen;     <span class="comment">// 数据缓冲区个数</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;    <span class="comment">// 控制信息缓冲区</span></span><br><span class="line">    <span class="type">size_t</span>        msg_controllen; <span class="comment">// 控制信息长度</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;      <span class="comment">// 消息标志</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="总结">总结</h3>
<h4 id="服务端-tcp">服务端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>bind()</code></strong>：绑定 IP 地址和端口号</li>
<li><strong><code>listen()</code></strong>：监听客户端连接请求</li>
<li><strong><code>accept()</code></strong>：接受客户端连接</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<h4 id="客户端-tcp">客户端 (TCP)</h4>
<ol type="1">
<li><strong><code>socket()</code></strong>：创建套接字</li>
<li><strong><code>connect()</code></strong>：连接服务器</li>
<li><strong><code>send()</code> /
<code>recv()</code></strong>：读写数据</li>
<li><strong><code>close()</code></strong>：关闭套接字</li>
</ol>
<blockquote>
<p><strong>客户端</strong> 不调用 <code>bind()</code> 是为了
<strong>简化编程</strong> 和
<strong>方便操作系统自动分配端口</strong>。</p>
<p><strong>服务端</strong> 必须调用 <code>bind()</code> 来
<strong>指定监听的 IP 地址和端口号</strong>，以便
<strong>客户端能够连接</strong>。</p>
</blockquote>
<h2 id="高级io函数">高级I/O函数</h2>
<p><code>pipe</code>、<code>dup</code>、<code>readv</code>、<code>sendfile</code>、<code>mmap</code>、<code>tee</code>、<code>fcntl</code></p>
<p><code>splice</code>：用于在两个文件描述符之间移动数据，而无需将数据从内核空间复制到用户空间，<strong>直接在内核空间</strong>中完成数据的传输。。它通常用于高效地将数据从一个文件描述符（例如管道、socket
或文件）传输到另一个文件描述符。核心原理是它利用了 Linux
内核的<strong>零拷贝（Zero-Copy）技术</strong></p>
<h2 id="linux服务器程序规范">Linux服务器程序规范</h2>
<p><strong>AF_UNIX Socket 类型</strong></p>
<ul>
<li><strong>AF_UNIX</strong> 是一种本地进程间通信（IPC）的 Socket
类型，也称为 <strong>Unix Domain Socket (UDS)</strong>。</li>
<li>它用于 <strong>同一台机器</strong>
上不同进程之间的通信，不涉及网络传输。</li>
<li>通信数据不会经过网络协议栈，因此
<strong>效率高、延迟低、开销小</strong>。</li>
</ul>
<h3 id="日志">日志</h3>
<ul>
<li><p><code>rsyslog</code> 是 Linux
系统中功能强大的日志管理工具，具有高性能、模块化、支持多种协议和格式化输出的特点。</p></li>
<li><p><strong>rsyslogd 守护进程</strong> 在接收到
<strong>用户进程</strong> 或 <strong>内核</strong>
输入的日志后，会按照配置文件中的规则，将它们输出到特定的
<strong>日志文件</strong> 中。</p></li>
</ul>
<p>下面是<strong>日志处理流程</strong></p>
<ol type="1">
<li><p><strong>日志收集</strong>：</p>
<ul>
<li><p><strong>用户进程日志</strong>：通过调用 <code>syslog()</code>
函数，将日志写入 <code>/dev/log</code>（AF_UNIX Socket）。</p>
<blockquote>
<ul>
<li><p><strong><code>syslog()</code></strong> 是 C
语言标准库中的一个函数，用于
<strong>向系统日志发送消息</strong>。</p></li>
<li><p>日志通过 <strong>AF_UNIX Socket</strong> 发送到
<code>/dev/log</code> 文件，由 <code>rsyslogd</code>
或其他系统日志守护进程收集、处理并写入日志文件。</p></li>
<li><p>典型用途：记录程序运行状态、错误信息、安全事件等，便于调试和维护</p></li>
</ul>
</blockquote></li>
<li><p><strong>内核日志</strong>：通过 <code>klog</code>
模块从内核中收集日志，例如启动、硬件、中断等信息。</p></li>
</ul></li>
<li><p><strong>rsyslogd 获取日志</strong>：</p>
<ul>
<li><code>rsyslogd</code> 守护进程监听 <code>/dev/log</code> 和
<code>/proc/kmsg</code>（内核日志），获取日志数据。</li>
</ul></li>
<li><p><strong>日志过滤与分类</strong>：</p>
<ul>
<li>根据配置文件（如 <code>/etc/rsyslog.conf</code> 和
<code>/etc/rsyslog.d/*.conf</code>）中的规则进行过滤和分类。</li>
<li>规则由 Facility（日志来源） 和 Level（日志级别） 组成</li>
</ul></li>
<li><p><strong>日志输出与存储</strong>：</p>
<ul>
<li>日志被写入到指定的日志文件，如：
<ul>
<li><code>/var/log/messages</code>：系统通用日志</li>
<li><code>/var/log/secure</code>：认证和安全相关日志</li>
<li><code>/var/log/maillog</code>：邮件日志</li>
<li><code>/var/log/cron</code>：定时任务日志</li>
<li><code>/var/log/kern.log</code>：内核日志</li>
</ul></li>
<li>或者转发至 <strong>远程日志服务器</strong> 或
<strong>数据库</strong> 进行集中存储和分析。</li>
</ul></li>
</ol>
<h3 id="用户信息">用户信息</h3>
<p>EGID/EUID
存在的⽬的是⽅便资源访问，给运⾏⽬标程序的(组)⽤户提供有效(组)用户的权限。</p>
<blockquote>
<p>示例：</p>
<ul>
<li><p><strong><code>su</code> 程序</strong> 在
<strong>普通用户启动时</strong>，<strong>EUID 临时变为
<code>root</code></strong>，从而拥有 <code>root</code> 权限。</p></li>
<li><p>由于 SUID 位（即set-user-id 标志）被设置，则 <strong>EUID 变为
root</strong>，进程可以 <strong>访问和修改 <code>/etc/passwd</code>
文件</strong>，并执行切换用户的操作。</p></li>
</ul>
</blockquote>
<ol type="1">
<li><p>获取用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实用户 ID (UID)</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效用户 ID (EUID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="type">void</span>)</span></span>;   <span class="comment">// 获取 真实组 ID (GID)</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">// 获取 有效组 ID (EGID)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设置用户信息</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;       <span class="comment">// 设置 真实用户 ID 和 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span></span>;     <span class="comment">// 设置 有效用户 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;       <span class="comment">// 设置 真实组 ID 和 有效组 ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span></span>;     <span class="comment">// 设置 有效组 ID</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="进程间关系">进程间关系</h3>
<h4 id="进程组">进程组</h4>
<ul>
<li>每个进程组都有一个唯一的 <strong>进程组 ID
(PGID)</strong>，用于标识该组中的所有进程。</li>
<li><strong>PGID（Process Group
ID）</strong>：进程组的唯一标识符，等于该组<strong>首领进程（Leader
Process）</strong> 的 PID（进程 ID）。</li>
<li><strong>首领进程</strong>：最先创建进程组的进程，PGID 等于它的
PID。如果首领进程退出，进程组不会消失，但其他进程的 PGID
不变。进程组将⼀直存在，直到其中<strong>所有进程</strong>都退出，或者加⼊到其他进程组。</li>
</ul>
<h4 id="会话">会话</h4>
<ul>
<li><p>一组相关的进程组组成一个会话，每个会话有一个唯一的
<strong>SID（Session ID）</strong>。</p></li>
<li><p><strong>Session ID
(SID)</strong>：会话的唯一标识符，等于会话首领进程（Session Leader）的
PID。</p></li>
<li><p><strong>会话首领进程</strong>：创建会话的进程，SID 等于它的
PID。这个进程可以成为<strong>守护进程</strong>。</p>
<blockquote>
<p><strong>调用进程不能是当前进程组的组长</strong>，否则会返回错误。这是因为：</p>
<ul>
<li>如果组长进程调用 <code>setsid()</code>，那么它的 <strong>PGID
(Process Group ID)</strong> 和 <strong>PID (Process ID)</strong>
相同，而 <code>setsid()</code>
要求调用进程成为<strong>新进程组的组长</strong>，即 <strong>PGID =
PID</strong>。如果它本身已经是组长，就无法改变 PGID，因此被禁止。</li>
</ul>
</blockquote></li>
</ul>
<h4 id="ps命令"><code>ps</code>命令</h4>
<p>用于<strong>查看系统中正在运行的进程</strong>。它可以显示进程的
PID、PPID、PGID、SID、TTY、状态、内存占用等详细信息。</p>
<ol type="1">
<li><p>查看所有进程的层级关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef --forest</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看会话、进程组和 PID 的关系</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看当前 Shell 会话中的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看前后台作业及进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,tty,stat,comm</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某个用户的所有进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u username</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="系统资源限制">系统资源限制</h3>
<ul>
<li><strong><code>getrlimit(int resource, struct rlimit \*rlim)</code></strong>：获取指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
<li><strong><code>setrlimit(int resource, const struct rlimit \*rlim)</code></strong>：设置指定资源的<strong>软限制</strong>和<strong>硬限制</strong>。</li>
</ul>
<h3 id="改变目录">改变目录</h3>
<ol type="1">
<li><p>获取<strong>当前工作目录</strong>的<strong>绝对路径</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>buf</code>：用于存储路径的缓冲区。</li>
<li><code>size</code>：缓冲区大小。</li>
<li>返回值：成功返回 <code>buf</code>；失败返回
<code>NULL</code>，并设置 <code>errno</code></li>
</ul></li>
<li><p>切换目录</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>path</code>：目标目录的路径（绝对路径或相对路径）。</li>
<li>返回值：成功返回 <code>0</code>；失败返回 <code>-1</code>，并设置
<code>errno</code></li>
</ul></li>
</ol>
<h3 id="服务器程序后台化">服务器程序后台化</h3>
<ol type="1">
<li><strong>创建子进程</strong> 并退出父进程，防止继续占用
<strong>终端</strong>。</li>
<li><strong>调用 <code>setsid()</code></strong>：
<ul>
<li>创建新会话 (<code>session</code>)，并成为会话首进程。</li>
<li>成为新进程组的<strong>组长</strong>。</li>
<li><strong>脱离</strong> 控制终端。</li>
</ul></li>
<li><strong>重设文件权限掩码</strong>：
<ul>
<li>使用 <code>umask(0)</code> 确保子进程可以创建任何权限的文件。</li>
</ul></li>
<li><strong>更改工作目录</strong>：
<ul>
<li>通常切换到根目录：<code>chdir("/")</code>，防止
<strong>占用文件系统</strong>。</li>
</ul></li>
<li><strong>关闭文件描述符</strong>：
<ul>
<li>关闭 <strong>stdin, stdout, stderr</strong>
(<code>0, 1, 2</code>)，防止<strong>占用终端资源</strong>。</li>
</ul></li>
<li><strong>重定向文件描述符</strong>：
<ul>
<li>重定向 <code>stdin, stdout, stderr</code> 到
<strong><code>/dev/null</code></strong> 或
<strong>日志文件</strong>。</li>
</ul></li>
</ol>
<h2 id="io模型">I/O模型</h2>
<p>其中最重要的就是<strong>I/O复用</strong></p>
<h3 id="阻塞io">阻塞I/O</h3>
<p>进程发起 I/O
请求后，线程会一直阻塞，直到数据准备好并被复制到用户空间，I/O
操作才完成。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>，如果数据未准备好，进程进入
<strong>阻塞状态</strong>。</li>
<li>内核等待数据准备好，并从内核缓冲区复制到用户空间。</li>
<li><code>read()</code> 返回，进程继续执行。</li>
</ol>
<h3 id="非阻塞io">非阻塞I/O</h3>
<p>进程发起I/O请求后，不管数据是否准备好都会直接返回。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>read()</code>：
<ul>
<li><strong>如果数据已准备好</strong>，<code>read()</code>
立即返回数据。</li>
<li><strong>如果数据未准备好</strong>，<code>read()</code> 立即返回
<code>-1</code>，并设置 <code>errno = EAGAIN</code>（不会阻塞）。</li>
</ul></li>
<li>进程通常会<strong>轮询</strong>（不断调用
<code>read()</code>）直到数据可用。</li>
</ol>
<h3 id="信号驱动io">信号驱动I/O</h3>
<p>让内核在 I/O 事件发生时发送信号 (<code>SIGIO</code>)
通知进程，进程在信号处理程序中执行 I/O 操作。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>fcntl()</code> 启用 <code>O_ASYNC</code>
标志，让内核在 I/O 事件发生时发送 <code>SIGIO</code> 信号。</li>
<li>进程继续执行其他任务，不阻塞。</li>
<li>当数据可用时，内核发送 <code>SIGIO</code> 信号。</li>
<li>信号处理函数调用 <code>read()</code> 读取数据。</li>
</ol>
<h3 id="异步io">异步I/O</h3>
<p>进程发起 I/O 请求后<strong>不会阻塞</strong>，内核在 I/O
操作完成后通知进程。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用 <code>aio_read()</code> 让内核执行 I/O 操作。</li>
<li>进程立即继续执行其他任务，不阻塞。</li>
<li>内核完成 I/O 后，主动通知进程（如回调函数或 <code>SIGEV</code>
机制）。</li>
<li>进程获取数据，I/O 操作完成。</li>
</ol>
<blockquote>
<p>异步I/O与信号驱动I/O的区别</p>
<p><strong>信号驱动 I/O (<code>SIGIO</code>)</strong>：</p>
<ul>
<li>只是<strong>提前通知</strong>进程 “数据可读”，但进程仍需
<code>read()</code> 获取数据。</li>
<li>适用于<strong>高并发网络 I/O</strong>（但现代高性能服务器一般用
<code>epoll</code>）。</li>
</ul>
<p><strong>异步 I/O (AIO)</strong>：</p>
<ul>
<li><strong>真正的异步</strong>，内核完成 I/O 后数据已就绪，无需
<code>read()</code>。</li>
<li>适用于<strong>高吞吐文件 I/O</strong>，如数据库、存储系统
(<code>io_uring</code> 适用于网络和文件)。</li>
</ul>
</blockquote>
<h3 id="io复用">I/O复用</h3>
<p>通过 <code>select()</code>、<code>poll()</code> 或
<code>epoll()</code> 让一个线程同时监视多个 I/O 事件，提高并发能力。</p>
<p><strong>流程</strong>：</p>
<ol type="1">
<li>进程调用
<code>select()</code>/<code>poll()</code>/<code>epoll_wait()</code>，等待多个文件描述符的状态变化。</li>
<li>如果某个描述符准备好，进程再去执行 <code>read()</code>。</li>
<li><code>read()</code>
仍然是阻塞的，但因为之前已经确认了数据可读，阻塞时间很短。</li>
</ol>
<h4 id="select">select</h4>
<p><code>select()</code> 函数是一种 <strong>I/O 多路复用</strong>
技术，它可以 <strong>同时监听多个文件描述符 (File Descriptor,
FD)</strong> 的状态。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>nfds</code></td>
<td>监听的最大文件描述符的值加 1（仅 Linux 需要，Windows
忽略此参数）。</td>
</tr>
<tr class="even">
<td><code>readfds</code></td>
<td>监听可读事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>writefds</code></td>
<td>监听可写事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="even">
<td><code>exceptfds</code></td>
<td>监听异常事件的文件描述符集合（可为 <code>NULL</code>）。</td>
</tr>
<tr class="odd">
<td><code>timeout</code></td>
<td>设定超时时间，可为 <code>NULL</code>（表示无限等待）。</td>
</tr>
</tbody>
</table>
<p>select成功时返回就绪（可读、可写和异常）⽂件描述符的总数。如果在超时时间内没有任何⽂件描述符就绪，select将返回0。select失败时返回-1。</p>
<p>下面是<code>select</code>监听的文件操作符可能出现的状态：（<code>FD_ISSET</code>用于判断状态是否变化即是否就绪，例如<code>FD_ISSET(fd, &amp;readfds)</code>
用于检查某个文件描述符 (<code>fd</code>) 是否<strong>在
<code>readfds</code> 集合中被标记为可读</strong>。）</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">监听类型</th>
<th style="text-align: center;">触发条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>可读
<code>readfds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 有数据可读
<br>2. <code>accept()</code> 有新连接 <br>3. <code>read()</code>
返回 0（对端关闭） <br>4. 终端、管道、文件可读</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>可写
<code>writefds</code></strong></td>
<td style="text-align: center;">1. <code>socket</code> 发送缓冲区可用
<br>2. <code>connect()</code> 非阻塞模式完成 <br>3.
<code>write()</code> 不会阻塞</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>异常
<code>exceptfds</code></strong></td>
<td style="text-align: center;">1. <code>connect()</code> 失败 <br>2.
<code>MSG_OOB</code> <strong>带外数据</strong> <br>3. TCP 连接复位
(RST)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>fd_set</code>：<strong>文件描述符（file
descriptor）集合</strong>，只能存 1024 个文件描述符</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;    <span class="comment">// 清空集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 添加文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 从集合中移除文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; <span class="comment">// 检查文件描述符是否准备就绪</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>两种应用：</p>
<p><strong><code>select()</code> + 非阻塞
I/O（纯事件驱动模型）</strong>：</p>
<ul>
<li>适用于 <strong>高并发、轻量级连接</strong> 的场景，如
<strong>聊天室、HTTP 代理服务器</strong>。</li>
<li>无需多进程或多线程，<strong>单线程即可管理和处理多个连接</strong>。</li>
</ul>
<p><strong><code>select()</code> +
<code>fork()</code>（混合模型）</strong>：</p>
<ul>
<li>适用于 <strong>中小规模并发</strong> 且
<strong>每个连接需要较重业务处理</strong> 的场景，如
<strong>文件上传、数据计算</strong>。</li>
<li>通过 <strong>子进程避免阻塞主进程</strong>，简化了 <strong>I/O
操作的编程模型</strong>。</li>
</ul>
<h4 id="poll">poll</h4>
<p><code>poll()</code> 是 <code>select()</code> 的改进版，<strong>去除了
1024 个文件描述符（fd）的限制</strong>，但仍然需要遍历整个 fd
列表。poll系统调⽤的返回值的含义与select相同。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> {</span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 监听的事件（POLLIN-可读, POLLOUT-可写, POLLERR-错误）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 触发的事件（由内核填充）</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>fds</code>: <code>pollfd</code>
结构体数组，存放要监听的文件描述符及其事件。</li>
<li><code>nfds</code>: <code>fds</code> 数组的大小。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<h4 id="epoll">epoll</h4>
<p><code>epoll</code> 是 Linux 特有的 <strong>高效 I/O 复用</strong>
机制，适用于 <strong>高并发场景（如 1 万个 socket）</strong>。</p>
<p><strong>(1) <code>epoll_create()</code>
创建内核事件表（epoll实例）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>创建内核事件表</strong>，返回 <code>epfd</code>（失败返回
<code>-1</code>）。</li>
</ul>
<p><strong>(2) <code>epoll_ctl()</code> 添加/删除/修改 fd（即管理
fd）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_event 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> {</span><br><span class="line">    <span class="type">uint32_t</span> events;  <span class="comment">// 监听的事件（EPOLLIN, EPOLLOUT 等，还包括EPOLLET-边缘触发模式）</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据（通常存 fd）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>op</code>: 操作类型：
<ul>
<li><code>EPOLL_CTL_ADD</code>：添加 <code>fd</code>。</li>
<li><code>EPOLL_CTL_MOD</code>：修改 <code>fd</code> 监听的事件。</li>
<li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code>。</li>
</ul></li>
<li><code>fd</code>: 需要监听的文件描述符（socket）。</li>
<li><code>event</code>: 监听的事件。</li>
</ul>
<p><strong>(3) <code>epoll_wait()</code> 获取发生事件的 fd</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>epfd</code>: <code>epoll_create()</code> 返回的 epoll
句柄。</li>
<li><code>events</code>: 用于存储触发事件的 <code>epoll_event</code>
数组。</li>
<li><code>maxevents</code>: <code>events</code> 数组的大小（建议设置为
<code>10</code>~<code>1000</code>）。</li>
<li><code>timeout</code>: 超时时间（毫秒），<code>-1</code>
表示无限等待，<code>0</code> 表示立即返回。</li>
</ul>
<p><strong>(4) LT（水平触发）和ET（边缘触发）模式</strong></p>
<p>LT：只要数据未被读取，<code>epoll_wait()</code>
<strong>一直返回</strong> 可读事件。</p>
<p>ET：<strong>只在状态变化时通知一次</strong>，如果不立即处理，<code>epoll_wait()</code>
<strong>不会再次通知</strong>。</p>
<ol type="1">
<li><strong>LT（Level Triggered，水平触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>：
<ul>
<li>只要文件描述符处于就绪状态（即有数据可读或可写），epoll
就会持续通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll 会在下一次调用 epoll_wait
时再次通知。</li>
</ul></li>
<li>特点:
<ul>
<li>简单易用: 适合初学者或简单的应用场景。</li>
<li>容错性强:
即使应用程序没有一次性处理完所有数据，也不会丢失事件。</li>
<li>可能效率较低: 如果应用程序没有及时处理数据，epoll
会频繁通知，导致不必要的开销。</li>
</ul></li>
<li>适用场景:
<ul>
<li>需要兼容性强的场景（如传统的 select 或 poll 迁移到 epoll）。</li>
<li>对性能要求不高的场景。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>ET（Edge Triggered，边缘触发）模式</strong></li>
</ol>
<ul>
<li><strong>行为</strong>:
<ul>
<li>只有当文件描述符的状态发生变化时（如从无数据变为有数据），epoll
才会通知应用程序。</li>
<li>如果应用程序没有处理完所有数据，epoll
不会再次通知，除非文件描述符的状态再次发生变化。</li>
</ul></li>
<li>特点:
<ul>
<li>高效: 减少了不必要的通知，适合高性能场景。</li>
<li>需要一次性处理完数据:
应用程序必须确保在一次事件通知中处理完所有数据，否则可能会丢失后续事件。</li>
<li>复杂性较高: 需要更精细的控制，通常与非阻塞 I/O 结合使用。</li>
</ul></li>
<li>适用场景:
<ul>
<li>高性能服务器（如 Web 服务器、游戏服务器）。</li>
<li>需要处理大量并发连接的场景。</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN; <span class="comment">// LT 模式</span></span><br><span class="line"><span class="comment">// event.events = EPOLLIN | EPOLLET; // ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>EPOLLONESHOT</code> 是 <code>epoll</code>
监听事件的一个<strong>特殊标志</strong>，它的作用是：</p>
<ul>
<li><strong>事件触发一次后，自动从 <code>epoll</code>
监听列表中移除</strong>。</li>
<li><strong>适用于多线程环境</strong>，防止多个线程同时处理同一个
<code>fd</code>。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内核事件表（Kernel Event Table）</strong> 是
<strong><code>epoll</code></strong>
机制的<strong>核心数据结构</strong>，用于<strong>存储和管理需要监听的文件描述符（fd）及其事件</strong>。它由
Linux 内核维护，提供了高效的事件通知机制。</p>
<ol type="1">
<li><p>为什么需要内核事件表？</p>
<p>在 <code>select()</code> 和 <code>poll()</code>
机制中，用户进程<strong>每次调用</strong>都要<strong>传递所有监听的
fd</strong>，导致<strong>大量数据拷贝和遍历</strong>，影响性能。</p>
<p><strong><code>epoll</code> 的改进：</strong></p>
<ol type="1">
<li><p><strong>fd 只需注册一次</strong>，存入
<strong>内核事件表</strong>，后续内核自动管理。</p></li>
<li><p><strong>避免无效 fd 遍历</strong>，只返回<strong>发生事件的
fd</strong>，提高效率（<code>O(1)</code>）。</p></li>
</ol></li>
<li><p>内核事件表的组成</p>
<p>内核事件表可以理解为一个<strong>红黑树 + 就绪列表</strong>：</p>
<ol type="1">
<li><strong>监听 fd 的红黑树</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>所有已注册的 fd</strong>，支持高效的
<strong>增/删/改</strong>。</li>
<li>由 <code>epoll_ctl()</code> 进行管理。</li>
</ul>
<ol start="2" type="1">
<li><strong>事件就绪列表</strong></li>
</ol>
<ul>
<li>作用：存储 <strong>发生事件的 fd</strong>。</li>
<li><code>epoll_wait()</code> 只返回<strong>就绪列表中的
fd</strong>，避免无效遍历，提高性能</li>
</ul></li>
</ol>
</blockquote>
<h2 id="两种事件处理模式">两种事件处理模式</h2>
<h3 id="reactor模式">Reactor模式</h3>
<p>使⽤<strong>同步I/O模型</strong>实现。其主要特点是<strong>由一个或多个
I/O 多路复用器（如
<code>select</code>、<code>poll</code>、<code>epoll</code>）监听事件</strong>，当事件发生时，通知相应的事件处理器进行处理。</p>
<ul>
<li><strong>主线程</strong> 监听 I/O 事件，分发任务。</li>
<li><strong>工作线程</strong> 处理 I/O 和业务逻辑，通常使用线程池。</li>
<li>适用于 <strong>高并发短 I/O 操作</strong>，如 <code>epoll</code>
服务器（Nginx、Redis）。</li>
</ul>
<h3 id="proactor模式">Proactor模式</h3>
<p>使⽤<strong>异步I/O模型</strong>实现。其核心思想是<strong>由操作系统内核完成
I/O
操作后再通知应用程序</strong>，即事件的处理由内核负责，而不是应用程序主动去检查事件状态。</p>
<ul>
<li><strong>主线程</strong> 提交异步 I/O，等待操作系统通知完成。</li>
<li><strong>操作系统</strong> 负责实际 I/O 读取和写入。</li>
<li><strong>工作线程</strong> 只处理完成的 I/O 数据，执行业务逻辑。</li>
<li>适用于 <strong>长时间异步 I/O 操作</strong>，如 Windows IOCP。</li>
</ul>
<h2 id="两种并发模式">两种并发模式</h2>
<h3 id="半同步半异步">半同步/半异步</h3>
<ol type="1">
<li><p>下面这种也叫<strong>半同步/半反应堆</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222231946543.png" alt="image-20250222231946543">
<figcaption aria-hidden="true">image-20250222231946543</figcaption>
</figure>
<p>上图中的异步线程只有⼀个，由主线程来充当，工作线程都是同步线程</p></li>
<li><p>下面是⾼效的<strong>半同步/半异步</strong>模式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/hxt616/PicGo@main/img/image-20250222232510227.png" alt="image-20250222232510227">
<figcaption aria-hidden="true">image-20250222232510227</figcaption>
</figure>
<p>注意这里的主线程只管理<strong>监听socket</strong>，而<strong>连接socket</strong>交给工作线程管理。在这种⾼效的半同步/半异步模式中，每个线程都⼯作在异步模式。所以它并⾮严格意义上的半同步/半异步模式。</p></li>
</ol>
<h3 id="领导者追随者模式">领导者/追随者模式</h3>
<ul>
<li>多个⼯作线程轮流获得事件源集合，轮流监听、分发并处理事件</li>
<li>在任意时间点，程序都仅有⼀个领导者线程，它负责监听I/O事件。</li>
<li>其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者</li>
<li>当前的领导者如果检测到I/O事件，⾸先要从线程池中推选出新的领导者线程，然后(当前领导者)处理I/O事件，新领导者等待新的I/O事件</li>
</ul>
<h2 id="libevent-框架">Libevent 框架</h2>
<p><code>libevent</code> 的核心概念可以通过以下方式理解：</p>
<ul>
<li><strong>事件处理器</strong>：事件处理器负责处理特定类型的事件，它们定义了事件的源（如文件描述符、信号等）和触发条件（如可读、可写、信号到来、定时器到期等）。每个事件处理器都绑定了一个回调函数，事件发生时，回调函数会被调用。</li>
<li><strong>事件多路分发器</strong>：事件分发器负责使用操作系统的 I/O
多路复用机制来监听事件源的状态，并触发相应的回调。它管理和调度所有事件的执行。</li>
<li><strong>事件队列</strong>：事件队列是 <code>libevent</code>
用来存储和调度事件的结构，它保证了事件按照正确的顺序（优先级、时间顺序等）进行调度。事件队列也负责管理
I/O、定时器、信号等类型的事件，并将它们传递给事件分发器进行执行。</li>
</ul>
<p><strong>核心结构</strong></p>
<ul>
<li><code>event_base</code>：事件分发器，管理所有事件。</li>
<li><code>event</code>：事件处理器，表示具体的
I/O、信号、定时器事件。</li>
</ul>
<p><strong>主要流程</strong></p>
<ol type="1">
<li><p><strong>创建事件循环</strong> →
<code>event_base_new()</code></p></li>
<li><p><strong>创建事件</strong> → <code>event_new()</code></p></li>
<li><p><strong>注册事件</strong> → <code>event_add()</code></p>
<blockquote>
<p><code>event_add()</code>
只是将事件添加到事件循环中，并将其注册到事件队列。它告诉
<code>libevent</code> 这个事件（例如 I/O
事件、信号事件）应当被监听和调度，但是它并没有
<strong>直接建立事件源与事件处理器之间的映射关系</strong>。对于信号事件（例如
<code>SIGINT</code>），这时就需要通过内部的映射函数来将信号（如
<code>SIGINT</code>）与对应的事件处理器进行关联。具体而言，<code>evmap_signal_add()</code>
就是用来处理这种信号与事件处理器的映射关系。</p>
</blockquote></li>
<li><p><strong>启动事件循环</strong> →
<code>event_base_dispatch()</code></p></li>
<li><p><strong>触发事件并执行回调</strong></p></li>
<li><p><strong>释放资源</strong> → <code>event_free()</code> /
<code>event_base_free()</code></p></li>
</ol>
<p><strong>事件处理机制</strong></p>
<ul>
<li><strong>I/O 事件</strong>：监听文件描述符的可读/可写状态。</li>
<li><strong>信号事件</strong>：监听系统信号（如
<code>SIGINT</code>）。</li>
<li><strong>定时器事件</strong>：在指定时间后触发回调。</li>
</ul>
<h2 id="多进程编程">多进程编程</h2>
<h3 id="exec与fork">exec与fork</h3>
<ol type="1">
<li><p><code>fork</code> 之后的内存状态</p>
<p>当你调用 <code>fork</code>
时，操作系统会创建一个新的进程（子进程），子进程是父进程的副本。这意味着：</p>
<ul>
<li>子进程会复制父进程的代码段、数据段、堆栈、打开的文件描述符等。</li>
<li><strong>在 <code>fork</code>
的瞬间，父进程和子进程的内存内容是完全相同的</strong>。</li>
</ul>
<p>但是，现代操作系统使用了一种称为 <strong>写时复制（Copy-On-Write,
COW）</strong> 的技术来优化 <code>fork</code> 的性能：</p>
<ul>
<li><strong>写时复制的含义</strong>：<code>fork</code>
之后，父进程和子进程共享同一块物理内存，直到其中一个进程尝试修改内存时，操作系统才会为修改的进程复制一份新的内存页。</li>
<li>这种机制避免了不必要的内存复制，提高了性能。</li>
</ul></li>
<li><p><code>exec</code> 的作用</p>
<p><code>exec</code> 的作用是
<strong>替换当前进程的映像</strong>。具体来说：</p>
<ul>
<li><code>exec</code>
会将当前进程的代码段、数据段、堆栈等全部替换为新程序的内容。</li>
<li>调用 <code>exec</code>
后，当前进程的内存空间会被新程序的内容覆盖。</li>
</ul></li>
<li><p>结合 <code>fork</code> 和 <code>exec</code> 的工作流程</p>
<p>当你在子进程中调用 <code>exec</code> 时，会发生以下事情：</p>
<ol type="1">
<li><strong>子进程的内存被替换</strong>：</li>
</ol>
<ul>
<li><code>exec</code>
会加载新程序的代码和数据到子进程的内存空间中。</li>
<li>由于写时复制的机制，子进程的内存修改不会影响父进程。</li>
</ul>
<ol start="2" type="1">
<li><strong>父进程不受影响</strong>：</li>
</ol>
<ul>
<li>父进程的内存空间保持不变，继续执行原来的代码。</li>
</ul>
<ol start="3" type="1">
<li><strong>子进程执行新程序</strong>：</li>
</ol>
<ul>
<li>子进程从新程序的入口点（通常是 <code>main</code>
函数）开始执行。</li>
</ul></li>
</ol>
<h2 id="多线程编程">多线程编程</h2>
<h3 id="互斥锁">1. 互斥锁</h3>
<p>互斥锁（<code>pthread_mutex_t</code>）是一种用于
<strong>保护共享资源</strong>
的同步机制，它确保同一时刻只有一个线程可以访问共享资源。多个线程如果要访问同一资源，必须先获取该互斥锁，获取锁成功后才能访问资源，访问完毕后释放锁。</p>
<ul>
<li><strong>主要作用</strong>：保护共享资源，防止多个线程同时访问导致数据不一致。</li>
<li><strong>行为</strong>：加锁后，其他线程无法加锁，直到锁被释放。</li>
<li><strong>示例用法</strong>：保证线程安全地访问全局变量、共享数据结构等。</li>
</ul>
<h3 id="信号量">2. 信号量</h3>
<p>信号量（<code>sem_t</code>）是一种计数机制，用于控制多个线程对共享资源的访问。信号量通常用于控制并发的线程数，或者用于线程间的同步。当信号量的值大于
0 时，表示可以继续执行，线程会执行
<code>sem_wait</code>（等待）直到信号量大于 0，然后
<code>sem_post</code>（释放）信号量。</p>
<ul>
<li><strong>主要作用</strong>：控制对共享资源的访问数量或线程间的同步。</li>
<li><strong>行为</strong>：信号量的值可以增加或减少，通常用于实现生产者-消费者模式、控制线程池大小等。</li>
<li><strong>示例用法</strong>：控制线程池中同时运行的线程数，或者协调生产者和消费者之间的同步。</li>
</ul>
<h3 id="条件变量">3. 条件变量</h3>
<p>条件变量（<code>pthread_cond_t</code>）是用于
<strong>线程间协调</strong>
的同步机制，允许线程在某个条件满足时被唤醒。它通常与互斥锁配合使用。当一个线程需要等待某个条件满足时，它会在条件变量上等待，并释放互斥锁。一旦条件满足，另一个线程就会通过条件变量通知（<code>signal</code>
或 <code>broadcast</code>）其他线程继续执行。</p>
<ul>
<li><strong>主要作用</strong>：线程间的协调与同步，常用于“等待某个条件满足”后继续执行。</li>
<li><strong>行为</strong>：线程等待条件变量时会释放互斥锁，直到条件满足时被通知。</li>
<li><strong>示例用法</strong>：线程等待某个资源准备好，或者等待某个状态变更，例如生产者-消费者模式中的条件等待。</li>
</ul>
<blockquote>
<p><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>：</p>
<ul>
<li>该函数会使当前线程进入
<strong>阻塞状态</strong>，并且<strong>自动释放</strong>传入的
<code>mutex</code>，直到满足条件并且 <code>pthread_cond_signal()</code>
或 <code>pthread_cond_broadcast()</code>
被调用时，才会唤醒该线程并重新获取锁。</li>
</ul>
<p><code>pthread_cond_signal()</code>：</p>
<ul>
<li>该函数 <strong>不会</strong> 释放 <code>mutex</code>。它的作用是通知
<strong>至少一个</strong> 等待该条件变量的线程可以继续执行。</li>
</ul>
</blockquote>
<h2 id="线程池">线程池</h2>
<h3 id="pthread_create"><code>pthread_create()</code></h3>
<p>父线程调用 <code>pthread_create()</code>
来创建子线程。在这个过程中，父线程提供一个回调函数（通常称为线程函数），该回调函数定义了子线程的行为。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>:
线程标识符的指针，函数成功后会填充该值，表示新创建的子线程。</li>
<li><code>attr</code>: 用于线程属性的结构体，通常可以为
<code>NULL</code>，表示使用默认属性。</li>
<li><code>start_routine</code>: 子线程执行的函数（线程函数）。</li>
<li><code>arg</code>: 传递给子线程函数的参数。</li>
</ul>
<h3 id="pthread_detach"><code>pthread_detach</code></h3>
<p><code>pthread_detach</code> 是 POSIX
线程库（<code>pthread</code>）中的一个函数，用于<strong>分离线程</strong>，使其在结束时自动释放资源，而不需要
<code>pthread_join()</code> 进行回收。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li><code>thread</code>：要分离的线程 ID（<code>pthread_t</code>
类型）。</li>
</ul>
<p>返回值</p>
<ul>
<li><strong>成功</strong>：返回 <code>0</code>。</li>
<li>失败：返回错误码（例如 EINVAL或 ESRCH）。
<ul>
<li><code>EINVAL</code>（Invalid
Argument）：线程已经是<strong>分离状态</strong>。</li>
<li><code>ESRCH</code>（No Such Process）：线程 ID
无效，线程不存在。</li>
</ul></li>
</ul>
<blockquote>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 37%">
<col style="width: 12%">
<col style="width: 14%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
<th><strong>回收资源</strong></th>
<th><strong>主线程等待</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>pthread_detach</code></td>
<td>让线程<strong>自动释放</strong>，无需 <code>join</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>长期运行的工作线程</td>
</tr>
<tr class="even">
<td><code>pthread_join</code></td>
<td><strong>阻塞</strong>等待线程执行完，并获取返回值</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>需要获取线程结果</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<ol type="1">
<li><p><strong>构造函数必须私有化</strong>（否则不是单例）</p></li>
<li><p>析构函数根据需求选择：</p>
<ul>
<li>需要防止外部删除 → 私有化 + 自定义销毁逻辑（如 atexit）
<ul>
<li>禁止用户直接销毁对象，通常用于单例模式或对象池。</li>
<li>控制对象的生命周期，只能通过特定的成员函数销毁对象。</li>
</ul></li>
<li>使用 Meyer's Singleton（局部静态变量）→ 可公开析构</li>
</ul></li>
</ol>
</blockquote>
<h3 id="懒汉模式">懒汉模式</h3>
<p>实例在第一次使用时创建</p>
<ul>
<li>在 C++11
及以上版本中，局部静态变量的初始化是线程安全的，可以简化单例模式的实现</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>() {}</span><br><span class="line">    ~<span class="built_in">single</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single&amp; <span class="title">getinstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> single instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="饿汉模式">饿汉模式</h3>
<p>实例在程序启动时创建</p>
<ul>
<li>利用局部静态变量的特性实现线程安全的单例模式。</li>
<li>C++11 及以上版本保证局部静态变量的初始化是线程安全的</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() {}  <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">// 静态成员初始化</span></span><br></pre></td></tr></tbody></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CPP/" rel="tag"># CPP</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"># 网络编程</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/04/CS106L/" rel="prev" title="CS106L-24Autumn">
      <i class="fa fa-chevron-left"></i> CS106L-24Autumn
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80api"><span class="nav-text">网络编程基础API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80"><span class="nav-text">套接字地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">创建套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">绑定套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">监听套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="nav-text">接受连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="nav-text">发起连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-text">关闭连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#close"><span class="nav-text">close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown"><span class="nav-text">shutdown</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-text">数据读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-text">TCP数据读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#udp%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%AF%BB%E5%86%99"><span class="nav-text">UDP数据报读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-text">通用数据读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-tcp"><span class="nav-text">服务端 (TCP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-tcp"><span class="nav-text">客户端 (TCP)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7io%E5%87%BD%E6%95%B0"><span class="nav-text">高级I&#x2F;O函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="nav-text">Linux服务器程序规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-text">日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-text">用户信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="nav-text">进程间关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-text">会话</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ps%E5%91%BD%E4%BB%A4"><span class="nav-text">ps命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-text">系统资源限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E7%9B%AE%E5%BD%95"><span class="nav-text">改变目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="nav-text">服务器程序后台化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%A8%A1%E5%9E%8B"><span class="nav-text">I&#x2F;O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9Eio"><span class="nav-text">阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9Eio"><span class="nav-text">非阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io"><span class="nav-text">信号驱动I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5io"><span class="nav-text">异步I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E5%A4%8D%E7%94%A8"><span class="nav-text">I&#x2F;O复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-text">epoll</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-text">两种事件处理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reactor%E6%A8%A1%E5%BC%8F"><span class="nav-text">Reactor模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proactor%E6%A8%A1%E5%BC%8F"><span class="nav-text">Proactor模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-text">两种并发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5"><span class="nav-text">半同步&#x2F;半异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%86%E5%AF%BC%E8%80%85%E8%BF%BD%E9%9A%8F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">领导者&#x2F;追随者模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libevent-%E6%A1%86%E6%9E%B6"><span class="nav-text">Libevent 框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-text">多进程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exec%E4%B8%8Efork"><span class="nav-text">exec与fork</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-text">多线程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">1. 互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">2. 信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">3. 条件变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread_create"><span class="nav-text">pthread_create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread_detach"><span class="nav-text">pthread_detach</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="nav-text">懒汉模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="nav-text">饿汉模式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxt"
      src="/images/hxt.jpg">
  <p class="site-author-name" itemprop="name">hxt</p>
  <div class="site-description" itemprop="description">May the Force be with you.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">407k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:10</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
